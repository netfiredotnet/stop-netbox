/*
NetBox API

API to access NetBox

API version: 2.11
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


// DcimApiService DcimApi service
type DcimApiService service

type ApiDcimCablesBulkDeleteRequest struct {
	ctx context.Context
	ApiService *DcimApiService
}

func (r ApiDcimCablesBulkDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimCablesBulkDeleteExecute(r)
}

/*
DcimCablesBulkDelete Method for DcimCablesBulkDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimCablesBulkDeleteRequest
*/
func (a *DcimApiService) DcimCablesBulkDelete(ctx context.Context) ApiDcimCablesBulkDeleteRequest {
	return ApiDcimCablesBulkDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DcimApiService) DcimCablesBulkDeleteExecute(r ApiDcimCablesBulkDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimCablesBulkDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/cables/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimCablesBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	data *WritableCable
}

func (r ApiDcimCablesBulkPartialUpdateRequest) Data(data WritableCable) ApiDcimCablesBulkPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimCablesBulkPartialUpdateRequest) Execute() (*Cable, *http.Response, error) {
	return r.ApiService.DcimCablesBulkPartialUpdateExecute(r)
}

/*
DcimCablesBulkPartialUpdate Method for DcimCablesBulkPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimCablesBulkPartialUpdateRequest
*/
func (a *DcimApiService) DcimCablesBulkPartialUpdate(ctx context.Context) ApiDcimCablesBulkPartialUpdateRequest {
	return ApiDcimCablesBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Cable
func (a *DcimApiService) DcimCablesBulkPartialUpdateExecute(r ApiDcimCablesBulkPartialUpdateRequest) (*Cable, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Cable
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimCablesBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/cables/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimCablesBulkUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	data *WritableCable
}

func (r ApiDcimCablesBulkUpdateRequest) Data(data WritableCable) ApiDcimCablesBulkUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimCablesBulkUpdateRequest) Execute() (*Cable, *http.Response, error) {
	return r.ApiService.DcimCablesBulkUpdateExecute(r)
}

/*
DcimCablesBulkUpdate Method for DcimCablesBulkUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimCablesBulkUpdateRequest
*/
func (a *DcimApiService) DcimCablesBulkUpdate(ctx context.Context) ApiDcimCablesBulkUpdateRequest {
	return ApiDcimCablesBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Cable
func (a *DcimApiService) DcimCablesBulkUpdateExecute(r ApiDcimCablesBulkUpdateRequest) (*Cable, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Cable
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimCablesBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/cables/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimCablesCreateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	data *WritableCable
}

func (r ApiDcimCablesCreateRequest) Data(data WritableCable) ApiDcimCablesCreateRequest {
	r.data = &data
	return r
}

func (r ApiDcimCablesCreateRequest) Execute() (*Cable, *http.Response, error) {
	return r.ApiService.DcimCablesCreateExecute(r)
}

/*
DcimCablesCreate Method for DcimCablesCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimCablesCreateRequest
*/
func (a *DcimApiService) DcimCablesCreate(ctx context.Context) ApiDcimCablesCreateRequest {
	return ApiDcimCablesCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Cable
func (a *DcimApiService) DcimCablesCreateExecute(r ApiDcimCablesCreateRequest) (*Cable, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Cable
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimCablesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/cables/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimCablesDeleteRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
}

func (r ApiDcimCablesDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimCablesDeleteExecute(r)
}

/*
DcimCablesDelete Method for DcimCablesDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this cable.
 @return ApiDcimCablesDeleteRequest
*/
func (a *DcimApiService) DcimCablesDelete(ctx context.Context, id int32) ApiDcimCablesDeleteRequest {
	return ApiDcimCablesDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DcimApiService) DcimCablesDeleteExecute(r ApiDcimCablesDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimCablesDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/cables/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimCablesListRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id *string
	label *string
	length *string
	lengthUnit *string
	created *string
	createdGte *string
	createdLte *string
	lastUpdated *string
	lastUpdatedGte *string
	lastUpdatedLte *string
	q *string
	type_ *string
	status *string
	color *string
	deviceId *string
	device *string
	rackId *string
	rack *string
	siteId *string
	site *string
	tenantId *string
	tenant *string
	tag *string
	idN *string
	idLte *string
	idLt *string
	idGte *string
	idGt *string
	labelN *string
	labelIc *string
	labelNic *string
	labelIew *string
	labelNiew *string
	labelIsw *string
	labelNisw *string
	labelIe *string
	labelNie *string
	labelEmpty *string
	lengthN *string
	lengthLte *string
	lengthLt *string
	lengthGte *string
	lengthGt *string
	lengthUnitN *string
	typeN *string
	statusN *string
	colorN *string
	tagN *string
	limit *int32
	offset *int32
}

func (r ApiDcimCablesListRequest) Id(id string) ApiDcimCablesListRequest {
	r.id = &id
	return r
}

func (r ApiDcimCablesListRequest) Label(label string) ApiDcimCablesListRequest {
	r.label = &label
	return r
}

func (r ApiDcimCablesListRequest) Length(length string) ApiDcimCablesListRequest {
	r.length = &length
	return r
}

func (r ApiDcimCablesListRequest) LengthUnit(lengthUnit string) ApiDcimCablesListRequest {
	r.lengthUnit = &lengthUnit
	return r
}

func (r ApiDcimCablesListRequest) Created(created string) ApiDcimCablesListRequest {
	r.created = &created
	return r
}

func (r ApiDcimCablesListRequest) CreatedGte(createdGte string) ApiDcimCablesListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiDcimCablesListRequest) CreatedLte(createdLte string) ApiDcimCablesListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiDcimCablesListRequest) LastUpdated(lastUpdated string) ApiDcimCablesListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiDcimCablesListRequest) LastUpdatedGte(lastUpdatedGte string) ApiDcimCablesListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiDcimCablesListRequest) LastUpdatedLte(lastUpdatedLte string) ApiDcimCablesListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiDcimCablesListRequest) Q(q string) ApiDcimCablesListRequest {
	r.q = &q
	return r
}

func (r ApiDcimCablesListRequest) Type_(type_ string) ApiDcimCablesListRequest {
	r.type_ = &type_
	return r
}

func (r ApiDcimCablesListRequest) Status(status string) ApiDcimCablesListRequest {
	r.status = &status
	return r
}

func (r ApiDcimCablesListRequest) Color(color string) ApiDcimCablesListRequest {
	r.color = &color
	return r
}

func (r ApiDcimCablesListRequest) DeviceId(deviceId string) ApiDcimCablesListRequest {
	r.deviceId = &deviceId
	return r
}

func (r ApiDcimCablesListRequest) Device(device string) ApiDcimCablesListRequest {
	r.device = &device
	return r
}

func (r ApiDcimCablesListRequest) RackId(rackId string) ApiDcimCablesListRequest {
	r.rackId = &rackId
	return r
}

func (r ApiDcimCablesListRequest) Rack(rack string) ApiDcimCablesListRequest {
	r.rack = &rack
	return r
}

func (r ApiDcimCablesListRequest) SiteId(siteId string) ApiDcimCablesListRequest {
	r.siteId = &siteId
	return r
}

func (r ApiDcimCablesListRequest) Site(site string) ApiDcimCablesListRequest {
	r.site = &site
	return r
}

func (r ApiDcimCablesListRequest) TenantId(tenantId string) ApiDcimCablesListRequest {
	r.tenantId = &tenantId
	return r
}

func (r ApiDcimCablesListRequest) Tenant(tenant string) ApiDcimCablesListRequest {
	r.tenant = &tenant
	return r
}

func (r ApiDcimCablesListRequest) Tag(tag string) ApiDcimCablesListRequest {
	r.tag = &tag
	return r
}

func (r ApiDcimCablesListRequest) IdN(idN string) ApiDcimCablesListRequest {
	r.idN = &idN
	return r
}

func (r ApiDcimCablesListRequest) IdLte(idLte string) ApiDcimCablesListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiDcimCablesListRequest) IdLt(idLt string) ApiDcimCablesListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiDcimCablesListRequest) IdGte(idGte string) ApiDcimCablesListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiDcimCablesListRequest) IdGt(idGt string) ApiDcimCablesListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiDcimCablesListRequest) LabelN(labelN string) ApiDcimCablesListRequest {
	r.labelN = &labelN
	return r
}

func (r ApiDcimCablesListRequest) LabelIc(labelIc string) ApiDcimCablesListRequest {
	r.labelIc = &labelIc
	return r
}

func (r ApiDcimCablesListRequest) LabelNic(labelNic string) ApiDcimCablesListRequest {
	r.labelNic = &labelNic
	return r
}

func (r ApiDcimCablesListRequest) LabelIew(labelIew string) ApiDcimCablesListRequest {
	r.labelIew = &labelIew
	return r
}

func (r ApiDcimCablesListRequest) LabelNiew(labelNiew string) ApiDcimCablesListRequest {
	r.labelNiew = &labelNiew
	return r
}

func (r ApiDcimCablesListRequest) LabelIsw(labelIsw string) ApiDcimCablesListRequest {
	r.labelIsw = &labelIsw
	return r
}

func (r ApiDcimCablesListRequest) LabelNisw(labelNisw string) ApiDcimCablesListRequest {
	r.labelNisw = &labelNisw
	return r
}

func (r ApiDcimCablesListRequest) LabelIe(labelIe string) ApiDcimCablesListRequest {
	r.labelIe = &labelIe
	return r
}

func (r ApiDcimCablesListRequest) LabelNie(labelNie string) ApiDcimCablesListRequest {
	r.labelNie = &labelNie
	return r
}

func (r ApiDcimCablesListRequest) LabelEmpty(labelEmpty string) ApiDcimCablesListRequest {
	r.labelEmpty = &labelEmpty
	return r
}

func (r ApiDcimCablesListRequest) LengthN(lengthN string) ApiDcimCablesListRequest {
	r.lengthN = &lengthN
	return r
}

func (r ApiDcimCablesListRequest) LengthLte(lengthLte string) ApiDcimCablesListRequest {
	r.lengthLte = &lengthLte
	return r
}

func (r ApiDcimCablesListRequest) LengthLt(lengthLt string) ApiDcimCablesListRequest {
	r.lengthLt = &lengthLt
	return r
}

func (r ApiDcimCablesListRequest) LengthGte(lengthGte string) ApiDcimCablesListRequest {
	r.lengthGte = &lengthGte
	return r
}

func (r ApiDcimCablesListRequest) LengthGt(lengthGt string) ApiDcimCablesListRequest {
	r.lengthGt = &lengthGt
	return r
}

func (r ApiDcimCablesListRequest) LengthUnitN(lengthUnitN string) ApiDcimCablesListRequest {
	r.lengthUnitN = &lengthUnitN
	return r
}

func (r ApiDcimCablesListRequest) TypeN(typeN string) ApiDcimCablesListRequest {
	r.typeN = &typeN
	return r
}

func (r ApiDcimCablesListRequest) StatusN(statusN string) ApiDcimCablesListRequest {
	r.statusN = &statusN
	return r
}

func (r ApiDcimCablesListRequest) ColorN(colorN string) ApiDcimCablesListRequest {
	r.colorN = &colorN
	return r
}

func (r ApiDcimCablesListRequest) TagN(tagN string) ApiDcimCablesListRequest {
	r.tagN = &tagN
	return r
}

// Number of results to return per page.
func (r ApiDcimCablesListRequest) Limit(limit int32) ApiDcimCablesListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiDcimCablesListRequest) Offset(offset int32) ApiDcimCablesListRequest {
	r.offset = &offset
	return r
}

func (r ApiDcimCablesListRequest) Execute() (*DcimCablesList200Response, *http.Response, error) {
	return r.ApiService.DcimCablesListExecute(r)
}

/*
DcimCablesList Method for DcimCablesList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimCablesListRequest
*/
func (a *DcimApiService) DcimCablesList(ctx context.Context) ApiDcimCablesListRequest {
	return ApiDcimCablesListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DcimCablesList200Response
func (a *DcimApiService) DcimCablesListExecute(r ApiDcimCablesListRequest) (*DcimCablesList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DcimCablesList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimCablesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/cables/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.label != nil {
		localVarQueryParams.Add("label", parameterToString(*r.label, ""))
	}
	if r.length != nil {
		localVarQueryParams.Add("length", parameterToString(*r.length, ""))
	}
	if r.lengthUnit != nil {
		localVarQueryParams.Add("length_unit", parameterToString(*r.lengthUnit, ""))
	}
	if r.created != nil {
		localVarQueryParams.Add("created", parameterToString(*r.created, ""))
	}
	if r.createdGte != nil {
		localVarQueryParams.Add("created__gte", parameterToString(*r.createdGte, ""))
	}
	if r.createdLte != nil {
		localVarQueryParams.Add("created__lte", parameterToString(*r.createdLte, ""))
	}
	if r.lastUpdated != nil {
		localVarQueryParams.Add("last_updated", parameterToString(*r.lastUpdated, ""))
	}
	if r.lastUpdatedGte != nil {
		localVarQueryParams.Add("last_updated__gte", parameterToString(*r.lastUpdatedGte, ""))
	}
	if r.lastUpdatedLte != nil {
		localVarQueryParams.Add("last_updated__lte", parameterToString(*r.lastUpdatedLte, ""))
	}
	if r.q != nil {
		localVarQueryParams.Add("q", parameterToString(*r.q, ""))
	}
	if r.type_ != nil {
		localVarQueryParams.Add("type", parameterToString(*r.type_, ""))
	}
	if r.status != nil {
		localVarQueryParams.Add("status", parameterToString(*r.status, ""))
	}
	if r.color != nil {
		localVarQueryParams.Add("color", parameterToString(*r.color, ""))
	}
	if r.deviceId != nil {
		localVarQueryParams.Add("device_id", parameterToString(*r.deviceId, ""))
	}
	if r.device != nil {
		localVarQueryParams.Add("device", parameterToString(*r.device, ""))
	}
	if r.rackId != nil {
		localVarQueryParams.Add("rack_id", parameterToString(*r.rackId, ""))
	}
	if r.rack != nil {
		localVarQueryParams.Add("rack", parameterToString(*r.rack, ""))
	}
	if r.siteId != nil {
		localVarQueryParams.Add("site_id", parameterToString(*r.siteId, ""))
	}
	if r.site != nil {
		localVarQueryParams.Add("site", parameterToString(*r.site, ""))
	}
	if r.tenantId != nil {
		localVarQueryParams.Add("tenant_id", parameterToString(*r.tenantId, ""))
	}
	if r.tenant != nil {
		localVarQueryParams.Add("tenant", parameterToString(*r.tenant, ""))
	}
	if r.tag != nil {
		localVarQueryParams.Add("tag", parameterToString(*r.tag, ""))
	}
	if r.idN != nil {
		localVarQueryParams.Add("id__n", parameterToString(*r.idN, ""))
	}
	if r.idLte != nil {
		localVarQueryParams.Add("id__lte", parameterToString(*r.idLte, ""))
	}
	if r.idLt != nil {
		localVarQueryParams.Add("id__lt", parameterToString(*r.idLt, ""))
	}
	if r.idGte != nil {
		localVarQueryParams.Add("id__gte", parameterToString(*r.idGte, ""))
	}
	if r.idGt != nil {
		localVarQueryParams.Add("id__gt", parameterToString(*r.idGt, ""))
	}
	if r.labelN != nil {
		localVarQueryParams.Add("label__n", parameterToString(*r.labelN, ""))
	}
	if r.labelIc != nil {
		localVarQueryParams.Add("label__ic", parameterToString(*r.labelIc, ""))
	}
	if r.labelNic != nil {
		localVarQueryParams.Add("label__nic", parameterToString(*r.labelNic, ""))
	}
	if r.labelIew != nil {
		localVarQueryParams.Add("label__iew", parameterToString(*r.labelIew, ""))
	}
	if r.labelNiew != nil {
		localVarQueryParams.Add("label__niew", parameterToString(*r.labelNiew, ""))
	}
	if r.labelIsw != nil {
		localVarQueryParams.Add("label__isw", parameterToString(*r.labelIsw, ""))
	}
	if r.labelNisw != nil {
		localVarQueryParams.Add("label__nisw", parameterToString(*r.labelNisw, ""))
	}
	if r.labelIe != nil {
		localVarQueryParams.Add("label__ie", parameterToString(*r.labelIe, ""))
	}
	if r.labelNie != nil {
		localVarQueryParams.Add("label__nie", parameterToString(*r.labelNie, ""))
	}
	if r.labelEmpty != nil {
		localVarQueryParams.Add("label__empty", parameterToString(*r.labelEmpty, ""))
	}
	if r.lengthN != nil {
		localVarQueryParams.Add("length__n", parameterToString(*r.lengthN, ""))
	}
	if r.lengthLte != nil {
		localVarQueryParams.Add("length__lte", parameterToString(*r.lengthLte, ""))
	}
	if r.lengthLt != nil {
		localVarQueryParams.Add("length__lt", parameterToString(*r.lengthLt, ""))
	}
	if r.lengthGte != nil {
		localVarQueryParams.Add("length__gte", parameterToString(*r.lengthGte, ""))
	}
	if r.lengthGt != nil {
		localVarQueryParams.Add("length__gt", parameterToString(*r.lengthGt, ""))
	}
	if r.lengthUnitN != nil {
		localVarQueryParams.Add("length_unit__n", parameterToString(*r.lengthUnitN, ""))
	}
	if r.typeN != nil {
		localVarQueryParams.Add("type__n", parameterToString(*r.typeN, ""))
	}
	if r.statusN != nil {
		localVarQueryParams.Add("status__n", parameterToString(*r.statusN, ""))
	}
	if r.colorN != nil {
		localVarQueryParams.Add("color__n", parameterToString(*r.colorN, ""))
	}
	if r.tagN != nil {
		localVarQueryParams.Add("tag__n", parameterToString(*r.tagN, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimCablesPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
	data *WritableCable
}

func (r ApiDcimCablesPartialUpdateRequest) Data(data WritableCable) ApiDcimCablesPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimCablesPartialUpdateRequest) Execute() (*Cable, *http.Response, error) {
	return r.ApiService.DcimCablesPartialUpdateExecute(r)
}

/*
DcimCablesPartialUpdate Method for DcimCablesPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this cable.
 @return ApiDcimCablesPartialUpdateRequest
*/
func (a *DcimApiService) DcimCablesPartialUpdate(ctx context.Context, id int32) ApiDcimCablesPartialUpdateRequest {
	return ApiDcimCablesPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Cable
func (a *DcimApiService) DcimCablesPartialUpdateExecute(r ApiDcimCablesPartialUpdateRequest) (*Cable, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Cable
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimCablesPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/cables/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimCablesReadRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
}

func (r ApiDcimCablesReadRequest) Execute() (*Cable, *http.Response, error) {
	return r.ApiService.DcimCablesReadExecute(r)
}

/*
DcimCablesRead Method for DcimCablesRead

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this cable.
 @return ApiDcimCablesReadRequest
*/
func (a *DcimApiService) DcimCablesRead(ctx context.Context, id int32) ApiDcimCablesReadRequest {
	return ApiDcimCablesReadRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Cable
func (a *DcimApiService) DcimCablesReadExecute(r ApiDcimCablesReadRequest) (*Cable, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Cable
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimCablesRead")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/cables/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimCablesUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
	data *WritableCable
}

func (r ApiDcimCablesUpdateRequest) Data(data WritableCable) ApiDcimCablesUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimCablesUpdateRequest) Execute() (*Cable, *http.Response, error) {
	return r.ApiService.DcimCablesUpdateExecute(r)
}

/*
DcimCablesUpdate Method for DcimCablesUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this cable.
 @return ApiDcimCablesUpdateRequest
*/
func (a *DcimApiService) DcimCablesUpdate(ctx context.Context, id int32) ApiDcimCablesUpdateRequest {
	return ApiDcimCablesUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Cable
func (a *DcimApiService) DcimCablesUpdateExecute(r ApiDcimCablesUpdateRequest) (*Cable, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Cable
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimCablesUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/cables/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimConnectedDeviceListRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	peerDevice *string
	peerInterface *string
}

// The name of the peer device
func (r ApiDcimConnectedDeviceListRequest) PeerDevice(peerDevice string) ApiDcimConnectedDeviceListRequest {
	r.peerDevice = &peerDevice
	return r
}

// The name of the peer interface
func (r ApiDcimConnectedDeviceListRequest) PeerInterface(peerInterface string) ApiDcimConnectedDeviceListRequest {
	r.peerInterface = &peerInterface
	return r
}

func (r ApiDcimConnectedDeviceListRequest) Execute() (*Device, *http.Response, error) {
	return r.ApiService.DcimConnectedDeviceListExecute(r)
}

/*
DcimConnectedDeviceList Method for DcimConnectedDeviceList

This endpoint allows a user to determine what device (if any) is connected to a given peer device and peer
interface. This is useful in a situation where a device boots with no configuration, but can detect its neighbors
via a protocol such as LLDP. Two query parameters must be included in the request:

* `peer_device`: The name of the peer device
* `peer_interface`: The name of the peer interface

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimConnectedDeviceListRequest
*/
func (a *DcimApiService) DcimConnectedDeviceList(ctx context.Context) ApiDcimConnectedDeviceListRequest {
	return ApiDcimConnectedDeviceListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Device
func (a *DcimApiService) DcimConnectedDeviceListExecute(r ApiDcimConnectedDeviceListRequest) (*Device, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Device
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimConnectedDeviceList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/connected-device/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.peerDevice == nil {
		return localVarReturnValue, nil, reportError("peerDevice is required and must be specified")
	}
	if r.peerInterface == nil {
		return localVarReturnValue, nil, reportError("peerInterface is required and must be specified")
	}

	localVarQueryParams.Add("peer_device", parameterToString(*r.peerDevice, ""))
	localVarQueryParams.Add("peer_interface", parameterToString(*r.peerInterface, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimConsoleConnectionsListRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	name *string
	site *string
	deviceId *string
	device *string
	nameN *string
	nameIc *string
	nameNic *string
	nameIew *string
	nameNiew *string
	nameIsw *string
	nameNisw *string
	nameIe *string
	nameNie *string
	nameEmpty *string
	limit *int32
	offset *int32
}

func (r ApiDcimConsoleConnectionsListRequest) Name(name string) ApiDcimConsoleConnectionsListRequest {
	r.name = &name
	return r
}

func (r ApiDcimConsoleConnectionsListRequest) Site(site string) ApiDcimConsoleConnectionsListRequest {
	r.site = &site
	return r
}

func (r ApiDcimConsoleConnectionsListRequest) DeviceId(deviceId string) ApiDcimConsoleConnectionsListRequest {
	r.deviceId = &deviceId
	return r
}

func (r ApiDcimConsoleConnectionsListRequest) Device(device string) ApiDcimConsoleConnectionsListRequest {
	r.device = &device
	return r
}

func (r ApiDcimConsoleConnectionsListRequest) NameN(nameN string) ApiDcimConsoleConnectionsListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiDcimConsoleConnectionsListRequest) NameIc(nameIc string) ApiDcimConsoleConnectionsListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiDcimConsoleConnectionsListRequest) NameNic(nameNic string) ApiDcimConsoleConnectionsListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiDcimConsoleConnectionsListRequest) NameIew(nameIew string) ApiDcimConsoleConnectionsListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiDcimConsoleConnectionsListRequest) NameNiew(nameNiew string) ApiDcimConsoleConnectionsListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiDcimConsoleConnectionsListRequest) NameIsw(nameIsw string) ApiDcimConsoleConnectionsListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiDcimConsoleConnectionsListRequest) NameNisw(nameNisw string) ApiDcimConsoleConnectionsListRequest {
	r.nameNisw = &nameNisw
	return r
}

func (r ApiDcimConsoleConnectionsListRequest) NameIe(nameIe string) ApiDcimConsoleConnectionsListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiDcimConsoleConnectionsListRequest) NameNie(nameNie string) ApiDcimConsoleConnectionsListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiDcimConsoleConnectionsListRequest) NameEmpty(nameEmpty string) ApiDcimConsoleConnectionsListRequest {
	r.nameEmpty = &nameEmpty
	return r
}

// Number of results to return per page.
func (r ApiDcimConsoleConnectionsListRequest) Limit(limit int32) ApiDcimConsoleConnectionsListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiDcimConsoleConnectionsListRequest) Offset(offset int32) ApiDcimConsoleConnectionsListRequest {
	r.offset = &offset
	return r
}

func (r ApiDcimConsoleConnectionsListRequest) Execute() (*DcimConsoleConnectionsList200Response, *http.Response, error) {
	return r.ApiService.DcimConsoleConnectionsListExecute(r)
}

/*
DcimConsoleConnectionsList Method for DcimConsoleConnectionsList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimConsoleConnectionsListRequest
*/
func (a *DcimApiService) DcimConsoleConnectionsList(ctx context.Context) ApiDcimConsoleConnectionsListRequest {
	return ApiDcimConsoleConnectionsListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DcimConsoleConnectionsList200Response
func (a *DcimApiService) DcimConsoleConnectionsListExecute(r ApiDcimConsoleConnectionsListRequest) (*DcimConsoleConnectionsList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DcimConsoleConnectionsList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimConsoleConnectionsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/console-connections/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.site != nil {
		localVarQueryParams.Add("site", parameterToString(*r.site, ""))
	}
	if r.deviceId != nil {
		localVarQueryParams.Add("device_id", parameterToString(*r.deviceId, ""))
	}
	if r.device != nil {
		localVarQueryParams.Add("device", parameterToString(*r.device, ""))
	}
	if r.nameN != nil {
		localVarQueryParams.Add("name__n", parameterToString(*r.nameN, ""))
	}
	if r.nameIc != nil {
		localVarQueryParams.Add("name__ic", parameterToString(*r.nameIc, ""))
	}
	if r.nameNic != nil {
		localVarQueryParams.Add("name__nic", parameterToString(*r.nameNic, ""))
	}
	if r.nameIew != nil {
		localVarQueryParams.Add("name__iew", parameterToString(*r.nameIew, ""))
	}
	if r.nameNiew != nil {
		localVarQueryParams.Add("name__niew", parameterToString(*r.nameNiew, ""))
	}
	if r.nameIsw != nil {
		localVarQueryParams.Add("name__isw", parameterToString(*r.nameIsw, ""))
	}
	if r.nameNisw != nil {
		localVarQueryParams.Add("name__nisw", parameterToString(*r.nameNisw, ""))
	}
	if r.nameIe != nil {
		localVarQueryParams.Add("name__ie", parameterToString(*r.nameIe, ""))
	}
	if r.nameNie != nil {
		localVarQueryParams.Add("name__nie", parameterToString(*r.nameNie, ""))
	}
	if r.nameEmpty != nil {
		localVarQueryParams.Add("name__empty", parameterToString(*r.nameEmpty, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimConsolePortTemplatesBulkDeleteRequest struct {
	ctx context.Context
	ApiService *DcimApiService
}

func (r ApiDcimConsolePortTemplatesBulkDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimConsolePortTemplatesBulkDeleteExecute(r)
}

/*
DcimConsolePortTemplatesBulkDelete Method for DcimConsolePortTemplatesBulkDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimConsolePortTemplatesBulkDeleteRequest
*/
func (a *DcimApiService) DcimConsolePortTemplatesBulkDelete(ctx context.Context) ApiDcimConsolePortTemplatesBulkDeleteRequest {
	return ApiDcimConsolePortTemplatesBulkDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DcimApiService) DcimConsolePortTemplatesBulkDeleteExecute(r ApiDcimConsolePortTemplatesBulkDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimConsolePortTemplatesBulkDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/console-port-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimConsolePortTemplatesBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	data *WritableConsolePortTemplate
}

func (r ApiDcimConsolePortTemplatesBulkPartialUpdateRequest) Data(data WritableConsolePortTemplate) ApiDcimConsolePortTemplatesBulkPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimConsolePortTemplatesBulkPartialUpdateRequest) Execute() (*ConsolePortTemplate, *http.Response, error) {
	return r.ApiService.DcimConsolePortTemplatesBulkPartialUpdateExecute(r)
}

/*
DcimConsolePortTemplatesBulkPartialUpdate Method for DcimConsolePortTemplatesBulkPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimConsolePortTemplatesBulkPartialUpdateRequest
*/
func (a *DcimApiService) DcimConsolePortTemplatesBulkPartialUpdate(ctx context.Context) ApiDcimConsolePortTemplatesBulkPartialUpdateRequest {
	return ApiDcimConsolePortTemplatesBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ConsolePortTemplate
func (a *DcimApiService) DcimConsolePortTemplatesBulkPartialUpdateExecute(r ApiDcimConsolePortTemplatesBulkPartialUpdateRequest) (*ConsolePortTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConsolePortTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimConsolePortTemplatesBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/console-port-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimConsolePortTemplatesBulkUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	data *WritableConsolePortTemplate
}

func (r ApiDcimConsolePortTemplatesBulkUpdateRequest) Data(data WritableConsolePortTemplate) ApiDcimConsolePortTemplatesBulkUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimConsolePortTemplatesBulkUpdateRequest) Execute() (*ConsolePortTemplate, *http.Response, error) {
	return r.ApiService.DcimConsolePortTemplatesBulkUpdateExecute(r)
}

/*
DcimConsolePortTemplatesBulkUpdate Method for DcimConsolePortTemplatesBulkUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimConsolePortTemplatesBulkUpdateRequest
*/
func (a *DcimApiService) DcimConsolePortTemplatesBulkUpdate(ctx context.Context) ApiDcimConsolePortTemplatesBulkUpdateRequest {
	return ApiDcimConsolePortTemplatesBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ConsolePortTemplate
func (a *DcimApiService) DcimConsolePortTemplatesBulkUpdateExecute(r ApiDcimConsolePortTemplatesBulkUpdateRequest) (*ConsolePortTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConsolePortTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimConsolePortTemplatesBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/console-port-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimConsolePortTemplatesCreateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	data *WritableConsolePortTemplate
}

func (r ApiDcimConsolePortTemplatesCreateRequest) Data(data WritableConsolePortTemplate) ApiDcimConsolePortTemplatesCreateRequest {
	r.data = &data
	return r
}

func (r ApiDcimConsolePortTemplatesCreateRequest) Execute() (*ConsolePortTemplate, *http.Response, error) {
	return r.ApiService.DcimConsolePortTemplatesCreateExecute(r)
}

/*
DcimConsolePortTemplatesCreate Method for DcimConsolePortTemplatesCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimConsolePortTemplatesCreateRequest
*/
func (a *DcimApiService) DcimConsolePortTemplatesCreate(ctx context.Context) ApiDcimConsolePortTemplatesCreateRequest {
	return ApiDcimConsolePortTemplatesCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ConsolePortTemplate
func (a *DcimApiService) DcimConsolePortTemplatesCreateExecute(r ApiDcimConsolePortTemplatesCreateRequest) (*ConsolePortTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConsolePortTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimConsolePortTemplatesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/console-port-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimConsolePortTemplatesDeleteRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
}

func (r ApiDcimConsolePortTemplatesDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimConsolePortTemplatesDeleteExecute(r)
}

/*
DcimConsolePortTemplatesDelete Method for DcimConsolePortTemplatesDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this console port template.
 @return ApiDcimConsolePortTemplatesDeleteRequest
*/
func (a *DcimApiService) DcimConsolePortTemplatesDelete(ctx context.Context, id int32) ApiDcimConsolePortTemplatesDeleteRequest {
	return ApiDcimConsolePortTemplatesDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DcimApiService) DcimConsolePortTemplatesDeleteExecute(r ApiDcimConsolePortTemplatesDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimConsolePortTemplatesDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/console-port-templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimConsolePortTemplatesListRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id *string
	name *string
	type_ *string
	created *string
	createdGte *string
	createdLte *string
	lastUpdated *string
	lastUpdatedGte *string
	lastUpdatedLte *string
	devicetypeId *string
	idN *string
	idLte *string
	idLt *string
	idGte *string
	idGt *string
	nameN *string
	nameIc *string
	nameNic *string
	nameIew *string
	nameNiew *string
	nameIsw *string
	nameNisw *string
	nameIe *string
	nameNie *string
	nameEmpty *string
	typeN *string
	devicetypeIdN *string
	limit *int32
	offset *int32
}

func (r ApiDcimConsolePortTemplatesListRequest) Id(id string) ApiDcimConsolePortTemplatesListRequest {
	r.id = &id
	return r
}

func (r ApiDcimConsolePortTemplatesListRequest) Name(name string) ApiDcimConsolePortTemplatesListRequest {
	r.name = &name
	return r
}

func (r ApiDcimConsolePortTemplatesListRequest) Type_(type_ string) ApiDcimConsolePortTemplatesListRequest {
	r.type_ = &type_
	return r
}

func (r ApiDcimConsolePortTemplatesListRequest) Created(created string) ApiDcimConsolePortTemplatesListRequest {
	r.created = &created
	return r
}

func (r ApiDcimConsolePortTemplatesListRequest) CreatedGte(createdGte string) ApiDcimConsolePortTemplatesListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiDcimConsolePortTemplatesListRequest) CreatedLte(createdLte string) ApiDcimConsolePortTemplatesListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiDcimConsolePortTemplatesListRequest) LastUpdated(lastUpdated string) ApiDcimConsolePortTemplatesListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiDcimConsolePortTemplatesListRequest) LastUpdatedGte(lastUpdatedGte string) ApiDcimConsolePortTemplatesListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiDcimConsolePortTemplatesListRequest) LastUpdatedLte(lastUpdatedLte string) ApiDcimConsolePortTemplatesListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiDcimConsolePortTemplatesListRequest) DevicetypeId(devicetypeId string) ApiDcimConsolePortTemplatesListRequest {
	r.devicetypeId = &devicetypeId
	return r
}

func (r ApiDcimConsolePortTemplatesListRequest) IdN(idN string) ApiDcimConsolePortTemplatesListRequest {
	r.idN = &idN
	return r
}

func (r ApiDcimConsolePortTemplatesListRequest) IdLte(idLte string) ApiDcimConsolePortTemplatesListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiDcimConsolePortTemplatesListRequest) IdLt(idLt string) ApiDcimConsolePortTemplatesListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiDcimConsolePortTemplatesListRequest) IdGte(idGte string) ApiDcimConsolePortTemplatesListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiDcimConsolePortTemplatesListRequest) IdGt(idGt string) ApiDcimConsolePortTemplatesListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiDcimConsolePortTemplatesListRequest) NameN(nameN string) ApiDcimConsolePortTemplatesListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiDcimConsolePortTemplatesListRequest) NameIc(nameIc string) ApiDcimConsolePortTemplatesListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiDcimConsolePortTemplatesListRequest) NameNic(nameNic string) ApiDcimConsolePortTemplatesListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiDcimConsolePortTemplatesListRequest) NameIew(nameIew string) ApiDcimConsolePortTemplatesListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiDcimConsolePortTemplatesListRequest) NameNiew(nameNiew string) ApiDcimConsolePortTemplatesListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiDcimConsolePortTemplatesListRequest) NameIsw(nameIsw string) ApiDcimConsolePortTemplatesListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiDcimConsolePortTemplatesListRequest) NameNisw(nameNisw string) ApiDcimConsolePortTemplatesListRequest {
	r.nameNisw = &nameNisw
	return r
}

func (r ApiDcimConsolePortTemplatesListRequest) NameIe(nameIe string) ApiDcimConsolePortTemplatesListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiDcimConsolePortTemplatesListRequest) NameNie(nameNie string) ApiDcimConsolePortTemplatesListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiDcimConsolePortTemplatesListRequest) NameEmpty(nameEmpty string) ApiDcimConsolePortTemplatesListRequest {
	r.nameEmpty = &nameEmpty
	return r
}

func (r ApiDcimConsolePortTemplatesListRequest) TypeN(typeN string) ApiDcimConsolePortTemplatesListRequest {
	r.typeN = &typeN
	return r
}

func (r ApiDcimConsolePortTemplatesListRequest) DevicetypeIdN(devicetypeIdN string) ApiDcimConsolePortTemplatesListRequest {
	r.devicetypeIdN = &devicetypeIdN
	return r
}

// Number of results to return per page.
func (r ApiDcimConsolePortTemplatesListRequest) Limit(limit int32) ApiDcimConsolePortTemplatesListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiDcimConsolePortTemplatesListRequest) Offset(offset int32) ApiDcimConsolePortTemplatesListRequest {
	r.offset = &offset
	return r
}

func (r ApiDcimConsolePortTemplatesListRequest) Execute() (*DcimConsolePortTemplatesList200Response, *http.Response, error) {
	return r.ApiService.DcimConsolePortTemplatesListExecute(r)
}

/*
DcimConsolePortTemplatesList Method for DcimConsolePortTemplatesList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimConsolePortTemplatesListRequest
*/
func (a *DcimApiService) DcimConsolePortTemplatesList(ctx context.Context) ApiDcimConsolePortTemplatesListRequest {
	return ApiDcimConsolePortTemplatesListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DcimConsolePortTemplatesList200Response
func (a *DcimApiService) DcimConsolePortTemplatesListExecute(r ApiDcimConsolePortTemplatesListRequest) (*DcimConsolePortTemplatesList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DcimConsolePortTemplatesList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimConsolePortTemplatesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/console-port-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.type_ != nil {
		localVarQueryParams.Add("type", parameterToString(*r.type_, ""))
	}
	if r.created != nil {
		localVarQueryParams.Add("created", parameterToString(*r.created, ""))
	}
	if r.createdGte != nil {
		localVarQueryParams.Add("created__gte", parameterToString(*r.createdGte, ""))
	}
	if r.createdLte != nil {
		localVarQueryParams.Add("created__lte", parameterToString(*r.createdLte, ""))
	}
	if r.lastUpdated != nil {
		localVarQueryParams.Add("last_updated", parameterToString(*r.lastUpdated, ""))
	}
	if r.lastUpdatedGte != nil {
		localVarQueryParams.Add("last_updated__gte", parameterToString(*r.lastUpdatedGte, ""))
	}
	if r.lastUpdatedLte != nil {
		localVarQueryParams.Add("last_updated__lte", parameterToString(*r.lastUpdatedLte, ""))
	}
	if r.devicetypeId != nil {
		localVarQueryParams.Add("devicetype_id", parameterToString(*r.devicetypeId, ""))
	}
	if r.idN != nil {
		localVarQueryParams.Add("id__n", parameterToString(*r.idN, ""))
	}
	if r.idLte != nil {
		localVarQueryParams.Add("id__lte", parameterToString(*r.idLte, ""))
	}
	if r.idLt != nil {
		localVarQueryParams.Add("id__lt", parameterToString(*r.idLt, ""))
	}
	if r.idGte != nil {
		localVarQueryParams.Add("id__gte", parameterToString(*r.idGte, ""))
	}
	if r.idGt != nil {
		localVarQueryParams.Add("id__gt", parameterToString(*r.idGt, ""))
	}
	if r.nameN != nil {
		localVarQueryParams.Add("name__n", parameterToString(*r.nameN, ""))
	}
	if r.nameIc != nil {
		localVarQueryParams.Add("name__ic", parameterToString(*r.nameIc, ""))
	}
	if r.nameNic != nil {
		localVarQueryParams.Add("name__nic", parameterToString(*r.nameNic, ""))
	}
	if r.nameIew != nil {
		localVarQueryParams.Add("name__iew", parameterToString(*r.nameIew, ""))
	}
	if r.nameNiew != nil {
		localVarQueryParams.Add("name__niew", parameterToString(*r.nameNiew, ""))
	}
	if r.nameIsw != nil {
		localVarQueryParams.Add("name__isw", parameterToString(*r.nameIsw, ""))
	}
	if r.nameNisw != nil {
		localVarQueryParams.Add("name__nisw", parameterToString(*r.nameNisw, ""))
	}
	if r.nameIe != nil {
		localVarQueryParams.Add("name__ie", parameterToString(*r.nameIe, ""))
	}
	if r.nameNie != nil {
		localVarQueryParams.Add("name__nie", parameterToString(*r.nameNie, ""))
	}
	if r.nameEmpty != nil {
		localVarQueryParams.Add("name__empty", parameterToString(*r.nameEmpty, ""))
	}
	if r.typeN != nil {
		localVarQueryParams.Add("type__n", parameterToString(*r.typeN, ""))
	}
	if r.devicetypeIdN != nil {
		localVarQueryParams.Add("devicetype_id__n", parameterToString(*r.devicetypeIdN, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimConsolePortTemplatesPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
	data *WritableConsolePortTemplate
}

func (r ApiDcimConsolePortTemplatesPartialUpdateRequest) Data(data WritableConsolePortTemplate) ApiDcimConsolePortTemplatesPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimConsolePortTemplatesPartialUpdateRequest) Execute() (*ConsolePortTemplate, *http.Response, error) {
	return r.ApiService.DcimConsolePortTemplatesPartialUpdateExecute(r)
}

/*
DcimConsolePortTemplatesPartialUpdate Method for DcimConsolePortTemplatesPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this console port template.
 @return ApiDcimConsolePortTemplatesPartialUpdateRequest
*/
func (a *DcimApiService) DcimConsolePortTemplatesPartialUpdate(ctx context.Context, id int32) ApiDcimConsolePortTemplatesPartialUpdateRequest {
	return ApiDcimConsolePortTemplatesPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ConsolePortTemplate
func (a *DcimApiService) DcimConsolePortTemplatesPartialUpdateExecute(r ApiDcimConsolePortTemplatesPartialUpdateRequest) (*ConsolePortTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConsolePortTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimConsolePortTemplatesPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/console-port-templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimConsolePortTemplatesReadRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
}

func (r ApiDcimConsolePortTemplatesReadRequest) Execute() (*ConsolePortTemplate, *http.Response, error) {
	return r.ApiService.DcimConsolePortTemplatesReadExecute(r)
}

/*
DcimConsolePortTemplatesRead Method for DcimConsolePortTemplatesRead

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this console port template.
 @return ApiDcimConsolePortTemplatesReadRequest
*/
func (a *DcimApiService) DcimConsolePortTemplatesRead(ctx context.Context, id int32) ApiDcimConsolePortTemplatesReadRequest {
	return ApiDcimConsolePortTemplatesReadRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ConsolePortTemplate
func (a *DcimApiService) DcimConsolePortTemplatesReadExecute(r ApiDcimConsolePortTemplatesReadRequest) (*ConsolePortTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConsolePortTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimConsolePortTemplatesRead")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/console-port-templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimConsolePortTemplatesUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
	data *WritableConsolePortTemplate
}

func (r ApiDcimConsolePortTemplatesUpdateRequest) Data(data WritableConsolePortTemplate) ApiDcimConsolePortTemplatesUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimConsolePortTemplatesUpdateRequest) Execute() (*ConsolePortTemplate, *http.Response, error) {
	return r.ApiService.DcimConsolePortTemplatesUpdateExecute(r)
}

/*
DcimConsolePortTemplatesUpdate Method for DcimConsolePortTemplatesUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this console port template.
 @return ApiDcimConsolePortTemplatesUpdateRequest
*/
func (a *DcimApiService) DcimConsolePortTemplatesUpdate(ctx context.Context, id int32) ApiDcimConsolePortTemplatesUpdateRequest {
	return ApiDcimConsolePortTemplatesUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ConsolePortTemplate
func (a *DcimApiService) DcimConsolePortTemplatesUpdateExecute(r ApiDcimConsolePortTemplatesUpdateRequest) (*ConsolePortTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConsolePortTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimConsolePortTemplatesUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/console-port-templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimConsolePortsBulkDeleteRequest struct {
	ctx context.Context
	ApiService *DcimApiService
}

func (r ApiDcimConsolePortsBulkDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimConsolePortsBulkDeleteExecute(r)
}

/*
DcimConsolePortsBulkDelete Method for DcimConsolePortsBulkDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimConsolePortsBulkDeleteRequest
*/
func (a *DcimApiService) DcimConsolePortsBulkDelete(ctx context.Context) ApiDcimConsolePortsBulkDeleteRequest {
	return ApiDcimConsolePortsBulkDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DcimApiService) DcimConsolePortsBulkDeleteExecute(r ApiDcimConsolePortsBulkDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimConsolePortsBulkDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/console-ports/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimConsolePortsBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	data *WritableConsolePort
}

func (r ApiDcimConsolePortsBulkPartialUpdateRequest) Data(data WritableConsolePort) ApiDcimConsolePortsBulkPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimConsolePortsBulkPartialUpdateRequest) Execute() (*ConsolePort, *http.Response, error) {
	return r.ApiService.DcimConsolePortsBulkPartialUpdateExecute(r)
}

/*
DcimConsolePortsBulkPartialUpdate Method for DcimConsolePortsBulkPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimConsolePortsBulkPartialUpdateRequest
*/
func (a *DcimApiService) DcimConsolePortsBulkPartialUpdate(ctx context.Context) ApiDcimConsolePortsBulkPartialUpdateRequest {
	return ApiDcimConsolePortsBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ConsolePort
func (a *DcimApiService) DcimConsolePortsBulkPartialUpdateExecute(r ApiDcimConsolePortsBulkPartialUpdateRequest) (*ConsolePort, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConsolePort
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimConsolePortsBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/console-ports/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimConsolePortsBulkUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	data *WritableConsolePort
}

func (r ApiDcimConsolePortsBulkUpdateRequest) Data(data WritableConsolePort) ApiDcimConsolePortsBulkUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimConsolePortsBulkUpdateRequest) Execute() (*ConsolePort, *http.Response, error) {
	return r.ApiService.DcimConsolePortsBulkUpdateExecute(r)
}

/*
DcimConsolePortsBulkUpdate Method for DcimConsolePortsBulkUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimConsolePortsBulkUpdateRequest
*/
func (a *DcimApiService) DcimConsolePortsBulkUpdate(ctx context.Context) ApiDcimConsolePortsBulkUpdateRequest {
	return ApiDcimConsolePortsBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ConsolePort
func (a *DcimApiService) DcimConsolePortsBulkUpdateExecute(r ApiDcimConsolePortsBulkUpdateRequest) (*ConsolePort, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConsolePort
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimConsolePortsBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/console-ports/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimConsolePortsCreateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	data *WritableConsolePort
}

func (r ApiDcimConsolePortsCreateRequest) Data(data WritableConsolePort) ApiDcimConsolePortsCreateRequest {
	r.data = &data
	return r
}

func (r ApiDcimConsolePortsCreateRequest) Execute() (*ConsolePort, *http.Response, error) {
	return r.ApiService.DcimConsolePortsCreateExecute(r)
}

/*
DcimConsolePortsCreate Method for DcimConsolePortsCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimConsolePortsCreateRequest
*/
func (a *DcimApiService) DcimConsolePortsCreate(ctx context.Context) ApiDcimConsolePortsCreateRequest {
	return ApiDcimConsolePortsCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ConsolePort
func (a *DcimApiService) DcimConsolePortsCreateExecute(r ApiDcimConsolePortsCreateRequest) (*ConsolePort, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConsolePort
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimConsolePortsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/console-ports/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimConsolePortsDeleteRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
}

func (r ApiDcimConsolePortsDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimConsolePortsDeleteExecute(r)
}

/*
DcimConsolePortsDelete Method for DcimConsolePortsDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this console port.
 @return ApiDcimConsolePortsDeleteRequest
*/
func (a *DcimApiService) DcimConsolePortsDelete(ctx context.Context, id int32) ApiDcimConsolePortsDeleteRequest {
	return ApiDcimConsolePortsDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DcimApiService) DcimConsolePortsDeleteExecute(r ApiDcimConsolePortsDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimConsolePortsDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/console-ports/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimConsolePortsListRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id *string
	name *string
	label *string
	description *string
	created *string
	createdGte *string
	createdLte *string
	lastUpdated *string
	lastUpdatedGte *string
	lastUpdatedLte *string
	q *string
	regionId *string
	region *string
	siteGroupId *string
	siteGroup *string
	siteId *string
	site *string
	deviceId *string
	device *string
	tag *string
	cabled *string
	connected *string
	type_ *string
	idN *string
	idLte *string
	idLt *string
	idGte *string
	idGt *string
	nameN *string
	nameIc *string
	nameNic *string
	nameIew *string
	nameNiew *string
	nameIsw *string
	nameNisw *string
	nameIe *string
	nameNie *string
	nameEmpty *string
	labelN *string
	labelIc *string
	labelNic *string
	labelIew *string
	labelNiew *string
	labelIsw *string
	labelNisw *string
	labelIe *string
	labelNie *string
	labelEmpty *string
	descriptionN *string
	descriptionIc *string
	descriptionNic *string
	descriptionIew *string
	descriptionNiew *string
	descriptionIsw *string
	descriptionNisw *string
	descriptionIe *string
	descriptionNie *string
	descriptionEmpty *string
	regionIdN *string
	regionN *string
	siteGroupIdN *string
	siteGroupN *string
	siteIdN *string
	siteN *string
	deviceIdN *string
	deviceN *string
	tagN *string
	typeN *string
	limit *int32
	offset *int32
}

func (r ApiDcimConsolePortsListRequest) Id(id string) ApiDcimConsolePortsListRequest {
	r.id = &id
	return r
}

func (r ApiDcimConsolePortsListRequest) Name(name string) ApiDcimConsolePortsListRequest {
	r.name = &name
	return r
}

func (r ApiDcimConsolePortsListRequest) Label(label string) ApiDcimConsolePortsListRequest {
	r.label = &label
	return r
}

func (r ApiDcimConsolePortsListRequest) Description(description string) ApiDcimConsolePortsListRequest {
	r.description = &description
	return r
}

func (r ApiDcimConsolePortsListRequest) Created(created string) ApiDcimConsolePortsListRequest {
	r.created = &created
	return r
}

func (r ApiDcimConsolePortsListRequest) CreatedGte(createdGte string) ApiDcimConsolePortsListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiDcimConsolePortsListRequest) CreatedLte(createdLte string) ApiDcimConsolePortsListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiDcimConsolePortsListRequest) LastUpdated(lastUpdated string) ApiDcimConsolePortsListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiDcimConsolePortsListRequest) LastUpdatedGte(lastUpdatedGte string) ApiDcimConsolePortsListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiDcimConsolePortsListRequest) LastUpdatedLte(lastUpdatedLte string) ApiDcimConsolePortsListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiDcimConsolePortsListRequest) Q(q string) ApiDcimConsolePortsListRequest {
	r.q = &q
	return r
}

func (r ApiDcimConsolePortsListRequest) RegionId(regionId string) ApiDcimConsolePortsListRequest {
	r.regionId = &regionId
	return r
}

func (r ApiDcimConsolePortsListRequest) Region(region string) ApiDcimConsolePortsListRequest {
	r.region = &region
	return r
}

func (r ApiDcimConsolePortsListRequest) SiteGroupId(siteGroupId string) ApiDcimConsolePortsListRequest {
	r.siteGroupId = &siteGroupId
	return r
}

func (r ApiDcimConsolePortsListRequest) SiteGroup(siteGroup string) ApiDcimConsolePortsListRequest {
	r.siteGroup = &siteGroup
	return r
}

func (r ApiDcimConsolePortsListRequest) SiteId(siteId string) ApiDcimConsolePortsListRequest {
	r.siteId = &siteId
	return r
}

func (r ApiDcimConsolePortsListRequest) Site(site string) ApiDcimConsolePortsListRequest {
	r.site = &site
	return r
}

func (r ApiDcimConsolePortsListRequest) DeviceId(deviceId string) ApiDcimConsolePortsListRequest {
	r.deviceId = &deviceId
	return r
}

func (r ApiDcimConsolePortsListRequest) Device(device string) ApiDcimConsolePortsListRequest {
	r.device = &device
	return r
}

func (r ApiDcimConsolePortsListRequest) Tag(tag string) ApiDcimConsolePortsListRequest {
	r.tag = &tag
	return r
}

func (r ApiDcimConsolePortsListRequest) Cabled(cabled string) ApiDcimConsolePortsListRequest {
	r.cabled = &cabled
	return r
}

func (r ApiDcimConsolePortsListRequest) Connected(connected string) ApiDcimConsolePortsListRequest {
	r.connected = &connected
	return r
}

func (r ApiDcimConsolePortsListRequest) Type_(type_ string) ApiDcimConsolePortsListRequest {
	r.type_ = &type_
	return r
}

func (r ApiDcimConsolePortsListRequest) IdN(idN string) ApiDcimConsolePortsListRequest {
	r.idN = &idN
	return r
}

func (r ApiDcimConsolePortsListRequest) IdLte(idLte string) ApiDcimConsolePortsListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiDcimConsolePortsListRequest) IdLt(idLt string) ApiDcimConsolePortsListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiDcimConsolePortsListRequest) IdGte(idGte string) ApiDcimConsolePortsListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiDcimConsolePortsListRequest) IdGt(idGt string) ApiDcimConsolePortsListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiDcimConsolePortsListRequest) NameN(nameN string) ApiDcimConsolePortsListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiDcimConsolePortsListRequest) NameIc(nameIc string) ApiDcimConsolePortsListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiDcimConsolePortsListRequest) NameNic(nameNic string) ApiDcimConsolePortsListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiDcimConsolePortsListRequest) NameIew(nameIew string) ApiDcimConsolePortsListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiDcimConsolePortsListRequest) NameNiew(nameNiew string) ApiDcimConsolePortsListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiDcimConsolePortsListRequest) NameIsw(nameIsw string) ApiDcimConsolePortsListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiDcimConsolePortsListRequest) NameNisw(nameNisw string) ApiDcimConsolePortsListRequest {
	r.nameNisw = &nameNisw
	return r
}

func (r ApiDcimConsolePortsListRequest) NameIe(nameIe string) ApiDcimConsolePortsListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiDcimConsolePortsListRequest) NameNie(nameNie string) ApiDcimConsolePortsListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiDcimConsolePortsListRequest) NameEmpty(nameEmpty string) ApiDcimConsolePortsListRequest {
	r.nameEmpty = &nameEmpty
	return r
}

func (r ApiDcimConsolePortsListRequest) LabelN(labelN string) ApiDcimConsolePortsListRequest {
	r.labelN = &labelN
	return r
}

func (r ApiDcimConsolePortsListRequest) LabelIc(labelIc string) ApiDcimConsolePortsListRequest {
	r.labelIc = &labelIc
	return r
}

func (r ApiDcimConsolePortsListRequest) LabelNic(labelNic string) ApiDcimConsolePortsListRequest {
	r.labelNic = &labelNic
	return r
}

func (r ApiDcimConsolePortsListRequest) LabelIew(labelIew string) ApiDcimConsolePortsListRequest {
	r.labelIew = &labelIew
	return r
}

func (r ApiDcimConsolePortsListRequest) LabelNiew(labelNiew string) ApiDcimConsolePortsListRequest {
	r.labelNiew = &labelNiew
	return r
}

func (r ApiDcimConsolePortsListRequest) LabelIsw(labelIsw string) ApiDcimConsolePortsListRequest {
	r.labelIsw = &labelIsw
	return r
}

func (r ApiDcimConsolePortsListRequest) LabelNisw(labelNisw string) ApiDcimConsolePortsListRequest {
	r.labelNisw = &labelNisw
	return r
}

func (r ApiDcimConsolePortsListRequest) LabelIe(labelIe string) ApiDcimConsolePortsListRequest {
	r.labelIe = &labelIe
	return r
}

func (r ApiDcimConsolePortsListRequest) LabelNie(labelNie string) ApiDcimConsolePortsListRequest {
	r.labelNie = &labelNie
	return r
}

func (r ApiDcimConsolePortsListRequest) LabelEmpty(labelEmpty string) ApiDcimConsolePortsListRequest {
	r.labelEmpty = &labelEmpty
	return r
}

func (r ApiDcimConsolePortsListRequest) DescriptionN(descriptionN string) ApiDcimConsolePortsListRequest {
	r.descriptionN = &descriptionN
	return r
}

func (r ApiDcimConsolePortsListRequest) DescriptionIc(descriptionIc string) ApiDcimConsolePortsListRequest {
	r.descriptionIc = &descriptionIc
	return r
}

func (r ApiDcimConsolePortsListRequest) DescriptionNic(descriptionNic string) ApiDcimConsolePortsListRequest {
	r.descriptionNic = &descriptionNic
	return r
}

func (r ApiDcimConsolePortsListRequest) DescriptionIew(descriptionIew string) ApiDcimConsolePortsListRequest {
	r.descriptionIew = &descriptionIew
	return r
}

func (r ApiDcimConsolePortsListRequest) DescriptionNiew(descriptionNiew string) ApiDcimConsolePortsListRequest {
	r.descriptionNiew = &descriptionNiew
	return r
}

func (r ApiDcimConsolePortsListRequest) DescriptionIsw(descriptionIsw string) ApiDcimConsolePortsListRequest {
	r.descriptionIsw = &descriptionIsw
	return r
}

func (r ApiDcimConsolePortsListRequest) DescriptionNisw(descriptionNisw string) ApiDcimConsolePortsListRequest {
	r.descriptionNisw = &descriptionNisw
	return r
}

func (r ApiDcimConsolePortsListRequest) DescriptionIe(descriptionIe string) ApiDcimConsolePortsListRequest {
	r.descriptionIe = &descriptionIe
	return r
}

func (r ApiDcimConsolePortsListRequest) DescriptionNie(descriptionNie string) ApiDcimConsolePortsListRequest {
	r.descriptionNie = &descriptionNie
	return r
}

func (r ApiDcimConsolePortsListRequest) DescriptionEmpty(descriptionEmpty string) ApiDcimConsolePortsListRequest {
	r.descriptionEmpty = &descriptionEmpty
	return r
}

func (r ApiDcimConsolePortsListRequest) RegionIdN(regionIdN string) ApiDcimConsolePortsListRequest {
	r.regionIdN = &regionIdN
	return r
}

func (r ApiDcimConsolePortsListRequest) RegionN(regionN string) ApiDcimConsolePortsListRequest {
	r.regionN = &regionN
	return r
}

func (r ApiDcimConsolePortsListRequest) SiteGroupIdN(siteGroupIdN string) ApiDcimConsolePortsListRequest {
	r.siteGroupIdN = &siteGroupIdN
	return r
}

func (r ApiDcimConsolePortsListRequest) SiteGroupN(siteGroupN string) ApiDcimConsolePortsListRequest {
	r.siteGroupN = &siteGroupN
	return r
}

func (r ApiDcimConsolePortsListRequest) SiteIdN(siteIdN string) ApiDcimConsolePortsListRequest {
	r.siteIdN = &siteIdN
	return r
}

func (r ApiDcimConsolePortsListRequest) SiteN(siteN string) ApiDcimConsolePortsListRequest {
	r.siteN = &siteN
	return r
}

func (r ApiDcimConsolePortsListRequest) DeviceIdN(deviceIdN string) ApiDcimConsolePortsListRequest {
	r.deviceIdN = &deviceIdN
	return r
}

func (r ApiDcimConsolePortsListRequest) DeviceN(deviceN string) ApiDcimConsolePortsListRequest {
	r.deviceN = &deviceN
	return r
}

func (r ApiDcimConsolePortsListRequest) TagN(tagN string) ApiDcimConsolePortsListRequest {
	r.tagN = &tagN
	return r
}

func (r ApiDcimConsolePortsListRequest) TypeN(typeN string) ApiDcimConsolePortsListRequest {
	r.typeN = &typeN
	return r
}

// Number of results to return per page.
func (r ApiDcimConsolePortsListRequest) Limit(limit int32) ApiDcimConsolePortsListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiDcimConsolePortsListRequest) Offset(offset int32) ApiDcimConsolePortsListRequest {
	r.offset = &offset
	return r
}

func (r ApiDcimConsolePortsListRequest) Execute() (*DcimConsoleConnectionsList200Response, *http.Response, error) {
	return r.ApiService.DcimConsolePortsListExecute(r)
}

/*
DcimConsolePortsList Method for DcimConsolePortsList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimConsolePortsListRequest
*/
func (a *DcimApiService) DcimConsolePortsList(ctx context.Context) ApiDcimConsolePortsListRequest {
	return ApiDcimConsolePortsListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DcimConsoleConnectionsList200Response
func (a *DcimApiService) DcimConsolePortsListExecute(r ApiDcimConsolePortsListRequest) (*DcimConsoleConnectionsList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DcimConsoleConnectionsList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimConsolePortsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/console-ports/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.label != nil {
		localVarQueryParams.Add("label", parameterToString(*r.label, ""))
	}
	if r.description != nil {
		localVarQueryParams.Add("description", parameterToString(*r.description, ""))
	}
	if r.created != nil {
		localVarQueryParams.Add("created", parameterToString(*r.created, ""))
	}
	if r.createdGte != nil {
		localVarQueryParams.Add("created__gte", parameterToString(*r.createdGte, ""))
	}
	if r.createdLte != nil {
		localVarQueryParams.Add("created__lte", parameterToString(*r.createdLte, ""))
	}
	if r.lastUpdated != nil {
		localVarQueryParams.Add("last_updated", parameterToString(*r.lastUpdated, ""))
	}
	if r.lastUpdatedGte != nil {
		localVarQueryParams.Add("last_updated__gte", parameterToString(*r.lastUpdatedGte, ""))
	}
	if r.lastUpdatedLte != nil {
		localVarQueryParams.Add("last_updated__lte", parameterToString(*r.lastUpdatedLte, ""))
	}
	if r.q != nil {
		localVarQueryParams.Add("q", parameterToString(*r.q, ""))
	}
	if r.regionId != nil {
		localVarQueryParams.Add("region_id", parameterToString(*r.regionId, ""))
	}
	if r.region != nil {
		localVarQueryParams.Add("region", parameterToString(*r.region, ""))
	}
	if r.siteGroupId != nil {
		localVarQueryParams.Add("site_group_id", parameterToString(*r.siteGroupId, ""))
	}
	if r.siteGroup != nil {
		localVarQueryParams.Add("site_group", parameterToString(*r.siteGroup, ""))
	}
	if r.siteId != nil {
		localVarQueryParams.Add("site_id", parameterToString(*r.siteId, ""))
	}
	if r.site != nil {
		localVarQueryParams.Add("site", parameterToString(*r.site, ""))
	}
	if r.deviceId != nil {
		localVarQueryParams.Add("device_id", parameterToString(*r.deviceId, ""))
	}
	if r.device != nil {
		localVarQueryParams.Add("device", parameterToString(*r.device, ""))
	}
	if r.tag != nil {
		localVarQueryParams.Add("tag", parameterToString(*r.tag, ""))
	}
	if r.cabled != nil {
		localVarQueryParams.Add("cabled", parameterToString(*r.cabled, ""))
	}
	if r.connected != nil {
		localVarQueryParams.Add("connected", parameterToString(*r.connected, ""))
	}
	if r.type_ != nil {
		localVarQueryParams.Add("type", parameterToString(*r.type_, ""))
	}
	if r.idN != nil {
		localVarQueryParams.Add("id__n", parameterToString(*r.idN, ""))
	}
	if r.idLte != nil {
		localVarQueryParams.Add("id__lte", parameterToString(*r.idLte, ""))
	}
	if r.idLt != nil {
		localVarQueryParams.Add("id__lt", parameterToString(*r.idLt, ""))
	}
	if r.idGte != nil {
		localVarQueryParams.Add("id__gte", parameterToString(*r.idGte, ""))
	}
	if r.idGt != nil {
		localVarQueryParams.Add("id__gt", parameterToString(*r.idGt, ""))
	}
	if r.nameN != nil {
		localVarQueryParams.Add("name__n", parameterToString(*r.nameN, ""))
	}
	if r.nameIc != nil {
		localVarQueryParams.Add("name__ic", parameterToString(*r.nameIc, ""))
	}
	if r.nameNic != nil {
		localVarQueryParams.Add("name__nic", parameterToString(*r.nameNic, ""))
	}
	if r.nameIew != nil {
		localVarQueryParams.Add("name__iew", parameterToString(*r.nameIew, ""))
	}
	if r.nameNiew != nil {
		localVarQueryParams.Add("name__niew", parameterToString(*r.nameNiew, ""))
	}
	if r.nameIsw != nil {
		localVarQueryParams.Add("name__isw", parameterToString(*r.nameIsw, ""))
	}
	if r.nameNisw != nil {
		localVarQueryParams.Add("name__nisw", parameterToString(*r.nameNisw, ""))
	}
	if r.nameIe != nil {
		localVarQueryParams.Add("name__ie", parameterToString(*r.nameIe, ""))
	}
	if r.nameNie != nil {
		localVarQueryParams.Add("name__nie", parameterToString(*r.nameNie, ""))
	}
	if r.nameEmpty != nil {
		localVarQueryParams.Add("name__empty", parameterToString(*r.nameEmpty, ""))
	}
	if r.labelN != nil {
		localVarQueryParams.Add("label__n", parameterToString(*r.labelN, ""))
	}
	if r.labelIc != nil {
		localVarQueryParams.Add("label__ic", parameterToString(*r.labelIc, ""))
	}
	if r.labelNic != nil {
		localVarQueryParams.Add("label__nic", parameterToString(*r.labelNic, ""))
	}
	if r.labelIew != nil {
		localVarQueryParams.Add("label__iew", parameterToString(*r.labelIew, ""))
	}
	if r.labelNiew != nil {
		localVarQueryParams.Add("label__niew", parameterToString(*r.labelNiew, ""))
	}
	if r.labelIsw != nil {
		localVarQueryParams.Add("label__isw", parameterToString(*r.labelIsw, ""))
	}
	if r.labelNisw != nil {
		localVarQueryParams.Add("label__nisw", parameterToString(*r.labelNisw, ""))
	}
	if r.labelIe != nil {
		localVarQueryParams.Add("label__ie", parameterToString(*r.labelIe, ""))
	}
	if r.labelNie != nil {
		localVarQueryParams.Add("label__nie", parameterToString(*r.labelNie, ""))
	}
	if r.labelEmpty != nil {
		localVarQueryParams.Add("label__empty", parameterToString(*r.labelEmpty, ""))
	}
	if r.descriptionN != nil {
		localVarQueryParams.Add("description__n", parameterToString(*r.descriptionN, ""))
	}
	if r.descriptionIc != nil {
		localVarQueryParams.Add("description__ic", parameterToString(*r.descriptionIc, ""))
	}
	if r.descriptionNic != nil {
		localVarQueryParams.Add("description__nic", parameterToString(*r.descriptionNic, ""))
	}
	if r.descriptionIew != nil {
		localVarQueryParams.Add("description__iew", parameterToString(*r.descriptionIew, ""))
	}
	if r.descriptionNiew != nil {
		localVarQueryParams.Add("description__niew", parameterToString(*r.descriptionNiew, ""))
	}
	if r.descriptionIsw != nil {
		localVarQueryParams.Add("description__isw", parameterToString(*r.descriptionIsw, ""))
	}
	if r.descriptionNisw != nil {
		localVarQueryParams.Add("description__nisw", parameterToString(*r.descriptionNisw, ""))
	}
	if r.descriptionIe != nil {
		localVarQueryParams.Add("description__ie", parameterToString(*r.descriptionIe, ""))
	}
	if r.descriptionNie != nil {
		localVarQueryParams.Add("description__nie", parameterToString(*r.descriptionNie, ""))
	}
	if r.descriptionEmpty != nil {
		localVarQueryParams.Add("description__empty", parameterToString(*r.descriptionEmpty, ""))
	}
	if r.regionIdN != nil {
		localVarQueryParams.Add("region_id__n", parameterToString(*r.regionIdN, ""))
	}
	if r.regionN != nil {
		localVarQueryParams.Add("region__n", parameterToString(*r.regionN, ""))
	}
	if r.siteGroupIdN != nil {
		localVarQueryParams.Add("site_group_id__n", parameterToString(*r.siteGroupIdN, ""))
	}
	if r.siteGroupN != nil {
		localVarQueryParams.Add("site_group__n", parameterToString(*r.siteGroupN, ""))
	}
	if r.siteIdN != nil {
		localVarQueryParams.Add("site_id__n", parameterToString(*r.siteIdN, ""))
	}
	if r.siteN != nil {
		localVarQueryParams.Add("site__n", parameterToString(*r.siteN, ""))
	}
	if r.deviceIdN != nil {
		localVarQueryParams.Add("device_id__n", parameterToString(*r.deviceIdN, ""))
	}
	if r.deviceN != nil {
		localVarQueryParams.Add("device__n", parameterToString(*r.deviceN, ""))
	}
	if r.tagN != nil {
		localVarQueryParams.Add("tag__n", parameterToString(*r.tagN, ""))
	}
	if r.typeN != nil {
		localVarQueryParams.Add("type__n", parameterToString(*r.typeN, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimConsolePortsPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
	data *WritableConsolePort
}

func (r ApiDcimConsolePortsPartialUpdateRequest) Data(data WritableConsolePort) ApiDcimConsolePortsPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimConsolePortsPartialUpdateRequest) Execute() (*ConsolePort, *http.Response, error) {
	return r.ApiService.DcimConsolePortsPartialUpdateExecute(r)
}

/*
DcimConsolePortsPartialUpdate Method for DcimConsolePortsPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this console port.
 @return ApiDcimConsolePortsPartialUpdateRequest
*/
func (a *DcimApiService) DcimConsolePortsPartialUpdate(ctx context.Context, id int32) ApiDcimConsolePortsPartialUpdateRequest {
	return ApiDcimConsolePortsPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ConsolePort
func (a *DcimApiService) DcimConsolePortsPartialUpdateExecute(r ApiDcimConsolePortsPartialUpdateRequest) (*ConsolePort, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConsolePort
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimConsolePortsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/console-ports/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimConsolePortsReadRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
}

func (r ApiDcimConsolePortsReadRequest) Execute() (*ConsolePort, *http.Response, error) {
	return r.ApiService.DcimConsolePortsReadExecute(r)
}

/*
DcimConsolePortsRead Method for DcimConsolePortsRead

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this console port.
 @return ApiDcimConsolePortsReadRequest
*/
func (a *DcimApiService) DcimConsolePortsRead(ctx context.Context, id int32) ApiDcimConsolePortsReadRequest {
	return ApiDcimConsolePortsReadRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ConsolePort
func (a *DcimApiService) DcimConsolePortsReadExecute(r ApiDcimConsolePortsReadRequest) (*ConsolePort, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConsolePort
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimConsolePortsRead")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/console-ports/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimConsolePortsTraceRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
}

func (r ApiDcimConsolePortsTraceRequest) Execute() (*ConsolePort, *http.Response, error) {
	return r.ApiService.DcimConsolePortsTraceExecute(r)
}

/*
DcimConsolePortsTrace Method for DcimConsolePortsTrace

Trace a complete cable path and return each segment as a three-tuple of (termination, cable, termination).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this console port.
 @return ApiDcimConsolePortsTraceRequest
*/
func (a *DcimApiService) DcimConsolePortsTrace(ctx context.Context, id int32) ApiDcimConsolePortsTraceRequest {
	return ApiDcimConsolePortsTraceRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ConsolePort
func (a *DcimApiService) DcimConsolePortsTraceExecute(r ApiDcimConsolePortsTraceRequest) (*ConsolePort, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConsolePort
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimConsolePortsTrace")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/console-ports/{id}/trace/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimConsolePortsUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
	data *WritableConsolePort
}

func (r ApiDcimConsolePortsUpdateRequest) Data(data WritableConsolePort) ApiDcimConsolePortsUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimConsolePortsUpdateRequest) Execute() (*ConsolePort, *http.Response, error) {
	return r.ApiService.DcimConsolePortsUpdateExecute(r)
}

/*
DcimConsolePortsUpdate Method for DcimConsolePortsUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this console port.
 @return ApiDcimConsolePortsUpdateRequest
*/
func (a *DcimApiService) DcimConsolePortsUpdate(ctx context.Context, id int32) ApiDcimConsolePortsUpdateRequest {
	return ApiDcimConsolePortsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ConsolePort
func (a *DcimApiService) DcimConsolePortsUpdateExecute(r ApiDcimConsolePortsUpdateRequest) (*ConsolePort, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConsolePort
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimConsolePortsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/console-ports/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimConsoleServerPortTemplatesBulkDeleteRequest struct {
	ctx context.Context
	ApiService *DcimApiService
}

func (r ApiDcimConsoleServerPortTemplatesBulkDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimConsoleServerPortTemplatesBulkDeleteExecute(r)
}

/*
DcimConsoleServerPortTemplatesBulkDelete Method for DcimConsoleServerPortTemplatesBulkDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimConsoleServerPortTemplatesBulkDeleteRequest
*/
func (a *DcimApiService) DcimConsoleServerPortTemplatesBulkDelete(ctx context.Context) ApiDcimConsoleServerPortTemplatesBulkDeleteRequest {
	return ApiDcimConsoleServerPortTemplatesBulkDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DcimApiService) DcimConsoleServerPortTemplatesBulkDeleteExecute(r ApiDcimConsoleServerPortTemplatesBulkDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimConsoleServerPortTemplatesBulkDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/console-server-port-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimConsoleServerPortTemplatesBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	data *WritableConsoleServerPortTemplate
}

func (r ApiDcimConsoleServerPortTemplatesBulkPartialUpdateRequest) Data(data WritableConsoleServerPortTemplate) ApiDcimConsoleServerPortTemplatesBulkPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimConsoleServerPortTemplatesBulkPartialUpdateRequest) Execute() (*ConsoleServerPortTemplate, *http.Response, error) {
	return r.ApiService.DcimConsoleServerPortTemplatesBulkPartialUpdateExecute(r)
}

/*
DcimConsoleServerPortTemplatesBulkPartialUpdate Method for DcimConsoleServerPortTemplatesBulkPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimConsoleServerPortTemplatesBulkPartialUpdateRequest
*/
func (a *DcimApiService) DcimConsoleServerPortTemplatesBulkPartialUpdate(ctx context.Context) ApiDcimConsoleServerPortTemplatesBulkPartialUpdateRequest {
	return ApiDcimConsoleServerPortTemplatesBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ConsoleServerPortTemplate
func (a *DcimApiService) DcimConsoleServerPortTemplatesBulkPartialUpdateExecute(r ApiDcimConsoleServerPortTemplatesBulkPartialUpdateRequest) (*ConsoleServerPortTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConsoleServerPortTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimConsoleServerPortTemplatesBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/console-server-port-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimConsoleServerPortTemplatesBulkUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	data *WritableConsoleServerPortTemplate
}

func (r ApiDcimConsoleServerPortTemplatesBulkUpdateRequest) Data(data WritableConsoleServerPortTemplate) ApiDcimConsoleServerPortTemplatesBulkUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimConsoleServerPortTemplatesBulkUpdateRequest) Execute() (*ConsoleServerPortTemplate, *http.Response, error) {
	return r.ApiService.DcimConsoleServerPortTemplatesBulkUpdateExecute(r)
}

/*
DcimConsoleServerPortTemplatesBulkUpdate Method for DcimConsoleServerPortTemplatesBulkUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimConsoleServerPortTemplatesBulkUpdateRequest
*/
func (a *DcimApiService) DcimConsoleServerPortTemplatesBulkUpdate(ctx context.Context) ApiDcimConsoleServerPortTemplatesBulkUpdateRequest {
	return ApiDcimConsoleServerPortTemplatesBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ConsoleServerPortTemplate
func (a *DcimApiService) DcimConsoleServerPortTemplatesBulkUpdateExecute(r ApiDcimConsoleServerPortTemplatesBulkUpdateRequest) (*ConsoleServerPortTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConsoleServerPortTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimConsoleServerPortTemplatesBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/console-server-port-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimConsoleServerPortTemplatesCreateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	data *WritableConsoleServerPortTemplate
}

func (r ApiDcimConsoleServerPortTemplatesCreateRequest) Data(data WritableConsoleServerPortTemplate) ApiDcimConsoleServerPortTemplatesCreateRequest {
	r.data = &data
	return r
}

func (r ApiDcimConsoleServerPortTemplatesCreateRequest) Execute() (*ConsoleServerPortTemplate, *http.Response, error) {
	return r.ApiService.DcimConsoleServerPortTemplatesCreateExecute(r)
}

/*
DcimConsoleServerPortTemplatesCreate Method for DcimConsoleServerPortTemplatesCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimConsoleServerPortTemplatesCreateRequest
*/
func (a *DcimApiService) DcimConsoleServerPortTemplatesCreate(ctx context.Context) ApiDcimConsoleServerPortTemplatesCreateRequest {
	return ApiDcimConsoleServerPortTemplatesCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ConsoleServerPortTemplate
func (a *DcimApiService) DcimConsoleServerPortTemplatesCreateExecute(r ApiDcimConsoleServerPortTemplatesCreateRequest) (*ConsoleServerPortTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConsoleServerPortTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimConsoleServerPortTemplatesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/console-server-port-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimConsoleServerPortTemplatesDeleteRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
}

func (r ApiDcimConsoleServerPortTemplatesDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimConsoleServerPortTemplatesDeleteExecute(r)
}

/*
DcimConsoleServerPortTemplatesDelete Method for DcimConsoleServerPortTemplatesDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this console server port template.
 @return ApiDcimConsoleServerPortTemplatesDeleteRequest
*/
func (a *DcimApiService) DcimConsoleServerPortTemplatesDelete(ctx context.Context, id int32) ApiDcimConsoleServerPortTemplatesDeleteRequest {
	return ApiDcimConsoleServerPortTemplatesDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DcimApiService) DcimConsoleServerPortTemplatesDeleteExecute(r ApiDcimConsoleServerPortTemplatesDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimConsoleServerPortTemplatesDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/console-server-port-templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimConsoleServerPortTemplatesListRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id *string
	name *string
	type_ *string
	created *string
	createdGte *string
	createdLte *string
	lastUpdated *string
	lastUpdatedGte *string
	lastUpdatedLte *string
	devicetypeId *string
	idN *string
	idLte *string
	idLt *string
	idGte *string
	idGt *string
	nameN *string
	nameIc *string
	nameNic *string
	nameIew *string
	nameNiew *string
	nameIsw *string
	nameNisw *string
	nameIe *string
	nameNie *string
	nameEmpty *string
	typeN *string
	devicetypeIdN *string
	limit *int32
	offset *int32
}

func (r ApiDcimConsoleServerPortTemplatesListRequest) Id(id string) ApiDcimConsoleServerPortTemplatesListRequest {
	r.id = &id
	return r
}

func (r ApiDcimConsoleServerPortTemplatesListRequest) Name(name string) ApiDcimConsoleServerPortTemplatesListRequest {
	r.name = &name
	return r
}

func (r ApiDcimConsoleServerPortTemplatesListRequest) Type_(type_ string) ApiDcimConsoleServerPortTemplatesListRequest {
	r.type_ = &type_
	return r
}

func (r ApiDcimConsoleServerPortTemplatesListRequest) Created(created string) ApiDcimConsoleServerPortTemplatesListRequest {
	r.created = &created
	return r
}

func (r ApiDcimConsoleServerPortTemplatesListRequest) CreatedGte(createdGte string) ApiDcimConsoleServerPortTemplatesListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiDcimConsoleServerPortTemplatesListRequest) CreatedLte(createdLte string) ApiDcimConsoleServerPortTemplatesListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiDcimConsoleServerPortTemplatesListRequest) LastUpdated(lastUpdated string) ApiDcimConsoleServerPortTemplatesListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiDcimConsoleServerPortTemplatesListRequest) LastUpdatedGte(lastUpdatedGte string) ApiDcimConsoleServerPortTemplatesListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiDcimConsoleServerPortTemplatesListRequest) LastUpdatedLte(lastUpdatedLte string) ApiDcimConsoleServerPortTemplatesListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiDcimConsoleServerPortTemplatesListRequest) DevicetypeId(devicetypeId string) ApiDcimConsoleServerPortTemplatesListRequest {
	r.devicetypeId = &devicetypeId
	return r
}

func (r ApiDcimConsoleServerPortTemplatesListRequest) IdN(idN string) ApiDcimConsoleServerPortTemplatesListRequest {
	r.idN = &idN
	return r
}

func (r ApiDcimConsoleServerPortTemplatesListRequest) IdLte(idLte string) ApiDcimConsoleServerPortTemplatesListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiDcimConsoleServerPortTemplatesListRequest) IdLt(idLt string) ApiDcimConsoleServerPortTemplatesListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiDcimConsoleServerPortTemplatesListRequest) IdGte(idGte string) ApiDcimConsoleServerPortTemplatesListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiDcimConsoleServerPortTemplatesListRequest) IdGt(idGt string) ApiDcimConsoleServerPortTemplatesListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiDcimConsoleServerPortTemplatesListRequest) NameN(nameN string) ApiDcimConsoleServerPortTemplatesListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiDcimConsoleServerPortTemplatesListRequest) NameIc(nameIc string) ApiDcimConsoleServerPortTemplatesListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiDcimConsoleServerPortTemplatesListRequest) NameNic(nameNic string) ApiDcimConsoleServerPortTemplatesListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiDcimConsoleServerPortTemplatesListRequest) NameIew(nameIew string) ApiDcimConsoleServerPortTemplatesListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiDcimConsoleServerPortTemplatesListRequest) NameNiew(nameNiew string) ApiDcimConsoleServerPortTemplatesListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiDcimConsoleServerPortTemplatesListRequest) NameIsw(nameIsw string) ApiDcimConsoleServerPortTemplatesListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiDcimConsoleServerPortTemplatesListRequest) NameNisw(nameNisw string) ApiDcimConsoleServerPortTemplatesListRequest {
	r.nameNisw = &nameNisw
	return r
}

func (r ApiDcimConsoleServerPortTemplatesListRequest) NameIe(nameIe string) ApiDcimConsoleServerPortTemplatesListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiDcimConsoleServerPortTemplatesListRequest) NameNie(nameNie string) ApiDcimConsoleServerPortTemplatesListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiDcimConsoleServerPortTemplatesListRequest) NameEmpty(nameEmpty string) ApiDcimConsoleServerPortTemplatesListRequest {
	r.nameEmpty = &nameEmpty
	return r
}

func (r ApiDcimConsoleServerPortTemplatesListRequest) TypeN(typeN string) ApiDcimConsoleServerPortTemplatesListRequest {
	r.typeN = &typeN
	return r
}

func (r ApiDcimConsoleServerPortTemplatesListRequest) DevicetypeIdN(devicetypeIdN string) ApiDcimConsoleServerPortTemplatesListRequest {
	r.devicetypeIdN = &devicetypeIdN
	return r
}

// Number of results to return per page.
func (r ApiDcimConsoleServerPortTemplatesListRequest) Limit(limit int32) ApiDcimConsoleServerPortTemplatesListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiDcimConsoleServerPortTemplatesListRequest) Offset(offset int32) ApiDcimConsoleServerPortTemplatesListRequest {
	r.offset = &offset
	return r
}

func (r ApiDcimConsoleServerPortTemplatesListRequest) Execute() (*DcimConsoleServerPortTemplatesList200Response, *http.Response, error) {
	return r.ApiService.DcimConsoleServerPortTemplatesListExecute(r)
}

/*
DcimConsoleServerPortTemplatesList Method for DcimConsoleServerPortTemplatesList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimConsoleServerPortTemplatesListRequest
*/
func (a *DcimApiService) DcimConsoleServerPortTemplatesList(ctx context.Context) ApiDcimConsoleServerPortTemplatesListRequest {
	return ApiDcimConsoleServerPortTemplatesListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DcimConsoleServerPortTemplatesList200Response
func (a *DcimApiService) DcimConsoleServerPortTemplatesListExecute(r ApiDcimConsoleServerPortTemplatesListRequest) (*DcimConsoleServerPortTemplatesList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DcimConsoleServerPortTemplatesList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimConsoleServerPortTemplatesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/console-server-port-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.type_ != nil {
		localVarQueryParams.Add("type", parameterToString(*r.type_, ""))
	}
	if r.created != nil {
		localVarQueryParams.Add("created", parameterToString(*r.created, ""))
	}
	if r.createdGte != nil {
		localVarQueryParams.Add("created__gte", parameterToString(*r.createdGte, ""))
	}
	if r.createdLte != nil {
		localVarQueryParams.Add("created__lte", parameterToString(*r.createdLte, ""))
	}
	if r.lastUpdated != nil {
		localVarQueryParams.Add("last_updated", parameterToString(*r.lastUpdated, ""))
	}
	if r.lastUpdatedGte != nil {
		localVarQueryParams.Add("last_updated__gte", parameterToString(*r.lastUpdatedGte, ""))
	}
	if r.lastUpdatedLte != nil {
		localVarQueryParams.Add("last_updated__lte", parameterToString(*r.lastUpdatedLte, ""))
	}
	if r.devicetypeId != nil {
		localVarQueryParams.Add("devicetype_id", parameterToString(*r.devicetypeId, ""))
	}
	if r.idN != nil {
		localVarQueryParams.Add("id__n", parameterToString(*r.idN, ""))
	}
	if r.idLte != nil {
		localVarQueryParams.Add("id__lte", parameterToString(*r.idLte, ""))
	}
	if r.idLt != nil {
		localVarQueryParams.Add("id__lt", parameterToString(*r.idLt, ""))
	}
	if r.idGte != nil {
		localVarQueryParams.Add("id__gte", parameterToString(*r.idGte, ""))
	}
	if r.idGt != nil {
		localVarQueryParams.Add("id__gt", parameterToString(*r.idGt, ""))
	}
	if r.nameN != nil {
		localVarQueryParams.Add("name__n", parameterToString(*r.nameN, ""))
	}
	if r.nameIc != nil {
		localVarQueryParams.Add("name__ic", parameterToString(*r.nameIc, ""))
	}
	if r.nameNic != nil {
		localVarQueryParams.Add("name__nic", parameterToString(*r.nameNic, ""))
	}
	if r.nameIew != nil {
		localVarQueryParams.Add("name__iew", parameterToString(*r.nameIew, ""))
	}
	if r.nameNiew != nil {
		localVarQueryParams.Add("name__niew", parameterToString(*r.nameNiew, ""))
	}
	if r.nameIsw != nil {
		localVarQueryParams.Add("name__isw", parameterToString(*r.nameIsw, ""))
	}
	if r.nameNisw != nil {
		localVarQueryParams.Add("name__nisw", parameterToString(*r.nameNisw, ""))
	}
	if r.nameIe != nil {
		localVarQueryParams.Add("name__ie", parameterToString(*r.nameIe, ""))
	}
	if r.nameNie != nil {
		localVarQueryParams.Add("name__nie", parameterToString(*r.nameNie, ""))
	}
	if r.nameEmpty != nil {
		localVarQueryParams.Add("name__empty", parameterToString(*r.nameEmpty, ""))
	}
	if r.typeN != nil {
		localVarQueryParams.Add("type__n", parameterToString(*r.typeN, ""))
	}
	if r.devicetypeIdN != nil {
		localVarQueryParams.Add("devicetype_id__n", parameterToString(*r.devicetypeIdN, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimConsoleServerPortTemplatesPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
	data *WritableConsoleServerPortTemplate
}

func (r ApiDcimConsoleServerPortTemplatesPartialUpdateRequest) Data(data WritableConsoleServerPortTemplate) ApiDcimConsoleServerPortTemplatesPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimConsoleServerPortTemplatesPartialUpdateRequest) Execute() (*ConsoleServerPortTemplate, *http.Response, error) {
	return r.ApiService.DcimConsoleServerPortTemplatesPartialUpdateExecute(r)
}

/*
DcimConsoleServerPortTemplatesPartialUpdate Method for DcimConsoleServerPortTemplatesPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this console server port template.
 @return ApiDcimConsoleServerPortTemplatesPartialUpdateRequest
*/
func (a *DcimApiService) DcimConsoleServerPortTemplatesPartialUpdate(ctx context.Context, id int32) ApiDcimConsoleServerPortTemplatesPartialUpdateRequest {
	return ApiDcimConsoleServerPortTemplatesPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ConsoleServerPortTemplate
func (a *DcimApiService) DcimConsoleServerPortTemplatesPartialUpdateExecute(r ApiDcimConsoleServerPortTemplatesPartialUpdateRequest) (*ConsoleServerPortTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConsoleServerPortTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimConsoleServerPortTemplatesPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/console-server-port-templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimConsoleServerPortTemplatesReadRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
}

func (r ApiDcimConsoleServerPortTemplatesReadRequest) Execute() (*ConsoleServerPortTemplate, *http.Response, error) {
	return r.ApiService.DcimConsoleServerPortTemplatesReadExecute(r)
}

/*
DcimConsoleServerPortTemplatesRead Method for DcimConsoleServerPortTemplatesRead

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this console server port template.
 @return ApiDcimConsoleServerPortTemplatesReadRequest
*/
func (a *DcimApiService) DcimConsoleServerPortTemplatesRead(ctx context.Context, id int32) ApiDcimConsoleServerPortTemplatesReadRequest {
	return ApiDcimConsoleServerPortTemplatesReadRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ConsoleServerPortTemplate
func (a *DcimApiService) DcimConsoleServerPortTemplatesReadExecute(r ApiDcimConsoleServerPortTemplatesReadRequest) (*ConsoleServerPortTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConsoleServerPortTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimConsoleServerPortTemplatesRead")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/console-server-port-templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimConsoleServerPortTemplatesUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
	data *WritableConsoleServerPortTemplate
}

func (r ApiDcimConsoleServerPortTemplatesUpdateRequest) Data(data WritableConsoleServerPortTemplate) ApiDcimConsoleServerPortTemplatesUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimConsoleServerPortTemplatesUpdateRequest) Execute() (*ConsoleServerPortTemplate, *http.Response, error) {
	return r.ApiService.DcimConsoleServerPortTemplatesUpdateExecute(r)
}

/*
DcimConsoleServerPortTemplatesUpdate Method for DcimConsoleServerPortTemplatesUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this console server port template.
 @return ApiDcimConsoleServerPortTemplatesUpdateRequest
*/
func (a *DcimApiService) DcimConsoleServerPortTemplatesUpdate(ctx context.Context, id int32) ApiDcimConsoleServerPortTemplatesUpdateRequest {
	return ApiDcimConsoleServerPortTemplatesUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ConsoleServerPortTemplate
func (a *DcimApiService) DcimConsoleServerPortTemplatesUpdateExecute(r ApiDcimConsoleServerPortTemplatesUpdateRequest) (*ConsoleServerPortTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConsoleServerPortTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimConsoleServerPortTemplatesUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/console-server-port-templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimConsoleServerPortsBulkDeleteRequest struct {
	ctx context.Context
	ApiService *DcimApiService
}

func (r ApiDcimConsoleServerPortsBulkDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimConsoleServerPortsBulkDeleteExecute(r)
}

/*
DcimConsoleServerPortsBulkDelete Method for DcimConsoleServerPortsBulkDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimConsoleServerPortsBulkDeleteRequest
*/
func (a *DcimApiService) DcimConsoleServerPortsBulkDelete(ctx context.Context) ApiDcimConsoleServerPortsBulkDeleteRequest {
	return ApiDcimConsoleServerPortsBulkDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DcimApiService) DcimConsoleServerPortsBulkDeleteExecute(r ApiDcimConsoleServerPortsBulkDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimConsoleServerPortsBulkDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/console-server-ports/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimConsoleServerPortsBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	data *WritableConsoleServerPort
}

func (r ApiDcimConsoleServerPortsBulkPartialUpdateRequest) Data(data WritableConsoleServerPort) ApiDcimConsoleServerPortsBulkPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimConsoleServerPortsBulkPartialUpdateRequest) Execute() (*ConsoleServerPort, *http.Response, error) {
	return r.ApiService.DcimConsoleServerPortsBulkPartialUpdateExecute(r)
}

/*
DcimConsoleServerPortsBulkPartialUpdate Method for DcimConsoleServerPortsBulkPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimConsoleServerPortsBulkPartialUpdateRequest
*/
func (a *DcimApiService) DcimConsoleServerPortsBulkPartialUpdate(ctx context.Context) ApiDcimConsoleServerPortsBulkPartialUpdateRequest {
	return ApiDcimConsoleServerPortsBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ConsoleServerPort
func (a *DcimApiService) DcimConsoleServerPortsBulkPartialUpdateExecute(r ApiDcimConsoleServerPortsBulkPartialUpdateRequest) (*ConsoleServerPort, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConsoleServerPort
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimConsoleServerPortsBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/console-server-ports/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimConsoleServerPortsBulkUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	data *WritableConsoleServerPort
}

func (r ApiDcimConsoleServerPortsBulkUpdateRequest) Data(data WritableConsoleServerPort) ApiDcimConsoleServerPortsBulkUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimConsoleServerPortsBulkUpdateRequest) Execute() (*ConsoleServerPort, *http.Response, error) {
	return r.ApiService.DcimConsoleServerPortsBulkUpdateExecute(r)
}

/*
DcimConsoleServerPortsBulkUpdate Method for DcimConsoleServerPortsBulkUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimConsoleServerPortsBulkUpdateRequest
*/
func (a *DcimApiService) DcimConsoleServerPortsBulkUpdate(ctx context.Context) ApiDcimConsoleServerPortsBulkUpdateRequest {
	return ApiDcimConsoleServerPortsBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ConsoleServerPort
func (a *DcimApiService) DcimConsoleServerPortsBulkUpdateExecute(r ApiDcimConsoleServerPortsBulkUpdateRequest) (*ConsoleServerPort, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConsoleServerPort
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimConsoleServerPortsBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/console-server-ports/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimConsoleServerPortsCreateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	data *WritableConsoleServerPort
}

func (r ApiDcimConsoleServerPortsCreateRequest) Data(data WritableConsoleServerPort) ApiDcimConsoleServerPortsCreateRequest {
	r.data = &data
	return r
}

func (r ApiDcimConsoleServerPortsCreateRequest) Execute() (*ConsoleServerPort, *http.Response, error) {
	return r.ApiService.DcimConsoleServerPortsCreateExecute(r)
}

/*
DcimConsoleServerPortsCreate Method for DcimConsoleServerPortsCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimConsoleServerPortsCreateRequest
*/
func (a *DcimApiService) DcimConsoleServerPortsCreate(ctx context.Context) ApiDcimConsoleServerPortsCreateRequest {
	return ApiDcimConsoleServerPortsCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ConsoleServerPort
func (a *DcimApiService) DcimConsoleServerPortsCreateExecute(r ApiDcimConsoleServerPortsCreateRequest) (*ConsoleServerPort, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConsoleServerPort
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimConsoleServerPortsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/console-server-ports/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimConsoleServerPortsDeleteRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
}

func (r ApiDcimConsoleServerPortsDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimConsoleServerPortsDeleteExecute(r)
}

/*
DcimConsoleServerPortsDelete Method for DcimConsoleServerPortsDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this console server port.
 @return ApiDcimConsoleServerPortsDeleteRequest
*/
func (a *DcimApiService) DcimConsoleServerPortsDelete(ctx context.Context, id int32) ApiDcimConsoleServerPortsDeleteRequest {
	return ApiDcimConsoleServerPortsDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DcimApiService) DcimConsoleServerPortsDeleteExecute(r ApiDcimConsoleServerPortsDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimConsoleServerPortsDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/console-server-ports/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimConsoleServerPortsListRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id *string
	name *string
	label *string
	description *string
	created *string
	createdGte *string
	createdLte *string
	lastUpdated *string
	lastUpdatedGte *string
	lastUpdatedLte *string
	q *string
	regionId *string
	region *string
	siteGroupId *string
	siteGroup *string
	siteId *string
	site *string
	deviceId *string
	device *string
	tag *string
	cabled *string
	connected *string
	type_ *string
	idN *string
	idLte *string
	idLt *string
	idGte *string
	idGt *string
	nameN *string
	nameIc *string
	nameNic *string
	nameIew *string
	nameNiew *string
	nameIsw *string
	nameNisw *string
	nameIe *string
	nameNie *string
	nameEmpty *string
	labelN *string
	labelIc *string
	labelNic *string
	labelIew *string
	labelNiew *string
	labelIsw *string
	labelNisw *string
	labelIe *string
	labelNie *string
	labelEmpty *string
	descriptionN *string
	descriptionIc *string
	descriptionNic *string
	descriptionIew *string
	descriptionNiew *string
	descriptionIsw *string
	descriptionNisw *string
	descriptionIe *string
	descriptionNie *string
	descriptionEmpty *string
	regionIdN *string
	regionN *string
	siteGroupIdN *string
	siteGroupN *string
	siteIdN *string
	siteN *string
	deviceIdN *string
	deviceN *string
	tagN *string
	typeN *string
	limit *int32
	offset *int32
}

func (r ApiDcimConsoleServerPortsListRequest) Id(id string) ApiDcimConsoleServerPortsListRequest {
	r.id = &id
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) Name(name string) ApiDcimConsoleServerPortsListRequest {
	r.name = &name
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) Label(label string) ApiDcimConsoleServerPortsListRequest {
	r.label = &label
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) Description(description string) ApiDcimConsoleServerPortsListRequest {
	r.description = &description
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) Created(created string) ApiDcimConsoleServerPortsListRequest {
	r.created = &created
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) CreatedGte(createdGte string) ApiDcimConsoleServerPortsListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) CreatedLte(createdLte string) ApiDcimConsoleServerPortsListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) LastUpdated(lastUpdated string) ApiDcimConsoleServerPortsListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) LastUpdatedGte(lastUpdatedGte string) ApiDcimConsoleServerPortsListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) LastUpdatedLte(lastUpdatedLte string) ApiDcimConsoleServerPortsListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) Q(q string) ApiDcimConsoleServerPortsListRequest {
	r.q = &q
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) RegionId(regionId string) ApiDcimConsoleServerPortsListRequest {
	r.regionId = &regionId
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) Region(region string) ApiDcimConsoleServerPortsListRequest {
	r.region = &region
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) SiteGroupId(siteGroupId string) ApiDcimConsoleServerPortsListRequest {
	r.siteGroupId = &siteGroupId
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) SiteGroup(siteGroup string) ApiDcimConsoleServerPortsListRequest {
	r.siteGroup = &siteGroup
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) SiteId(siteId string) ApiDcimConsoleServerPortsListRequest {
	r.siteId = &siteId
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) Site(site string) ApiDcimConsoleServerPortsListRequest {
	r.site = &site
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) DeviceId(deviceId string) ApiDcimConsoleServerPortsListRequest {
	r.deviceId = &deviceId
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) Device(device string) ApiDcimConsoleServerPortsListRequest {
	r.device = &device
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) Tag(tag string) ApiDcimConsoleServerPortsListRequest {
	r.tag = &tag
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) Cabled(cabled string) ApiDcimConsoleServerPortsListRequest {
	r.cabled = &cabled
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) Connected(connected string) ApiDcimConsoleServerPortsListRequest {
	r.connected = &connected
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) Type_(type_ string) ApiDcimConsoleServerPortsListRequest {
	r.type_ = &type_
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) IdN(idN string) ApiDcimConsoleServerPortsListRequest {
	r.idN = &idN
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) IdLte(idLte string) ApiDcimConsoleServerPortsListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) IdLt(idLt string) ApiDcimConsoleServerPortsListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) IdGte(idGte string) ApiDcimConsoleServerPortsListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) IdGt(idGt string) ApiDcimConsoleServerPortsListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) NameN(nameN string) ApiDcimConsoleServerPortsListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) NameIc(nameIc string) ApiDcimConsoleServerPortsListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) NameNic(nameNic string) ApiDcimConsoleServerPortsListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) NameIew(nameIew string) ApiDcimConsoleServerPortsListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) NameNiew(nameNiew string) ApiDcimConsoleServerPortsListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) NameIsw(nameIsw string) ApiDcimConsoleServerPortsListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) NameNisw(nameNisw string) ApiDcimConsoleServerPortsListRequest {
	r.nameNisw = &nameNisw
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) NameIe(nameIe string) ApiDcimConsoleServerPortsListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) NameNie(nameNie string) ApiDcimConsoleServerPortsListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) NameEmpty(nameEmpty string) ApiDcimConsoleServerPortsListRequest {
	r.nameEmpty = &nameEmpty
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) LabelN(labelN string) ApiDcimConsoleServerPortsListRequest {
	r.labelN = &labelN
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) LabelIc(labelIc string) ApiDcimConsoleServerPortsListRequest {
	r.labelIc = &labelIc
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) LabelNic(labelNic string) ApiDcimConsoleServerPortsListRequest {
	r.labelNic = &labelNic
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) LabelIew(labelIew string) ApiDcimConsoleServerPortsListRequest {
	r.labelIew = &labelIew
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) LabelNiew(labelNiew string) ApiDcimConsoleServerPortsListRequest {
	r.labelNiew = &labelNiew
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) LabelIsw(labelIsw string) ApiDcimConsoleServerPortsListRequest {
	r.labelIsw = &labelIsw
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) LabelNisw(labelNisw string) ApiDcimConsoleServerPortsListRequest {
	r.labelNisw = &labelNisw
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) LabelIe(labelIe string) ApiDcimConsoleServerPortsListRequest {
	r.labelIe = &labelIe
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) LabelNie(labelNie string) ApiDcimConsoleServerPortsListRequest {
	r.labelNie = &labelNie
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) LabelEmpty(labelEmpty string) ApiDcimConsoleServerPortsListRequest {
	r.labelEmpty = &labelEmpty
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) DescriptionN(descriptionN string) ApiDcimConsoleServerPortsListRequest {
	r.descriptionN = &descriptionN
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) DescriptionIc(descriptionIc string) ApiDcimConsoleServerPortsListRequest {
	r.descriptionIc = &descriptionIc
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) DescriptionNic(descriptionNic string) ApiDcimConsoleServerPortsListRequest {
	r.descriptionNic = &descriptionNic
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) DescriptionIew(descriptionIew string) ApiDcimConsoleServerPortsListRequest {
	r.descriptionIew = &descriptionIew
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) DescriptionNiew(descriptionNiew string) ApiDcimConsoleServerPortsListRequest {
	r.descriptionNiew = &descriptionNiew
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) DescriptionIsw(descriptionIsw string) ApiDcimConsoleServerPortsListRequest {
	r.descriptionIsw = &descriptionIsw
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) DescriptionNisw(descriptionNisw string) ApiDcimConsoleServerPortsListRequest {
	r.descriptionNisw = &descriptionNisw
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) DescriptionIe(descriptionIe string) ApiDcimConsoleServerPortsListRequest {
	r.descriptionIe = &descriptionIe
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) DescriptionNie(descriptionNie string) ApiDcimConsoleServerPortsListRequest {
	r.descriptionNie = &descriptionNie
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) DescriptionEmpty(descriptionEmpty string) ApiDcimConsoleServerPortsListRequest {
	r.descriptionEmpty = &descriptionEmpty
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) RegionIdN(regionIdN string) ApiDcimConsoleServerPortsListRequest {
	r.regionIdN = &regionIdN
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) RegionN(regionN string) ApiDcimConsoleServerPortsListRequest {
	r.regionN = &regionN
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) SiteGroupIdN(siteGroupIdN string) ApiDcimConsoleServerPortsListRequest {
	r.siteGroupIdN = &siteGroupIdN
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) SiteGroupN(siteGroupN string) ApiDcimConsoleServerPortsListRequest {
	r.siteGroupN = &siteGroupN
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) SiteIdN(siteIdN string) ApiDcimConsoleServerPortsListRequest {
	r.siteIdN = &siteIdN
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) SiteN(siteN string) ApiDcimConsoleServerPortsListRequest {
	r.siteN = &siteN
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) DeviceIdN(deviceIdN string) ApiDcimConsoleServerPortsListRequest {
	r.deviceIdN = &deviceIdN
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) DeviceN(deviceN string) ApiDcimConsoleServerPortsListRequest {
	r.deviceN = &deviceN
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) TagN(tagN string) ApiDcimConsoleServerPortsListRequest {
	r.tagN = &tagN
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) TypeN(typeN string) ApiDcimConsoleServerPortsListRequest {
	r.typeN = &typeN
	return r
}

// Number of results to return per page.
func (r ApiDcimConsoleServerPortsListRequest) Limit(limit int32) ApiDcimConsoleServerPortsListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiDcimConsoleServerPortsListRequest) Offset(offset int32) ApiDcimConsoleServerPortsListRequest {
	r.offset = &offset
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) Execute() (*DcimConsoleServerPortsList200Response, *http.Response, error) {
	return r.ApiService.DcimConsoleServerPortsListExecute(r)
}

/*
DcimConsoleServerPortsList Method for DcimConsoleServerPortsList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimConsoleServerPortsListRequest
*/
func (a *DcimApiService) DcimConsoleServerPortsList(ctx context.Context) ApiDcimConsoleServerPortsListRequest {
	return ApiDcimConsoleServerPortsListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DcimConsoleServerPortsList200Response
func (a *DcimApiService) DcimConsoleServerPortsListExecute(r ApiDcimConsoleServerPortsListRequest) (*DcimConsoleServerPortsList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DcimConsoleServerPortsList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimConsoleServerPortsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/console-server-ports/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.label != nil {
		localVarQueryParams.Add("label", parameterToString(*r.label, ""))
	}
	if r.description != nil {
		localVarQueryParams.Add("description", parameterToString(*r.description, ""))
	}
	if r.created != nil {
		localVarQueryParams.Add("created", parameterToString(*r.created, ""))
	}
	if r.createdGte != nil {
		localVarQueryParams.Add("created__gte", parameterToString(*r.createdGte, ""))
	}
	if r.createdLte != nil {
		localVarQueryParams.Add("created__lte", parameterToString(*r.createdLte, ""))
	}
	if r.lastUpdated != nil {
		localVarQueryParams.Add("last_updated", parameterToString(*r.lastUpdated, ""))
	}
	if r.lastUpdatedGte != nil {
		localVarQueryParams.Add("last_updated__gte", parameterToString(*r.lastUpdatedGte, ""))
	}
	if r.lastUpdatedLte != nil {
		localVarQueryParams.Add("last_updated__lte", parameterToString(*r.lastUpdatedLte, ""))
	}
	if r.q != nil {
		localVarQueryParams.Add("q", parameterToString(*r.q, ""))
	}
	if r.regionId != nil {
		localVarQueryParams.Add("region_id", parameterToString(*r.regionId, ""))
	}
	if r.region != nil {
		localVarQueryParams.Add("region", parameterToString(*r.region, ""))
	}
	if r.siteGroupId != nil {
		localVarQueryParams.Add("site_group_id", parameterToString(*r.siteGroupId, ""))
	}
	if r.siteGroup != nil {
		localVarQueryParams.Add("site_group", parameterToString(*r.siteGroup, ""))
	}
	if r.siteId != nil {
		localVarQueryParams.Add("site_id", parameterToString(*r.siteId, ""))
	}
	if r.site != nil {
		localVarQueryParams.Add("site", parameterToString(*r.site, ""))
	}
	if r.deviceId != nil {
		localVarQueryParams.Add("device_id", parameterToString(*r.deviceId, ""))
	}
	if r.device != nil {
		localVarQueryParams.Add("device", parameterToString(*r.device, ""))
	}
	if r.tag != nil {
		localVarQueryParams.Add("tag", parameterToString(*r.tag, ""))
	}
	if r.cabled != nil {
		localVarQueryParams.Add("cabled", parameterToString(*r.cabled, ""))
	}
	if r.connected != nil {
		localVarQueryParams.Add("connected", parameterToString(*r.connected, ""))
	}
	if r.type_ != nil {
		localVarQueryParams.Add("type", parameterToString(*r.type_, ""))
	}
	if r.idN != nil {
		localVarQueryParams.Add("id__n", parameterToString(*r.idN, ""))
	}
	if r.idLte != nil {
		localVarQueryParams.Add("id__lte", parameterToString(*r.idLte, ""))
	}
	if r.idLt != nil {
		localVarQueryParams.Add("id__lt", parameterToString(*r.idLt, ""))
	}
	if r.idGte != nil {
		localVarQueryParams.Add("id__gte", parameterToString(*r.idGte, ""))
	}
	if r.idGt != nil {
		localVarQueryParams.Add("id__gt", parameterToString(*r.idGt, ""))
	}
	if r.nameN != nil {
		localVarQueryParams.Add("name__n", parameterToString(*r.nameN, ""))
	}
	if r.nameIc != nil {
		localVarQueryParams.Add("name__ic", parameterToString(*r.nameIc, ""))
	}
	if r.nameNic != nil {
		localVarQueryParams.Add("name__nic", parameterToString(*r.nameNic, ""))
	}
	if r.nameIew != nil {
		localVarQueryParams.Add("name__iew", parameterToString(*r.nameIew, ""))
	}
	if r.nameNiew != nil {
		localVarQueryParams.Add("name__niew", parameterToString(*r.nameNiew, ""))
	}
	if r.nameIsw != nil {
		localVarQueryParams.Add("name__isw", parameterToString(*r.nameIsw, ""))
	}
	if r.nameNisw != nil {
		localVarQueryParams.Add("name__nisw", parameterToString(*r.nameNisw, ""))
	}
	if r.nameIe != nil {
		localVarQueryParams.Add("name__ie", parameterToString(*r.nameIe, ""))
	}
	if r.nameNie != nil {
		localVarQueryParams.Add("name__nie", parameterToString(*r.nameNie, ""))
	}
	if r.nameEmpty != nil {
		localVarQueryParams.Add("name__empty", parameterToString(*r.nameEmpty, ""))
	}
	if r.labelN != nil {
		localVarQueryParams.Add("label__n", parameterToString(*r.labelN, ""))
	}
	if r.labelIc != nil {
		localVarQueryParams.Add("label__ic", parameterToString(*r.labelIc, ""))
	}
	if r.labelNic != nil {
		localVarQueryParams.Add("label__nic", parameterToString(*r.labelNic, ""))
	}
	if r.labelIew != nil {
		localVarQueryParams.Add("label__iew", parameterToString(*r.labelIew, ""))
	}
	if r.labelNiew != nil {
		localVarQueryParams.Add("label__niew", parameterToString(*r.labelNiew, ""))
	}
	if r.labelIsw != nil {
		localVarQueryParams.Add("label__isw", parameterToString(*r.labelIsw, ""))
	}
	if r.labelNisw != nil {
		localVarQueryParams.Add("label__nisw", parameterToString(*r.labelNisw, ""))
	}
	if r.labelIe != nil {
		localVarQueryParams.Add("label__ie", parameterToString(*r.labelIe, ""))
	}
	if r.labelNie != nil {
		localVarQueryParams.Add("label__nie", parameterToString(*r.labelNie, ""))
	}
	if r.labelEmpty != nil {
		localVarQueryParams.Add("label__empty", parameterToString(*r.labelEmpty, ""))
	}
	if r.descriptionN != nil {
		localVarQueryParams.Add("description__n", parameterToString(*r.descriptionN, ""))
	}
	if r.descriptionIc != nil {
		localVarQueryParams.Add("description__ic", parameterToString(*r.descriptionIc, ""))
	}
	if r.descriptionNic != nil {
		localVarQueryParams.Add("description__nic", parameterToString(*r.descriptionNic, ""))
	}
	if r.descriptionIew != nil {
		localVarQueryParams.Add("description__iew", parameterToString(*r.descriptionIew, ""))
	}
	if r.descriptionNiew != nil {
		localVarQueryParams.Add("description__niew", parameterToString(*r.descriptionNiew, ""))
	}
	if r.descriptionIsw != nil {
		localVarQueryParams.Add("description__isw", parameterToString(*r.descriptionIsw, ""))
	}
	if r.descriptionNisw != nil {
		localVarQueryParams.Add("description__nisw", parameterToString(*r.descriptionNisw, ""))
	}
	if r.descriptionIe != nil {
		localVarQueryParams.Add("description__ie", parameterToString(*r.descriptionIe, ""))
	}
	if r.descriptionNie != nil {
		localVarQueryParams.Add("description__nie", parameterToString(*r.descriptionNie, ""))
	}
	if r.descriptionEmpty != nil {
		localVarQueryParams.Add("description__empty", parameterToString(*r.descriptionEmpty, ""))
	}
	if r.regionIdN != nil {
		localVarQueryParams.Add("region_id__n", parameterToString(*r.regionIdN, ""))
	}
	if r.regionN != nil {
		localVarQueryParams.Add("region__n", parameterToString(*r.regionN, ""))
	}
	if r.siteGroupIdN != nil {
		localVarQueryParams.Add("site_group_id__n", parameterToString(*r.siteGroupIdN, ""))
	}
	if r.siteGroupN != nil {
		localVarQueryParams.Add("site_group__n", parameterToString(*r.siteGroupN, ""))
	}
	if r.siteIdN != nil {
		localVarQueryParams.Add("site_id__n", parameterToString(*r.siteIdN, ""))
	}
	if r.siteN != nil {
		localVarQueryParams.Add("site__n", parameterToString(*r.siteN, ""))
	}
	if r.deviceIdN != nil {
		localVarQueryParams.Add("device_id__n", parameterToString(*r.deviceIdN, ""))
	}
	if r.deviceN != nil {
		localVarQueryParams.Add("device__n", parameterToString(*r.deviceN, ""))
	}
	if r.tagN != nil {
		localVarQueryParams.Add("tag__n", parameterToString(*r.tagN, ""))
	}
	if r.typeN != nil {
		localVarQueryParams.Add("type__n", parameterToString(*r.typeN, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimConsoleServerPortsPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
	data *WritableConsoleServerPort
}

func (r ApiDcimConsoleServerPortsPartialUpdateRequest) Data(data WritableConsoleServerPort) ApiDcimConsoleServerPortsPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimConsoleServerPortsPartialUpdateRequest) Execute() (*ConsoleServerPort, *http.Response, error) {
	return r.ApiService.DcimConsoleServerPortsPartialUpdateExecute(r)
}

/*
DcimConsoleServerPortsPartialUpdate Method for DcimConsoleServerPortsPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this console server port.
 @return ApiDcimConsoleServerPortsPartialUpdateRequest
*/
func (a *DcimApiService) DcimConsoleServerPortsPartialUpdate(ctx context.Context, id int32) ApiDcimConsoleServerPortsPartialUpdateRequest {
	return ApiDcimConsoleServerPortsPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ConsoleServerPort
func (a *DcimApiService) DcimConsoleServerPortsPartialUpdateExecute(r ApiDcimConsoleServerPortsPartialUpdateRequest) (*ConsoleServerPort, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConsoleServerPort
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimConsoleServerPortsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/console-server-ports/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimConsoleServerPortsReadRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
}

func (r ApiDcimConsoleServerPortsReadRequest) Execute() (*ConsoleServerPort, *http.Response, error) {
	return r.ApiService.DcimConsoleServerPortsReadExecute(r)
}

/*
DcimConsoleServerPortsRead Method for DcimConsoleServerPortsRead

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this console server port.
 @return ApiDcimConsoleServerPortsReadRequest
*/
func (a *DcimApiService) DcimConsoleServerPortsRead(ctx context.Context, id int32) ApiDcimConsoleServerPortsReadRequest {
	return ApiDcimConsoleServerPortsReadRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ConsoleServerPort
func (a *DcimApiService) DcimConsoleServerPortsReadExecute(r ApiDcimConsoleServerPortsReadRequest) (*ConsoleServerPort, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConsoleServerPort
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimConsoleServerPortsRead")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/console-server-ports/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimConsoleServerPortsTraceRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
}

func (r ApiDcimConsoleServerPortsTraceRequest) Execute() (*ConsoleServerPort, *http.Response, error) {
	return r.ApiService.DcimConsoleServerPortsTraceExecute(r)
}

/*
DcimConsoleServerPortsTrace Method for DcimConsoleServerPortsTrace

Trace a complete cable path and return each segment as a three-tuple of (termination, cable, termination).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this console server port.
 @return ApiDcimConsoleServerPortsTraceRequest
*/
func (a *DcimApiService) DcimConsoleServerPortsTrace(ctx context.Context, id int32) ApiDcimConsoleServerPortsTraceRequest {
	return ApiDcimConsoleServerPortsTraceRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ConsoleServerPort
func (a *DcimApiService) DcimConsoleServerPortsTraceExecute(r ApiDcimConsoleServerPortsTraceRequest) (*ConsoleServerPort, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConsoleServerPort
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimConsoleServerPortsTrace")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/console-server-ports/{id}/trace/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimConsoleServerPortsUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
	data *WritableConsoleServerPort
}

func (r ApiDcimConsoleServerPortsUpdateRequest) Data(data WritableConsoleServerPort) ApiDcimConsoleServerPortsUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimConsoleServerPortsUpdateRequest) Execute() (*ConsoleServerPort, *http.Response, error) {
	return r.ApiService.DcimConsoleServerPortsUpdateExecute(r)
}

/*
DcimConsoleServerPortsUpdate Method for DcimConsoleServerPortsUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this console server port.
 @return ApiDcimConsoleServerPortsUpdateRequest
*/
func (a *DcimApiService) DcimConsoleServerPortsUpdate(ctx context.Context, id int32) ApiDcimConsoleServerPortsUpdateRequest {
	return ApiDcimConsoleServerPortsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ConsoleServerPort
func (a *DcimApiService) DcimConsoleServerPortsUpdateExecute(r ApiDcimConsoleServerPortsUpdateRequest) (*ConsoleServerPort, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConsoleServerPort
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimConsoleServerPortsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/console-server-ports/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimDeviceBayTemplatesBulkDeleteRequest struct {
	ctx context.Context
	ApiService *DcimApiService
}

func (r ApiDcimDeviceBayTemplatesBulkDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimDeviceBayTemplatesBulkDeleteExecute(r)
}

/*
DcimDeviceBayTemplatesBulkDelete Method for DcimDeviceBayTemplatesBulkDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimDeviceBayTemplatesBulkDeleteRequest
*/
func (a *DcimApiService) DcimDeviceBayTemplatesBulkDelete(ctx context.Context) ApiDcimDeviceBayTemplatesBulkDeleteRequest {
	return ApiDcimDeviceBayTemplatesBulkDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DcimApiService) DcimDeviceBayTemplatesBulkDeleteExecute(r ApiDcimDeviceBayTemplatesBulkDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimDeviceBayTemplatesBulkDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/device-bay-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimDeviceBayTemplatesBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	data *WritableDeviceBayTemplate
}

func (r ApiDcimDeviceBayTemplatesBulkPartialUpdateRequest) Data(data WritableDeviceBayTemplate) ApiDcimDeviceBayTemplatesBulkPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimDeviceBayTemplatesBulkPartialUpdateRequest) Execute() (*DeviceBayTemplate, *http.Response, error) {
	return r.ApiService.DcimDeviceBayTemplatesBulkPartialUpdateExecute(r)
}

/*
DcimDeviceBayTemplatesBulkPartialUpdate Method for DcimDeviceBayTemplatesBulkPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimDeviceBayTemplatesBulkPartialUpdateRequest
*/
func (a *DcimApiService) DcimDeviceBayTemplatesBulkPartialUpdate(ctx context.Context) ApiDcimDeviceBayTemplatesBulkPartialUpdateRequest {
	return ApiDcimDeviceBayTemplatesBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DeviceBayTemplate
func (a *DcimApiService) DcimDeviceBayTemplatesBulkPartialUpdateExecute(r ApiDcimDeviceBayTemplatesBulkPartialUpdateRequest) (*DeviceBayTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeviceBayTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimDeviceBayTemplatesBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/device-bay-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimDeviceBayTemplatesBulkUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	data *WritableDeviceBayTemplate
}

func (r ApiDcimDeviceBayTemplatesBulkUpdateRequest) Data(data WritableDeviceBayTemplate) ApiDcimDeviceBayTemplatesBulkUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimDeviceBayTemplatesBulkUpdateRequest) Execute() (*DeviceBayTemplate, *http.Response, error) {
	return r.ApiService.DcimDeviceBayTemplatesBulkUpdateExecute(r)
}

/*
DcimDeviceBayTemplatesBulkUpdate Method for DcimDeviceBayTemplatesBulkUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimDeviceBayTemplatesBulkUpdateRequest
*/
func (a *DcimApiService) DcimDeviceBayTemplatesBulkUpdate(ctx context.Context) ApiDcimDeviceBayTemplatesBulkUpdateRequest {
	return ApiDcimDeviceBayTemplatesBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DeviceBayTemplate
func (a *DcimApiService) DcimDeviceBayTemplatesBulkUpdateExecute(r ApiDcimDeviceBayTemplatesBulkUpdateRequest) (*DeviceBayTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeviceBayTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimDeviceBayTemplatesBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/device-bay-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimDeviceBayTemplatesCreateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	data *WritableDeviceBayTemplate
}

func (r ApiDcimDeviceBayTemplatesCreateRequest) Data(data WritableDeviceBayTemplate) ApiDcimDeviceBayTemplatesCreateRequest {
	r.data = &data
	return r
}

func (r ApiDcimDeviceBayTemplatesCreateRequest) Execute() (*DeviceBayTemplate, *http.Response, error) {
	return r.ApiService.DcimDeviceBayTemplatesCreateExecute(r)
}

/*
DcimDeviceBayTemplatesCreate Method for DcimDeviceBayTemplatesCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimDeviceBayTemplatesCreateRequest
*/
func (a *DcimApiService) DcimDeviceBayTemplatesCreate(ctx context.Context) ApiDcimDeviceBayTemplatesCreateRequest {
	return ApiDcimDeviceBayTemplatesCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DeviceBayTemplate
func (a *DcimApiService) DcimDeviceBayTemplatesCreateExecute(r ApiDcimDeviceBayTemplatesCreateRequest) (*DeviceBayTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeviceBayTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimDeviceBayTemplatesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/device-bay-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimDeviceBayTemplatesDeleteRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
}

func (r ApiDcimDeviceBayTemplatesDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimDeviceBayTemplatesDeleteExecute(r)
}

/*
DcimDeviceBayTemplatesDelete Method for DcimDeviceBayTemplatesDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this device bay template.
 @return ApiDcimDeviceBayTemplatesDeleteRequest
*/
func (a *DcimApiService) DcimDeviceBayTemplatesDelete(ctx context.Context, id int32) ApiDcimDeviceBayTemplatesDeleteRequest {
	return ApiDcimDeviceBayTemplatesDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DcimApiService) DcimDeviceBayTemplatesDeleteExecute(r ApiDcimDeviceBayTemplatesDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimDeviceBayTemplatesDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/device-bay-templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimDeviceBayTemplatesListRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id *string
	name *string
	created *string
	createdGte *string
	createdLte *string
	lastUpdated *string
	lastUpdatedGte *string
	lastUpdatedLte *string
	devicetypeId *string
	idN *string
	idLte *string
	idLt *string
	idGte *string
	idGt *string
	nameN *string
	nameIc *string
	nameNic *string
	nameIew *string
	nameNiew *string
	nameIsw *string
	nameNisw *string
	nameIe *string
	nameNie *string
	nameEmpty *string
	devicetypeIdN *string
	limit *int32
	offset *int32
}

func (r ApiDcimDeviceBayTemplatesListRequest) Id(id string) ApiDcimDeviceBayTemplatesListRequest {
	r.id = &id
	return r
}

func (r ApiDcimDeviceBayTemplatesListRequest) Name(name string) ApiDcimDeviceBayTemplatesListRequest {
	r.name = &name
	return r
}

func (r ApiDcimDeviceBayTemplatesListRequest) Created(created string) ApiDcimDeviceBayTemplatesListRequest {
	r.created = &created
	return r
}

func (r ApiDcimDeviceBayTemplatesListRequest) CreatedGte(createdGte string) ApiDcimDeviceBayTemplatesListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiDcimDeviceBayTemplatesListRequest) CreatedLte(createdLte string) ApiDcimDeviceBayTemplatesListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiDcimDeviceBayTemplatesListRequest) LastUpdated(lastUpdated string) ApiDcimDeviceBayTemplatesListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiDcimDeviceBayTemplatesListRequest) LastUpdatedGte(lastUpdatedGte string) ApiDcimDeviceBayTemplatesListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiDcimDeviceBayTemplatesListRequest) LastUpdatedLte(lastUpdatedLte string) ApiDcimDeviceBayTemplatesListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiDcimDeviceBayTemplatesListRequest) DevicetypeId(devicetypeId string) ApiDcimDeviceBayTemplatesListRequest {
	r.devicetypeId = &devicetypeId
	return r
}

func (r ApiDcimDeviceBayTemplatesListRequest) IdN(idN string) ApiDcimDeviceBayTemplatesListRequest {
	r.idN = &idN
	return r
}

func (r ApiDcimDeviceBayTemplatesListRequest) IdLte(idLte string) ApiDcimDeviceBayTemplatesListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiDcimDeviceBayTemplatesListRequest) IdLt(idLt string) ApiDcimDeviceBayTemplatesListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiDcimDeviceBayTemplatesListRequest) IdGte(idGte string) ApiDcimDeviceBayTemplatesListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiDcimDeviceBayTemplatesListRequest) IdGt(idGt string) ApiDcimDeviceBayTemplatesListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiDcimDeviceBayTemplatesListRequest) NameN(nameN string) ApiDcimDeviceBayTemplatesListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiDcimDeviceBayTemplatesListRequest) NameIc(nameIc string) ApiDcimDeviceBayTemplatesListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiDcimDeviceBayTemplatesListRequest) NameNic(nameNic string) ApiDcimDeviceBayTemplatesListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiDcimDeviceBayTemplatesListRequest) NameIew(nameIew string) ApiDcimDeviceBayTemplatesListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiDcimDeviceBayTemplatesListRequest) NameNiew(nameNiew string) ApiDcimDeviceBayTemplatesListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiDcimDeviceBayTemplatesListRequest) NameIsw(nameIsw string) ApiDcimDeviceBayTemplatesListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiDcimDeviceBayTemplatesListRequest) NameNisw(nameNisw string) ApiDcimDeviceBayTemplatesListRequest {
	r.nameNisw = &nameNisw
	return r
}

func (r ApiDcimDeviceBayTemplatesListRequest) NameIe(nameIe string) ApiDcimDeviceBayTemplatesListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiDcimDeviceBayTemplatesListRequest) NameNie(nameNie string) ApiDcimDeviceBayTemplatesListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiDcimDeviceBayTemplatesListRequest) NameEmpty(nameEmpty string) ApiDcimDeviceBayTemplatesListRequest {
	r.nameEmpty = &nameEmpty
	return r
}

func (r ApiDcimDeviceBayTemplatesListRequest) DevicetypeIdN(devicetypeIdN string) ApiDcimDeviceBayTemplatesListRequest {
	r.devicetypeIdN = &devicetypeIdN
	return r
}

// Number of results to return per page.
func (r ApiDcimDeviceBayTemplatesListRequest) Limit(limit int32) ApiDcimDeviceBayTemplatesListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiDcimDeviceBayTemplatesListRequest) Offset(offset int32) ApiDcimDeviceBayTemplatesListRequest {
	r.offset = &offset
	return r
}

func (r ApiDcimDeviceBayTemplatesListRequest) Execute() (*DcimDeviceBayTemplatesList200Response, *http.Response, error) {
	return r.ApiService.DcimDeviceBayTemplatesListExecute(r)
}

/*
DcimDeviceBayTemplatesList Method for DcimDeviceBayTemplatesList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimDeviceBayTemplatesListRequest
*/
func (a *DcimApiService) DcimDeviceBayTemplatesList(ctx context.Context) ApiDcimDeviceBayTemplatesListRequest {
	return ApiDcimDeviceBayTemplatesListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DcimDeviceBayTemplatesList200Response
func (a *DcimApiService) DcimDeviceBayTemplatesListExecute(r ApiDcimDeviceBayTemplatesListRequest) (*DcimDeviceBayTemplatesList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DcimDeviceBayTemplatesList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimDeviceBayTemplatesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/device-bay-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.created != nil {
		localVarQueryParams.Add("created", parameterToString(*r.created, ""))
	}
	if r.createdGte != nil {
		localVarQueryParams.Add("created__gte", parameterToString(*r.createdGte, ""))
	}
	if r.createdLte != nil {
		localVarQueryParams.Add("created__lte", parameterToString(*r.createdLte, ""))
	}
	if r.lastUpdated != nil {
		localVarQueryParams.Add("last_updated", parameterToString(*r.lastUpdated, ""))
	}
	if r.lastUpdatedGte != nil {
		localVarQueryParams.Add("last_updated__gte", parameterToString(*r.lastUpdatedGte, ""))
	}
	if r.lastUpdatedLte != nil {
		localVarQueryParams.Add("last_updated__lte", parameterToString(*r.lastUpdatedLte, ""))
	}
	if r.devicetypeId != nil {
		localVarQueryParams.Add("devicetype_id", parameterToString(*r.devicetypeId, ""))
	}
	if r.idN != nil {
		localVarQueryParams.Add("id__n", parameterToString(*r.idN, ""))
	}
	if r.idLte != nil {
		localVarQueryParams.Add("id__lte", parameterToString(*r.idLte, ""))
	}
	if r.idLt != nil {
		localVarQueryParams.Add("id__lt", parameterToString(*r.idLt, ""))
	}
	if r.idGte != nil {
		localVarQueryParams.Add("id__gte", parameterToString(*r.idGte, ""))
	}
	if r.idGt != nil {
		localVarQueryParams.Add("id__gt", parameterToString(*r.idGt, ""))
	}
	if r.nameN != nil {
		localVarQueryParams.Add("name__n", parameterToString(*r.nameN, ""))
	}
	if r.nameIc != nil {
		localVarQueryParams.Add("name__ic", parameterToString(*r.nameIc, ""))
	}
	if r.nameNic != nil {
		localVarQueryParams.Add("name__nic", parameterToString(*r.nameNic, ""))
	}
	if r.nameIew != nil {
		localVarQueryParams.Add("name__iew", parameterToString(*r.nameIew, ""))
	}
	if r.nameNiew != nil {
		localVarQueryParams.Add("name__niew", parameterToString(*r.nameNiew, ""))
	}
	if r.nameIsw != nil {
		localVarQueryParams.Add("name__isw", parameterToString(*r.nameIsw, ""))
	}
	if r.nameNisw != nil {
		localVarQueryParams.Add("name__nisw", parameterToString(*r.nameNisw, ""))
	}
	if r.nameIe != nil {
		localVarQueryParams.Add("name__ie", parameterToString(*r.nameIe, ""))
	}
	if r.nameNie != nil {
		localVarQueryParams.Add("name__nie", parameterToString(*r.nameNie, ""))
	}
	if r.nameEmpty != nil {
		localVarQueryParams.Add("name__empty", parameterToString(*r.nameEmpty, ""))
	}
	if r.devicetypeIdN != nil {
		localVarQueryParams.Add("devicetype_id__n", parameterToString(*r.devicetypeIdN, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimDeviceBayTemplatesPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
	data *WritableDeviceBayTemplate
}

func (r ApiDcimDeviceBayTemplatesPartialUpdateRequest) Data(data WritableDeviceBayTemplate) ApiDcimDeviceBayTemplatesPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimDeviceBayTemplatesPartialUpdateRequest) Execute() (*DeviceBayTemplate, *http.Response, error) {
	return r.ApiService.DcimDeviceBayTemplatesPartialUpdateExecute(r)
}

/*
DcimDeviceBayTemplatesPartialUpdate Method for DcimDeviceBayTemplatesPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this device bay template.
 @return ApiDcimDeviceBayTemplatesPartialUpdateRequest
*/
func (a *DcimApiService) DcimDeviceBayTemplatesPartialUpdate(ctx context.Context, id int32) ApiDcimDeviceBayTemplatesPartialUpdateRequest {
	return ApiDcimDeviceBayTemplatesPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return DeviceBayTemplate
func (a *DcimApiService) DcimDeviceBayTemplatesPartialUpdateExecute(r ApiDcimDeviceBayTemplatesPartialUpdateRequest) (*DeviceBayTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeviceBayTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimDeviceBayTemplatesPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/device-bay-templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimDeviceBayTemplatesReadRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
}

func (r ApiDcimDeviceBayTemplatesReadRequest) Execute() (*DeviceBayTemplate, *http.Response, error) {
	return r.ApiService.DcimDeviceBayTemplatesReadExecute(r)
}

/*
DcimDeviceBayTemplatesRead Method for DcimDeviceBayTemplatesRead

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this device bay template.
 @return ApiDcimDeviceBayTemplatesReadRequest
*/
func (a *DcimApiService) DcimDeviceBayTemplatesRead(ctx context.Context, id int32) ApiDcimDeviceBayTemplatesReadRequest {
	return ApiDcimDeviceBayTemplatesReadRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return DeviceBayTemplate
func (a *DcimApiService) DcimDeviceBayTemplatesReadExecute(r ApiDcimDeviceBayTemplatesReadRequest) (*DeviceBayTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeviceBayTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimDeviceBayTemplatesRead")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/device-bay-templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimDeviceBayTemplatesUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
	data *WritableDeviceBayTemplate
}

func (r ApiDcimDeviceBayTemplatesUpdateRequest) Data(data WritableDeviceBayTemplate) ApiDcimDeviceBayTemplatesUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimDeviceBayTemplatesUpdateRequest) Execute() (*DeviceBayTemplate, *http.Response, error) {
	return r.ApiService.DcimDeviceBayTemplatesUpdateExecute(r)
}

/*
DcimDeviceBayTemplatesUpdate Method for DcimDeviceBayTemplatesUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this device bay template.
 @return ApiDcimDeviceBayTemplatesUpdateRequest
*/
func (a *DcimApiService) DcimDeviceBayTemplatesUpdate(ctx context.Context, id int32) ApiDcimDeviceBayTemplatesUpdateRequest {
	return ApiDcimDeviceBayTemplatesUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return DeviceBayTemplate
func (a *DcimApiService) DcimDeviceBayTemplatesUpdateExecute(r ApiDcimDeviceBayTemplatesUpdateRequest) (*DeviceBayTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeviceBayTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimDeviceBayTemplatesUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/device-bay-templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimDeviceBaysBulkDeleteRequest struct {
	ctx context.Context
	ApiService *DcimApiService
}

func (r ApiDcimDeviceBaysBulkDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimDeviceBaysBulkDeleteExecute(r)
}

/*
DcimDeviceBaysBulkDelete Method for DcimDeviceBaysBulkDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimDeviceBaysBulkDeleteRequest
*/
func (a *DcimApiService) DcimDeviceBaysBulkDelete(ctx context.Context) ApiDcimDeviceBaysBulkDeleteRequest {
	return ApiDcimDeviceBaysBulkDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DcimApiService) DcimDeviceBaysBulkDeleteExecute(r ApiDcimDeviceBaysBulkDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimDeviceBaysBulkDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/device-bays/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimDeviceBaysBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	data *WritableDeviceBay
}

func (r ApiDcimDeviceBaysBulkPartialUpdateRequest) Data(data WritableDeviceBay) ApiDcimDeviceBaysBulkPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimDeviceBaysBulkPartialUpdateRequest) Execute() (*DeviceBay, *http.Response, error) {
	return r.ApiService.DcimDeviceBaysBulkPartialUpdateExecute(r)
}

/*
DcimDeviceBaysBulkPartialUpdate Method for DcimDeviceBaysBulkPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimDeviceBaysBulkPartialUpdateRequest
*/
func (a *DcimApiService) DcimDeviceBaysBulkPartialUpdate(ctx context.Context) ApiDcimDeviceBaysBulkPartialUpdateRequest {
	return ApiDcimDeviceBaysBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DeviceBay
func (a *DcimApiService) DcimDeviceBaysBulkPartialUpdateExecute(r ApiDcimDeviceBaysBulkPartialUpdateRequest) (*DeviceBay, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeviceBay
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimDeviceBaysBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/device-bays/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimDeviceBaysBulkUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	data *WritableDeviceBay
}

func (r ApiDcimDeviceBaysBulkUpdateRequest) Data(data WritableDeviceBay) ApiDcimDeviceBaysBulkUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimDeviceBaysBulkUpdateRequest) Execute() (*DeviceBay, *http.Response, error) {
	return r.ApiService.DcimDeviceBaysBulkUpdateExecute(r)
}

/*
DcimDeviceBaysBulkUpdate Method for DcimDeviceBaysBulkUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimDeviceBaysBulkUpdateRequest
*/
func (a *DcimApiService) DcimDeviceBaysBulkUpdate(ctx context.Context) ApiDcimDeviceBaysBulkUpdateRequest {
	return ApiDcimDeviceBaysBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DeviceBay
func (a *DcimApiService) DcimDeviceBaysBulkUpdateExecute(r ApiDcimDeviceBaysBulkUpdateRequest) (*DeviceBay, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeviceBay
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimDeviceBaysBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/device-bays/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimDeviceBaysCreateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	data *WritableDeviceBay
}

func (r ApiDcimDeviceBaysCreateRequest) Data(data WritableDeviceBay) ApiDcimDeviceBaysCreateRequest {
	r.data = &data
	return r
}

func (r ApiDcimDeviceBaysCreateRequest) Execute() (*DeviceBay, *http.Response, error) {
	return r.ApiService.DcimDeviceBaysCreateExecute(r)
}

/*
DcimDeviceBaysCreate Method for DcimDeviceBaysCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimDeviceBaysCreateRequest
*/
func (a *DcimApiService) DcimDeviceBaysCreate(ctx context.Context) ApiDcimDeviceBaysCreateRequest {
	return ApiDcimDeviceBaysCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DeviceBay
func (a *DcimApiService) DcimDeviceBaysCreateExecute(r ApiDcimDeviceBaysCreateRequest) (*DeviceBay, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeviceBay
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimDeviceBaysCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/device-bays/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimDeviceBaysDeleteRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
}

func (r ApiDcimDeviceBaysDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimDeviceBaysDeleteExecute(r)
}

/*
DcimDeviceBaysDelete Method for DcimDeviceBaysDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this device bay.
 @return ApiDcimDeviceBaysDeleteRequest
*/
func (a *DcimApiService) DcimDeviceBaysDelete(ctx context.Context, id int32) ApiDcimDeviceBaysDeleteRequest {
	return ApiDcimDeviceBaysDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DcimApiService) DcimDeviceBaysDeleteExecute(r ApiDcimDeviceBaysDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimDeviceBaysDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/device-bays/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimDeviceBaysListRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id *string
	name *string
	label *string
	description *string
	created *string
	createdGte *string
	createdLte *string
	lastUpdated *string
	lastUpdatedGte *string
	lastUpdatedLte *string
	q *string
	regionId *string
	region *string
	siteGroupId *string
	siteGroup *string
	siteId *string
	site *string
	deviceId *string
	device *string
	tag *string
	idN *string
	idLte *string
	idLt *string
	idGte *string
	idGt *string
	nameN *string
	nameIc *string
	nameNic *string
	nameIew *string
	nameNiew *string
	nameIsw *string
	nameNisw *string
	nameIe *string
	nameNie *string
	nameEmpty *string
	labelN *string
	labelIc *string
	labelNic *string
	labelIew *string
	labelNiew *string
	labelIsw *string
	labelNisw *string
	labelIe *string
	labelNie *string
	labelEmpty *string
	descriptionN *string
	descriptionIc *string
	descriptionNic *string
	descriptionIew *string
	descriptionNiew *string
	descriptionIsw *string
	descriptionNisw *string
	descriptionIe *string
	descriptionNie *string
	descriptionEmpty *string
	regionIdN *string
	regionN *string
	siteGroupIdN *string
	siteGroupN *string
	siteIdN *string
	siteN *string
	deviceIdN *string
	deviceN *string
	tagN *string
	limit *int32
	offset *int32
}

func (r ApiDcimDeviceBaysListRequest) Id(id string) ApiDcimDeviceBaysListRequest {
	r.id = &id
	return r
}

func (r ApiDcimDeviceBaysListRequest) Name(name string) ApiDcimDeviceBaysListRequest {
	r.name = &name
	return r
}

func (r ApiDcimDeviceBaysListRequest) Label(label string) ApiDcimDeviceBaysListRequest {
	r.label = &label
	return r
}

func (r ApiDcimDeviceBaysListRequest) Description(description string) ApiDcimDeviceBaysListRequest {
	r.description = &description
	return r
}

func (r ApiDcimDeviceBaysListRequest) Created(created string) ApiDcimDeviceBaysListRequest {
	r.created = &created
	return r
}

func (r ApiDcimDeviceBaysListRequest) CreatedGte(createdGte string) ApiDcimDeviceBaysListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiDcimDeviceBaysListRequest) CreatedLte(createdLte string) ApiDcimDeviceBaysListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiDcimDeviceBaysListRequest) LastUpdated(lastUpdated string) ApiDcimDeviceBaysListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiDcimDeviceBaysListRequest) LastUpdatedGte(lastUpdatedGte string) ApiDcimDeviceBaysListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiDcimDeviceBaysListRequest) LastUpdatedLte(lastUpdatedLte string) ApiDcimDeviceBaysListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiDcimDeviceBaysListRequest) Q(q string) ApiDcimDeviceBaysListRequest {
	r.q = &q
	return r
}

func (r ApiDcimDeviceBaysListRequest) RegionId(regionId string) ApiDcimDeviceBaysListRequest {
	r.regionId = &regionId
	return r
}

func (r ApiDcimDeviceBaysListRequest) Region(region string) ApiDcimDeviceBaysListRequest {
	r.region = &region
	return r
}

func (r ApiDcimDeviceBaysListRequest) SiteGroupId(siteGroupId string) ApiDcimDeviceBaysListRequest {
	r.siteGroupId = &siteGroupId
	return r
}

func (r ApiDcimDeviceBaysListRequest) SiteGroup(siteGroup string) ApiDcimDeviceBaysListRequest {
	r.siteGroup = &siteGroup
	return r
}

func (r ApiDcimDeviceBaysListRequest) SiteId(siteId string) ApiDcimDeviceBaysListRequest {
	r.siteId = &siteId
	return r
}

func (r ApiDcimDeviceBaysListRequest) Site(site string) ApiDcimDeviceBaysListRequest {
	r.site = &site
	return r
}

func (r ApiDcimDeviceBaysListRequest) DeviceId(deviceId string) ApiDcimDeviceBaysListRequest {
	r.deviceId = &deviceId
	return r
}

func (r ApiDcimDeviceBaysListRequest) Device(device string) ApiDcimDeviceBaysListRequest {
	r.device = &device
	return r
}

func (r ApiDcimDeviceBaysListRequest) Tag(tag string) ApiDcimDeviceBaysListRequest {
	r.tag = &tag
	return r
}

func (r ApiDcimDeviceBaysListRequest) IdN(idN string) ApiDcimDeviceBaysListRequest {
	r.idN = &idN
	return r
}

func (r ApiDcimDeviceBaysListRequest) IdLte(idLte string) ApiDcimDeviceBaysListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiDcimDeviceBaysListRequest) IdLt(idLt string) ApiDcimDeviceBaysListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiDcimDeviceBaysListRequest) IdGte(idGte string) ApiDcimDeviceBaysListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiDcimDeviceBaysListRequest) IdGt(idGt string) ApiDcimDeviceBaysListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiDcimDeviceBaysListRequest) NameN(nameN string) ApiDcimDeviceBaysListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiDcimDeviceBaysListRequest) NameIc(nameIc string) ApiDcimDeviceBaysListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiDcimDeviceBaysListRequest) NameNic(nameNic string) ApiDcimDeviceBaysListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiDcimDeviceBaysListRequest) NameIew(nameIew string) ApiDcimDeviceBaysListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiDcimDeviceBaysListRequest) NameNiew(nameNiew string) ApiDcimDeviceBaysListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiDcimDeviceBaysListRequest) NameIsw(nameIsw string) ApiDcimDeviceBaysListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiDcimDeviceBaysListRequest) NameNisw(nameNisw string) ApiDcimDeviceBaysListRequest {
	r.nameNisw = &nameNisw
	return r
}

func (r ApiDcimDeviceBaysListRequest) NameIe(nameIe string) ApiDcimDeviceBaysListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiDcimDeviceBaysListRequest) NameNie(nameNie string) ApiDcimDeviceBaysListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiDcimDeviceBaysListRequest) NameEmpty(nameEmpty string) ApiDcimDeviceBaysListRequest {
	r.nameEmpty = &nameEmpty
	return r
}

func (r ApiDcimDeviceBaysListRequest) LabelN(labelN string) ApiDcimDeviceBaysListRequest {
	r.labelN = &labelN
	return r
}

func (r ApiDcimDeviceBaysListRequest) LabelIc(labelIc string) ApiDcimDeviceBaysListRequest {
	r.labelIc = &labelIc
	return r
}

func (r ApiDcimDeviceBaysListRequest) LabelNic(labelNic string) ApiDcimDeviceBaysListRequest {
	r.labelNic = &labelNic
	return r
}

func (r ApiDcimDeviceBaysListRequest) LabelIew(labelIew string) ApiDcimDeviceBaysListRequest {
	r.labelIew = &labelIew
	return r
}

func (r ApiDcimDeviceBaysListRequest) LabelNiew(labelNiew string) ApiDcimDeviceBaysListRequest {
	r.labelNiew = &labelNiew
	return r
}

func (r ApiDcimDeviceBaysListRequest) LabelIsw(labelIsw string) ApiDcimDeviceBaysListRequest {
	r.labelIsw = &labelIsw
	return r
}

func (r ApiDcimDeviceBaysListRequest) LabelNisw(labelNisw string) ApiDcimDeviceBaysListRequest {
	r.labelNisw = &labelNisw
	return r
}

func (r ApiDcimDeviceBaysListRequest) LabelIe(labelIe string) ApiDcimDeviceBaysListRequest {
	r.labelIe = &labelIe
	return r
}

func (r ApiDcimDeviceBaysListRequest) LabelNie(labelNie string) ApiDcimDeviceBaysListRequest {
	r.labelNie = &labelNie
	return r
}

func (r ApiDcimDeviceBaysListRequest) LabelEmpty(labelEmpty string) ApiDcimDeviceBaysListRequest {
	r.labelEmpty = &labelEmpty
	return r
}

func (r ApiDcimDeviceBaysListRequest) DescriptionN(descriptionN string) ApiDcimDeviceBaysListRequest {
	r.descriptionN = &descriptionN
	return r
}

func (r ApiDcimDeviceBaysListRequest) DescriptionIc(descriptionIc string) ApiDcimDeviceBaysListRequest {
	r.descriptionIc = &descriptionIc
	return r
}

func (r ApiDcimDeviceBaysListRequest) DescriptionNic(descriptionNic string) ApiDcimDeviceBaysListRequest {
	r.descriptionNic = &descriptionNic
	return r
}

func (r ApiDcimDeviceBaysListRequest) DescriptionIew(descriptionIew string) ApiDcimDeviceBaysListRequest {
	r.descriptionIew = &descriptionIew
	return r
}

func (r ApiDcimDeviceBaysListRequest) DescriptionNiew(descriptionNiew string) ApiDcimDeviceBaysListRequest {
	r.descriptionNiew = &descriptionNiew
	return r
}

func (r ApiDcimDeviceBaysListRequest) DescriptionIsw(descriptionIsw string) ApiDcimDeviceBaysListRequest {
	r.descriptionIsw = &descriptionIsw
	return r
}

func (r ApiDcimDeviceBaysListRequest) DescriptionNisw(descriptionNisw string) ApiDcimDeviceBaysListRequest {
	r.descriptionNisw = &descriptionNisw
	return r
}

func (r ApiDcimDeviceBaysListRequest) DescriptionIe(descriptionIe string) ApiDcimDeviceBaysListRequest {
	r.descriptionIe = &descriptionIe
	return r
}

func (r ApiDcimDeviceBaysListRequest) DescriptionNie(descriptionNie string) ApiDcimDeviceBaysListRequest {
	r.descriptionNie = &descriptionNie
	return r
}

func (r ApiDcimDeviceBaysListRequest) DescriptionEmpty(descriptionEmpty string) ApiDcimDeviceBaysListRequest {
	r.descriptionEmpty = &descriptionEmpty
	return r
}

func (r ApiDcimDeviceBaysListRequest) RegionIdN(regionIdN string) ApiDcimDeviceBaysListRequest {
	r.regionIdN = &regionIdN
	return r
}

func (r ApiDcimDeviceBaysListRequest) RegionN(regionN string) ApiDcimDeviceBaysListRequest {
	r.regionN = &regionN
	return r
}

func (r ApiDcimDeviceBaysListRequest) SiteGroupIdN(siteGroupIdN string) ApiDcimDeviceBaysListRequest {
	r.siteGroupIdN = &siteGroupIdN
	return r
}

func (r ApiDcimDeviceBaysListRequest) SiteGroupN(siteGroupN string) ApiDcimDeviceBaysListRequest {
	r.siteGroupN = &siteGroupN
	return r
}

func (r ApiDcimDeviceBaysListRequest) SiteIdN(siteIdN string) ApiDcimDeviceBaysListRequest {
	r.siteIdN = &siteIdN
	return r
}

func (r ApiDcimDeviceBaysListRequest) SiteN(siteN string) ApiDcimDeviceBaysListRequest {
	r.siteN = &siteN
	return r
}

func (r ApiDcimDeviceBaysListRequest) DeviceIdN(deviceIdN string) ApiDcimDeviceBaysListRequest {
	r.deviceIdN = &deviceIdN
	return r
}

func (r ApiDcimDeviceBaysListRequest) DeviceN(deviceN string) ApiDcimDeviceBaysListRequest {
	r.deviceN = &deviceN
	return r
}

func (r ApiDcimDeviceBaysListRequest) TagN(tagN string) ApiDcimDeviceBaysListRequest {
	r.tagN = &tagN
	return r
}

// Number of results to return per page.
func (r ApiDcimDeviceBaysListRequest) Limit(limit int32) ApiDcimDeviceBaysListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiDcimDeviceBaysListRequest) Offset(offset int32) ApiDcimDeviceBaysListRequest {
	r.offset = &offset
	return r
}

func (r ApiDcimDeviceBaysListRequest) Execute() (*DcimDeviceBaysList200Response, *http.Response, error) {
	return r.ApiService.DcimDeviceBaysListExecute(r)
}

/*
DcimDeviceBaysList Method for DcimDeviceBaysList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimDeviceBaysListRequest
*/
func (a *DcimApiService) DcimDeviceBaysList(ctx context.Context) ApiDcimDeviceBaysListRequest {
	return ApiDcimDeviceBaysListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DcimDeviceBaysList200Response
func (a *DcimApiService) DcimDeviceBaysListExecute(r ApiDcimDeviceBaysListRequest) (*DcimDeviceBaysList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DcimDeviceBaysList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimDeviceBaysList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/device-bays/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.label != nil {
		localVarQueryParams.Add("label", parameterToString(*r.label, ""))
	}
	if r.description != nil {
		localVarQueryParams.Add("description", parameterToString(*r.description, ""))
	}
	if r.created != nil {
		localVarQueryParams.Add("created", parameterToString(*r.created, ""))
	}
	if r.createdGte != nil {
		localVarQueryParams.Add("created__gte", parameterToString(*r.createdGte, ""))
	}
	if r.createdLte != nil {
		localVarQueryParams.Add("created__lte", parameterToString(*r.createdLte, ""))
	}
	if r.lastUpdated != nil {
		localVarQueryParams.Add("last_updated", parameterToString(*r.lastUpdated, ""))
	}
	if r.lastUpdatedGte != nil {
		localVarQueryParams.Add("last_updated__gte", parameterToString(*r.lastUpdatedGte, ""))
	}
	if r.lastUpdatedLte != nil {
		localVarQueryParams.Add("last_updated__lte", parameterToString(*r.lastUpdatedLte, ""))
	}
	if r.q != nil {
		localVarQueryParams.Add("q", parameterToString(*r.q, ""))
	}
	if r.regionId != nil {
		localVarQueryParams.Add("region_id", parameterToString(*r.regionId, ""))
	}
	if r.region != nil {
		localVarQueryParams.Add("region", parameterToString(*r.region, ""))
	}
	if r.siteGroupId != nil {
		localVarQueryParams.Add("site_group_id", parameterToString(*r.siteGroupId, ""))
	}
	if r.siteGroup != nil {
		localVarQueryParams.Add("site_group", parameterToString(*r.siteGroup, ""))
	}
	if r.siteId != nil {
		localVarQueryParams.Add("site_id", parameterToString(*r.siteId, ""))
	}
	if r.site != nil {
		localVarQueryParams.Add("site", parameterToString(*r.site, ""))
	}
	if r.deviceId != nil {
		localVarQueryParams.Add("device_id", parameterToString(*r.deviceId, ""))
	}
	if r.device != nil {
		localVarQueryParams.Add("device", parameterToString(*r.device, ""))
	}
	if r.tag != nil {
		localVarQueryParams.Add("tag", parameterToString(*r.tag, ""))
	}
	if r.idN != nil {
		localVarQueryParams.Add("id__n", parameterToString(*r.idN, ""))
	}
	if r.idLte != nil {
		localVarQueryParams.Add("id__lte", parameterToString(*r.idLte, ""))
	}
	if r.idLt != nil {
		localVarQueryParams.Add("id__lt", parameterToString(*r.idLt, ""))
	}
	if r.idGte != nil {
		localVarQueryParams.Add("id__gte", parameterToString(*r.idGte, ""))
	}
	if r.idGt != nil {
		localVarQueryParams.Add("id__gt", parameterToString(*r.idGt, ""))
	}
	if r.nameN != nil {
		localVarQueryParams.Add("name__n", parameterToString(*r.nameN, ""))
	}
	if r.nameIc != nil {
		localVarQueryParams.Add("name__ic", parameterToString(*r.nameIc, ""))
	}
	if r.nameNic != nil {
		localVarQueryParams.Add("name__nic", parameterToString(*r.nameNic, ""))
	}
	if r.nameIew != nil {
		localVarQueryParams.Add("name__iew", parameterToString(*r.nameIew, ""))
	}
	if r.nameNiew != nil {
		localVarQueryParams.Add("name__niew", parameterToString(*r.nameNiew, ""))
	}
	if r.nameIsw != nil {
		localVarQueryParams.Add("name__isw", parameterToString(*r.nameIsw, ""))
	}
	if r.nameNisw != nil {
		localVarQueryParams.Add("name__nisw", parameterToString(*r.nameNisw, ""))
	}
	if r.nameIe != nil {
		localVarQueryParams.Add("name__ie", parameterToString(*r.nameIe, ""))
	}
	if r.nameNie != nil {
		localVarQueryParams.Add("name__nie", parameterToString(*r.nameNie, ""))
	}
	if r.nameEmpty != nil {
		localVarQueryParams.Add("name__empty", parameterToString(*r.nameEmpty, ""))
	}
	if r.labelN != nil {
		localVarQueryParams.Add("label__n", parameterToString(*r.labelN, ""))
	}
	if r.labelIc != nil {
		localVarQueryParams.Add("label__ic", parameterToString(*r.labelIc, ""))
	}
	if r.labelNic != nil {
		localVarQueryParams.Add("label__nic", parameterToString(*r.labelNic, ""))
	}
	if r.labelIew != nil {
		localVarQueryParams.Add("label__iew", parameterToString(*r.labelIew, ""))
	}
	if r.labelNiew != nil {
		localVarQueryParams.Add("label__niew", parameterToString(*r.labelNiew, ""))
	}
	if r.labelIsw != nil {
		localVarQueryParams.Add("label__isw", parameterToString(*r.labelIsw, ""))
	}
	if r.labelNisw != nil {
		localVarQueryParams.Add("label__nisw", parameterToString(*r.labelNisw, ""))
	}
	if r.labelIe != nil {
		localVarQueryParams.Add("label__ie", parameterToString(*r.labelIe, ""))
	}
	if r.labelNie != nil {
		localVarQueryParams.Add("label__nie", parameterToString(*r.labelNie, ""))
	}
	if r.labelEmpty != nil {
		localVarQueryParams.Add("label__empty", parameterToString(*r.labelEmpty, ""))
	}
	if r.descriptionN != nil {
		localVarQueryParams.Add("description__n", parameterToString(*r.descriptionN, ""))
	}
	if r.descriptionIc != nil {
		localVarQueryParams.Add("description__ic", parameterToString(*r.descriptionIc, ""))
	}
	if r.descriptionNic != nil {
		localVarQueryParams.Add("description__nic", parameterToString(*r.descriptionNic, ""))
	}
	if r.descriptionIew != nil {
		localVarQueryParams.Add("description__iew", parameterToString(*r.descriptionIew, ""))
	}
	if r.descriptionNiew != nil {
		localVarQueryParams.Add("description__niew", parameterToString(*r.descriptionNiew, ""))
	}
	if r.descriptionIsw != nil {
		localVarQueryParams.Add("description__isw", parameterToString(*r.descriptionIsw, ""))
	}
	if r.descriptionNisw != nil {
		localVarQueryParams.Add("description__nisw", parameterToString(*r.descriptionNisw, ""))
	}
	if r.descriptionIe != nil {
		localVarQueryParams.Add("description__ie", parameterToString(*r.descriptionIe, ""))
	}
	if r.descriptionNie != nil {
		localVarQueryParams.Add("description__nie", parameterToString(*r.descriptionNie, ""))
	}
	if r.descriptionEmpty != nil {
		localVarQueryParams.Add("description__empty", parameterToString(*r.descriptionEmpty, ""))
	}
	if r.regionIdN != nil {
		localVarQueryParams.Add("region_id__n", parameterToString(*r.regionIdN, ""))
	}
	if r.regionN != nil {
		localVarQueryParams.Add("region__n", parameterToString(*r.regionN, ""))
	}
	if r.siteGroupIdN != nil {
		localVarQueryParams.Add("site_group_id__n", parameterToString(*r.siteGroupIdN, ""))
	}
	if r.siteGroupN != nil {
		localVarQueryParams.Add("site_group__n", parameterToString(*r.siteGroupN, ""))
	}
	if r.siteIdN != nil {
		localVarQueryParams.Add("site_id__n", parameterToString(*r.siteIdN, ""))
	}
	if r.siteN != nil {
		localVarQueryParams.Add("site__n", parameterToString(*r.siteN, ""))
	}
	if r.deviceIdN != nil {
		localVarQueryParams.Add("device_id__n", parameterToString(*r.deviceIdN, ""))
	}
	if r.deviceN != nil {
		localVarQueryParams.Add("device__n", parameterToString(*r.deviceN, ""))
	}
	if r.tagN != nil {
		localVarQueryParams.Add("tag__n", parameterToString(*r.tagN, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimDeviceBaysPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
	data *WritableDeviceBay
}

func (r ApiDcimDeviceBaysPartialUpdateRequest) Data(data WritableDeviceBay) ApiDcimDeviceBaysPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimDeviceBaysPartialUpdateRequest) Execute() (*DeviceBay, *http.Response, error) {
	return r.ApiService.DcimDeviceBaysPartialUpdateExecute(r)
}

/*
DcimDeviceBaysPartialUpdate Method for DcimDeviceBaysPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this device bay.
 @return ApiDcimDeviceBaysPartialUpdateRequest
*/
func (a *DcimApiService) DcimDeviceBaysPartialUpdate(ctx context.Context, id int32) ApiDcimDeviceBaysPartialUpdateRequest {
	return ApiDcimDeviceBaysPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return DeviceBay
func (a *DcimApiService) DcimDeviceBaysPartialUpdateExecute(r ApiDcimDeviceBaysPartialUpdateRequest) (*DeviceBay, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeviceBay
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimDeviceBaysPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/device-bays/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimDeviceBaysReadRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
}

func (r ApiDcimDeviceBaysReadRequest) Execute() (*DeviceBay, *http.Response, error) {
	return r.ApiService.DcimDeviceBaysReadExecute(r)
}

/*
DcimDeviceBaysRead Method for DcimDeviceBaysRead

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this device bay.
 @return ApiDcimDeviceBaysReadRequest
*/
func (a *DcimApiService) DcimDeviceBaysRead(ctx context.Context, id int32) ApiDcimDeviceBaysReadRequest {
	return ApiDcimDeviceBaysReadRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return DeviceBay
func (a *DcimApiService) DcimDeviceBaysReadExecute(r ApiDcimDeviceBaysReadRequest) (*DeviceBay, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeviceBay
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimDeviceBaysRead")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/device-bays/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimDeviceBaysUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
	data *WritableDeviceBay
}

func (r ApiDcimDeviceBaysUpdateRequest) Data(data WritableDeviceBay) ApiDcimDeviceBaysUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimDeviceBaysUpdateRequest) Execute() (*DeviceBay, *http.Response, error) {
	return r.ApiService.DcimDeviceBaysUpdateExecute(r)
}

/*
DcimDeviceBaysUpdate Method for DcimDeviceBaysUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this device bay.
 @return ApiDcimDeviceBaysUpdateRequest
*/
func (a *DcimApiService) DcimDeviceBaysUpdate(ctx context.Context, id int32) ApiDcimDeviceBaysUpdateRequest {
	return ApiDcimDeviceBaysUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return DeviceBay
func (a *DcimApiService) DcimDeviceBaysUpdateExecute(r ApiDcimDeviceBaysUpdateRequest) (*DeviceBay, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeviceBay
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimDeviceBaysUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/device-bays/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimDeviceRolesBulkDeleteRequest struct {
	ctx context.Context
	ApiService *DcimApiService
}

func (r ApiDcimDeviceRolesBulkDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimDeviceRolesBulkDeleteExecute(r)
}

/*
DcimDeviceRolesBulkDelete Method for DcimDeviceRolesBulkDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimDeviceRolesBulkDeleteRequest
*/
func (a *DcimApiService) DcimDeviceRolesBulkDelete(ctx context.Context) ApiDcimDeviceRolesBulkDeleteRequest {
	return ApiDcimDeviceRolesBulkDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DcimApiService) DcimDeviceRolesBulkDeleteExecute(r ApiDcimDeviceRolesBulkDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimDeviceRolesBulkDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/device-roles/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimDeviceRolesBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	data *DeviceRole
}

func (r ApiDcimDeviceRolesBulkPartialUpdateRequest) Data(data DeviceRole) ApiDcimDeviceRolesBulkPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimDeviceRolesBulkPartialUpdateRequest) Execute() (*DeviceRole, *http.Response, error) {
	return r.ApiService.DcimDeviceRolesBulkPartialUpdateExecute(r)
}

/*
DcimDeviceRolesBulkPartialUpdate Method for DcimDeviceRolesBulkPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimDeviceRolesBulkPartialUpdateRequest
*/
func (a *DcimApiService) DcimDeviceRolesBulkPartialUpdate(ctx context.Context) ApiDcimDeviceRolesBulkPartialUpdateRequest {
	return ApiDcimDeviceRolesBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DeviceRole
func (a *DcimApiService) DcimDeviceRolesBulkPartialUpdateExecute(r ApiDcimDeviceRolesBulkPartialUpdateRequest) (*DeviceRole, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeviceRole
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimDeviceRolesBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/device-roles/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimDeviceRolesBulkUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	data *DeviceRole
}

func (r ApiDcimDeviceRolesBulkUpdateRequest) Data(data DeviceRole) ApiDcimDeviceRolesBulkUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimDeviceRolesBulkUpdateRequest) Execute() (*DeviceRole, *http.Response, error) {
	return r.ApiService.DcimDeviceRolesBulkUpdateExecute(r)
}

/*
DcimDeviceRolesBulkUpdate Method for DcimDeviceRolesBulkUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimDeviceRolesBulkUpdateRequest
*/
func (a *DcimApiService) DcimDeviceRolesBulkUpdate(ctx context.Context) ApiDcimDeviceRolesBulkUpdateRequest {
	return ApiDcimDeviceRolesBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DeviceRole
func (a *DcimApiService) DcimDeviceRolesBulkUpdateExecute(r ApiDcimDeviceRolesBulkUpdateRequest) (*DeviceRole, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeviceRole
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimDeviceRolesBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/device-roles/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimDeviceRolesCreateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	data *DeviceRole
}

func (r ApiDcimDeviceRolesCreateRequest) Data(data DeviceRole) ApiDcimDeviceRolesCreateRequest {
	r.data = &data
	return r
}

func (r ApiDcimDeviceRolesCreateRequest) Execute() (*DeviceRole, *http.Response, error) {
	return r.ApiService.DcimDeviceRolesCreateExecute(r)
}

/*
DcimDeviceRolesCreate Method for DcimDeviceRolesCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimDeviceRolesCreateRequest
*/
func (a *DcimApiService) DcimDeviceRolesCreate(ctx context.Context) ApiDcimDeviceRolesCreateRequest {
	return ApiDcimDeviceRolesCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DeviceRole
func (a *DcimApiService) DcimDeviceRolesCreateExecute(r ApiDcimDeviceRolesCreateRequest) (*DeviceRole, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeviceRole
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimDeviceRolesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/device-roles/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimDeviceRolesDeleteRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
}

func (r ApiDcimDeviceRolesDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimDeviceRolesDeleteExecute(r)
}

/*
DcimDeviceRolesDelete Method for DcimDeviceRolesDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this device role.
 @return ApiDcimDeviceRolesDeleteRequest
*/
func (a *DcimApiService) DcimDeviceRolesDelete(ctx context.Context, id int32) ApiDcimDeviceRolesDeleteRequest {
	return ApiDcimDeviceRolesDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DcimApiService) DcimDeviceRolesDeleteExecute(r ApiDcimDeviceRolesDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimDeviceRolesDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/device-roles/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimDeviceRolesListRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id *string
	name *string
	slug *string
	color *string
	vmRole *string
	created *string
	createdGte *string
	createdLte *string
	lastUpdated *string
	lastUpdatedGte *string
	lastUpdatedLte *string
	q *string
	idN *string
	idLte *string
	idLt *string
	idGte *string
	idGt *string
	nameN *string
	nameIc *string
	nameNic *string
	nameIew *string
	nameNiew *string
	nameIsw *string
	nameNisw *string
	nameIe *string
	nameNie *string
	nameEmpty *string
	slugN *string
	slugIc *string
	slugNic *string
	slugIew *string
	slugNiew *string
	slugIsw *string
	slugNisw *string
	slugIe *string
	slugNie *string
	slugEmpty *string
	colorN *string
	colorIc *string
	colorNic *string
	colorIew *string
	colorNiew *string
	colorIsw *string
	colorNisw *string
	colorIe *string
	colorNie *string
	colorEmpty *string
	limit *int32
	offset *int32
}

func (r ApiDcimDeviceRolesListRequest) Id(id string) ApiDcimDeviceRolesListRequest {
	r.id = &id
	return r
}

func (r ApiDcimDeviceRolesListRequest) Name(name string) ApiDcimDeviceRolesListRequest {
	r.name = &name
	return r
}

func (r ApiDcimDeviceRolesListRequest) Slug(slug string) ApiDcimDeviceRolesListRequest {
	r.slug = &slug
	return r
}

func (r ApiDcimDeviceRolesListRequest) Color(color string) ApiDcimDeviceRolesListRequest {
	r.color = &color
	return r
}

func (r ApiDcimDeviceRolesListRequest) VmRole(vmRole string) ApiDcimDeviceRolesListRequest {
	r.vmRole = &vmRole
	return r
}

func (r ApiDcimDeviceRolesListRequest) Created(created string) ApiDcimDeviceRolesListRequest {
	r.created = &created
	return r
}

func (r ApiDcimDeviceRolesListRequest) CreatedGte(createdGte string) ApiDcimDeviceRolesListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiDcimDeviceRolesListRequest) CreatedLte(createdLte string) ApiDcimDeviceRolesListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiDcimDeviceRolesListRequest) LastUpdated(lastUpdated string) ApiDcimDeviceRolesListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiDcimDeviceRolesListRequest) LastUpdatedGte(lastUpdatedGte string) ApiDcimDeviceRolesListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiDcimDeviceRolesListRequest) LastUpdatedLte(lastUpdatedLte string) ApiDcimDeviceRolesListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiDcimDeviceRolesListRequest) Q(q string) ApiDcimDeviceRolesListRequest {
	r.q = &q
	return r
}

func (r ApiDcimDeviceRolesListRequest) IdN(idN string) ApiDcimDeviceRolesListRequest {
	r.idN = &idN
	return r
}

func (r ApiDcimDeviceRolesListRequest) IdLte(idLte string) ApiDcimDeviceRolesListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiDcimDeviceRolesListRequest) IdLt(idLt string) ApiDcimDeviceRolesListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiDcimDeviceRolesListRequest) IdGte(idGte string) ApiDcimDeviceRolesListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiDcimDeviceRolesListRequest) IdGt(idGt string) ApiDcimDeviceRolesListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiDcimDeviceRolesListRequest) NameN(nameN string) ApiDcimDeviceRolesListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiDcimDeviceRolesListRequest) NameIc(nameIc string) ApiDcimDeviceRolesListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiDcimDeviceRolesListRequest) NameNic(nameNic string) ApiDcimDeviceRolesListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiDcimDeviceRolesListRequest) NameIew(nameIew string) ApiDcimDeviceRolesListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiDcimDeviceRolesListRequest) NameNiew(nameNiew string) ApiDcimDeviceRolesListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiDcimDeviceRolesListRequest) NameIsw(nameIsw string) ApiDcimDeviceRolesListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiDcimDeviceRolesListRequest) NameNisw(nameNisw string) ApiDcimDeviceRolesListRequest {
	r.nameNisw = &nameNisw
	return r
}

func (r ApiDcimDeviceRolesListRequest) NameIe(nameIe string) ApiDcimDeviceRolesListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiDcimDeviceRolesListRequest) NameNie(nameNie string) ApiDcimDeviceRolesListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiDcimDeviceRolesListRequest) NameEmpty(nameEmpty string) ApiDcimDeviceRolesListRequest {
	r.nameEmpty = &nameEmpty
	return r
}

func (r ApiDcimDeviceRolesListRequest) SlugN(slugN string) ApiDcimDeviceRolesListRequest {
	r.slugN = &slugN
	return r
}

func (r ApiDcimDeviceRolesListRequest) SlugIc(slugIc string) ApiDcimDeviceRolesListRequest {
	r.slugIc = &slugIc
	return r
}

func (r ApiDcimDeviceRolesListRequest) SlugNic(slugNic string) ApiDcimDeviceRolesListRequest {
	r.slugNic = &slugNic
	return r
}

func (r ApiDcimDeviceRolesListRequest) SlugIew(slugIew string) ApiDcimDeviceRolesListRequest {
	r.slugIew = &slugIew
	return r
}

func (r ApiDcimDeviceRolesListRequest) SlugNiew(slugNiew string) ApiDcimDeviceRolesListRequest {
	r.slugNiew = &slugNiew
	return r
}

func (r ApiDcimDeviceRolesListRequest) SlugIsw(slugIsw string) ApiDcimDeviceRolesListRequest {
	r.slugIsw = &slugIsw
	return r
}

func (r ApiDcimDeviceRolesListRequest) SlugNisw(slugNisw string) ApiDcimDeviceRolesListRequest {
	r.slugNisw = &slugNisw
	return r
}

func (r ApiDcimDeviceRolesListRequest) SlugIe(slugIe string) ApiDcimDeviceRolesListRequest {
	r.slugIe = &slugIe
	return r
}

func (r ApiDcimDeviceRolesListRequest) SlugNie(slugNie string) ApiDcimDeviceRolesListRequest {
	r.slugNie = &slugNie
	return r
}

func (r ApiDcimDeviceRolesListRequest) SlugEmpty(slugEmpty string) ApiDcimDeviceRolesListRequest {
	r.slugEmpty = &slugEmpty
	return r
}

func (r ApiDcimDeviceRolesListRequest) ColorN(colorN string) ApiDcimDeviceRolesListRequest {
	r.colorN = &colorN
	return r
}

func (r ApiDcimDeviceRolesListRequest) ColorIc(colorIc string) ApiDcimDeviceRolesListRequest {
	r.colorIc = &colorIc
	return r
}

func (r ApiDcimDeviceRolesListRequest) ColorNic(colorNic string) ApiDcimDeviceRolesListRequest {
	r.colorNic = &colorNic
	return r
}

func (r ApiDcimDeviceRolesListRequest) ColorIew(colorIew string) ApiDcimDeviceRolesListRequest {
	r.colorIew = &colorIew
	return r
}

func (r ApiDcimDeviceRolesListRequest) ColorNiew(colorNiew string) ApiDcimDeviceRolesListRequest {
	r.colorNiew = &colorNiew
	return r
}

func (r ApiDcimDeviceRolesListRequest) ColorIsw(colorIsw string) ApiDcimDeviceRolesListRequest {
	r.colorIsw = &colorIsw
	return r
}

func (r ApiDcimDeviceRolesListRequest) ColorNisw(colorNisw string) ApiDcimDeviceRolesListRequest {
	r.colorNisw = &colorNisw
	return r
}

func (r ApiDcimDeviceRolesListRequest) ColorIe(colorIe string) ApiDcimDeviceRolesListRequest {
	r.colorIe = &colorIe
	return r
}

func (r ApiDcimDeviceRolesListRequest) ColorNie(colorNie string) ApiDcimDeviceRolesListRequest {
	r.colorNie = &colorNie
	return r
}

func (r ApiDcimDeviceRolesListRequest) ColorEmpty(colorEmpty string) ApiDcimDeviceRolesListRequest {
	r.colorEmpty = &colorEmpty
	return r
}

// Number of results to return per page.
func (r ApiDcimDeviceRolesListRequest) Limit(limit int32) ApiDcimDeviceRolesListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiDcimDeviceRolesListRequest) Offset(offset int32) ApiDcimDeviceRolesListRequest {
	r.offset = &offset
	return r
}

func (r ApiDcimDeviceRolesListRequest) Execute() (*DcimDeviceRolesList200Response, *http.Response, error) {
	return r.ApiService.DcimDeviceRolesListExecute(r)
}

/*
DcimDeviceRolesList Method for DcimDeviceRolesList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimDeviceRolesListRequest
*/
func (a *DcimApiService) DcimDeviceRolesList(ctx context.Context) ApiDcimDeviceRolesListRequest {
	return ApiDcimDeviceRolesListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DcimDeviceRolesList200Response
func (a *DcimApiService) DcimDeviceRolesListExecute(r ApiDcimDeviceRolesListRequest) (*DcimDeviceRolesList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DcimDeviceRolesList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimDeviceRolesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/device-roles/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.slug != nil {
		localVarQueryParams.Add("slug", parameterToString(*r.slug, ""))
	}
	if r.color != nil {
		localVarQueryParams.Add("color", parameterToString(*r.color, ""))
	}
	if r.vmRole != nil {
		localVarQueryParams.Add("vm_role", parameterToString(*r.vmRole, ""))
	}
	if r.created != nil {
		localVarQueryParams.Add("created", parameterToString(*r.created, ""))
	}
	if r.createdGte != nil {
		localVarQueryParams.Add("created__gte", parameterToString(*r.createdGte, ""))
	}
	if r.createdLte != nil {
		localVarQueryParams.Add("created__lte", parameterToString(*r.createdLte, ""))
	}
	if r.lastUpdated != nil {
		localVarQueryParams.Add("last_updated", parameterToString(*r.lastUpdated, ""))
	}
	if r.lastUpdatedGte != nil {
		localVarQueryParams.Add("last_updated__gte", parameterToString(*r.lastUpdatedGte, ""))
	}
	if r.lastUpdatedLte != nil {
		localVarQueryParams.Add("last_updated__lte", parameterToString(*r.lastUpdatedLte, ""))
	}
	if r.q != nil {
		localVarQueryParams.Add("q", parameterToString(*r.q, ""))
	}
	if r.idN != nil {
		localVarQueryParams.Add("id__n", parameterToString(*r.idN, ""))
	}
	if r.idLte != nil {
		localVarQueryParams.Add("id__lte", parameterToString(*r.idLte, ""))
	}
	if r.idLt != nil {
		localVarQueryParams.Add("id__lt", parameterToString(*r.idLt, ""))
	}
	if r.idGte != nil {
		localVarQueryParams.Add("id__gte", parameterToString(*r.idGte, ""))
	}
	if r.idGt != nil {
		localVarQueryParams.Add("id__gt", parameterToString(*r.idGt, ""))
	}
	if r.nameN != nil {
		localVarQueryParams.Add("name__n", parameterToString(*r.nameN, ""))
	}
	if r.nameIc != nil {
		localVarQueryParams.Add("name__ic", parameterToString(*r.nameIc, ""))
	}
	if r.nameNic != nil {
		localVarQueryParams.Add("name__nic", parameterToString(*r.nameNic, ""))
	}
	if r.nameIew != nil {
		localVarQueryParams.Add("name__iew", parameterToString(*r.nameIew, ""))
	}
	if r.nameNiew != nil {
		localVarQueryParams.Add("name__niew", parameterToString(*r.nameNiew, ""))
	}
	if r.nameIsw != nil {
		localVarQueryParams.Add("name__isw", parameterToString(*r.nameIsw, ""))
	}
	if r.nameNisw != nil {
		localVarQueryParams.Add("name__nisw", parameterToString(*r.nameNisw, ""))
	}
	if r.nameIe != nil {
		localVarQueryParams.Add("name__ie", parameterToString(*r.nameIe, ""))
	}
	if r.nameNie != nil {
		localVarQueryParams.Add("name__nie", parameterToString(*r.nameNie, ""))
	}
	if r.nameEmpty != nil {
		localVarQueryParams.Add("name__empty", parameterToString(*r.nameEmpty, ""))
	}
	if r.slugN != nil {
		localVarQueryParams.Add("slug__n", parameterToString(*r.slugN, ""))
	}
	if r.slugIc != nil {
		localVarQueryParams.Add("slug__ic", parameterToString(*r.slugIc, ""))
	}
	if r.slugNic != nil {
		localVarQueryParams.Add("slug__nic", parameterToString(*r.slugNic, ""))
	}
	if r.slugIew != nil {
		localVarQueryParams.Add("slug__iew", parameterToString(*r.slugIew, ""))
	}
	if r.slugNiew != nil {
		localVarQueryParams.Add("slug__niew", parameterToString(*r.slugNiew, ""))
	}
	if r.slugIsw != nil {
		localVarQueryParams.Add("slug__isw", parameterToString(*r.slugIsw, ""))
	}
	if r.slugNisw != nil {
		localVarQueryParams.Add("slug__nisw", parameterToString(*r.slugNisw, ""))
	}
	if r.slugIe != nil {
		localVarQueryParams.Add("slug__ie", parameterToString(*r.slugIe, ""))
	}
	if r.slugNie != nil {
		localVarQueryParams.Add("slug__nie", parameterToString(*r.slugNie, ""))
	}
	if r.slugEmpty != nil {
		localVarQueryParams.Add("slug__empty", parameterToString(*r.slugEmpty, ""))
	}
	if r.colorN != nil {
		localVarQueryParams.Add("color__n", parameterToString(*r.colorN, ""))
	}
	if r.colorIc != nil {
		localVarQueryParams.Add("color__ic", parameterToString(*r.colorIc, ""))
	}
	if r.colorNic != nil {
		localVarQueryParams.Add("color__nic", parameterToString(*r.colorNic, ""))
	}
	if r.colorIew != nil {
		localVarQueryParams.Add("color__iew", parameterToString(*r.colorIew, ""))
	}
	if r.colorNiew != nil {
		localVarQueryParams.Add("color__niew", parameterToString(*r.colorNiew, ""))
	}
	if r.colorIsw != nil {
		localVarQueryParams.Add("color__isw", parameterToString(*r.colorIsw, ""))
	}
	if r.colorNisw != nil {
		localVarQueryParams.Add("color__nisw", parameterToString(*r.colorNisw, ""))
	}
	if r.colorIe != nil {
		localVarQueryParams.Add("color__ie", parameterToString(*r.colorIe, ""))
	}
	if r.colorNie != nil {
		localVarQueryParams.Add("color__nie", parameterToString(*r.colorNie, ""))
	}
	if r.colorEmpty != nil {
		localVarQueryParams.Add("color__empty", parameterToString(*r.colorEmpty, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimDeviceRolesPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
	data *DeviceRole
}

func (r ApiDcimDeviceRolesPartialUpdateRequest) Data(data DeviceRole) ApiDcimDeviceRolesPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimDeviceRolesPartialUpdateRequest) Execute() (*DeviceRole, *http.Response, error) {
	return r.ApiService.DcimDeviceRolesPartialUpdateExecute(r)
}

/*
DcimDeviceRolesPartialUpdate Method for DcimDeviceRolesPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this device role.
 @return ApiDcimDeviceRolesPartialUpdateRequest
*/
func (a *DcimApiService) DcimDeviceRolesPartialUpdate(ctx context.Context, id int32) ApiDcimDeviceRolesPartialUpdateRequest {
	return ApiDcimDeviceRolesPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return DeviceRole
func (a *DcimApiService) DcimDeviceRolesPartialUpdateExecute(r ApiDcimDeviceRolesPartialUpdateRequest) (*DeviceRole, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeviceRole
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimDeviceRolesPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/device-roles/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimDeviceRolesReadRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
}

func (r ApiDcimDeviceRolesReadRequest) Execute() (*DeviceRole, *http.Response, error) {
	return r.ApiService.DcimDeviceRolesReadExecute(r)
}

/*
DcimDeviceRolesRead Method for DcimDeviceRolesRead

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this device role.
 @return ApiDcimDeviceRolesReadRequest
*/
func (a *DcimApiService) DcimDeviceRolesRead(ctx context.Context, id int32) ApiDcimDeviceRolesReadRequest {
	return ApiDcimDeviceRolesReadRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return DeviceRole
func (a *DcimApiService) DcimDeviceRolesReadExecute(r ApiDcimDeviceRolesReadRequest) (*DeviceRole, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeviceRole
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimDeviceRolesRead")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/device-roles/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimDeviceRolesUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
	data *DeviceRole
}

func (r ApiDcimDeviceRolesUpdateRequest) Data(data DeviceRole) ApiDcimDeviceRolesUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimDeviceRolesUpdateRequest) Execute() (*DeviceRole, *http.Response, error) {
	return r.ApiService.DcimDeviceRolesUpdateExecute(r)
}

/*
DcimDeviceRolesUpdate Method for DcimDeviceRolesUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this device role.
 @return ApiDcimDeviceRolesUpdateRequest
*/
func (a *DcimApiService) DcimDeviceRolesUpdate(ctx context.Context, id int32) ApiDcimDeviceRolesUpdateRequest {
	return ApiDcimDeviceRolesUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return DeviceRole
func (a *DcimApiService) DcimDeviceRolesUpdateExecute(r ApiDcimDeviceRolesUpdateRequest) (*DeviceRole, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeviceRole
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimDeviceRolesUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/device-roles/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimDeviceTypesBulkDeleteRequest struct {
	ctx context.Context
	ApiService *DcimApiService
}

func (r ApiDcimDeviceTypesBulkDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimDeviceTypesBulkDeleteExecute(r)
}

/*
DcimDeviceTypesBulkDelete Method for DcimDeviceTypesBulkDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimDeviceTypesBulkDeleteRequest
*/
func (a *DcimApiService) DcimDeviceTypesBulkDelete(ctx context.Context) ApiDcimDeviceTypesBulkDeleteRequest {
	return ApiDcimDeviceTypesBulkDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DcimApiService) DcimDeviceTypesBulkDeleteExecute(r ApiDcimDeviceTypesBulkDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimDeviceTypesBulkDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/device-types/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimDeviceTypesBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	data *WritableDeviceType
}

func (r ApiDcimDeviceTypesBulkPartialUpdateRequest) Data(data WritableDeviceType) ApiDcimDeviceTypesBulkPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimDeviceTypesBulkPartialUpdateRequest) Execute() (*DeviceType, *http.Response, error) {
	return r.ApiService.DcimDeviceTypesBulkPartialUpdateExecute(r)
}

/*
DcimDeviceTypesBulkPartialUpdate Method for DcimDeviceTypesBulkPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimDeviceTypesBulkPartialUpdateRequest
*/
func (a *DcimApiService) DcimDeviceTypesBulkPartialUpdate(ctx context.Context) ApiDcimDeviceTypesBulkPartialUpdateRequest {
	return ApiDcimDeviceTypesBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DeviceType
func (a *DcimApiService) DcimDeviceTypesBulkPartialUpdateExecute(r ApiDcimDeviceTypesBulkPartialUpdateRequest) (*DeviceType, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeviceType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimDeviceTypesBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/device-types/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimDeviceTypesBulkUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	data *WritableDeviceType
}

func (r ApiDcimDeviceTypesBulkUpdateRequest) Data(data WritableDeviceType) ApiDcimDeviceTypesBulkUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimDeviceTypesBulkUpdateRequest) Execute() (*DeviceType, *http.Response, error) {
	return r.ApiService.DcimDeviceTypesBulkUpdateExecute(r)
}

/*
DcimDeviceTypesBulkUpdate Method for DcimDeviceTypesBulkUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimDeviceTypesBulkUpdateRequest
*/
func (a *DcimApiService) DcimDeviceTypesBulkUpdate(ctx context.Context) ApiDcimDeviceTypesBulkUpdateRequest {
	return ApiDcimDeviceTypesBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DeviceType
func (a *DcimApiService) DcimDeviceTypesBulkUpdateExecute(r ApiDcimDeviceTypesBulkUpdateRequest) (*DeviceType, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeviceType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimDeviceTypesBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/device-types/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimDeviceTypesCreateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	data *WritableDeviceType
}

func (r ApiDcimDeviceTypesCreateRequest) Data(data WritableDeviceType) ApiDcimDeviceTypesCreateRequest {
	r.data = &data
	return r
}

func (r ApiDcimDeviceTypesCreateRequest) Execute() (*DeviceType, *http.Response, error) {
	return r.ApiService.DcimDeviceTypesCreateExecute(r)
}

/*
DcimDeviceTypesCreate Method for DcimDeviceTypesCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimDeviceTypesCreateRequest
*/
func (a *DcimApiService) DcimDeviceTypesCreate(ctx context.Context) ApiDcimDeviceTypesCreateRequest {
	return ApiDcimDeviceTypesCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DeviceType
func (a *DcimApiService) DcimDeviceTypesCreateExecute(r ApiDcimDeviceTypesCreateRequest) (*DeviceType, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeviceType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimDeviceTypesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/device-types/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimDeviceTypesDeleteRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
}

func (r ApiDcimDeviceTypesDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimDeviceTypesDeleteExecute(r)
}

/*
DcimDeviceTypesDelete Method for DcimDeviceTypesDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this device type.
 @return ApiDcimDeviceTypesDeleteRequest
*/
func (a *DcimApiService) DcimDeviceTypesDelete(ctx context.Context, id int32) ApiDcimDeviceTypesDeleteRequest {
	return ApiDcimDeviceTypesDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DcimApiService) DcimDeviceTypesDeleteExecute(r ApiDcimDeviceTypesDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimDeviceTypesDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/device-types/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimDeviceTypesListRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id *string
	model *string
	slug *string
	partNumber *string
	uHeight *string
	isFullDepth *string
	subdeviceRole *string
	created *string
	createdGte *string
	createdLte *string
	lastUpdated *string
	lastUpdatedGte *string
	lastUpdatedLte *string
	q *string
	manufacturerId *string
	manufacturer *string
	consolePorts *string
	consoleServerPorts *string
	powerPorts *string
	powerOutlets *string
	interfaces *string
	passThroughPorts *string
	deviceBays *string
	tag *string
	idN *string
	idLte *string
	idLt *string
	idGte *string
	idGt *string
	modelN *string
	modelIc *string
	modelNic *string
	modelIew *string
	modelNiew *string
	modelIsw *string
	modelNisw *string
	modelIe *string
	modelNie *string
	modelEmpty *string
	slugN *string
	slugIc *string
	slugNic *string
	slugIew *string
	slugNiew *string
	slugIsw *string
	slugNisw *string
	slugIe *string
	slugNie *string
	slugEmpty *string
	partNumberN *string
	partNumberIc *string
	partNumberNic *string
	partNumberIew *string
	partNumberNiew *string
	partNumberIsw *string
	partNumberNisw *string
	partNumberIe *string
	partNumberNie *string
	partNumberEmpty *string
	uHeightN *string
	uHeightLte *string
	uHeightLt *string
	uHeightGte *string
	uHeightGt *string
	subdeviceRoleN *string
	manufacturerIdN *string
	manufacturerN *string
	tagN *string
	limit *int32
	offset *int32
}

func (r ApiDcimDeviceTypesListRequest) Id(id string) ApiDcimDeviceTypesListRequest {
	r.id = &id
	return r
}

func (r ApiDcimDeviceTypesListRequest) Model(model string) ApiDcimDeviceTypesListRequest {
	r.model = &model
	return r
}

func (r ApiDcimDeviceTypesListRequest) Slug(slug string) ApiDcimDeviceTypesListRequest {
	r.slug = &slug
	return r
}

func (r ApiDcimDeviceTypesListRequest) PartNumber(partNumber string) ApiDcimDeviceTypesListRequest {
	r.partNumber = &partNumber
	return r
}

func (r ApiDcimDeviceTypesListRequest) UHeight(uHeight string) ApiDcimDeviceTypesListRequest {
	r.uHeight = &uHeight
	return r
}

func (r ApiDcimDeviceTypesListRequest) IsFullDepth(isFullDepth string) ApiDcimDeviceTypesListRequest {
	r.isFullDepth = &isFullDepth
	return r
}

func (r ApiDcimDeviceTypesListRequest) SubdeviceRole(subdeviceRole string) ApiDcimDeviceTypesListRequest {
	r.subdeviceRole = &subdeviceRole
	return r
}

func (r ApiDcimDeviceTypesListRequest) Created(created string) ApiDcimDeviceTypesListRequest {
	r.created = &created
	return r
}

func (r ApiDcimDeviceTypesListRequest) CreatedGte(createdGte string) ApiDcimDeviceTypesListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiDcimDeviceTypesListRequest) CreatedLte(createdLte string) ApiDcimDeviceTypesListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiDcimDeviceTypesListRequest) LastUpdated(lastUpdated string) ApiDcimDeviceTypesListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiDcimDeviceTypesListRequest) LastUpdatedGte(lastUpdatedGte string) ApiDcimDeviceTypesListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiDcimDeviceTypesListRequest) LastUpdatedLte(lastUpdatedLte string) ApiDcimDeviceTypesListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiDcimDeviceTypesListRequest) Q(q string) ApiDcimDeviceTypesListRequest {
	r.q = &q
	return r
}

func (r ApiDcimDeviceTypesListRequest) ManufacturerId(manufacturerId string) ApiDcimDeviceTypesListRequest {
	r.manufacturerId = &manufacturerId
	return r
}

func (r ApiDcimDeviceTypesListRequest) Manufacturer(manufacturer string) ApiDcimDeviceTypesListRequest {
	r.manufacturer = &manufacturer
	return r
}

func (r ApiDcimDeviceTypesListRequest) ConsolePorts(consolePorts string) ApiDcimDeviceTypesListRequest {
	r.consolePorts = &consolePorts
	return r
}

func (r ApiDcimDeviceTypesListRequest) ConsoleServerPorts(consoleServerPorts string) ApiDcimDeviceTypesListRequest {
	r.consoleServerPorts = &consoleServerPorts
	return r
}

func (r ApiDcimDeviceTypesListRequest) PowerPorts(powerPorts string) ApiDcimDeviceTypesListRequest {
	r.powerPorts = &powerPorts
	return r
}

func (r ApiDcimDeviceTypesListRequest) PowerOutlets(powerOutlets string) ApiDcimDeviceTypesListRequest {
	r.powerOutlets = &powerOutlets
	return r
}

func (r ApiDcimDeviceTypesListRequest) Interfaces(interfaces string) ApiDcimDeviceTypesListRequest {
	r.interfaces = &interfaces
	return r
}

func (r ApiDcimDeviceTypesListRequest) PassThroughPorts(passThroughPorts string) ApiDcimDeviceTypesListRequest {
	r.passThroughPorts = &passThroughPorts
	return r
}

func (r ApiDcimDeviceTypesListRequest) DeviceBays(deviceBays string) ApiDcimDeviceTypesListRequest {
	r.deviceBays = &deviceBays
	return r
}

func (r ApiDcimDeviceTypesListRequest) Tag(tag string) ApiDcimDeviceTypesListRequest {
	r.tag = &tag
	return r
}

func (r ApiDcimDeviceTypesListRequest) IdN(idN string) ApiDcimDeviceTypesListRequest {
	r.idN = &idN
	return r
}

func (r ApiDcimDeviceTypesListRequest) IdLte(idLte string) ApiDcimDeviceTypesListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiDcimDeviceTypesListRequest) IdLt(idLt string) ApiDcimDeviceTypesListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiDcimDeviceTypesListRequest) IdGte(idGte string) ApiDcimDeviceTypesListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiDcimDeviceTypesListRequest) IdGt(idGt string) ApiDcimDeviceTypesListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiDcimDeviceTypesListRequest) ModelN(modelN string) ApiDcimDeviceTypesListRequest {
	r.modelN = &modelN
	return r
}

func (r ApiDcimDeviceTypesListRequest) ModelIc(modelIc string) ApiDcimDeviceTypesListRequest {
	r.modelIc = &modelIc
	return r
}

func (r ApiDcimDeviceTypesListRequest) ModelNic(modelNic string) ApiDcimDeviceTypesListRequest {
	r.modelNic = &modelNic
	return r
}

func (r ApiDcimDeviceTypesListRequest) ModelIew(modelIew string) ApiDcimDeviceTypesListRequest {
	r.modelIew = &modelIew
	return r
}

func (r ApiDcimDeviceTypesListRequest) ModelNiew(modelNiew string) ApiDcimDeviceTypesListRequest {
	r.modelNiew = &modelNiew
	return r
}

func (r ApiDcimDeviceTypesListRequest) ModelIsw(modelIsw string) ApiDcimDeviceTypesListRequest {
	r.modelIsw = &modelIsw
	return r
}

func (r ApiDcimDeviceTypesListRequest) ModelNisw(modelNisw string) ApiDcimDeviceTypesListRequest {
	r.modelNisw = &modelNisw
	return r
}

func (r ApiDcimDeviceTypesListRequest) ModelIe(modelIe string) ApiDcimDeviceTypesListRequest {
	r.modelIe = &modelIe
	return r
}

func (r ApiDcimDeviceTypesListRequest) ModelNie(modelNie string) ApiDcimDeviceTypesListRequest {
	r.modelNie = &modelNie
	return r
}

func (r ApiDcimDeviceTypesListRequest) ModelEmpty(modelEmpty string) ApiDcimDeviceTypesListRequest {
	r.modelEmpty = &modelEmpty
	return r
}

func (r ApiDcimDeviceTypesListRequest) SlugN(slugN string) ApiDcimDeviceTypesListRequest {
	r.slugN = &slugN
	return r
}

func (r ApiDcimDeviceTypesListRequest) SlugIc(slugIc string) ApiDcimDeviceTypesListRequest {
	r.slugIc = &slugIc
	return r
}

func (r ApiDcimDeviceTypesListRequest) SlugNic(slugNic string) ApiDcimDeviceTypesListRequest {
	r.slugNic = &slugNic
	return r
}

func (r ApiDcimDeviceTypesListRequest) SlugIew(slugIew string) ApiDcimDeviceTypesListRequest {
	r.slugIew = &slugIew
	return r
}

func (r ApiDcimDeviceTypesListRequest) SlugNiew(slugNiew string) ApiDcimDeviceTypesListRequest {
	r.slugNiew = &slugNiew
	return r
}

func (r ApiDcimDeviceTypesListRequest) SlugIsw(slugIsw string) ApiDcimDeviceTypesListRequest {
	r.slugIsw = &slugIsw
	return r
}

func (r ApiDcimDeviceTypesListRequest) SlugNisw(slugNisw string) ApiDcimDeviceTypesListRequest {
	r.slugNisw = &slugNisw
	return r
}

func (r ApiDcimDeviceTypesListRequest) SlugIe(slugIe string) ApiDcimDeviceTypesListRequest {
	r.slugIe = &slugIe
	return r
}

func (r ApiDcimDeviceTypesListRequest) SlugNie(slugNie string) ApiDcimDeviceTypesListRequest {
	r.slugNie = &slugNie
	return r
}

func (r ApiDcimDeviceTypesListRequest) SlugEmpty(slugEmpty string) ApiDcimDeviceTypesListRequest {
	r.slugEmpty = &slugEmpty
	return r
}

func (r ApiDcimDeviceTypesListRequest) PartNumberN(partNumberN string) ApiDcimDeviceTypesListRequest {
	r.partNumberN = &partNumberN
	return r
}

func (r ApiDcimDeviceTypesListRequest) PartNumberIc(partNumberIc string) ApiDcimDeviceTypesListRequest {
	r.partNumberIc = &partNumberIc
	return r
}

func (r ApiDcimDeviceTypesListRequest) PartNumberNic(partNumberNic string) ApiDcimDeviceTypesListRequest {
	r.partNumberNic = &partNumberNic
	return r
}

func (r ApiDcimDeviceTypesListRequest) PartNumberIew(partNumberIew string) ApiDcimDeviceTypesListRequest {
	r.partNumberIew = &partNumberIew
	return r
}

func (r ApiDcimDeviceTypesListRequest) PartNumberNiew(partNumberNiew string) ApiDcimDeviceTypesListRequest {
	r.partNumberNiew = &partNumberNiew
	return r
}

func (r ApiDcimDeviceTypesListRequest) PartNumberIsw(partNumberIsw string) ApiDcimDeviceTypesListRequest {
	r.partNumberIsw = &partNumberIsw
	return r
}

func (r ApiDcimDeviceTypesListRequest) PartNumberNisw(partNumberNisw string) ApiDcimDeviceTypesListRequest {
	r.partNumberNisw = &partNumberNisw
	return r
}

func (r ApiDcimDeviceTypesListRequest) PartNumberIe(partNumberIe string) ApiDcimDeviceTypesListRequest {
	r.partNumberIe = &partNumberIe
	return r
}

func (r ApiDcimDeviceTypesListRequest) PartNumberNie(partNumberNie string) ApiDcimDeviceTypesListRequest {
	r.partNumberNie = &partNumberNie
	return r
}

func (r ApiDcimDeviceTypesListRequest) PartNumberEmpty(partNumberEmpty string) ApiDcimDeviceTypesListRequest {
	r.partNumberEmpty = &partNumberEmpty
	return r
}

func (r ApiDcimDeviceTypesListRequest) UHeightN(uHeightN string) ApiDcimDeviceTypesListRequest {
	r.uHeightN = &uHeightN
	return r
}

func (r ApiDcimDeviceTypesListRequest) UHeightLte(uHeightLte string) ApiDcimDeviceTypesListRequest {
	r.uHeightLte = &uHeightLte
	return r
}

func (r ApiDcimDeviceTypesListRequest) UHeightLt(uHeightLt string) ApiDcimDeviceTypesListRequest {
	r.uHeightLt = &uHeightLt
	return r
}

func (r ApiDcimDeviceTypesListRequest) UHeightGte(uHeightGte string) ApiDcimDeviceTypesListRequest {
	r.uHeightGte = &uHeightGte
	return r
}

func (r ApiDcimDeviceTypesListRequest) UHeightGt(uHeightGt string) ApiDcimDeviceTypesListRequest {
	r.uHeightGt = &uHeightGt
	return r
}

func (r ApiDcimDeviceTypesListRequest) SubdeviceRoleN(subdeviceRoleN string) ApiDcimDeviceTypesListRequest {
	r.subdeviceRoleN = &subdeviceRoleN
	return r
}

func (r ApiDcimDeviceTypesListRequest) ManufacturerIdN(manufacturerIdN string) ApiDcimDeviceTypesListRequest {
	r.manufacturerIdN = &manufacturerIdN
	return r
}

func (r ApiDcimDeviceTypesListRequest) ManufacturerN(manufacturerN string) ApiDcimDeviceTypesListRequest {
	r.manufacturerN = &manufacturerN
	return r
}

func (r ApiDcimDeviceTypesListRequest) TagN(tagN string) ApiDcimDeviceTypesListRequest {
	r.tagN = &tagN
	return r
}

// Number of results to return per page.
func (r ApiDcimDeviceTypesListRequest) Limit(limit int32) ApiDcimDeviceTypesListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiDcimDeviceTypesListRequest) Offset(offset int32) ApiDcimDeviceTypesListRequest {
	r.offset = &offset
	return r
}

func (r ApiDcimDeviceTypesListRequest) Execute() (*DcimDeviceTypesList200Response, *http.Response, error) {
	return r.ApiService.DcimDeviceTypesListExecute(r)
}

/*
DcimDeviceTypesList Method for DcimDeviceTypesList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimDeviceTypesListRequest
*/
func (a *DcimApiService) DcimDeviceTypesList(ctx context.Context) ApiDcimDeviceTypesListRequest {
	return ApiDcimDeviceTypesListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DcimDeviceTypesList200Response
func (a *DcimApiService) DcimDeviceTypesListExecute(r ApiDcimDeviceTypesListRequest) (*DcimDeviceTypesList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DcimDeviceTypesList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimDeviceTypesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/device-types/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.model != nil {
		localVarQueryParams.Add("model", parameterToString(*r.model, ""))
	}
	if r.slug != nil {
		localVarQueryParams.Add("slug", parameterToString(*r.slug, ""))
	}
	if r.partNumber != nil {
		localVarQueryParams.Add("part_number", parameterToString(*r.partNumber, ""))
	}
	if r.uHeight != nil {
		localVarQueryParams.Add("u_height", parameterToString(*r.uHeight, ""))
	}
	if r.isFullDepth != nil {
		localVarQueryParams.Add("is_full_depth", parameterToString(*r.isFullDepth, ""))
	}
	if r.subdeviceRole != nil {
		localVarQueryParams.Add("subdevice_role", parameterToString(*r.subdeviceRole, ""))
	}
	if r.created != nil {
		localVarQueryParams.Add("created", parameterToString(*r.created, ""))
	}
	if r.createdGte != nil {
		localVarQueryParams.Add("created__gte", parameterToString(*r.createdGte, ""))
	}
	if r.createdLte != nil {
		localVarQueryParams.Add("created__lte", parameterToString(*r.createdLte, ""))
	}
	if r.lastUpdated != nil {
		localVarQueryParams.Add("last_updated", parameterToString(*r.lastUpdated, ""))
	}
	if r.lastUpdatedGte != nil {
		localVarQueryParams.Add("last_updated__gte", parameterToString(*r.lastUpdatedGte, ""))
	}
	if r.lastUpdatedLte != nil {
		localVarQueryParams.Add("last_updated__lte", parameterToString(*r.lastUpdatedLte, ""))
	}
	if r.q != nil {
		localVarQueryParams.Add("q", parameterToString(*r.q, ""))
	}
	if r.manufacturerId != nil {
		localVarQueryParams.Add("manufacturer_id", parameterToString(*r.manufacturerId, ""))
	}
	if r.manufacturer != nil {
		localVarQueryParams.Add("manufacturer", parameterToString(*r.manufacturer, ""))
	}
	if r.consolePorts != nil {
		localVarQueryParams.Add("console_ports", parameterToString(*r.consolePorts, ""))
	}
	if r.consoleServerPorts != nil {
		localVarQueryParams.Add("console_server_ports", parameterToString(*r.consoleServerPorts, ""))
	}
	if r.powerPorts != nil {
		localVarQueryParams.Add("power_ports", parameterToString(*r.powerPorts, ""))
	}
	if r.powerOutlets != nil {
		localVarQueryParams.Add("power_outlets", parameterToString(*r.powerOutlets, ""))
	}
	if r.interfaces != nil {
		localVarQueryParams.Add("interfaces", parameterToString(*r.interfaces, ""))
	}
	if r.passThroughPorts != nil {
		localVarQueryParams.Add("pass_through_ports", parameterToString(*r.passThroughPorts, ""))
	}
	if r.deviceBays != nil {
		localVarQueryParams.Add("device_bays", parameterToString(*r.deviceBays, ""))
	}
	if r.tag != nil {
		localVarQueryParams.Add("tag", parameterToString(*r.tag, ""))
	}
	if r.idN != nil {
		localVarQueryParams.Add("id__n", parameterToString(*r.idN, ""))
	}
	if r.idLte != nil {
		localVarQueryParams.Add("id__lte", parameterToString(*r.idLte, ""))
	}
	if r.idLt != nil {
		localVarQueryParams.Add("id__lt", parameterToString(*r.idLt, ""))
	}
	if r.idGte != nil {
		localVarQueryParams.Add("id__gte", parameterToString(*r.idGte, ""))
	}
	if r.idGt != nil {
		localVarQueryParams.Add("id__gt", parameterToString(*r.idGt, ""))
	}
	if r.modelN != nil {
		localVarQueryParams.Add("model__n", parameterToString(*r.modelN, ""))
	}
	if r.modelIc != nil {
		localVarQueryParams.Add("model__ic", parameterToString(*r.modelIc, ""))
	}
	if r.modelNic != nil {
		localVarQueryParams.Add("model__nic", parameterToString(*r.modelNic, ""))
	}
	if r.modelIew != nil {
		localVarQueryParams.Add("model__iew", parameterToString(*r.modelIew, ""))
	}
	if r.modelNiew != nil {
		localVarQueryParams.Add("model__niew", parameterToString(*r.modelNiew, ""))
	}
	if r.modelIsw != nil {
		localVarQueryParams.Add("model__isw", parameterToString(*r.modelIsw, ""))
	}
	if r.modelNisw != nil {
		localVarQueryParams.Add("model__nisw", parameterToString(*r.modelNisw, ""))
	}
	if r.modelIe != nil {
		localVarQueryParams.Add("model__ie", parameterToString(*r.modelIe, ""))
	}
	if r.modelNie != nil {
		localVarQueryParams.Add("model__nie", parameterToString(*r.modelNie, ""))
	}
	if r.modelEmpty != nil {
		localVarQueryParams.Add("model__empty", parameterToString(*r.modelEmpty, ""))
	}
	if r.slugN != nil {
		localVarQueryParams.Add("slug__n", parameterToString(*r.slugN, ""))
	}
	if r.slugIc != nil {
		localVarQueryParams.Add("slug__ic", parameterToString(*r.slugIc, ""))
	}
	if r.slugNic != nil {
		localVarQueryParams.Add("slug__nic", parameterToString(*r.slugNic, ""))
	}
	if r.slugIew != nil {
		localVarQueryParams.Add("slug__iew", parameterToString(*r.slugIew, ""))
	}
	if r.slugNiew != nil {
		localVarQueryParams.Add("slug__niew", parameterToString(*r.slugNiew, ""))
	}
	if r.slugIsw != nil {
		localVarQueryParams.Add("slug__isw", parameterToString(*r.slugIsw, ""))
	}
	if r.slugNisw != nil {
		localVarQueryParams.Add("slug__nisw", parameterToString(*r.slugNisw, ""))
	}
	if r.slugIe != nil {
		localVarQueryParams.Add("slug__ie", parameterToString(*r.slugIe, ""))
	}
	if r.slugNie != nil {
		localVarQueryParams.Add("slug__nie", parameterToString(*r.slugNie, ""))
	}
	if r.slugEmpty != nil {
		localVarQueryParams.Add("slug__empty", parameterToString(*r.slugEmpty, ""))
	}
	if r.partNumberN != nil {
		localVarQueryParams.Add("part_number__n", parameterToString(*r.partNumberN, ""))
	}
	if r.partNumberIc != nil {
		localVarQueryParams.Add("part_number__ic", parameterToString(*r.partNumberIc, ""))
	}
	if r.partNumberNic != nil {
		localVarQueryParams.Add("part_number__nic", parameterToString(*r.partNumberNic, ""))
	}
	if r.partNumberIew != nil {
		localVarQueryParams.Add("part_number__iew", parameterToString(*r.partNumberIew, ""))
	}
	if r.partNumberNiew != nil {
		localVarQueryParams.Add("part_number__niew", parameterToString(*r.partNumberNiew, ""))
	}
	if r.partNumberIsw != nil {
		localVarQueryParams.Add("part_number__isw", parameterToString(*r.partNumberIsw, ""))
	}
	if r.partNumberNisw != nil {
		localVarQueryParams.Add("part_number__nisw", parameterToString(*r.partNumberNisw, ""))
	}
	if r.partNumberIe != nil {
		localVarQueryParams.Add("part_number__ie", parameterToString(*r.partNumberIe, ""))
	}
	if r.partNumberNie != nil {
		localVarQueryParams.Add("part_number__nie", parameterToString(*r.partNumberNie, ""))
	}
	if r.partNumberEmpty != nil {
		localVarQueryParams.Add("part_number__empty", parameterToString(*r.partNumberEmpty, ""))
	}
	if r.uHeightN != nil {
		localVarQueryParams.Add("u_height__n", parameterToString(*r.uHeightN, ""))
	}
	if r.uHeightLte != nil {
		localVarQueryParams.Add("u_height__lte", parameterToString(*r.uHeightLte, ""))
	}
	if r.uHeightLt != nil {
		localVarQueryParams.Add("u_height__lt", parameterToString(*r.uHeightLt, ""))
	}
	if r.uHeightGte != nil {
		localVarQueryParams.Add("u_height__gte", parameterToString(*r.uHeightGte, ""))
	}
	if r.uHeightGt != nil {
		localVarQueryParams.Add("u_height__gt", parameterToString(*r.uHeightGt, ""))
	}
	if r.subdeviceRoleN != nil {
		localVarQueryParams.Add("subdevice_role__n", parameterToString(*r.subdeviceRoleN, ""))
	}
	if r.manufacturerIdN != nil {
		localVarQueryParams.Add("manufacturer_id__n", parameterToString(*r.manufacturerIdN, ""))
	}
	if r.manufacturerN != nil {
		localVarQueryParams.Add("manufacturer__n", parameterToString(*r.manufacturerN, ""))
	}
	if r.tagN != nil {
		localVarQueryParams.Add("tag__n", parameterToString(*r.tagN, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimDeviceTypesPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
	data *WritableDeviceType
}

func (r ApiDcimDeviceTypesPartialUpdateRequest) Data(data WritableDeviceType) ApiDcimDeviceTypesPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimDeviceTypesPartialUpdateRequest) Execute() (*DeviceType, *http.Response, error) {
	return r.ApiService.DcimDeviceTypesPartialUpdateExecute(r)
}

/*
DcimDeviceTypesPartialUpdate Method for DcimDeviceTypesPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this device type.
 @return ApiDcimDeviceTypesPartialUpdateRequest
*/
func (a *DcimApiService) DcimDeviceTypesPartialUpdate(ctx context.Context, id int32) ApiDcimDeviceTypesPartialUpdateRequest {
	return ApiDcimDeviceTypesPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return DeviceType
func (a *DcimApiService) DcimDeviceTypesPartialUpdateExecute(r ApiDcimDeviceTypesPartialUpdateRequest) (*DeviceType, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeviceType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimDeviceTypesPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/device-types/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimDeviceTypesReadRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
}

func (r ApiDcimDeviceTypesReadRequest) Execute() (*DeviceType, *http.Response, error) {
	return r.ApiService.DcimDeviceTypesReadExecute(r)
}

/*
DcimDeviceTypesRead Method for DcimDeviceTypesRead

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this device type.
 @return ApiDcimDeviceTypesReadRequest
*/
func (a *DcimApiService) DcimDeviceTypesRead(ctx context.Context, id int32) ApiDcimDeviceTypesReadRequest {
	return ApiDcimDeviceTypesReadRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return DeviceType
func (a *DcimApiService) DcimDeviceTypesReadExecute(r ApiDcimDeviceTypesReadRequest) (*DeviceType, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeviceType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimDeviceTypesRead")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/device-types/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimDeviceTypesUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
	data *WritableDeviceType
}

func (r ApiDcimDeviceTypesUpdateRequest) Data(data WritableDeviceType) ApiDcimDeviceTypesUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimDeviceTypesUpdateRequest) Execute() (*DeviceType, *http.Response, error) {
	return r.ApiService.DcimDeviceTypesUpdateExecute(r)
}

/*
DcimDeviceTypesUpdate Method for DcimDeviceTypesUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this device type.
 @return ApiDcimDeviceTypesUpdateRequest
*/
func (a *DcimApiService) DcimDeviceTypesUpdate(ctx context.Context, id int32) ApiDcimDeviceTypesUpdateRequest {
	return ApiDcimDeviceTypesUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return DeviceType
func (a *DcimApiService) DcimDeviceTypesUpdateExecute(r ApiDcimDeviceTypesUpdateRequest) (*DeviceType, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeviceType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimDeviceTypesUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/device-types/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimDevicesBulkDeleteRequest struct {
	ctx context.Context
	ApiService *DcimApiService
}

func (r ApiDcimDevicesBulkDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimDevicesBulkDeleteExecute(r)
}

/*
DcimDevicesBulkDelete Method for DcimDevicesBulkDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimDevicesBulkDeleteRequest
*/
func (a *DcimApiService) DcimDevicesBulkDelete(ctx context.Context) ApiDcimDevicesBulkDeleteRequest {
	return ApiDcimDevicesBulkDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DcimApiService) DcimDevicesBulkDeleteExecute(r ApiDcimDevicesBulkDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimDevicesBulkDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/devices/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimDevicesBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	data *WritableDeviceWithConfigContext
}

func (r ApiDcimDevicesBulkPartialUpdateRequest) Data(data WritableDeviceWithConfigContext) ApiDcimDevicesBulkPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimDevicesBulkPartialUpdateRequest) Execute() (*DeviceWithConfigContext, *http.Response, error) {
	return r.ApiService.DcimDevicesBulkPartialUpdateExecute(r)
}

/*
DcimDevicesBulkPartialUpdate Method for DcimDevicesBulkPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimDevicesBulkPartialUpdateRequest
*/
func (a *DcimApiService) DcimDevicesBulkPartialUpdate(ctx context.Context) ApiDcimDevicesBulkPartialUpdateRequest {
	return ApiDcimDevicesBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DeviceWithConfigContext
func (a *DcimApiService) DcimDevicesBulkPartialUpdateExecute(r ApiDcimDevicesBulkPartialUpdateRequest) (*DeviceWithConfigContext, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeviceWithConfigContext
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimDevicesBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/devices/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimDevicesBulkUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	data *WritableDeviceWithConfigContext
}

func (r ApiDcimDevicesBulkUpdateRequest) Data(data WritableDeviceWithConfigContext) ApiDcimDevicesBulkUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimDevicesBulkUpdateRequest) Execute() (*DeviceWithConfigContext, *http.Response, error) {
	return r.ApiService.DcimDevicesBulkUpdateExecute(r)
}

/*
DcimDevicesBulkUpdate Method for DcimDevicesBulkUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimDevicesBulkUpdateRequest
*/
func (a *DcimApiService) DcimDevicesBulkUpdate(ctx context.Context) ApiDcimDevicesBulkUpdateRequest {
	return ApiDcimDevicesBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DeviceWithConfigContext
func (a *DcimApiService) DcimDevicesBulkUpdateExecute(r ApiDcimDevicesBulkUpdateRequest) (*DeviceWithConfigContext, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeviceWithConfigContext
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimDevicesBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/devices/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimDevicesCreateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	data *WritableDeviceWithConfigContext
}

func (r ApiDcimDevicesCreateRequest) Data(data WritableDeviceWithConfigContext) ApiDcimDevicesCreateRequest {
	r.data = &data
	return r
}

func (r ApiDcimDevicesCreateRequest) Execute() (*DeviceWithConfigContext, *http.Response, error) {
	return r.ApiService.DcimDevicesCreateExecute(r)
}

/*
DcimDevicesCreate Method for DcimDevicesCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimDevicesCreateRequest
*/
func (a *DcimApiService) DcimDevicesCreate(ctx context.Context) ApiDcimDevicesCreateRequest {
	return ApiDcimDevicesCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DeviceWithConfigContext
func (a *DcimApiService) DcimDevicesCreateExecute(r ApiDcimDevicesCreateRequest) (*DeviceWithConfigContext, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeviceWithConfigContext
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimDevicesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/devices/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimDevicesDeleteRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
}

func (r ApiDcimDevicesDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimDevicesDeleteExecute(r)
}

/*
DcimDevicesDelete Method for DcimDevicesDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this device.
 @return ApiDcimDevicesDeleteRequest
*/
func (a *DcimApiService) DcimDevicesDelete(ctx context.Context, id int32) ApiDcimDevicesDeleteRequest {
	return ApiDcimDevicesDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DcimApiService) DcimDevicesDeleteExecute(r ApiDcimDevicesDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimDevicesDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/devices/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimDevicesListRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id *string
	name *string
	assetTag *string
	face *string
	position *string
	vcPosition *string
	vcPriority *string
	created *string
	createdGte *string
	createdLte *string
	lastUpdated *string
	lastUpdatedGte *string
	lastUpdatedLte *string
	tenantGroupId *string
	tenantGroup *string
	tenantId *string
	tenant *string
	localContextData *string
	q *string
	manufacturerId *string
	manufacturer *string
	deviceTypeId *string
	roleId *string
	role *string
	platformId *string
	platform *string
	regionId *string
	region *string
	siteGroupId *string
	siteGroup *string
	siteId *string
	site *string
	locationId *string
	rackId *string
	clusterId *string
	model *string
	status *string
	isFullDepth *string
	macAddress *string
	serial *string
	hasPrimaryIp *string
	virtualChassisId *string
	virtualChassisMember *string
	consolePorts *string
	consoleServerPorts *string
	powerPorts *string
	powerOutlets *string
	interfaces *string
	passThroughPorts *string
	deviceBays *string
	tag *string
	idN *string
	idLte *string
	idLt *string
	idGte *string
	idGt *string
	nameN *string
	nameIc *string
	nameNic *string
	nameIew *string
	nameNiew *string
	nameIsw *string
	nameNisw *string
	nameIe *string
	nameNie *string
	nameEmpty *string
	assetTagN *string
	assetTagIc *string
	assetTagNic *string
	assetTagIew *string
	assetTagNiew *string
	assetTagIsw *string
	assetTagNisw *string
	assetTagIe *string
	assetTagNie *string
	assetTagEmpty *string
	faceN *string
	positionN *string
	positionLte *string
	positionLt *string
	positionGte *string
	positionGt *string
	vcPositionN *string
	vcPositionLte *string
	vcPositionLt *string
	vcPositionGte *string
	vcPositionGt *string
	vcPriorityN *string
	vcPriorityLte *string
	vcPriorityLt *string
	vcPriorityGte *string
	vcPriorityGt *string
	tenantGroupIdN *string
	tenantGroupN *string
	tenantIdN *string
	tenantN *string
	manufacturerIdN *string
	manufacturerN *string
	deviceTypeIdN *string
	roleIdN *string
	roleN *string
	platformIdN *string
	platformN *string
	regionIdN *string
	regionN *string
	siteGroupIdN *string
	siteGroupN *string
	siteIdN *string
	siteN *string
	locationIdN *string
	rackIdN *string
	clusterIdN *string
	modelN *string
	statusN *string
	macAddressN *string
	macAddressIc *string
	macAddressNic *string
	macAddressIew *string
	macAddressNiew *string
	macAddressIsw *string
	macAddressNisw *string
	macAddressIe *string
	macAddressNie *string
	virtualChassisIdN *string
	tagN *string
	limit *int32
	offset *int32
}

func (r ApiDcimDevicesListRequest) Id(id string) ApiDcimDevicesListRequest {
	r.id = &id
	return r
}

func (r ApiDcimDevicesListRequest) Name(name string) ApiDcimDevicesListRequest {
	r.name = &name
	return r
}

func (r ApiDcimDevicesListRequest) AssetTag(assetTag string) ApiDcimDevicesListRequest {
	r.assetTag = &assetTag
	return r
}

func (r ApiDcimDevicesListRequest) Face(face string) ApiDcimDevicesListRequest {
	r.face = &face
	return r
}

func (r ApiDcimDevicesListRequest) Position(position string) ApiDcimDevicesListRequest {
	r.position = &position
	return r
}

func (r ApiDcimDevicesListRequest) VcPosition(vcPosition string) ApiDcimDevicesListRequest {
	r.vcPosition = &vcPosition
	return r
}

func (r ApiDcimDevicesListRequest) VcPriority(vcPriority string) ApiDcimDevicesListRequest {
	r.vcPriority = &vcPriority
	return r
}

func (r ApiDcimDevicesListRequest) Created(created string) ApiDcimDevicesListRequest {
	r.created = &created
	return r
}

func (r ApiDcimDevicesListRequest) CreatedGte(createdGte string) ApiDcimDevicesListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiDcimDevicesListRequest) CreatedLte(createdLte string) ApiDcimDevicesListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiDcimDevicesListRequest) LastUpdated(lastUpdated string) ApiDcimDevicesListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiDcimDevicesListRequest) LastUpdatedGte(lastUpdatedGte string) ApiDcimDevicesListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiDcimDevicesListRequest) LastUpdatedLte(lastUpdatedLte string) ApiDcimDevicesListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiDcimDevicesListRequest) TenantGroupId(tenantGroupId string) ApiDcimDevicesListRequest {
	r.tenantGroupId = &tenantGroupId
	return r
}

func (r ApiDcimDevicesListRequest) TenantGroup(tenantGroup string) ApiDcimDevicesListRequest {
	r.tenantGroup = &tenantGroup
	return r
}

func (r ApiDcimDevicesListRequest) TenantId(tenantId string) ApiDcimDevicesListRequest {
	r.tenantId = &tenantId
	return r
}

func (r ApiDcimDevicesListRequest) Tenant(tenant string) ApiDcimDevicesListRequest {
	r.tenant = &tenant
	return r
}

func (r ApiDcimDevicesListRequest) LocalContextData(localContextData string) ApiDcimDevicesListRequest {
	r.localContextData = &localContextData
	return r
}

func (r ApiDcimDevicesListRequest) Q(q string) ApiDcimDevicesListRequest {
	r.q = &q
	return r
}

func (r ApiDcimDevicesListRequest) ManufacturerId(manufacturerId string) ApiDcimDevicesListRequest {
	r.manufacturerId = &manufacturerId
	return r
}

func (r ApiDcimDevicesListRequest) Manufacturer(manufacturer string) ApiDcimDevicesListRequest {
	r.manufacturer = &manufacturer
	return r
}

func (r ApiDcimDevicesListRequest) DeviceTypeId(deviceTypeId string) ApiDcimDevicesListRequest {
	r.deviceTypeId = &deviceTypeId
	return r
}

func (r ApiDcimDevicesListRequest) RoleId(roleId string) ApiDcimDevicesListRequest {
	r.roleId = &roleId
	return r
}

func (r ApiDcimDevicesListRequest) Role(role string) ApiDcimDevicesListRequest {
	r.role = &role
	return r
}

func (r ApiDcimDevicesListRequest) PlatformId(platformId string) ApiDcimDevicesListRequest {
	r.platformId = &platformId
	return r
}

func (r ApiDcimDevicesListRequest) Platform(platform string) ApiDcimDevicesListRequest {
	r.platform = &platform
	return r
}

func (r ApiDcimDevicesListRequest) RegionId(regionId string) ApiDcimDevicesListRequest {
	r.regionId = &regionId
	return r
}

func (r ApiDcimDevicesListRequest) Region(region string) ApiDcimDevicesListRequest {
	r.region = &region
	return r
}

func (r ApiDcimDevicesListRequest) SiteGroupId(siteGroupId string) ApiDcimDevicesListRequest {
	r.siteGroupId = &siteGroupId
	return r
}

func (r ApiDcimDevicesListRequest) SiteGroup(siteGroup string) ApiDcimDevicesListRequest {
	r.siteGroup = &siteGroup
	return r
}

func (r ApiDcimDevicesListRequest) SiteId(siteId string) ApiDcimDevicesListRequest {
	r.siteId = &siteId
	return r
}

func (r ApiDcimDevicesListRequest) Site(site string) ApiDcimDevicesListRequest {
	r.site = &site
	return r
}

func (r ApiDcimDevicesListRequest) LocationId(locationId string) ApiDcimDevicesListRequest {
	r.locationId = &locationId
	return r
}

func (r ApiDcimDevicesListRequest) RackId(rackId string) ApiDcimDevicesListRequest {
	r.rackId = &rackId
	return r
}

func (r ApiDcimDevicesListRequest) ClusterId(clusterId string) ApiDcimDevicesListRequest {
	r.clusterId = &clusterId
	return r
}

func (r ApiDcimDevicesListRequest) Model(model string) ApiDcimDevicesListRequest {
	r.model = &model
	return r
}

func (r ApiDcimDevicesListRequest) Status(status string) ApiDcimDevicesListRequest {
	r.status = &status
	return r
}

func (r ApiDcimDevicesListRequest) IsFullDepth(isFullDepth string) ApiDcimDevicesListRequest {
	r.isFullDepth = &isFullDepth
	return r
}

func (r ApiDcimDevicesListRequest) MacAddress(macAddress string) ApiDcimDevicesListRequest {
	r.macAddress = &macAddress
	return r
}

func (r ApiDcimDevicesListRequest) Serial(serial string) ApiDcimDevicesListRequest {
	r.serial = &serial
	return r
}

func (r ApiDcimDevicesListRequest) HasPrimaryIp(hasPrimaryIp string) ApiDcimDevicesListRequest {
	r.hasPrimaryIp = &hasPrimaryIp
	return r
}

func (r ApiDcimDevicesListRequest) VirtualChassisId(virtualChassisId string) ApiDcimDevicesListRequest {
	r.virtualChassisId = &virtualChassisId
	return r
}

func (r ApiDcimDevicesListRequest) VirtualChassisMember(virtualChassisMember string) ApiDcimDevicesListRequest {
	r.virtualChassisMember = &virtualChassisMember
	return r
}

func (r ApiDcimDevicesListRequest) ConsolePorts(consolePorts string) ApiDcimDevicesListRequest {
	r.consolePorts = &consolePorts
	return r
}

func (r ApiDcimDevicesListRequest) ConsoleServerPorts(consoleServerPorts string) ApiDcimDevicesListRequest {
	r.consoleServerPorts = &consoleServerPorts
	return r
}

func (r ApiDcimDevicesListRequest) PowerPorts(powerPorts string) ApiDcimDevicesListRequest {
	r.powerPorts = &powerPorts
	return r
}

func (r ApiDcimDevicesListRequest) PowerOutlets(powerOutlets string) ApiDcimDevicesListRequest {
	r.powerOutlets = &powerOutlets
	return r
}

func (r ApiDcimDevicesListRequest) Interfaces(interfaces string) ApiDcimDevicesListRequest {
	r.interfaces = &interfaces
	return r
}

func (r ApiDcimDevicesListRequest) PassThroughPorts(passThroughPorts string) ApiDcimDevicesListRequest {
	r.passThroughPorts = &passThroughPorts
	return r
}

func (r ApiDcimDevicesListRequest) DeviceBays(deviceBays string) ApiDcimDevicesListRequest {
	r.deviceBays = &deviceBays
	return r
}

func (r ApiDcimDevicesListRequest) Tag(tag string) ApiDcimDevicesListRequest {
	r.tag = &tag
	return r
}

func (r ApiDcimDevicesListRequest) IdN(idN string) ApiDcimDevicesListRequest {
	r.idN = &idN
	return r
}

func (r ApiDcimDevicesListRequest) IdLte(idLte string) ApiDcimDevicesListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiDcimDevicesListRequest) IdLt(idLt string) ApiDcimDevicesListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiDcimDevicesListRequest) IdGte(idGte string) ApiDcimDevicesListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiDcimDevicesListRequest) IdGt(idGt string) ApiDcimDevicesListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiDcimDevicesListRequest) NameN(nameN string) ApiDcimDevicesListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiDcimDevicesListRequest) NameIc(nameIc string) ApiDcimDevicesListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiDcimDevicesListRequest) NameNic(nameNic string) ApiDcimDevicesListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiDcimDevicesListRequest) NameIew(nameIew string) ApiDcimDevicesListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiDcimDevicesListRequest) NameNiew(nameNiew string) ApiDcimDevicesListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiDcimDevicesListRequest) NameIsw(nameIsw string) ApiDcimDevicesListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiDcimDevicesListRequest) NameNisw(nameNisw string) ApiDcimDevicesListRequest {
	r.nameNisw = &nameNisw
	return r
}

func (r ApiDcimDevicesListRequest) NameIe(nameIe string) ApiDcimDevicesListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiDcimDevicesListRequest) NameNie(nameNie string) ApiDcimDevicesListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiDcimDevicesListRequest) NameEmpty(nameEmpty string) ApiDcimDevicesListRequest {
	r.nameEmpty = &nameEmpty
	return r
}

func (r ApiDcimDevicesListRequest) AssetTagN(assetTagN string) ApiDcimDevicesListRequest {
	r.assetTagN = &assetTagN
	return r
}

func (r ApiDcimDevicesListRequest) AssetTagIc(assetTagIc string) ApiDcimDevicesListRequest {
	r.assetTagIc = &assetTagIc
	return r
}

func (r ApiDcimDevicesListRequest) AssetTagNic(assetTagNic string) ApiDcimDevicesListRequest {
	r.assetTagNic = &assetTagNic
	return r
}

func (r ApiDcimDevicesListRequest) AssetTagIew(assetTagIew string) ApiDcimDevicesListRequest {
	r.assetTagIew = &assetTagIew
	return r
}

func (r ApiDcimDevicesListRequest) AssetTagNiew(assetTagNiew string) ApiDcimDevicesListRequest {
	r.assetTagNiew = &assetTagNiew
	return r
}

func (r ApiDcimDevicesListRequest) AssetTagIsw(assetTagIsw string) ApiDcimDevicesListRequest {
	r.assetTagIsw = &assetTagIsw
	return r
}

func (r ApiDcimDevicesListRequest) AssetTagNisw(assetTagNisw string) ApiDcimDevicesListRequest {
	r.assetTagNisw = &assetTagNisw
	return r
}

func (r ApiDcimDevicesListRequest) AssetTagIe(assetTagIe string) ApiDcimDevicesListRequest {
	r.assetTagIe = &assetTagIe
	return r
}

func (r ApiDcimDevicesListRequest) AssetTagNie(assetTagNie string) ApiDcimDevicesListRequest {
	r.assetTagNie = &assetTagNie
	return r
}

func (r ApiDcimDevicesListRequest) AssetTagEmpty(assetTagEmpty string) ApiDcimDevicesListRequest {
	r.assetTagEmpty = &assetTagEmpty
	return r
}

func (r ApiDcimDevicesListRequest) FaceN(faceN string) ApiDcimDevicesListRequest {
	r.faceN = &faceN
	return r
}

func (r ApiDcimDevicesListRequest) PositionN(positionN string) ApiDcimDevicesListRequest {
	r.positionN = &positionN
	return r
}

func (r ApiDcimDevicesListRequest) PositionLte(positionLte string) ApiDcimDevicesListRequest {
	r.positionLte = &positionLte
	return r
}

func (r ApiDcimDevicesListRequest) PositionLt(positionLt string) ApiDcimDevicesListRequest {
	r.positionLt = &positionLt
	return r
}

func (r ApiDcimDevicesListRequest) PositionGte(positionGte string) ApiDcimDevicesListRequest {
	r.positionGte = &positionGte
	return r
}

func (r ApiDcimDevicesListRequest) PositionGt(positionGt string) ApiDcimDevicesListRequest {
	r.positionGt = &positionGt
	return r
}

func (r ApiDcimDevicesListRequest) VcPositionN(vcPositionN string) ApiDcimDevicesListRequest {
	r.vcPositionN = &vcPositionN
	return r
}

func (r ApiDcimDevicesListRequest) VcPositionLte(vcPositionLte string) ApiDcimDevicesListRequest {
	r.vcPositionLte = &vcPositionLte
	return r
}

func (r ApiDcimDevicesListRequest) VcPositionLt(vcPositionLt string) ApiDcimDevicesListRequest {
	r.vcPositionLt = &vcPositionLt
	return r
}

func (r ApiDcimDevicesListRequest) VcPositionGte(vcPositionGte string) ApiDcimDevicesListRequest {
	r.vcPositionGte = &vcPositionGte
	return r
}

func (r ApiDcimDevicesListRequest) VcPositionGt(vcPositionGt string) ApiDcimDevicesListRequest {
	r.vcPositionGt = &vcPositionGt
	return r
}

func (r ApiDcimDevicesListRequest) VcPriorityN(vcPriorityN string) ApiDcimDevicesListRequest {
	r.vcPriorityN = &vcPriorityN
	return r
}

func (r ApiDcimDevicesListRequest) VcPriorityLte(vcPriorityLte string) ApiDcimDevicesListRequest {
	r.vcPriorityLte = &vcPriorityLte
	return r
}

func (r ApiDcimDevicesListRequest) VcPriorityLt(vcPriorityLt string) ApiDcimDevicesListRequest {
	r.vcPriorityLt = &vcPriorityLt
	return r
}

func (r ApiDcimDevicesListRequest) VcPriorityGte(vcPriorityGte string) ApiDcimDevicesListRequest {
	r.vcPriorityGte = &vcPriorityGte
	return r
}

func (r ApiDcimDevicesListRequest) VcPriorityGt(vcPriorityGt string) ApiDcimDevicesListRequest {
	r.vcPriorityGt = &vcPriorityGt
	return r
}

func (r ApiDcimDevicesListRequest) TenantGroupIdN(tenantGroupIdN string) ApiDcimDevicesListRequest {
	r.tenantGroupIdN = &tenantGroupIdN
	return r
}

func (r ApiDcimDevicesListRequest) TenantGroupN(tenantGroupN string) ApiDcimDevicesListRequest {
	r.tenantGroupN = &tenantGroupN
	return r
}

func (r ApiDcimDevicesListRequest) TenantIdN(tenantIdN string) ApiDcimDevicesListRequest {
	r.tenantIdN = &tenantIdN
	return r
}

func (r ApiDcimDevicesListRequest) TenantN(tenantN string) ApiDcimDevicesListRequest {
	r.tenantN = &tenantN
	return r
}

func (r ApiDcimDevicesListRequest) ManufacturerIdN(manufacturerIdN string) ApiDcimDevicesListRequest {
	r.manufacturerIdN = &manufacturerIdN
	return r
}

func (r ApiDcimDevicesListRequest) ManufacturerN(manufacturerN string) ApiDcimDevicesListRequest {
	r.manufacturerN = &manufacturerN
	return r
}

func (r ApiDcimDevicesListRequest) DeviceTypeIdN(deviceTypeIdN string) ApiDcimDevicesListRequest {
	r.deviceTypeIdN = &deviceTypeIdN
	return r
}

func (r ApiDcimDevicesListRequest) RoleIdN(roleIdN string) ApiDcimDevicesListRequest {
	r.roleIdN = &roleIdN
	return r
}

func (r ApiDcimDevicesListRequest) RoleN(roleN string) ApiDcimDevicesListRequest {
	r.roleN = &roleN
	return r
}

func (r ApiDcimDevicesListRequest) PlatformIdN(platformIdN string) ApiDcimDevicesListRequest {
	r.platformIdN = &platformIdN
	return r
}

func (r ApiDcimDevicesListRequest) PlatformN(platformN string) ApiDcimDevicesListRequest {
	r.platformN = &platformN
	return r
}

func (r ApiDcimDevicesListRequest) RegionIdN(regionIdN string) ApiDcimDevicesListRequest {
	r.regionIdN = &regionIdN
	return r
}

func (r ApiDcimDevicesListRequest) RegionN(regionN string) ApiDcimDevicesListRequest {
	r.regionN = &regionN
	return r
}

func (r ApiDcimDevicesListRequest) SiteGroupIdN(siteGroupIdN string) ApiDcimDevicesListRequest {
	r.siteGroupIdN = &siteGroupIdN
	return r
}

func (r ApiDcimDevicesListRequest) SiteGroupN(siteGroupN string) ApiDcimDevicesListRequest {
	r.siteGroupN = &siteGroupN
	return r
}

func (r ApiDcimDevicesListRequest) SiteIdN(siteIdN string) ApiDcimDevicesListRequest {
	r.siteIdN = &siteIdN
	return r
}

func (r ApiDcimDevicesListRequest) SiteN(siteN string) ApiDcimDevicesListRequest {
	r.siteN = &siteN
	return r
}

func (r ApiDcimDevicesListRequest) LocationIdN(locationIdN string) ApiDcimDevicesListRequest {
	r.locationIdN = &locationIdN
	return r
}

func (r ApiDcimDevicesListRequest) RackIdN(rackIdN string) ApiDcimDevicesListRequest {
	r.rackIdN = &rackIdN
	return r
}

func (r ApiDcimDevicesListRequest) ClusterIdN(clusterIdN string) ApiDcimDevicesListRequest {
	r.clusterIdN = &clusterIdN
	return r
}

func (r ApiDcimDevicesListRequest) ModelN(modelN string) ApiDcimDevicesListRequest {
	r.modelN = &modelN
	return r
}

func (r ApiDcimDevicesListRequest) StatusN(statusN string) ApiDcimDevicesListRequest {
	r.statusN = &statusN
	return r
}

func (r ApiDcimDevicesListRequest) MacAddressN(macAddressN string) ApiDcimDevicesListRequest {
	r.macAddressN = &macAddressN
	return r
}

func (r ApiDcimDevicesListRequest) MacAddressIc(macAddressIc string) ApiDcimDevicesListRequest {
	r.macAddressIc = &macAddressIc
	return r
}

func (r ApiDcimDevicesListRequest) MacAddressNic(macAddressNic string) ApiDcimDevicesListRequest {
	r.macAddressNic = &macAddressNic
	return r
}

func (r ApiDcimDevicesListRequest) MacAddressIew(macAddressIew string) ApiDcimDevicesListRequest {
	r.macAddressIew = &macAddressIew
	return r
}

func (r ApiDcimDevicesListRequest) MacAddressNiew(macAddressNiew string) ApiDcimDevicesListRequest {
	r.macAddressNiew = &macAddressNiew
	return r
}

func (r ApiDcimDevicesListRequest) MacAddressIsw(macAddressIsw string) ApiDcimDevicesListRequest {
	r.macAddressIsw = &macAddressIsw
	return r
}

func (r ApiDcimDevicesListRequest) MacAddressNisw(macAddressNisw string) ApiDcimDevicesListRequest {
	r.macAddressNisw = &macAddressNisw
	return r
}

func (r ApiDcimDevicesListRequest) MacAddressIe(macAddressIe string) ApiDcimDevicesListRequest {
	r.macAddressIe = &macAddressIe
	return r
}

func (r ApiDcimDevicesListRequest) MacAddressNie(macAddressNie string) ApiDcimDevicesListRequest {
	r.macAddressNie = &macAddressNie
	return r
}

func (r ApiDcimDevicesListRequest) VirtualChassisIdN(virtualChassisIdN string) ApiDcimDevicesListRequest {
	r.virtualChassisIdN = &virtualChassisIdN
	return r
}

func (r ApiDcimDevicesListRequest) TagN(tagN string) ApiDcimDevicesListRequest {
	r.tagN = &tagN
	return r
}

// Number of results to return per page.
func (r ApiDcimDevicesListRequest) Limit(limit int32) ApiDcimDevicesListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiDcimDevicesListRequest) Offset(offset int32) ApiDcimDevicesListRequest {
	r.offset = &offset
	return r
}

func (r ApiDcimDevicesListRequest) Execute() (*DcimDevicesList200Response, *http.Response, error) {
	return r.ApiService.DcimDevicesListExecute(r)
}

/*
DcimDevicesList Method for DcimDevicesList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimDevicesListRequest
*/
func (a *DcimApiService) DcimDevicesList(ctx context.Context) ApiDcimDevicesListRequest {
	return ApiDcimDevicesListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DcimDevicesList200Response
func (a *DcimApiService) DcimDevicesListExecute(r ApiDcimDevicesListRequest) (*DcimDevicesList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DcimDevicesList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimDevicesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/devices/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.assetTag != nil {
		localVarQueryParams.Add("asset_tag", parameterToString(*r.assetTag, ""))
	}
	if r.face != nil {
		localVarQueryParams.Add("face", parameterToString(*r.face, ""))
	}
	if r.position != nil {
		localVarQueryParams.Add("position", parameterToString(*r.position, ""))
	}
	if r.vcPosition != nil {
		localVarQueryParams.Add("vc_position", parameterToString(*r.vcPosition, ""))
	}
	if r.vcPriority != nil {
		localVarQueryParams.Add("vc_priority", parameterToString(*r.vcPriority, ""))
	}
	if r.created != nil {
		localVarQueryParams.Add("created", parameterToString(*r.created, ""))
	}
	if r.createdGte != nil {
		localVarQueryParams.Add("created__gte", parameterToString(*r.createdGte, ""))
	}
	if r.createdLte != nil {
		localVarQueryParams.Add("created__lte", parameterToString(*r.createdLte, ""))
	}
	if r.lastUpdated != nil {
		localVarQueryParams.Add("last_updated", parameterToString(*r.lastUpdated, ""))
	}
	if r.lastUpdatedGte != nil {
		localVarQueryParams.Add("last_updated__gte", parameterToString(*r.lastUpdatedGte, ""))
	}
	if r.lastUpdatedLte != nil {
		localVarQueryParams.Add("last_updated__lte", parameterToString(*r.lastUpdatedLte, ""))
	}
	if r.tenantGroupId != nil {
		localVarQueryParams.Add("tenant_group_id", parameterToString(*r.tenantGroupId, ""))
	}
	if r.tenantGroup != nil {
		localVarQueryParams.Add("tenant_group", parameterToString(*r.tenantGroup, ""))
	}
	if r.tenantId != nil {
		localVarQueryParams.Add("tenant_id", parameterToString(*r.tenantId, ""))
	}
	if r.tenant != nil {
		localVarQueryParams.Add("tenant", parameterToString(*r.tenant, ""))
	}
	if r.localContextData != nil {
		localVarQueryParams.Add("local_context_data", parameterToString(*r.localContextData, ""))
	}
	if r.q != nil {
		localVarQueryParams.Add("q", parameterToString(*r.q, ""))
	}
	if r.manufacturerId != nil {
		localVarQueryParams.Add("manufacturer_id", parameterToString(*r.manufacturerId, ""))
	}
	if r.manufacturer != nil {
		localVarQueryParams.Add("manufacturer", parameterToString(*r.manufacturer, ""))
	}
	if r.deviceTypeId != nil {
		localVarQueryParams.Add("device_type_id", parameterToString(*r.deviceTypeId, ""))
	}
	if r.roleId != nil {
		localVarQueryParams.Add("role_id", parameterToString(*r.roleId, ""))
	}
	if r.role != nil {
		localVarQueryParams.Add("role", parameterToString(*r.role, ""))
	}
	if r.platformId != nil {
		localVarQueryParams.Add("platform_id", parameterToString(*r.platformId, ""))
	}
	if r.platform != nil {
		localVarQueryParams.Add("platform", parameterToString(*r.platform, ""))
	}
	if r.regionId != nil {
		localVarQueryParams.Add("region_id", parameterToString(*r.regionId, ""))
	}
	if r.region != nil {
		localVarQueryParams.Add("region", parameterToString(*r.region, ""))
	}
	if r.siteGroupId != nil {
		localVarQueryParams.Add("site_group_id", parameterToString(*r.siteGroupId, ""))
	}
	if r.siteGroup != nil {
		localVarQueryParams.Add("site_group", parameterToString(*r.siteGroup, ""))
	}
	if r.siteId != nil {
		localVarQueryParams.Add("site_id", parameterToString(*r.siteId, ""))
	}
	if r.site != nil {
		localVarQueryParams.Add("site", parameterToString(*r.site, ""))
	}
	if r.locationId != nil {
		localVarQueryParams.Add("location_id", parameterToString(*r.locationId, ""))
	}
	if r.rackId != nil {
		localVarQueryParams.Add("rack_id", parameterToString(*r.rackId, ""))
	}
	if r.clusterId != nil {
		localVarQueryParams.Add("cluster_id", parameterToString(*r.clusterId, ""))
	}
	if r.model != nil {
		localVarQueryParams.Add("model", parameterToString(*r.model, ""))
	}
	if r.status != nil {
		localVarQueryParams.Add("status", parameterToString(*r.status, ""))
	}
	if r.isFullDepth != nil {
		localVarQueryParams.Add("is_full_depth", parameterToString(*r.isFullDepth, ""))
	}
	if r.macAddress != nil {
		localVarQueryParams.Add("mac_address", parameterToString(*r.macAddress, ""))
	}
	if r.serial != nil {
		localVarQueryParams.Add("serial", parameterToString(*r.serial, ""))
	}
	if r.hasPrimaryIp != nil {
		localVarQueryParams.Add("has_primary_ip", parameterToString(*r.hasPrimaryIp, ""))
	}
	if r.virtualChassisId != nil {
		localVarQueryParams.Add("virtual_chassis_id", parameterToString(*r.virtualChassisId, ""))
	}
	if r.virtualChassisMember != nil {
		localVarQueryParams.Add("virtual_chassis_member", parameterToString(*r.virtualChassisMember, ""))
	}
	if r.consolePorts != nil {
		localVarQueryParams.Add("console_ports", parameterToString(*r.consolePorts, ""))
	}
	if r.consoleServerPorts != nil {
		localVarQueryParams.Add("console_server_ports", parameterToString(*r.consoleServerPorts, ""))
	}
	if r.powerPorts != nil {
		localVarQueryParams.Add("power_ports", parameterToString(*r.powerPorts, ""))
	}
	if r.powerOutlets != nil {
		localVarQueryParams.Add("power_outlets", parameterToString(*r.powerOutlets, ""))
	}
	if r.interfaces != nil {
		localVarQueryParams.Add("interfaces", parameterToString(*r.interfaces, ""))
	}
	if r.passThroughPorts != nil {
		localVarQueryParams.Add("pass_through_ports", parameterToString(*r.passThroughPorts, ""))
	}
	if r.deviceBays != nil {
		localVarQueryParams.Add("device_bays", parameterToString(*r.deviceBays, ""))
	}
	if r.tag != nil {
		localVarQueryParams.Add("tag", parameterToString(*r.tag, ""))
	}
	if r.idN != nil {
		localVarQueryParams.Add("id__n", parameterToString(*r.idN, ""))
	}
	if r.idLte != nil {
		localVarQueryParams.Add("id__lte", parameterToString(*r.idLte, ""))
	}
	if r.idLt != nil {
		localVarQueryParams.Add("id__lt", parameterToString(*r.idLt, ""))
	}
	if r.idGte != nil {
		localVarQueryParams.Add("id__gte", parameterToString(*r.idGte, ""))
	}
	if r.idGt != nil {
		localVarQueryParams.Add("id__gt", parameterToString(*r.idGt, ""))
	}
	if r.nameN != nil {
		localVarQueryParams.Add("name__n", parameterToString(*r.nameN, ""))
	}
	if r.nameIc != nil {
		localVarQueryParams.Add("name__ic", parameterToString(*r.nameIc, ""))
	}
	if r.nameNic != nil {
		localVarQueryParams.Add("name__nic", parameterToString(*r.nameNic, ""))
	}
	if r.nameIew != nil {
		localVarQueryParams.Add("name__iew", parameterToString(*r.nameIew, ""))
	}
	if r.nameNiew != nil {
		localVarQueryParams.Add("name__niew", parameterToString(*r.nameNiew, ""))
	}
	if r.nameIsw != nil {
		localVarQueryParams.Add("name__isw", parameterToString(*r.nameIsw, ""))
	}
	if r.nameNisw != nil {
		localVarQueryParams.Add("name__nisw", parameterToString(*r.nameNisw, ""))
	}
	if r.nameIe != nil {
		localVarQueryParams.Add("name__ie", parameterToString(*r.nameIe, ""))
	}
	if r.nameNie != nil {
		localVarQueryParams.Add("name__nie", parameterToString(*r.nameNie, ""))
	}
	if r.nameEmpty != nil {
		localVarQueryParams.Add("name__empty", parameterToString(*r.nameEmpty, ""))
	}
	if r.assetTagN != nil {
		localVarQueryParams.Add("asset_tag__n", parameterToString(*r.assetTagN, ""))
	}
	if r.assetTagIc != nil {
		localVarQueryParams.Add("asset_tag__ic", parameterToString(*r.assetTagIc, ""))
	}
	if r.assetTagNic != nil {
		localVarQueryParams.Add("asset_tag__nic", parameterToString(*r.assetTagNic, ""))
	}
	if r.assetTagIew != nil {
		localVarQueryParams.Add("asset_tag__iew", parameterToString(*r.assetTagIew, ""))
	}
	if r.assetTagNiew != nil {
		localVarQueryParams.Add("asset_tag__niew", parameterToString(*r.assetTagNiew, ""))
	}
	if r.assetTagIsw != nil {
		localVarQueryParams.Add("asset_tag__isw", parameterToString(*r.assetTagIsw, ""))
	}
	if r.assetTagNisw != nil {
		localVarQueryParams.Add("asset_tag__nisw", parameterToString(*r.assetTagNisw, ""))
	}
	if r.assetTagIe != nil {
		localVarQueryParams.Add("asset_tag__ie", parameterToString(*r.assetTagIe, ""))
	}
	if r.assetTagNie != nil {
		localVarQueryParams.Add("asset_tag__nie", parameterToString(*r.assetTagNie, ""))
	}
	if r.assetTagEmpty != nil {
		localVarQueryParams.Add("asset_tag__empty", parameterToString(*r.assetTagEmpty, ""))
	}
	if r.faceN != nil {
		localVarQueryParams.Add("face__n", parameterToString(*r.faceN, ""))
	}
	if r.positionN != nil {
		localVarQueryParams.Add("position__n", parameterToString(*r.positionN, ""))
	}
	if r.positionLte != nil {
		localVarQueryParams.Add("position__lte", parameterToString(*r.positionLte, ""))
	}
	if r.positionLt != nil {
		localVarQueryParams.Add("position__lt", parameterToString(*r.positionLt, ""))
	}
	if r.positionGte != nil {
		localVarQueryParams.Add("position__gte", parameterToString(*r.positionGte, ""))
	}
	if r.positionGt != nil {
		localVarQueryParams.Add("position__gt", parameterToString(*r.positionGt, ""))
	}
	if r.vcPositionN != nil {
		localVarQueryParams.Add("vc_position__n", parameterToString(*r.vcPositionN, ""))
	}
	if r.vcPositionLte != nil {
		localVarQueryParams.Add("vc_position__lte", parameterToString(*r.vcPositionLte, ""))
	}
	if r.vcPositionLt != nil {
		localVarQueryParams.Add("vc_position__lt", parameterToString(*r.vcPositionLt, ""))
	}
	if r.vcPositionGte != nil {
		localVarQueryParams.Add("vc_position__gte", parameterToString(*r.vcPositionGte, ""))
	}
	if r.vcPositionGt != nil {
		localVarQueryParams.Add("vc_position__gt", parameterToString(*r.vcPositionGt, ""))
	}
	if r.vcPriorityN != nil {
		localVarQueryParams.Add("vc_priority__n", parameterToString(*r.vcPriorityN, ""))
	}
	if r.vcPriorityLte != nil {
		localVarQueryParams.Add("vc_priority__lte", parameterToString(*r.vcPriorityLte, ""))
	}
	if r.vcPriorityLt != nil {
		localVarQueryParams.Add("vc_priority__lt", parameterToString(*r.vcPriorityLt, ""))
	}
	if r.vcPriorityGte != nil {
		localVarQueryParams.Add("vc_priority__gte", parameterToString(*r.vcPriorityGte, ""))
	}
	if r.vcPriorityGt != nil {
		localVarQueryParams.Add("vc_priority__gt", parameterToString(*r.vcPriorityGt, ""))
	}
	if r.tenantGroupIdN != nil {
		localVarQueryParams.Add("tenant_group_id__n", parameterToString(*r.tenantGroupIdN, ""))
	}
	if r.tenantGroupN != nil {
		localVarQueryParams.Add("tenant_group__n", parameterToString(*r.tenantGroupN, ""))
	}
	if r.tenantIdN != nil {
		localVarQueryParams.Add("tenant_id__n", parameterToString(*r.tenantIdN, ""))
	}
	if r.tenantN != nil {
		localVarQueryParams.Add("tenant__n", parameterToString(*r.tenantN, ""))
	}
	if r.manufacturerIdN != nil {
		localVarQueryParams.Add("manufacturer_id__n", parameterToString(*r.manufacturerIdN, ""))
	}
	if r.manufacturerN != nil {
		localVarQueryParams.Add("manufacturer__n", parameterToString(*r.manufacturerN, ""))
	}
	if r.deviceTypeIdN != nil {
		localVarQueryParams.Add("device_type_id__n", parameterToString(*r.deviceTypeIdN, ""))
	}
	if r.roleIdN != nil {
		localVarQueryParams.Add("role_id__n", parameterToString(*r.roleIdN, ""))
	}
	if r.roleN != nil {
		localVarQueryParams.Add("role__n", parameterToString(*r.roleN, ""))
	}
	if r.platformIdN != nil {
		localVarQueryParams.Add("platform_id__n", parameterToString(*r.platformIdN, ""))
	}
	if r.platformN != nil {
		localVarQueryParams.Add("platform__n", parameterToString(*r.platformN, ""))
	}
	if r.regionIdN != nil {
		localVarQueryParams.Add("region_id__n", parameterToString(*r.regionIdN, ""))
	}
	if r.regionN != nil {
		localVarQueryParams.Add("region__n", parameterToString(*r.regionN, ""))
	}
	if r.siteGroupIdN != nil {
		localVarQueryParams.Add("site_group_id__n", parameterToString(*r.siteGroupIdN, ""))
	}
	if r.siteGroupN != nil {
		localVarQueryParams.Add("site_group__n", parameterToString(*r.siteGroupN, ""))
	}
	if r.siteIdN != nil {
		localVarQueryParams.Add("site_id__n", parameterToString(*r.siteIdN, ""))
	}
	if r.siteN != nil {
		localVarQueryParams.Add("site__n", parameterToString(*r.siteN, ""))
	}
	if r.locationIdN != nil {
		localVarQueryParams.Add("location_id__n", parameterToString(*r.locationIdN, ""))
	}
	if r.rackIdN != nil {
		localVarQueryParams.Add("rack_id__n", parameterToString(*r.rackIdN, ""))
	}
	if r.clusterIdN != nil {
		localVarQueryParams.Add("cluster_id__n", parameterToString(*r.clusterIdN, ""))
	}
	if r.modelN != nil {
		localVarQueryParams.Add("model__n", parameterToString(*r.modelN, ""))
	}
	if r.statusN != nil {
		localVarQueryParams.Add("status__n", parameterToString(*r.statusN, ""))
	}
	if r.macAddressN != nil {
		localVarQueryParams.Add("mac_address__n", parameterToString(*r.macAddressN, ""))
	}
	if r.macAddressIc != nil {
		localVarQueryParams.Add("mac_address__ic", parameterToString(*r.macAddressIc, ""))
	}
	if r.macAddressNic != nil {
		localVarQueryParams.Add("mac_address__nic", parameterToString(*r.macAddressNic, ""))
	}
	if r.macAddressIew != nil {
		localVarQueryParams.Add("mac_address__iew", parameterToString(*r.macAddressIew, ""))
	}
	if r.macAddressNiew != nil {
		localVarQueryParams.Add("mac_address__niew", parameterToString(*r.macAddressNiew, ""))
	}
	if r.macAddressIsw != nil {
		localVarQueryParams.Add("mac_address__isw", parameterToString(*r.macAddressIsw, ""))
	}
	if r.macAddressNisw != nil {
		localVarQueryParams.Add("mac_address__nisw", parameterToString(*r.macAddressNisw, ""))
	}
	if r.macAddressIe != nil {
		localVarQueryParams.Add("mac_address__ie", parameterToString(*r.macAddressIe, ""))
	}
	if r.macAddressNie != nil {
		localVarQueryParams.Add("mac_address__nie", parameterToString(*r.macAddressNie, ""))
	}
	if r.virtualChassisIdN != nil {
		localVarQueryParams.Add("virtual_chassis_id__n", parameterToString(*r.virtualChassisIdN, ""))
	}
	if r.tagN != nil {
		localVarQueryParams.Add("tag__n", parameterToString(*r.tagN, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimDevicesNapalmRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
	method *string
}

func (r ApiDcimDevicesNapalmRequest) Method(method string) ApiDcimDevicesNapalmRequest {
	r.method = &method
	return r
}

func (r ApiDcimDevicesNapalmRequest) Execute() (*DeviceNAPALM, *http.Response, error) {
	return r.ApiService.DcimDevicesNapalmExecute(r)
}

/*
DcimDevicesNapalm Method for DcimDevicesNapalm

Execute a NAPALM method on a Device

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this device.
 @return ApiDcimDevicesNapalmRequest
*/
func (a *DcimApiService) DcimDevicesNapalm(ctx context.Context, id int32) ApiDcimDevicesNapalmRequest {
	return ApiDcimDevicesNapalmRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return DeviceNAPALM
func (a *DcimApiService) DcimDevicesNapalmExecute(r ApiDcimDevicesNapalmRequest) (*DeviceNAPALM, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeviceNAPALM
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimDevicesNapalm")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/devices/{id}/napalm/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.method == nil {
		return localVarReturnValue, nil, reportError("method is required and must be specified")
	}

	localVarQueryParams.Add("method", parameterToString(*r.method, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimDevicesPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
	data *WritableDeviceWithConfigContext
}

func (r ApiDcimDevicesPartialUpdateRequest) Data(data WritableDeviceWithConfigContext) ApiDcimDevicesPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimDevicesPartialUpdateRequest) Execute() (*DeviceWithConfigContext, *http.Response, error) {
	return r.ApiService.DcimDevicesPartialUpdateExecute(r)
}

/*
DcimDevicesPartialUpdate Method for DcimDevicesPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this device.
 @return ApiDcimDevicesPartialUpdateRequest
*/
func (a *DcimApiService) DcimDevicesPartialUpdate(ctx context.Context, id int32) ApiDcimDevicesPartialUpdateRequest {
	return ApiDcimDevicesPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return DeviceWithConfigContext
func (a *DcimApiService) DcimDevicesPartialUpdateExecute(r ApiDcimDevicesPartialUpdateRequest) (*DeviceWithConfigContext, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeviceWithConfigContext
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimDevicesPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/devices/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimDevicesReadRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
}

func (r ApiDcimDevicesReadRequest) Execute() (*DeviceWithConfigContext, *http.Response, error) {
	return r.ApiService.DcimDevicesReadExecute(r)
}

/*
DcimDevicesRead Method for DcimDevicesRead

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this device.
 @return ApiDcimDevicesReadRequest
*/
func (a *DcimApiService) DcimDevicesRead(ctx context.Context, id int32) ApiDcimDevicesReadRequest {
	return ApiDcimDevicesReadRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return DeviceWithConfigContext
func (a *DcimApiService) DcimDevicesReadExecute(r ApiDcimDevicesReadRequest) (*DeviceWithConfigContext, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeviceWithConfigContext
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimDevicesRead")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/devices/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimDevicesUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
	data *WritableDeviceWithConfigContext
}

func (r ApiDcimDevicesUpdateRequest) Data(data WritableDeviceWithConfigContext) ApiDcimDevicesUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimDevicesUpdateRequest) Execute() (*DeviceWithConfigContext, *http.Response, error) {
	return r.ApiService.DcimDevicesUpdateExecute(r)
}

/*
DcimDevicesUpdate Method for DcimDevicesUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this device.
 @return ApiDcimDevicesUpdateRequest
*/
func (a *DcimApiService) DcimDevicesUpdate(ctx context.Context, id int32) ApiDcimDevicesUpdateRequest {
	return ApiDcimDevicesUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return DeviceWithConfigContext
func (a *DcimApiService) DcimDevicesUpdateExecute(r ApiDcimDevicesUpdateRequest) (*DeviceWithConfigContext, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeviceWithConfigContext
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimDevicesUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/devices/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimFrontPortTemplatesBulkDeleteRequest struct {
	ctx context.Context
	ApiService *DcimApiService
}

func (r ApiDcimFrontPortTemplatesBulkDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimFrontPortTemplatesBulkDeleteExecute(r)
}

/*
DcimFrontPortTemplatesBulkDelete Method for DcimFrontPortTemplatesBulkDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimFrontPortTemplatesBulkDeleteRequest
*/
func (a *DcimApiService) DcimFrontPortTemplatesBulkDelete(ctx context.Context) ApiDcimFrontPortTemplatesBulkDeleteRequest {
	return ApiDcimFrontPortTemplatesBulkDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DcimApiService) DcimFrontPortTemplatesBulkDeleteExecute(r ApiDcimFrontPortTemplatesBulkDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimFrontPortTemplatesBulkDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/front-port-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimFrontPortTemplatesBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	data *WritableFrontPortTemplate
}

func (r ApiDcimFrontPortTemplatesBulkPartialUpdateRequest) Data(data WritableFrontPortTemplate) ApiDcimFrontPortTemplatesBulkPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimFrontPortTemplatesBulkPartialUpdateRequest) Execute() (*FrontPortTemplate, *http.Response, error) {
	return r.ApiService.DcimFrontPortTemplatesBulkPartialUpdateExecute(r)
}

/*
DcimFrontPortTemplatesBulkPartialUpdate Method for DcimFrontPortTemplatesBulkPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimFrontPortTemplatesBulkPartialUpdateRequest
*/
func (a *DcimApiService) DcimFrontPortTemplatesBulkPartialUpdate(ctx context.Context) ApiDcimFrontPortTemplatesBulkPartialUpdateRequest {
	return ApiDcimFrontPortTemplatesBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FrontPortTemplate
func (a *DcimApiService) DcimFrontPortTemplatesBulkPartialUpdateExecute(r ApiDcimFrontPortTemplatesBulkPartialUpdateRequest) (*FrontPortTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FrontPortTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimFrontPortTemplatesBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/front-port-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimFrontPortTemplatesBulkUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	data *WritableFrontPortTemplate
}

func (r ApiDcimFrontPortTemplatesBulkUpdateRequest) Data(data WritableFrontPortTemplate) ApiDcimFrontPortTemplatesBulkUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimFrontPortTemplatesBulkUpdateRequest) Execute() (*FrontPortTemplate, *http.Response, error) {
	return r.ApiService.DcimFrontPortTemplatesBulkUpdateExecute(r)
}

/*
DcimFrontPortTemplatesBulkUpdate Method for DcimFrontPortTemplatesBulkUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimFrontPortTemplatesBulkUpdateRequest
*/
func (a *DcimApiService) DcimFrontPortTemplatesBulkUpdate(ctx context.Context) ApiDcimFrontPortTemplatesBulkUpdateRequest {
	return ApiDcimFrontPortTemplatesBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FrontPortTemplate
func (a *DcimApiService) DcimFrontPortTemplatesBulkUpdateExecute(r ApiDcimFrontPortTemplatesBulkUpdateRequest) (*FrontPortTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FrontPortTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimFrontPortTemplatesBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/front-port-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimFrontPortTemplatesCreateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	data *WritableFrontPortTemplate
}

func (r ApiDcimFrontPortTemplatesCreateRequest) Data(data WritableFrontPortTemplate) ApiDcimFrontPortTemplatesCreateRequest {
	r.data = &data
	return r
}

func (r ApiDcimFrontPortTemplatesCreateRequest) Execute() (*FrontPortTemplate, *http.Response, error) {
	return r.ApiService.DcimFrontPortTemplatesCreateExecute(r)
}

/*
DcimFrontPortTemplatesCreate Method for DcimFrontPortTemplatesCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimFrontPortTemplatesCreateRequest
*/
func (a *DcimApiService) DcimFrontPortTemplatesCreate(ctx context.Context) ApiDcimFrontPortTemplatesCreateRequest {
	return ApiDcimFrontPortTemplatesCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FrontPortTemplate
func (a *DcimApiService) DcimFrontPortTemplatesCreateExecute(r ApiDcimFrontPortTemplatesCreateRequest) (*FrontPortTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FrontPortTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimFrontPortTemplatesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/front-port-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimFrontPortTemplatesDeleteRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
}

func (r ApiDcimFrontPortTemplatesDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimFrontPortTemplatesDeleteExecute(r)
}

/*
DcimFrontPortTemplatesDelete Method for DcimFrontPortTemplatesDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this front port template.
 @return ApiDcimFrontPortTemplatesDeleteRequest
*/
func (a *DcimApiService) DcimFrontPortTemplatesDelete(ctx context.Context, id int32) ApiDcimFrontPortTemplatesDeleteRequest {
	return ApiDcimFrontPortTemplatesDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DcimApiService) DcimFrontPortTemplatesDeleteExecute(r ApiDcimFrontPortTemplatesDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimFrontPortTemplatesDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/front-port-templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimFrontPortTemplatesListRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id *string
	name *string
	type_ *string
	created *string
	createdGte *string
	createdLte *string
	lastUpdated *string
	lastUpdatedGte *string
	lastUpdatedLte *string
	devicetypeId *string
	idN *string
	idLte *string
	idLt *string
	idGte *string
	idGt *string
	nameN *string
	nameIc *string
	nameNic *string
	nameIew *string
	nameNiew *string
	nameIsw *string
	nameNisw *string
	nameIe *string
	nameNie *string
	nameEmpty *string
	typeN *string
	devicetypeIdN *string
	limit *int32
	offset *int32
}

func (r ApiDcimFrontPortTemplatesListRequest) Id(id string) ApiDcimFrontPortTemplatesListRequest {
	r.id = &id
	return r
}

func (r ApiDcimFrontPortTemplatesListRequest) Name(name string) ApiDcimFrontPortTemplatesListRequest {
	r.name = &name
	return r
}

func (r ApiDcimFrontPortTemplatesListRequest) Type_(type_ string) ApiDcimFrontPortTemplatesListRequest {
	r.type_ = &type_
	return r
}

func (r ApiDcimFrontPortTemplatesListRequest) Created(created string) ApiDcimFrontPortTemplatesListRequest {
	r.created = &created
	return r
}

func (r ApiDcimFrontPortTemplatesListRequest) CreatedGte(createdGte string) ApiDcimFrontPortTemplatesListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiDcimFrontPortTemplatesListRequest) CreatedLte(createdLte string) ApiDcimFrontPortTemplatesListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiDcimFrontPortTemplatesListRequest) LastUpdated(lastUpdated string) ApiDcimFrontPortTemplatesListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiDcimFrontPortTemplatesListRequest) LastUpdatedGte(lastUpdatedGte string) ApiDcimFrontPortTemplatesListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiDcimFrontPortTemplatesListRequest) LastUpdatedLte(lastUpdatedLte string) ApiDcimFrontPortTemplatesListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiDcimFrontPortTemplatesListRequest) DevicetypeId(devicetypeId string) ApiDcimFrontPortTemplatesListRequest {
	r.devicetypeId = &devicetypeId
	return r
}

func (r ApiDcimFrontPortTemplatesListRequest) IdN(idN string) ApiDcimFrontPortTemplatesListRequest {
	r.idN = &idN
	return r
}

func (r ApiDcimFrontPortTemplatesListRequest) IdLte(idLte string) ApiDcimFrontPortTemplatesListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiDcimFrontPortTemplatesListRequest) IdLt(idLt string) ApiDcimFrontPortTemplatesListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiDcimFrontPortTemplatesListRequest) IdGte(idGte string) ApiDcimFrontPortTemplatesListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiDcimFrontPortTemplatesListRequest) IdGt(idGt string) ApiDcimFrontPortTemplatesListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiDcimFrontPortTemplatesListRequest) NameN(nameN string) ApiDcimFrontPortTemplatesListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiDcimFrontPortTemplatesListRequest) NameIc(nameIc string) ApiDcimFrontPortTemplatesListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiDcimFrontPortTemplatesListRequest) NameNic(nameNic string) ApiDcimFrontPortTemplatesListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiDcimFrontPortTemplatesListRequest) NameIew(nameIew string) ApiDcimFrontPortTemplatesListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiDcimFrontPortTemplatesListRequest) NameNiew(nameNiew string) ApiDcimFrontPortTemplatesListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiDcimFrontPortTemplatesListRequest) NameIsw(nameIsw string) ApiDcimFrontPortTemplatesListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiDcimFrontPortTemplatesListRequest) NameNisw(nameNisw string) ApiDcimFrontPortTemplatesListRequest {
	r.nameNisw = &nameNisw
	return r
}

func (r ApiDcimFrontPortTemplatesListRequest) NameIe(nameIe string) ApiDcimFrontPortTemplatesListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiDcimFrontPortTemplatesListRequest) NameNie(nameNie string) ApiDcimFrontPortTemplatesListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiDcimFrontPortTemplatesListRequest) NameEmpty(nameEmpty string) ApiDcimFrontPortTemplatesListRequest {
	r.nameEmpty = &nameEmpty
	return r
}

func (r ApiDcimFrontPortTemplatesListRequest) TypeN(typeN string) ApiDcimFrontPortTemplatesListRequest {
	r.typeN = &typeN
	return r
}

func (r ApiDcimFrontPortTemplatesListRequest) DevicetypeIdN(devicetypeIdN string) ApiDcimFrontPortTemplatesListRequest {
	r.devicetypeIdN = &devicetypeIdN
	return r
}

// Number of results to return per page.
func (r ApiDcimFrontPortTemplatesListRequest) Limit(limit int32) ApiDcimFrontPortTemplatesListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiDcimFrontPortTemplatesListRequest) Offset(offset int32) ApiDcimFrontPortTemplatesListRequest {
	r.offset = &offset
	return r
}

func (r ApiDcimFrontPortTemplatesListRequest) Execute() (*DcimFrontPortTemplatesList200Response, *http.Response, error) {
	return r.ApiService.DcimFrontPortTemplatesListExecute(r)
}

/*
DcimFrontPortTemplatesList Method for DcimFrontPortTemplatesList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimFrontPortTemplatesListRequest
*/
func (a *DcimApiService) DcimFrontPortTemplatesList(ctx context.Context) ApiDcimFrontPortTemplatesListRequest {
	return ApiDcimFrontPortTemplatesListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DcimFrontPortTemplatesList200Response
func (a *DcimApiService) DcimFrontPortTemplatesListExecute(r ApiDcimFrontPortTemplatesListRequest) (*DcimFrontPortTemplatesList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DcimFrontPortTemplatesList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimFrontPortTemplatesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/front-port-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.type_ != nil {
		localVarQueryParams.Add("type", parameterToString(*r.type_, ""))
	}
	if r.created != nil {
		localVarQueryParams.Add("created", parameterToString(*r.created, ""))
	}
	if r.createdGte != nil {
		localVarQueryParams.Add("created__gte", parameterToString(*r.createdGte, ""))
	}
	if r.createdLte != nil {
		localVarQueryParams.Add("created__lte", parameterToString(*r.createdLte, ""))
	}
	if r.lastUpdated != nil {
		localVarQueryParams.Add("last_updated", parameterToString(*r.lastUpdated, ""))
	}
	if r.lastUpdatedGte != nil {
		localVarQueryParams.Add("last_updated__gte", parameterToString(*r.lastUpdatedGte, ""))
	}
	if r.lastUpdatedLte != nil {
		localVarQueryParams.Add("last_updated__lte", parameterToString(*r.lastUpdatedLte, ""))
	}
	if r.devicetypeId != nil {
		localVarQueryParams.Add("devicetype_id", parameterToString(*r.devicetypeId, ""))
	}
	if r.idN != nil {
		localVarQueryParams.Add("id__n", parameterToString(*r.idN, ""))
	}
	if r.idLte != nil {
		localVarQueryParams.Add("id__lte", parameterToString(*r.idLte, ""))
	}
	if r.idLt != nil {
		localVarQueryParams.Add("id__lt", parameterToString(*r.idLt, ""))
	}
	if r.idGte != nil {
		localVarQueryParams.Add("id__gte", parameterToString(*r.idGte, ""))
	}
	if r.idGt != nil {
		localVarQueryParams.Add("id__gt", parameterToString(*r.idGt, ""))
	}
	if r.nameN != nil {
		localVarQueryParams.Add("name__n", parameterToString(*r.nameN, ""))
	}
	if r.nameIc != nil {
		localVarQueryParams.Add("name__ic", parameterToString(*r.nameIc, ""))
	}
	if r.nameNic != nil {
		localVarQueryParams.Add("name__nic", parameterToString(*r.nameNic, ""))
	}
	if r.nameIew != nil {
		localVarQueryParams.Add("name__iew", parameterToString(*r.nameIew, ""))
	}
	if r.nameNiew != nil {
		localVarQueryParams.Add("name__niew", parameterToString(*r.nameNiew, ""))
	}
	if r.nameIsw != nil {
		localVarQueryParams.Add("name__isw", parameterToString(*r.nameIsw, ""))
	}
	if r.nameNisw != nil {
		localVarQueryParams.Add("name__nisw", parameterToString(*r.nameNisw, ""))
	}
	if r.nameIe != nil {
		localVarQueryParams.Add("name__ie", parameterToString(*r.nameIe, ""))
	}
	if r.nameNie != nil {
		localVarQueryParams.Add("name__nie", parameterToString(*r.nameNie, ""))
	}
	if r.nameEmpty != nil {
		localVarQueryParams.Add("name__empty", parameterToString(*r.nameEmpty, ""))
	}
	if r.typeN != nil {
		localVarQueryParams.Add("type__n", parameterToString(*r.typeN, ""))
	}
	if r.devicetypeIdN != nil {
		localVarQueryParams.Add("devicetype_id__n", parameterToString(*r.devicetypeIdN, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimFrontPortTemplatesPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
	data *WritableFrontPortTemplate
}

func (r ApiDcimFrontPortTemplatesPartialUpdateRequest) Data(data WritableFrontPortTemplate) ApiDcimFrontPortTemplatesPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimFrontPortTemplatesPartialUpdateRequest) Execute() (*FrontPortTemplate, *http.Response, error) {
	return r.ApiService.DcimFrontPortTemplatesPartialUpdateExecute(r)
}

/*
DcimFrontPortTemplatesPartialUpdate Method for DcimFrontPortTemplatesPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this front port template.
 @return ApiDcimFrontPortTemplatesPartialUpdateRequest
*/
func (a *DcimApiService) DcimFrontPortTemplatesPartialUpdate(ctx context.Context, id int32) ApiDcimFrontPortTemplatesPartialUpdateRequest {
	return ApiDcimFrontPortTemplatesPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return FrontPortTemplate
func (a *DcimApiService) DcimFrontPortTemplatesPartialUpdateExecute(r ApiDcimFrontPortTemplatesPartialUpdateRequest) (*FrontPortTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FrontPortTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimFrontPortTemplatesPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/front-port-templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimFrontPortTemplatesReadRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
}

func (r ApiDcimFrontPortTemplatesReadRequest) Execute() (*FrontPortTemplate, *http.Response, error) {
	return r.ApiService.DcimFrontPortTemplatesReadExecute(r)
}

/*
DcimFrontPortTemplatesRead Method for DcimFrontPortTemplatesRead

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this front port template.
 @return ApiDcimFrontPortTemplatesReadRequest
*/
func (a *DcimApiService) DcimFrontPortTemplatesRead(ctx context.Context, id int32) ApiDcimFrontPortTemplatesReadRequest {
	return ApiDcimFrontPortTemplatesReadRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return FrontPortTemplate
func (a *DcimApiService) DcimFrontPortTemplatesReadExecute(r ApiDcimFrontPortTemplatesReadRequest) (*FrontPortTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FrontPortTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimFrontPortTemplatesRead")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/front-port-templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimFrontPortTemplatesUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
	data *WritableFrontPortTemplate
}

func (r ApiDcimFrontPortTemplatesUpdateRequest) Data(data WritableFrontPortTemplate) ApiDcimFrontPortTemplatesUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimFrontPortTemplatesUpdateRequest) Execute() (*FrontPortTemplate, *http.Response, error) {
	return r.ApiService.DcimFrontPortTemplatesUpdateExecute(r)
}

/*
DcimFrontPortTemplatesUpdate Method for DcimFrontPortTemplatesUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this front port template.
 @return ApiDcimFrontPortTemplatesUpdateRequest
*/
func (a *DcimApiService) DcimFrontPortTemplatesUpdate(ctx context.Context, id int32) ApiDcimFrontPortTemplatesUpdateRequest {
	return ApiDcimFrontPortTemplatesUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return FrontPortTemplate
func (a *DcimApiService) DcimFrontPortTemplatesUpdateExecute(r ApiDcimFrontPortTemplatesUpdateRequest) (*FrontPortTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FrontPortTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimFrontPortTemplatesUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/front-port-templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimFrontPortsBulkDeleteRequest struct {
	ctx context.Context
	ApiService *DcimApiService
}

func (r ApiDcimFrontPortsBulkDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimFrontPortsBulkDeleteExecute(r)
}

/*
DcimFrontPortsBulkDelete Method for DcimFrontPortsBulkDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimFrontPortsBulkDeleteRequest
*/
func (a *DcimApiService) DcimFrontPortsBulkDelete(ctx context.Context) ApiDcimFrontPortsBulkDeleteRequest {
	return ApiDcimFrontPortsBulkDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DcimApiService) DcimFrontPortsBulkDeleteExecute(r ApiDcimFrontPortsBulkDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimFrontPortsBulkDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/front-ports/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimFrontPortsBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	data *WritableFrontPort
}

func (r ApiDcimFrontPortsBulkPartialUpdateRequest) Data(data WritableFrontPort) ApiDcimFrontPortsBulkPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimFrontPortsBulkPartialUpdateRequest) Execute() (*FrontPort, *http.Response, error) {
	return r.ApiService.DcimFrontPortsBulkPartialUpdateExecute(r)
}

/*
DcimFrontPortsBulkPartialUpdate Method for DcimFrontPortsBulkPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimFrontPortsBulkPartialUpdateRequest
*/
func (a *DcimApiService) DcimFrontPortsBulkPartialUpdate(ctx context.Context) ApiDcimFrontPortsBulkPartialUpdateRequest {
	return ApiDcimFrontPortsBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FrontPort
func (a *DcimApiService) DcimFrontPortsBulkPartialUpdateExecute(r ApiDcimFrontPortsBulkPartialUpdateRequest) (*FrontPort, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FrontPort
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimFrontPortsBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/front-ports/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimFrontPortsBulkUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	data *WritableFrontPort
}

func (r ApiDcimFrontPortsBulkUpdateRequest) Data(data WritableFrontPort) ApiDcimFrontPortsBulkUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimFrontPortsBulkUpdateRequest) Execute() (*FrontPort, *http.Response, error) {
	return r.ApiService.DcimFrontPortsBulkUpdateExecute(r)
}

/*
DcimFrontPortsBulkUpdate Method for DcimFrontPortsBulkUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimFrontPortsBulkUpdateRequest
*/
func (a *DcimApiService) DcimFrontPortsBulkUpdate(ctx context.Context) ApiDcimFrontPortsBulkUpdateRequest {
	return ApiDcimFrontPortsBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FrontPort
func (a *DcimApiService) DcimFrontPortsBulkUpdateExecute(r ApiDcimFrontPortsBulkUpdateRequest) (*FrontPort, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FrontPort
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimFrontPortsBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/front-ports/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimFrontPortsCreateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	data *WritableFrontPort
}

func (r ApiDcimFrontPortsCreateRequest) Data(data WritableFrontPort) ApiDcimFrontPortsCreateRequest {
	r.data = &data
	return r
}

func (r ApiDcimFrontPortsCreateRequest) Execute() (*FrontPort, *http.Response, error) {
	return r.ApiService.DcimFrontPortsCreateExecute(r)
}

/*
DcimFrontPortsCreate Method for DcimFrontPortsCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimFrontPortsCreateRequest
*/
func (a *DcimApiService) DcimFrontPortsCreate(ctx context.Context) ApiDcimFrontPortsCreateRequest {
	return ApiDcimFrontPortsCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FrontPort
func (a *DcimApiService) DcimFrontPortsCreateExecute(r ApiDcimFrontPortsCreateRequest) (*FrontPort, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FrontPort
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimFrontPortsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/front-ports/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimFrontPortsDeleteRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
}

func (r ApiDcimFrontPortsDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimFrontPortsDeleteExecute(r)
}

/*
DcimFrontPortsDelete Method for DcimFrontPortsDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this front port.
 @return ApiDcimFrontPortsDeleteRequest
*/
func (a *DcimApiService) DcimFrontPortsDelete(ctx context.Context, id int32) ApiDcimFrontPortsDeleteRequest {
	return ApiDcimFrontPortsDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DcimApiService) DcimFrontPortsDeleteExecute(r ApiDcimFrontPortsDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimFrontPortsDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/front-ports/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimFrontPortsListRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id *string
	name *string
	label *string
	type_ *string
	description *string
	created *string
	createdGte *string
	createdLte *string
	lastUpdated *string
	lastUpdatedGte *string
	lastUpdatedLte *string
	q *string
	regionId *string
	region *string
	siteGroupId *string
	siteGroup *string
	siteId *string
	site *string
	deviceId *string
	device *string
	tag *string
	cabled *string
	idN *string
	idLte *string
	idLt *string
	idGte *string
	idGt *string
	nameN *string
	nameIc *string
	nameNic *string
	nameIew *string
	nameNiew *string
	nameIsw *string
	nameNisw *string
	nameIe *string
	nameNie *string
	nameEmpty *string
	labelN *string
	labelIc *string
	labelNic *string
	labelIew *string
	labelNiew *string
	labelIsw *string
	labelNisw *string
	labelIe *string
	labelNie *string
	labelEmpty *string
	typeN *string
	descriptionN *string
	descriptionIc *string
	descriptionNic *string
	descriptionIew *string
	descriptionNiew *string
	descriptionIsw *string
	descriptionNisw *string
	descriptionIe *string
	descriptionNie *string
	descriptionEmpty *string
	regionIdN *string
	regionN *string
	siteGroupIdN *string
	siteGroupN *string
	siteIdN *string
	siteN *string
	deviceIdN *string
	deviceN *string
	tagN *string
	limit *int32
	offset *int32
}

func (r ApiDcimFrontPortsListRequest) Id(id string) ApiDcimFrontPortsListRequest {
	r.id = &id
	return r
}

func (r ApiDcimFrontPortsListRequest) Name(name string) ApiDcimFrontPortsListRequest {
	r.name = &name
	return r
}

func (r ApiDcimFrontPortsListRequest) Label(label string) ApiDcimFrontPortsListRequest {
	r.label = &label
	return r
}

func (r ApiDcimFrontPortsListRequest) Type_(type_ string) ApiDcimFrontPortsListRequest {
	r.type_ = &type_
	return r
}

func (r ApiDcimFrontPortsListRequest) Description(description string) ApiDcimFrontPortsListRequest {
	r.description = &description
	return r
}

func (r ApiDcimFrontPortsListRequest) Created(created string) ApiDcimFrontPortsListRequest {
	r.created = &created
	return r
}

func (r ApiDcimFrontPortsListRequest) CreatedGte(createdGte string) ApiDcimFrontPortsListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiDcimFrontPortsListRequest) CreatedLte(createdLte string) ApiDcimFrontPortsListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiDcimFrontPortsListRequest) LastUpdated(lastUpdated string) ApiDcimFrontPortsListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiDcimFrontPortsListRequest) LastUpdatedGte(lastUpdatedGte string) ApiDcimFrontPortsListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiDcimFrontPortsListRequest) LastUpdatedLte(lastUpdatedLte string) ApiDcimFrontPortsListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiDcimFrontPortsListRequest) Q(q string) ApiDcimFrontPortsListRequest {
	r.q = &q
	return r
}

func (r ApiDcimFrontPortsListRequest) RegionId(regionId string) ApiDcimFrontPortsListRequest {
	r.regionId = &regionId
	return r
}

func (r ApiDcimFrontPortsListRequest) Region(region string) ApiDcimFrontPortsListRequest {
	r.region = &region
	return r
}

func (r ApiDcimFrontPortsListRequest) SiteGroupId(siteGroupId string) ApiDcimFrontPortsListRequest {
	r.siteGroupId = &siteGroupId
	return r
}

func (r ApiDcimFrontPortsListRequest) SiteGroup(siteGroup string) ApiDcimFrontPortsListRequest {
	r.siteGroup = &siteGroup
	return r
}

func (r ApiDcimFrontPortsListRequest) SiteId(siteId string) ApiDcimFrontPortsListRequest {
	r.siteId = &siteId
	return r
}

func (r ApiDcimFrontPortsListRequest) Site(site string) ApiDcimFrontPortsListRequest {
	r.site = &site
	return r
}

func (r ApiDcimFrontPortsListRequest) DeviceId(deviceId string) ApiDcimFrontPortsListRequest {
	r.deviceId = &deviceId
	return r
}

func (r ApiDcimFrontPortsListRequest) Device(device string) ApiDcimFrontPortsListRequest {
	r.device = &device
	return r
}

func (r ApiDcimFrontPortsListRequest) Tag(tag string) ApiDcimFrontPortsListRequest {
	r.tag = &tag
	return r
}

func (r ApiDcimFrontPortsListRequest) Cabled(cabled string) ApiDcimFrontPortsListRequest {
	r.cabled = &cabled
	return r
}

func (r ApiDcimFrontPortsListRequest) IdN(idN string) ApiDcimFrontPortsListRequest {
	r.idN = &idN
	return r
}

func (r ApiDcimFrontPortsListRequest) IdLte(idLte string) ApiDcimFrontPortsListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiDcimFrontPortsListRequest) IdLt(idLt string) ApiDcimFrontPortsListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiDcimFrontPortsListRequest) IdGte(idGte string) ApiDcimFrontPortsListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiDcimFrontPortsListRequest) IdGt(idGt string) ApiDcimFrontPortsListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiDcimFrontPortsListRequest) NameN(nameN string) ApiDcimFrontPortsListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiDcimFrontPortsListRequest) NameIc(nameIc string) ApiDcimFrontPortsListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiDcimFrontPortsListRequest) NameNic(nameNic string) ApiDcimFrontPortsListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiDcimFrontPortsListRequest) NameIew(nameIew string) ApiDcimFrontPortsListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiDcimFrontPortsListRequest) NameNiew(nameNiew string) ApiDcimFrontPortsListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiDcimFrontPortsListRequest) NameIsw(nameIsw string) ApiDcimFrontPortsListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiDcimFrontPortsListRequest) NameNisw(nameNisw string) ApiDcimFrontPortsListRequest {
	r.nameNisw = &nameNisw
	return r
}

func (r ApiDcimFrontPortsListRequest) NameIe(nameIe string) ApiDcimFrontPortsListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiDcimFrontPortsListRequest) NameNie(nameNie string) ApiDcimFrontPortsListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiDcimFrontPortsListRequest) NameEmpty(nameEmpty string) ApiDcimFrontPortsListRequest {
	r.nameEmpty = &nameEmpty
	return r
}

func (r ApiDcimFrontPortsListRequest) LabelN(labelN string) ApiDcimFrontPortsListRequest {
	r.labelN = &labelN
	return r
}

func (r ApiDcimFrontPortsListRequest) LabelIc(labelIc string) ApiDcimFrontPortsListRequest {
	r.labelIc = &labelIc
	return r
}

func (r ApiDcimFrontPortsListRequest) LabelNic(labelNic string) ApiDcimFrontPortsListRequest {
	r.labelNic = &labelNic
	return r
}

func (r ApiDcimFrontPortsListRequest) LabelIew(labelIew string) ApiDcimFrontPortsListRequest {
	r.labelIew = &labelIew
	return r
}

func (r ApiDcimFrontPortsListRequest) LabelNiew(labelNiew string) ApiDcimFrontPortsListRequest {
	r.labelNiew = &labelNiew
	return r
}

func (r ApiDcimFrontPortsListRequest) LabelIsw(labelIsw string) ApiDcimFrontPortsListRequest {
	r.labelIsw = &labelIsw
	return r
}

func (r ApiDcimFrontPortsListRequest) LabelNisw(labelNisw string) ApiDcimFrontPortsListRequest {
	r.labelNisw = &labelNisw
	return r
}

func (r ApiDcimFrontPortsListRequest) LabelIe(labelIe string) ApiDcimFrontPortsListRequest {
	r.labelIe = &labelIe
	return r
}

func (r ApiDcimFrontPortsListRequest) LabelNie(labelNie string) ApiDcimFrontPortsListRequest {
	r.labelNie = &labelNie
	return r
}

func (r ApiDcimFrontPortsListRequest) LabelEmpty(labelEmpty string) ApiDcimFrontPortsListRequest {
	r.labelEmpty = &labelEmpty
	return r
}

func (r ApiDcimFrontPortsListRequest) TypeN(typeN string) ApiDcimFrontPortsListRequest {
	r.typeN = &typeN
	return r
}

func (r ApiDcimFrontPortsListRequest) DescriptionN(descriptionN string) ApiDcimFrontPortsListRequest {
	r.descriptionN = &descriptionN
	return r
}

func (r ApiDcimFrontPortsListRequest) DescriptionIc(descriptionIc string) ApiDcimFrontPortsListRequest {
	r.descriptionIc = &descriptionIc
	return r
}

func (r ApiDcimFrontPortsListRequest) DescriptionNic(descriptionNic string) ApiDcimFrontPortsListRequest {
	r.descriptionNic = &descriptionNic
	return r
}

func (r ApiDcimFrontPortsListRequest) DescriptionIew(descriptionIew string) ApiDcimFrontPortsListRequest {
	r.descriptionIew = &descriptionIew
	return r
}

func (r ApiDcimFrontPortsListRequest) DescriptionNiew(descriptionNiew string) ApiDcimFrontPortsListRequest {
	r.descriptionNiew = &descriptionNiew
	return r
}

func (r ApiDcimFrontPortsListRequest) DescriptionIsw(descriptionIsw string) ApiDcimFrontPortsListRequest {
	r.descriptionIsw = &descriptionIsw
	return r
}

func (r ApiDcimFrontPortsListRequest) DescriptionNisw(descriptionNisw string) ApiDcimFrontPortsListRequest {
	r.descriptionNisw = &descriptionNisw
	return r
}

func (r ApiDcimFrontPortsListRequest) DescriptionIe(descriptionIe string) ApiDcimFrontPortsListRequest {
	r.descriptionIe = &descriptionIe
	return r
}

func (r ApiDcimFrontPortsListRequest) DescriptionNie(descriptionNie string) ApiDcimFrontPortsListRequest {
	r.descriptionNie = &descriptionNie
	return r
}

func (r ApiDcimFrontPortsListRequest) DescriptionEmpty(descriptionEmpty string) ApiDcimFrontPortsListRequest {
	r.descriptionEmpty = &descriptionEmpty
	return r
}

func (r ApiDcimFrontPortsListRequest) RegionIdN(regionIdN string) ApiDcimFrontPortsListRequest {
	r.regionIdN = &regionIdN
	return r
}

func (r ApiDcimFrontPortsListRequest) RegionN(regionN string) ApiDcimFrontPortsListRequest {
	r.regionN = &regionN
	return r
}

func (r ApiDcimFrontPortsListRequest) SiteGroupIdN(siteGroupIdN string) ApiDcimFrontPortsListRequest {
	r.siteGroupIdN = &siteGroupIdN
	return r
}

func (r ApiDcimFrontPortsListRequest) SiteGroupN(siteGroupN string) ApiDcimFrontPortsListRequest {
	r.siteGroupN = &siteGroupN
	return r
}

func (r ApiDcimFrontPortsListRequest) SiteIdN(siteIdN string) ApiDcimFrontPortsListRequest {
	r.siteIdN = &siteIdN
	return r
}

func (r ApiDcimFrontPortsListRequest) SiteN(siteN string) ApiDcimFrontPortsListRequest {
	r.siteN = &siteN
	return r
}

func (r ApiDcimFrontPortsListRequest) DeviceIdN(deviceIdN string) ApiDcimFrontPortsListRequest {
	r.deviceIdN = &deviceIdN
	return r
}

func (r ApiDcimFrontPortsListRequest) DeviceN(deviceN string) ApiDcimFrontPortsListRequest {
	r.deviceN = &deviceN
	return r
}

func (r ApiDcimFrontPortsListRequest) TagN(tagN string) ApiDcimFrontPortsListRequest {
	r.tagN = &tagN
	return r
}

// Number of results to return per page.
func (r ApiDcimFrontPortsListRequest) Limit(limit int32) ApiDcimFrontPortsListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiDcimFrontPortsListRequest) Offset(offset int32) ApiDcimFrontPortsListRequest {
	r.offset = &offset
	return r
}

func (r ApiDcimFrontPortsListRequest) Execute() (*DcimFrontPortsList200Response, *http.Response, error) {
	return r.ApiService.DcimFrontPortsListExecute(r)
}

/*
DcimFrontPortsList Method for DcimFrontPortsList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimFrontPortsListRequest
*/
func (a *DcimApiService) DcimFrontPortsList(ctx context.Context) ApiDcimFrontPortsListRequest {
	return ApiDcimFrontPortsListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DcimFrontPortsList200Response
func (a *DcimApiService) DcimFrontPortsListExecute(r ApiDcimFrontPortsListRequest) (*DcimFrontPortsList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DcimFrontPortsList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimFrontPortsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/front-ports/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.label != nil {
		localVarQueryParams.Add("label", parameterToString(*r.label, ""))
	}
	if r.type_ != nil {
		localVarQueryParams.Add("type", parameterToString(*r.type_, ""))
	}
	if r.description != nil {
		localVarQueryParams.Add("description", parameterToString(*r.description, ""))
	}
	if r.created != nil {
		localVarQueryParams.Add("created", parameterToString(*r.created, ""))
	}
	if r.createdGte != nil {
		localVarQueryParams.Add("created__gte", parameterToString(*r.createdGte, ""))
	}
	if r.createdLte != nil {
		localVarQueryParams.Add("created__lte", parameterToString(*r.createdLte, ""))
	}
	if r.lastUpdated != nil {
		localVarQueryParams.Add("last_updated", parameterToString(*r.lastUpdated, ""))
	}
	if r.lastUpdatedGte != nil {
		localVarQueryParams.Add("last_updated__gte", parameterToString(*r.lastUpdatedGte, ""))
	}
	if r.lastUpdatedLte != nil {
		localVarQueryParams.Add("last_updated__lte", parameterToString(*r.lastUpdatedLte, ""))
	}
	if r.q != nil {
		localVarQueryParams.Add("q", parameterToString(*r.q, ""))
	}
	if r.regionId != nil {
		localVarQueryParams.Add("region_id", parameterToString(*r.regionId, ""))
	}
	if r.region != nil {
		localVarQueryParams.Add("region", parameterToString(*r.region, ""))
	}
	if r.siteGroupId != nil {
		localVarQueryParams.Add("site_group_id", parameterToString(*r.siteGroupId, ""))
	}
	if r.siteGroup != nil {
		localVarQueryParams.Add("site_group", parameterToString(*r.siteGroup, ""))
	}
	if r.siteId != nil {
		localVarQueryParams.Add("site_id", parameterToString(*r.siteId, ""))
	}
	if r.site != nil {
		localVarQueryParams.Add("site", parameterToString(*r.site, ""))
	}
	if r.deviceId != nil {
		localVarQueryParams.Add("device_id", parameterToString(*r.deviceId, ""))
	}
	if r.device != nil {
		localVarQueryParams.Add("device", parameterToString(*r.device, ""))
	}
	if r.tag != nil {
		localVarQueryParams.Add("tag", parameterToString(*r.tag, ""))
	}
	if r.cabled != nil {
		localVarQueryParams.Add("cabled", parameterToString(*r.cabled, ""))
	}
	if r.idN != nil {
		localVarQueryParams.Add("id__n", parameterToString(*r.idN, ""))
	}
	if r.idLte != nil {
		localVarQueryParams.Add("id__lte", parameterToString(*r.idLte, ""))
	}
	if r.idLt != nil {
		localVarQueryParams.Add("id__lt", parameterToString(*r.idLt, ""))
	}
	if r.idGte != nil {
		localVarQueryParams.Add("id__gte", parameterToString(*r.idGte, ""))
	}
	if r.idGt != nil {
		localVarQueryParams.Add("id__gt", parameterToString(*r.idGt, ""))
	}
	if r.nameN != nil {
		localVarQueryParams.Add("name__n", parameterToString(*r.nameN, ""))
	}
	if r.nameIc != nil {
		localVarQueryParams.Add("name__ic", parameterToString(*r.nameIc, ""))
	}
	if r.nameNic != nil {
		localVarQueryParams.Add("name__nic", parameterToString(*r.nameNic, ""))
	}
	if r.nameIew != nil {
		localVarQueryParams.Add("name__iew", parameterToString(*r.nameIew, ""))
	}
	if r.nameNiew != nil {
		localVarQueryParams.Add("name__niew", parameterToString(*r.nameNiew, ""))
	}
	if r.nameIsw != nil {
		localVarQueryParams.Add("name__isw", parameterToString(*r.nameIsw, ""))
	}
	if r.nameNisw != nil {
		localVarQueryParams.Add("name__nisw", parameterToString(*r.nameNisw, ""))
	}
	if r.nameIe != nil {
		localVarQueryParams.Add("name__ie", parameterToString(*r.nameIe, ""))
	}
	if r.nameNie != nil {
		localVarQueryParams.Add("name__nie", parameterToString(*r.nameNie, ""))
	}
	if r.nameEmpty != nil {
		localVarQueryParams.Add("name__empty", parameterToString(*r.nameEmpty, ""))
	}
	if r.labelN != nil {
		localVarQueryParams.Add("label__n", parameterToString(*r.labelN, ""))
	}
	if r.labelIc != nil {
		localVarQueryParams.Add("label__ic", parameterToString(*r.labelIc, ""))
	}
	if r.labelNic != nil {
		localVarQueryParams.Add("label__nic", parameterToString(*r.labelNic, ""))
	}
	if r.labelIew != nil {
		localVarQueryParams.Add("label__iew", parameterToString(*r.labelIew, ""))
	}
	if r.labelNiew != nil {
		localVarQueryParams.Add("label__niew", parameterToString(*r.labelNiew, ""))
	}
	if r.labelIsw != nil {
		localVarQueryParams.Add("label__isw", parameterToString(*r.labelIsw, ""))
	}
	if r.labelNisw != nil {
		localVarQueryParams.Add("label__nisw", parameterToString(*r.labelNisw, ""))
	}
	if r.labelIe != nil {
		localVarQueryParams.Add("label__ie", parameterToString(*r.labelIe, ""))
	}
	if r.labelNie != nil {
		localVarQueryParams.Add("label__nie", parameterToString(*r.labelNie, ""))
	}
	if r.labelEmpty != nil {
		localVarQueryParams.Add("label__empty", parameterToString(*r.labelEmpty, ""))
	}
	if r.typeN != nil {
		localVarQueryParams.Add("type__n", parameterToString(*r.typeN, ""))
	}
	if r.descriptionN != nil {
		localVarQueryParams.Add("description__n", parameterToString(*r.descriptionN, ""))
	}
	if r.descriptionIc != nil {
		localVarQueryParams.Add("description__ic", parameterToString(*r.descriptionIc, ""))
	}
	if r.descriptionNic != nil {
		localVarQueryParams.Add("description__nic", parameterToString(*r.descriptionNic, ""))
	}
	if r.descriptionIew != nil {
		localVarQueryParams.Add("description__iew", parameterToString(*r.descriptionIew, ""))
	}
	if r.descriptionNiew != nil {
		localVarQueryParams.Add("description__niew", parameterToString(*r.descriptionNiew, ""))
	}
	if r.descriptionIsw != nil {
		localVarQueryParams.Add("description__isw", parameterToString(*r.descriptionIsw, ""))
	}
	if r.descriptionNisw != nil {
		localVarQueryParams.Add("description__nisw", parameterToString(*r.descriptionNisw, ""))
	}
	if r.descriptionIe != nil {
		localVarQueryParams.Add("description__ie", parameterToString(*r.descriptionIe, ""))
	}
	if r.descriptionNie != nil {
		localVarQueryParams.Add("description__nie", parameterToString(*r.descriptionNie, ""))
	}
	if r.descriptionEmpty != nil {
		localVarQueryParams.Add("description__empty", parameterToString(*r.descriptionEmpty, ""))
	}
	if r.regionIdN != nil {
		localVarQueryParams.Add("region_id__n", parameterToString(*r.regionIdN, ""))
	}
	if r.regionN != nil {
		localVarQueryParams.Add("region__n", parameterToString(*r.regionN, ""))
	}
	if r.siteGroupIdN != nil {
		localVarQueryParams.Add("site_group_id__n", parameterToString(*r.siteGroupIdN, ""))
	}
	if r.siteGroupN != nil {
		localVarQueryParams.Add("site_group__n", parameterToString(*r.siteGroupN, ""))
	}
	if r.siteIdN != nil {
		localVarQueryParams.Add("site_id__n", parameterToString(*r.siteIdN, ""))
	}
	if r.siteN != nil {
		localVarQueryParams.Add("site__n", parameterToString(*r.siteN, ""))
	}
	if r.deviceIdN != nil {
		localVarQueryParams.Add("device_id__n", parameterToString(*r.deviceIdN, ""))
	}
	if r.deviceN != nil {
		localVarQueryParams.Add("device__n", parameterToString(*r.deviceN, ""))
	}
	if r.tagN != nil {
		localVarQueryParams.Add("tag__n", parameterToString(*r.tagN, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimFrontPortsPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
	data *WritableFrontPort
}

func (r ApiDcimFrontPortsPartialUpdateRequest) Data(data WritableFrontPort) ApiDcimFrontPortsPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimFrontPortsPartialUpdateRequest) Execute() (*FrontPort, *http.Response, error) {
	return r.ApiService.DcimFrontPortsPartialUpdateExecute(r)
}

/*
DcimFrontPortsPartialUpdate Method for DcimFrontPortsPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this front port.
 @return ApiDcimFrontPortsPartialUpdateRequest
*/
func (a *DcimApiService) DcimFrontPortsPartialUpdate(ctx context.Context, id int32) ApiDcimFrontPortsPartialUpdateRequest {
	return ApiDcimFrontPortsPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return FrontPort
func (a *DcimApiService) DcimFrontPortsPartialUpdateExecute(r ApiDcimFrontPortsPartialUpdateRequest) (*FrontPort, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FrontPort
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimFrontPortsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/front-ports/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimFrontPortsPathsRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
}

func (r ApiDcimFrontPortsPathsRequest) Execute() (*FrontPort, *http.Response, error) {
	return r.ApiService.DcimFrontPortsPathsExecute(r)
}

/*
DcimFrontPortsPaths Method for DcimFrontPortsPaths

Return all CablePaths which traverse a given pass-through port.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this front port.
 @return ApiDcimFrontPortsPathsRequest
*/
func (a *DcimApiService) DcimFrontPortsPaths(ctx context.Context, id int32) ApiDcimFrontPortsPathsRequest {
	return ApiDcimFrontPortsPathsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return FrontPort
func (a *DcimApiService) DcimFrontPortsPathsExecute(r ApiDcimFrontPortsPathsRequest) (*FrontPort, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FrontPort
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimFrontPortsPaths")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/front-ports/{id}/paths/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimFrontPortsReadRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
}

func (r ApiDcimFrontPortsReadRequest) Execute() (*FrontPort, *http.Response, error) {
	return r.ApiService.DcimFrontPortsReadExecute(r)
}

/*
DcimFrontPortsRead Method for DcimFrontPortsRead

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this front port.
 @return ApiDcimFrontPortsReadRequest
*/
func (a *DcimApiService) DcimFrontPortsRead(ctx context.Context, id int32) ApiDcimFrontPortsReadRequest {
	return ApiDcimFrontPortsReadRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return FrontPort
func (a *DcimApiService) DcimFrontPortsReadExecute(r ApiDcimFrontPortsReadRequest) (*FrontPort, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FrontPort
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimFrontPortsRead")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/front-ports/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimFrontPortsUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
	data *WritableFrontPort
}

func (r ApiDcimFrontPortsUpdateRequest) Data(data WritableFrontPort) ApiDcimFrontPortsUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimFrontPortsUpdateRequest) Execute() (*FrontPort, *http.Response, error) {
	return r.ApiService.DcimFrontPortsUpdateExecute(r)
}

/*
DcimFrontPortsUpdate Method for DcimFrontPortsUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this front port.
 @return ApiDcimFrontPortsUpdateRequest
*/
func (a *DcimApiService) DcimFrontPortsUpdate(ctx context.Context, id int32) ApiDcimFrontPortsUpdateRequest {
	return ApiDcimFrontPortsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return FrontPort
func (a *DcimApiService) DcimFrontPortsUpdateExecute(r ApiDcimFrontPortsUpdateRequest) (*FrontPort, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FrontPort
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimFrontPortsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/front-ports/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimInterfaceConnectionsListRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	site *string
	deviceId *string
	device *string
	limit *int32
	offset *int32
}

func (r ApiDcimInterfaceConnectionsListRequest) Site(site string) ApiDcimInterfaceConnectionsListRequest {
	r.site = &site
	return r
}

func (r ApiDcimInterfaceConnectionsListRequest) DeviceId(deviceId string) ApiDcimInterfaceConnectionsListRequest {
	r.deviceId = &deviceId
	return r
}

func (r ApiDcimInterfaceConnectionsListRequest) Device(device string) ApiDcimInterfaceConnectionsListRequest {
	r.device = &device
	return r
}

// Number of results to return per page.
func (r ApiDcimInterfaceConnectionsListRequest) Limit(limit int32) ApiDcimInterfaceConnectionsListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiDcimInterfaceConnectionsListRequest) Offset(offset int32) ApiDcimInterfaceConnectionsListRequest {
	r.offset = &offset
	return r
}

func (r ApiDcimInterfaceConnectionsListRequest) Execute() (*DcimInterfaceConnectionsList200Response, *http.Response, error) {
	return r.ApiService.DcimInterfaceConnectionsListExecute(r)
}

/*
DcimInterfaceConnectionsList Method for DcimInterfaceConnectionsList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimInterfaceConnectionsListRequest
*/
func (a *DcimApiService) DcimInterfaceConnectionsList(ctx context.Context) ApiDcimInterfaceConnectionsListRequest {
	return ApiDcimInterfaceConnectionsListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DcimInterfaceConnectionsList200Response
func (a *DcimApiService) DcimInterfaceConnectionsListExecute(r ApiDcimInterfaceConnectionsListRequest) (*DcimInterfaceConnectionsList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DcimInterfaceConnectionsList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimInterfaceConnectionsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/interface-connections/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.site != nil {
		localVarQueryParams.Add("site", parameterToString(*r.site, ""))
	}
	if r.deviceId != nil {
		localVarQueryParams.Add("device_id", parameterToString(*r.deviceId, ""))
	}
	if r.device != nil {
		localVarQueryParams.Add("device", parameterToString(*r.device, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimInterfaceTemplatesBulkDeleteRequest struct {
	ctx context.Context
	ApiService *DcimApiService
}

func (r ApiDcimInterfaceTemplatesBulkDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimInterfaceTemplatesBulkDeleteExecute(r)
}

/*
DcimInterfaceTemplatesBulkDelete Method for DcimInterfaceTemplatesBulkDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimInterfaceTemplatesBulkDeleteRequest
*/
func (a *DcimApiService) DcimInterfaceTemplatesBulkDelete(ctx context.Context) ApiDcimInterfaceTemplatesBulkDeleteRequest {
	return ApiDcimInterfaceTemplatesBulkDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DcimApiService) DcimInterfaceTemplatesBulkDeleteExecute(r ApiDcimInterfaceTemplatesBulkDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimInterfaceTemplatesBulkDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/interface-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimInterfaceTemplatesBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	data *WritableInterfaceTemplate
}

func (r ApiDcimInterfaceTemplatesBulkPartialUpdateRequest) Data(data WritableInterfaceTemplate) ApiDcimInterfaceTemplatesBulkPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimInterfaceTemplatesBulkPartialUpdateRequest) Execute() (*InterfaceTemplate, *http.Response, error) {
	return r.ApiService.DcimInterfaceTemplatesBulkPartialUpdateExecute(r)
}

/*
DcimInterfaceTemplatesBulkPartialUpdate Method for DcimInterfaceTemplatesBulkPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimInterfaceTemplatesBulkPartialUpdateRequest
*/
func (a *DcimApiService) DcimInterfaceTemplatesBulkPartialUpdate(ctx context.Context) ApiDcimInterfaceTemplatesBulkPartialUpdateRequest {
	return ApiDcimInterfaceTemplatesBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InterfaceTemplate
func (a *DcimApiService) DcimInterfaceTemplatesBulkPartialUpdateExecute(r ApiDcimInterfaceTemplatesBulkPartialUpdateRequest) (*InterfaceTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InterfaceTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimInterfaceTemplatesBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/interface-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimInterfaceTemplatesBulkUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	data *WritableInterfaceTemplate
}

func (r ApiDcimInterfaceTemplatesBulkUpdateRequest) Data(data WritableInterfaceTemplate) ApiDcimInterfaceTemplatesBulkUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimInterfaceTemplatesBulkUpdateRequest) Execute() (*InterfaceTemplate, *http.Response, error) {
	return r.ApiService.DcimInterfaceTemplatesBulkUpdateExecute(r)
}

/*
DcimInterfaceTemplatesBulkUpdate Method for DcimInterfaceTemplatesBulkUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimInterfaceTemplatesBulkUpdateRequest
*/
func (a *DcimApiService) DcimInterfaceTemplatesBulkUpdate(ctx context.Context) ApiDcimInterfaceTemplatesBulkUpdateRequest {
	return ApiDcimInterfaceTemplatesBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InterfaceTemplate
func (a *DcimApiService) DcimInterfaceTemplatesBulkUpdateExecute(r ApiDcimInterfaceTemplatesBulkUpdateRequest) (*InterfaceTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InterfaceTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimInterfaceTemplatesBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/interface-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimInterfaceTemplatesCreateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	data *WritableInterfaceTemplate
}

func (r ApiDcimInterfaceTemplatesCreateRequest) Data(data WritableInterfaceTemplate) ApiDcimInterfaceTemplatesCreateRequest {
	r.data = &data
	return r
}

func (r ApiDcimInterfaceTemplatesCreateRequest) Execute() (*InterfaceTemplate, *http.Response, error) {
	return r.ApiService.DcimInterfaceTemplatesCreateExecute(r)
}

/*
DcimInterfaceTemplatesCreate Method for DcimInterfaceTemplatesCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimInterfaceTemplatesCreateRequest
*/
func (a *DcimApiService) DcimInterfaceTemplatesCreate(ctx context.Context) ApiDcimInterfaceTemplatesCreateRequest {
	return ApiDcimInterfaceTemplatesCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InterfaceTemplate
func (a *DcimApiService) DcimInterfaceTemplatesCreateExecute(r ApiDcimInterfaceTemplatesCreateRequest) (*InterfaceTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InterfaceTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimInterfaceTemplatesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/interface-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimInterfaceTemplatesDeleteRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
}

func (r ApiDcimInterfaceTemplatesDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimInterfaceTemplatesDeleteExecute(r)
}

/*
DcimInterfaceTemplatesDelete Method for DcimInterfaceTemplatesDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this interface template.
 @return ApiDcimInterfaceTemplatesDeleteRequest
*/
func (a *DcimApiService) DcimInterfaceTemplatesDelete(ctx context.Context, id int32) ApiDcimInterfaceTemplatesDeleteRequest {
	return ApiDcimInterfaceTemplatesDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DcimApiService) DcimInterfaceTemplatesDeleteExecute(r ApiDcimInterfaceTemplatesDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimInterfaceTemplatesDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/interface-templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimInterfaceTemplatesListRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id *string
	name *string
	type_ *string
	mgmtOnly *string
	created *string
	createdGte *string
	createdLte *string
	lastUpdated *string
	lastUpdatedGte *string
	lastUpdatedLte *string
	devicetypeId *string
	idN *string
	idLte *string
	idLt *string
	idGte *string
	idGt *string
	nameN *string
	nameIc *string
	nameNic *string
	nameIew *string
	nameNiew *string
	nameIsw *string
	nameNisw *string
	nameIe *string
	nameNie *string
	nameEmpty *string
	typeN *string
	devicetypeIdN *string
	limit *int32
	offset *int32
}

func (r ApiDcimInterfaceTemplatesListRequest) Id(id string) ApiDcimInterfaceTemplatesListRequest {
	r.id = &id
	return r
}

func (r ApiDcimInterfaceTemplatesListRequest) Name(name string) ApiDcimInterfaceTemplatesListRequest {
	r.name = &name
	return r
}

func (r ApiDcimInterfaceTemplatesListRequest) Type_(type_ string) ApiDcimInterfaceTemplatesListRequest {
	r.type_ = &type_
	return r
}

func (r ApiDcimInterfaceTemplatesListRequest) MgmtOnly(mgmtOnly string) ApiDcimInterfaceTemplatesListRequest {
	r.mgmtOnly = &mgmtOnly
	return r
}

func (r ApiDcimInterfaceTemplatesListRequest) Created(created string) ApiDcimInterfaceTemplatesListRequest {
	r.created = &created
	return r
}

func (r ApiDcimInterfaceTemplatesListRequest) CreatedGte(createdGte string) ApiDcimInterfaceTemplatesListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiDcimInterfaceTemplatesListRequest) CreatedLte(createdLte string) ApiDcimInterfaceTemplatesListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiDcimInterfaceTemplatesListRequest) LastUpdated(lastUpdated string) ApiDcimInterfaceTemplatesListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiDcimInterfaceTemplatesListRequest) LastUpdatedGte(lastUpdatedGte string) ApiDcimInterfaceTemplatesListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiDcimInterfaceTemplatesListRequest) LastUpdatedLte(lastUpdatedLte string) ApiDcimInterfaceTemplatesListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiDcimInterfaceTemplatesListRequest) DevicetypeId(devicetypeId string) ApiDcimInterfaceTemplatesListRequest {
	r.devicetypeId = &devicetypeId
	return r
}

func (r ApiDcimInterfaceTemplatesListRequest) IdN(idN string) ApiDcimInterfaceTemplatesListRequest {
	r.idN = &idN
	return r
}

func (r ApiDcimInterfaceTemplatesListRequest) IdLte(idLte string) ApiDcimInterfaceTemplatesListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiDcimInterfaceTemplatesListRequest) IdLt(idLt string) ApiDcimInterfaceTemplatesListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiDcimInterfaceTemplatesListRequest) IdGte(idGte string) ApiDcimInterfaceTemplatesListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiDcimInterfaceTemplatesListRequest) IdGt(idGt string) ApiDcimInterfaceTemplatesListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiDcimInterfaceTemplatesListRequest) NameN(nameN string) ApiDcimInterfaceTemplatesListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiDcimInterfaceTemplatesListRequest) NameIc(nameIc string) ApiDcimInterfaceTemplatesListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiDcimInterfaceTemplatesListRequest) NameNic(nameNic string) ApiDcimInterfaceTemplatesListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiDcimInterfaceTemplatesListRequest) NameIew(nameIew string) ApiDcimInterfaceTemplatesListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiDcimInterfaceTemplatesListRequest) NameNiew(nameNiew string) ApiDcimInterfaceTemplatesListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiDcimInterfaceTemplatesListRequest) NameIsw(nameIsw string) ApiDcimInterfaceTemplatesListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiDcimInterfaceTemplatesListRequest) NameNisw(nameNisw string) ApiDcimInterfaceTemplatesListRequest {
	r.nameNisw = &nameNisw
	return r
}

func (r ApiDcimInterfaceTemplatesListRequest) NameIe(nameIe string) ApiDcimInterfaceTemplatesListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiDcimInterfaceTemplatesListRequest) NameNie(nameNie string) ApiDcimInterfaceTemplatesListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiDcimInterfaceTemplatesListRequest) NameEmpty(nameEmpty string) ApiDcimInterfaceTemplatesListRequest {
	r.nameEmpty = &nameEmpty
	return r
}

func (r ApiDcimInterfaceTemplatesListRequest) TypeN(typeN string) ApiDcimInterfaceTemplatesListRequest {
	r.typeN = &typeN
	return r
}

func (r ApiDcimInterfaceTemplatesListRequest) DevicetypeIdN(devicetypeIdN string) ApiDcimInterfaceTemplatesListRequest {
	r.devicetypeIdN = &devicetypeIdN
	return r
}

// Number of results to return per page.
func (r ApiDcimInterfaceTemplatesListRequest) Limit(limit int32) ApiDcimInterfaceTemplatesListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiDcimInterfaceTemplatesListRequest) Offset(offset int32) ApiDcimInterfaceTemplatesListRequest {
	r.offset = &offset
	return r
}

func (r ApiDcimInterfaceTemplatesListRequest) Execute() (*DcimInterfaceTemplatesList200Response, *http.Response, error) {
	return r.ApiService.DcimInterfaceTemplatesListExecute(r)
}

/*
DcimInterfaceTemplatesList Method for DcimInterfaceTemplatesList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimInterfaceTemplatesListRequest
*/
func (a *DcimApiService) DcimInterfaceTemplatesList(ctx context.Context) ApiDcimInterfaceTemplatesListRequest {
	return ApiDcimInterfaceTemplatesListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DcimInterfaceTemplatesList200Response
func (a *DcimApiService) DcimInterfaceTemplatesListExecute(r ApiDcimInterfaceTemplatesListRequest) (*DcimInterfaceTemplatesList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DcimInterfaceTemplatesList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimInterfaceTemplatesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/interface-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.type_ != nil {
		localVarQueryParams.Add("type", parameterToString(*r.type_, ""))
	}
	if r.mgmtOnly != nil {
		localVarQueryParams.Add("mgmt_only", parameterToString(*r.mgmtOnly, ""))
	}
	if r.created != nil {
		localVarQueryParams.Add("created", parameterToString(*r.created, ""))
	}
	if r.createdGte != nil {
		localVarQueryParams.Add("created__gte", parameterToString(*r.createdGte, ""))
	}
	if r.createdLte != nil {
		localVarQueryParams.Add("created__lte", parameterToString(*r.createdLte, ""))
	}
	if r.lastUpdated != nil {
		localVarQueryParams.Add("last_updated", parameterToString(*r.lastUpdated, ""))
	}
	if r.lastUpdatedGte != nil {
		localVarQueryParams.Add("last_updated__gte", parameterToString(*r.lastUpdatedGte, ""))
	}
	if r.lastUpdatedLte != nil {
		localVarQueryParams.Add("last_updated__lte", parameterToString(*r.lastUpdatedLte, ""))
	}
	if r.devicetypeId != nil {
		localVarQueryParams.Add("devicetype_id", parameterToString(*r.devicetypeId, ""))
	}
	if r.idN != nil {
		localVarQueryParams.Add("id__n", parameterToString(*r.idN, ""))
	}
	if r.idLte != nil {
		localVarQueryParams.Add("id__lte", parameterToString(*r.idLte, ""))
	}
	if r.idLt != nil {
		localVarQueryParams.Add("id__lt", parameterToString(*r.idLt, ""))
	}
	if r.idGte != nil {
		localVarQueryParams.Add("id__gte", parameterToString(*r.idGte, ""))
	}
	if r.idGt != nil {
		localVarQueryParams.Add("id__gt", parameterToString(*r.idGt, ""))
	}
	if r.nameN != nil {
		localVarQueryParams.Add("name__n", parameterToString(*r.nameN, ""))
	}
	if r.nameIc != nil {
		localVarQueryParams.Add("name__ic", parameterToString(*r.nameIc, ""))
	}
	if r.nameNic != nil {
		localVarQueryParams.Add("name__nic", parameterToString(*r.nameNic, ""))
	}
	if r.nameIew != nil {
		localVarQueryParams.Add("name__iew", parameterToString(*r.nameIew, ""))
	}
	if r.nameNiew != nil {
		localVarQueryParams.Add("name__niew", parameterToString(*r.nameNiew, ""))
	}
	if r.nameIsw != nil {
		localVarQueryParams.Add("name__isw", parameterToString(*r.nameIsw, ""))
	}
	if r.nameNisw != nil {
		localVarQueryParams.Add("name__nisw", parameterToString(*r.nameNisw, ""))
	}
	if r.nameIe != nil {
		localVarQueryParams.Add("name__ie", parameterToString(*r.nameIe, ""))
	}
	if r.nameNie != nil {
		localVarQueryParams.Add("name__nie", parameterToString(*r.nameNie, ""))
	}
	if r.nameEmpty != nil {
		localVarQueryParams.Add("name__empty", parameterToString(*r.nameEmpty, ""))
	}
	if r.typeN != nil {
		localVarQueryParams.Add("type__n", parameterToString(*r.typeN, ""))
	}
	if r.devicetypeIdN != nil {
		localVarQueryParams.Add("devicetype_id__n", parameterToString(*r.devicetypeIdN, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimInterfaceTemplatesPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
	data *WritableInterfaceTemplate
}

func (r ApiDcimInterfaceTemplatesPartialUpdateRequest) Data(data WritableInterfaceTemplate) ApiDcimInterfaceTemplatesPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimInterfaceTemplatesPartialUpdateRequest) Execute() (*InterfaceTemplate, *http.Response, error) {
	return r.ApiService.DcimInterfaceTemplatesPartialUpdateExecute(r)
}

/*
DcimInterfaceTemplatesPartialUpdate Method for DcimInterfaceTemplatesPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this interface template.
 @return ApiDcimInterfaceTemplatesPartialUpdateRequest
*/
func (a *DcimApiService) DcimInterfaceTemplatesPartialUpdate(ctx context.Context, id int32) ApiDcimInterfaceTemplatesPartialUpdateRequest {
	return ApiDcimInterfaceTemplatesPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return InterfaceTemplate
func (a *DcimApiService) DcimInterfaceTemplatesPartialUpdateExecute(r ApiDcimInterfaceTemplatesPartialUpdateRequest) (*InterfaceTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InterfaceTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimInterfaceTemplatesPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/interface-templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimInterfaceTemplatesReadRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
}

func (r ApiDcimInterfaceTemplatesReadRequest) Execute() (*InterfaceTemplate, *http.Response, error) {
	return r.ApiService.DcimInterfaceTemplatesReadExecute(r)
}

/*
DcimInterfaceTemplatesRead Method for DcimInterfaceTemplatesRead

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this interface template.
 @return ApiDcimInterfaceTemplatesReadRequest
*/
func (a *DcimApiService) DcimInterfaceTemplatesRead(ctx context.Context, id int32) ApiDcimInterfaceTemplatesReadRequest {
	return ApiDcimInterfaceTemplatesReadRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return InterfaceTemplate
func (a *DcimApiService) DcimInterfaceTemplatesReadExecute(r ApiDcimInterfaceTemplatesReadRequest) (*InterfaceTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InterfaceTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimInterfaceTemplatesRead")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/interface-templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimInterfaceTemplatesUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
	data *WritableInterfaceTemplate
}

func (r ApiDcimInterfaceTemplatesUpdateRequest) Data(data WritableInterfaceTemplate) ApiDcimInterfaceTemplatesUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimInterfaceTemplatesUpdateRequest) Execute() (*InterfaceTemplate, *http.Response, error) {
	return r.ApiService.DcimInterfaceTemplatesUpdateExecute(r)
}

/*
DcimInterfaceTemplatesUpdate Method for DcimInterfaceTemplatesUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this interface template.
 @return ApiDcimInterfaceTemplatesUpdateRequest
*/
func (a *DcimApiService) DcimInterfaceTemplatesUpdate(ctx context.Context, id int32) ApiDcimInterfaceTemplatesUpdateRequest {
	return ApiDcimInterfaceTemplatesUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return InterfaceTemplate
func (a *DcimApiService) DcimInterfaceTemplatesUpdateExecute(r ApiDcimInterfaceTemplatesUpdateRequest) (*InterfaceTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InterfaceTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimInterfaceTemplatesUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/interface-templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimInterfacesBulkDeleteRequest struct {
	ctx context.Context
	ApiService *DcimApiService
}

func (r ApiDcimInterfacesBulkDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimInterfacesBulkDeleteExecute(r)
}

/*
DcimInterfacesBulkDelete Method for DcimInterfacesBulkDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimInterfacesBulkDeleteRequest
*/
func (a *DcimApiService) DcimInterfacesBulkDelete(ctx context.Context) ApiDcimInterfacesBulkDeleteRequest {
	return ApiDcimInterfacesBulkDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DcimApiService) DcimInterfacesBulkDeleteExecute(r ApiDcimInterfacesBulkDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimInterfacesBulkDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/interfaces/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimInterfacesBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	data *WritableInterface
}

func (r ApiDcimInterfacesBulkPartialUpdateRequest) Data(data WritableInterface) ApiDcimInterfacesBulkPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimInterfacesBulkPartialUpdateRequest) Execute() (*Interface, *http.Response, error) {
	return r.ApiService.DcimInterfacesBulkPartialUpdateExecute(r)
}

/*
DcimInterfacesBulkPartialUpdate Method for DcimInterfacesBulkPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimInterfacesBulkPartialUpdateRequest
*/
func (a *DcimApiService) DcimInterfacesBulkPartialUpdate(ctx context.Context) ApiDcimInterfacesBulkPartialUpdateRequest {
	return ApiDcimInterfacesBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Interface
func (a *DcimApiService) DcimInterfacesBulkPartialUpdateExecute(r ApiDcimInterfacesBulkPartialUpdateRequest) (*Interface, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Interface
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimInterfacesBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/interfaces/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimInterfacesBulkUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	data *WritableInterface
}

func (r ApiDcimInterfacesBulkUpdateRequest) Data(data WritableInterface) ApiDcimInterfacesBulkUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimInterfacesBulkUpdateRequest) Execute() (*Interface, *http.Response, error) {
	return r.ApiService.DcimInterfacesBulkUpdateExecute(r)
}

/*
DcimInterfacesBulkUpdate Method for DcimInterfacesBulkUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimInterfacesBulkUpdateRequest
*/
func (a *DcimApiService) DcimInterfacesBulkUpdate(ctx context.Context) ApiDcimInterfacesBulkUpdateRequest {
	return ApiDcimInterfacesBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Interface
func (a *DcimApiService) DcimInterfacesBulkUpdateExecute(r ApiDcimInterfacesBulkUpdateRequest) (*Interface, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Interface
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimInterfacesBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/interfaces/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimInterfacesCreateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	data *WritableInterface
}

func (r ApiDcimInterfacesCreateRequest) Data(data WritableInterface) ApiDcimInterfacesCreateRequest {
	r.data = &data
	return r
}

func (r ApiDcimInterfacesCreateRequest) Execute() (*Interface, *http.Response, error) {
	return r.ApiService.DcimInterfacesCreateExecute(r)
}

/*
DcimInterfacesCreate Method for DcimInterfacesCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimInterfacesCreateRequest
*/
func (a *DcimApiService) DcimInterfacesCreate(ctx context.Context) ApiDcimInterfacesCreateRequest {
	return ApiDcimInterfacesCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Interface
func (a *DcimApiService) DcimInterfacesCreateExecute(r ApiDcimInterfacesCreateRequest) (*Interface, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Interface
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimInterfacesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/interfaces/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimInterfacesDeleteRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
}

func (r ApiDcimInterfacesDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimInterfacesDeleteExecute(r)
}

/*
DcimInterfacesDelete Method for DcimInterfacesDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this interface.
 @return ApiDcimInterfacesDeleteRequest
*/
func (a *DcimApiService) DcimInterfacesDelete(ctx context.Context, id int32) ApiDcimInterfacesDeleteRequest {
	return ApiDcimInterfacesDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DcimApiService) DcimInterfacesDeleteExecute(r ApiDcimInterfacesDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimInterfacesDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/interfaces/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimInterfacesListRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id *string
	name *string
	label *string
	type_ *string
	enabled *string
	mtu *string
	mgmtOnly *string
	mode *string
	description *string
	created *string
	createdGte *string
	createdLte *string
	lastUpdated *string
	lastUpdatedGte *string
	lastUpdatedLte *string
	q *string
	regionId *string
	region *string
	siteGroupId *string
	siteGroup *string
	siteId *string
	site *string
	deviceId *string
	device *string
	tag *string
	cabled *string
	connected *string
	kind *string
	parentId *string
	lagId *string
	macAddress *string
	vlanId *string
	vlan *string
	idN *string
	idLte *string
	idLt *string
	idGte *string
	idGt *string
	nameN *string
	nameIc *string
	nameNic *string
	nameIew *string
	nameNiew *string
	nameIsw *string
	nameNisw *string
	nameIe *string
	nameNie *string
	nameEmpty *string
	labelN *string
	labelIc *string
	labelNic *string
	labelIew *string
	labelNiew *string
	labelIsw *string
	labelNisw *string
	labelIe *string
	labelNie *string
	labelEmpty *string
	typeN *string
	mtuN *string
	mtuLte *string
	mtuLt *string
	mtuGte *string
	mtuGt *string
	modeN *string
	descriptionN *string
	descriptionIc *string
	descriptionNic *string
	descriptionIew *string
	descriptionNiew *string
	descriptionIsw *string
	descriptionNisw *string
	descriptionIe *string
	descriptionNie *string
	descriptionEmpty *string
	regionIdN *string
	regionN *string
	siteGroupIdN *string
	siteGroupN *string
	siteIdN *string
	siteN *string
	tagN *string
	parentIdN *string
	lagIdN *string
	macAddressN *string
	macAddressIc *string
	macAddressNic *string
	macAddressIew *string
	macAddressNiew *string
	macAddressIsw *string
	macAddressNisw *string
	macAddressIe *string
	macAddressNie *string
	limit *int32
	offset *int32
}

func (r ApiDcimInterfacesListRequest) Id(id string) ApiDcimInterfacesListRequest {
	r.id = &id
	return r
}

func (r ApiDcimInterfacesListRequest) Name(name string) ApiDcimInterfacesListRequest {
	r.name = &name
	return r
}

func (r ApiDcimInterfacesListRequest) Label(label string) ApiDcimInterfacesListRequest {
	r.label = &label
	return r
}

func (r ApiDcimInterfacesListRequest) Type_(type_ string) ApiDcimInterfacesListRequest {
	r.type_ = &type_
	return r
}

func (r ApiDcimInterfacesListRequest) Enabled(enabled string) ApiDcimInterfacesListRequest {
	r.enabled = &enabled
	return r
}

func (r ApiDcimInterfacesListRequest) Mtu(mtu string) ApiDcimInterfacesListRequest {
	r.mtu = &mtu
	return r
}

func (r ApiDcimInterfacesListRequest) MgmtOnly(mgmtOnly string) ApiDcimInterfacesListRequest {
	r.mgmtOnly = &mgmtOnly
	return r
}

func (r ApiDcimInterfacesListRequest) Mode(mode string) ApiDcimInterfacesListRequest {
	r.mode = &mode
	return r
}

func (r ApiDcimInterfacesListRequest) Description(description string) ApiDcimInterfacesListRequest {
	r.description = &description
	return r
}

func (r ApiDcimInterfacesListRequest) Created(created string) ApiDcimInterfacesListRequest {
	r.created = &created
	return r
}

func (r ApiDcimInterfacesListRequest) CreatedGte(createdGte string) ApiDcimInterfacesListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiDcimInterfacesListRequest) CreatedLte(createdLte string) ApiDcimInterfacesListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiDcimInterfacesListRequest) LastUpdated(lastUpdated string) ApiDcimInterfacesListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiDcimInterfacesListRequest) LastUpdatedGte(lastUpdatedGte string) ApiDcimInterfacesListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiDcimInterfacesListRequest) LastUpdatedLte(lastUpdatedLte string) ApiDcimInterfacesListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiDcimInterfacesListRequest) Q(q string) ApiDcimInterfacesListRequest {
	r.q = &q
	return r
}

func (r ApiDcimInterfacesListRequest) RegionId(regionId string) ApiDcimInterfacesListRequest {
	r.regionId = &regionId
	return r
}

func (r ApiDcimInterfacesListRequest) Region(region string) ApiDcimInterfacesListRequest {
	r.region = &region
	return r
}

func (r ApiDcimInterfacesListRequest) SiteGroupId(siteGroupId string) ApiDcimInterfacesListRequest {
	r.siteGroupId = &siteGroupId
	return r
}

func (r ApiDcimInterfacesListRequest) SiteGroup(siteGroup string) ApiDcimInterfacesListRequest {
	r.siteGroup = &siteGroup
	return r
}

func (r ApiDcimInterfacesListRequest) SiteId(siteId string) ApiDcimInterfacesListRequest {
	r.siteId = &siteId
	return r
}

func (r ApiDcimInterfacesListRequest) Site(site string) ApiDcimInterfacesListRequest {
	r.site = &site
	return r
}

func (r ApiDcimInterfacesListRequest) DeviceId(deviceId string) ApiDcimInterfacesListRequest {
	r.deviceId = &deviceId
	return r
}

func (r ApiDcimInterfacesListRequest) Device(device string) ApiDcimInterfacesListRequest {
	r.device = &device
	return r
}

func (r ApiDcimInterfacesListRequest) Tag(tag string) ApiDcimInterfacesListRequest {
	r.tag = &tag
	return r
}

func (r ApiDcimInterfacesListRequest) Cabled(cabled string) ApiDcimInterfacesListRequest {
	r.cabled = &cabled
	return r
}

func (r ApiDcimInterfacesListRequest) Connected(connected string) ApiDcimInterfacesListRequest {
	r.connected = &connected
	return r
}

func (r ApiDcimInterfacesListRequest) Kind(kind string) ApiDcimInterfacesListRequest {
	r.kind = &kind
	return r
}

func (r ApiDcimInterfacesListRequest) ParentId(parentId string) ApiDcimInterfacesListRequest {
	r.parentId = &parentId
	return r
}

func (r ApiDcimInterfacesListRequest) LagId(lagId string) ApiDcimInterfacesListRequest {
	r.lagId = &lagId
	return r
}

func (r ApiDcimInterfacesListRequest) MacAddress(macAddress string) ApiDcimInterfacesListRequest {
	r.macAddress = &macAddress
	return r
}

func (r ApiDcimInterfacesListRequest) VlanId(vlanId string) ApiDcimInterfacesListRequest {
	r.vlanId = &vlanId
	return r
}

func (r ApiDcimInterfacesListRequest) Vlan(vlan string) ApiDcimInterfacesListRequest {
	r.vlan = &vlan
	return r
}

func (r ApiDcimInterfacesListRequest) IdN(idN string) ApiDcimInterfacesListRequest {
	r.idN = &idN
	return r
}

func (r ApiDcimInterfacesListRequest) IdLte(idLte string) ApiDcimInterfacesListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiDcimInterfacesListRequest) IdLt(idLt string) ApiDcimInterfacesListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiDcimInterfacesListRequest) IdGte(idGte string) ApiDcimInterfacesListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiDcimInterfacesListRequest) IdGt(idGt string) ApiDcimInterfacesListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiDcimInterfacesListRequest) NameN(nameN string) ApiDcimInterfacesListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiDcimInterfacesListRequest) NameIc(nameIc string) ApiDcimInterfacesListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiDcimInterfacesListRequest) NameNic(nameNic string) ApiDcimInterfacesListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiDcimInterfacesListRequest) NameIew(nameIew string) ApiDcimInterfacesListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiDcimInterfacesListRequest) NameNiew(nameNiew string) ApiDcimInterfacesListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiDcimInterfacesListRequest) NameIsw(nameIsw string) ApiDcimInterfacesListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiDcimInterfacesListRequest) NameNisw(nameNisw string) ApiDcimInterfacesListRequest {
	r.nameNisw = &nameNisw
	return r
}

func (r ApiDcimInterfacesListRequest) NameIe(nameIe string) ApiDcimInterfacesListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiDcimInterfacesListRequest) NameNie(nameNie string) ApiDcimInterfacesListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiDcimInterfacesListRequest) NameEmpty(nameEmpty string) ApiDcimInterfacesListRequest {
	r.nameEmpty = &nameEmpty
	return r
}

func (r ApiDcimInterfacesListRequest) LabelN(labelN string) ApiDcimInterfacesListRequest {
	r.labelN = &labelN
	return r
}

func (r ApiDcimInterfacesListRequest) LabelIc(labelIc string) ApiDcimInterfacesListRequest {
	r.labelIc = &labelIc
	return r
}

func (r ApiDcimInterfacesListRequest) LabelNic(labelNic string) ApiDcimInterfacesListRequest {
	r.labelNic = &labelNic
	return r
}

func (r ApiDcimInterfacesListRequest) LabelIew(labelIew string) ApiDcimInterfacesListRequest {
	r.labelIew = &labelIew
	return r
}

func (r ApiDcimInterfacesListRequest) LabelNiew(labelNiew string) ApiDcimInterfacesListRequest {
	r.labelNiew = &labelNiew
	return r
}

func (r ApiDcimInterfacesListRequest) LabelIsw(labelIsw string) ApiDcimInterfacesListRequest {
	r.labelIsw = &labelIsw
	return r
}

func (r ApiDcimInterfacesListRequest) LabelNisw(labelNisw string) ApiDcimInterfacesListRequest {
	r.labelNisw = &labelNisw
	return r
}

func (r ApiDcimInterfacesListRequest) LabelIe(labelIe string) ApiDcimInterfacesListRequest {
	r.labelIe = &labelIe
	return r
}

func (r ApiDcimInterfacesListRequest) LabelNie(labelNie string) ApiDcimInterfacesListRequest {
	r.labelNie = &labelNie
	return r
}

func (r ApiDcimInterfacesListRequest) LabelEmpty(labelEmpty string) ApiDcimInterfacesListRequest {
	r.labelEmpty = &labelEmpty
	return r
}

func (r ApiDcimInterfacesListRequest) TypeN(typeN string) ApiDcimInterfacesListRequest {
	r.typeN = &typeN
	return r
}

func (r ApiDcimInterfacesListRequest) MtuN(mtuN string) ApiDcimInterfacesListRequest {
	r.mtuN = &mtuN
	return r
}

func (r ApiDcimInterfacesListRequest) MtuLte(mtuLte string) ApiDcimInterfacesListRequest {
	r.mtuLte = &mtuLte
	return r
}

func (r ApiDcimInterfacesListRequest) MtuLt(mtuLt string) ApiDcimInterfacesListRequest {
	r.mtuLt = &mtuLt
	return r
}

func (r ApiDcimInterfacesListRequest) MtuGte(mtuGte string) ApiDcimInterfacesListRequest {
	r.mtuGte = &mtuGte
	return r
}

func (r ApiDcimInterfacesListRequest) MtuGt(mtuGt string) ApiDcimInterfacesListRequest {
	r.mtuGt = &mtuGt
	return r
}

func (r ApiDcimInterfacesListRequest) ModeN(modeN string) ApiDcimInterfacesListRequest {
	r.modeN = &modeN
	return r
}

func (r ApiDcimInterfacesListRequest) DescriptionN(descriptionN string) ApiDcimInterfacesListRequest {
	r.descriptionN = &descriptionN
	return r
}

func (r ApiDcimInterfacesListRequest) DescriptionIc(descriptionIc string) ApiDcimInterfacesListRequest {
	r.descriptionIc = &descriptionIc
	return r
}

func (r ApiDcimInterfacesListRequest) DescriptionNic(descriptionNic string) ApiDcimInterfacesListRequest {
	r.descriptionNic = &descriptionNic
	return r
}

func (r ApiDcimInterfacesListRequest) DescriptionIew(descriptionIew string) ApiDcimInterfacesListRequest {
	r.descriptionIew = &descriptionIew
	return r
}

func (r ApiDcimInterfacesListRequest) DescriptionNiew(descriptionNiew string) ApiDcimInterfacesListRequest {
	r.descriptionNiew = &descriptionNiew
	return r
}

func (r ApiDcimInterfacesListRequest) DescriptionIsw(descriptionIsw string) ApiDcimInterfacesListRequest {
	r.descriptionIsw = &descriptionIsw
	return r
}

func (r ApiDcimInterfacesListRequest) DescriptionNisw(descriptionNisw string) ApiDcimInterfacesListRequest {
	r.descriptionNisw = &descriptionNisw
	return r
}

func (r ApiDcimInterfacesListRequest) DescriptionIe(descriptionIe string) ApiDcimInterfacesListRequest {
	r.descriptionIe = &descriptionIe
	return r
}

func (r ApiDcimInterfacesListRequest) DescriptionNie(descriptionNie string) ApiDcimInterfacesListRequest {
	r.descriptionNie = &descriptionNie
	return r
}

func (r ApiDcimInterfacesListRequest) DescriptionEmpty(descriptionEmpty string) ApiDcimInterfacesListRequest {
	r.descriptionEmpty = &descriptionEmpty
	return r
}

func (r ApiDcimInterfacesListRequest) RegionIdN(regionIdN string) ApiDcimInterfacesListRequest {
	r.regionIdN = &regionIdN
	return r
}

func (r ApiDcimInterfacesListRequest) RegionN(regionN string) ApiDcimInterfacesListRequest {
	r.regionN = &regionN
	return r
}

func (r ApiDcimInterfacesListRequest) SiteGroupIdN(siteGroupIdN string) ApiDcimInterfacesListRequest {
	r.siteGroupIdN = &siteGroupIdN
	return r
}

func (r ApiDcimInterfacesListRequest) SiteGroupN(siteGroupN string) ApiDcimInterfacesListRequest {
	r.siteGroupN = &siteGroupN
	return r
}

func (r ApiDcimInterfacesListRequest) SiteIdN(siteIdN string) ApiDcimInterfacesListRequest {
	r.siteIdN = &siteIdN
	return r
}

func (r ApiDcimInterfacesListRequest) SiteN(siteN string) ApiDcimInterfacesListRequest {
	r.siteN = &siteN
	return r
}

func (r ApiDcimInterfacesListRequest) TagN(tagN string) ApiDcimInterfacesListRequest {
	r.tagN = &tagN
	return r
}

func (r ApiDcimInterfacesListRequest) ParentIdN(parentIdN string) ApiDcimInterfacesListRequest {
	r.parentIdN = &parentIdN
	return r
}

func (r ApiDcimInterfacesListRequest) LagIdN(lagIdN string) ApiDcimInterfacesListRequest {
	r.lagIdN = &lagIdN
	return r
}

func (r ApiDcimInterfacesListRequest) MacAddressN(macAddressN string) ApiDcimInterfacesListRequest {
	r.macAddressN = &macAddressN
	return r
}

func (r ApiDcimInterfacesListRequest) MacAddressIc(macAddressIc string) ApiDcimInterfacesListRequest {
	r.macAddressIc = &macAddressIc
	return r
}

func (r ApiDcimInterfacesListRequest) MacAddressNic(macAddressNic string) ApiDcimInterfacesListRequest {
	r.macAddressNic = &macAddressNic
	return r
}

func (r ApiDcimInterfacesListRequest) MacAddressIew(macAddressIew string) ApiDcimInterfacesListRequest {
	r.macAddressIew = &macAddressIew
	return r
}

func (r ApiDcimInterfacesListRequest) MacAddressNiew(macAddressNiew string) ApiDcimInterfacesListRequest {
	r.macAddressNiew = &macAddressNiew
	return r
}

func (r ApiDcimInterfacesListRequest) MacAddressIsw(macAddressIsw string) ApiDcimInterfacesListRequest {
	r.macAddressIsw = &macAddressIsw
	return r
}

func (r ApiDcimInterfacesListRequest) MacAddressNisw(macAddressNisw string) ApiDcimInterfacesListRequest {
	r.macAddressNisw = &macAddressNisw
	return r
}

func (r ApiDcimInterfacesListRequest) MacAddressIe(macAddressIe string) ApiDcimInterfacesListRequest {
	r.macAddressIe = &macAddressIe
	return r
}

func (r ApiDcimInterfacesListRequest) MacAddressNie(macAddressNie string) ApiDcimInterfacesListRequest {
	r.macAddressNie = &macAddressNie
	return r
}

// Number of results to return per page.
func (r ApiDcimInterfacesListRequest) Limit(limit int32) ApiDcimInterfacesListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiDcimInterfacesListRequest) Offset(offset int32) ApiDcimInterfacesListRequest {
	r.offset = &offset
	return r
}

func (r ApiDcimInterfacesListRequest) Execute() (*DcimInterfacesList200Response, *http.Response, error) {
	return r.ApiService.DcimInterfacesListExecute(r)
}

/*
DcimInterfacesList Method for DcimInterfacesList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimInterfacesListRequest
*/
func (a *DcimApiService) DcimInterfacesList(ctx context.Context) ApiDcimInterfacesListRequest {
	return ApiDcimInterfacesListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DcimInterfacesList200Response
func (a *DcimApiService) DcimInterfacesListExecute(r ApiDcimInterfacesListRequest) (*DcimInterfacesList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DcimInterfacesList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimInterfacesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/interfaces/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.label != nil {
		localVarQueryParams.Add("label", parameterToString(*r.label, ""))
	}
	if r.type_ != nil {
		localVarQueryParams.Add("type", parameterToString(*r.type_, ""))
	}
	if r.enabled != nil {
		localVarQueryParams.Add("enabled", parameterToString(*r.enabled, ""))
	}
	if r.mtu != nil {
		localVarQueryParams.Add("mtu", parameterToString(*r.mtu, ""))
	}
	if r.mgmtOnly != nil {
		localVarQueryParams.Add("mgmt_only", parameterToString(*r.mgmtOnly, ""))
	}
	if r.mode != nil {
		localVarQueryParams.Add("mode", parameterToString(*r.mode, ""))
	}
	if r.description != nil {
		localVarQueryParams.Add("description", parameterToString(*r.description, ""))
	}
	if r.created != nil {
		localVarQueryParams.Add("created", parameterToString(*r.created, ""))
	}
	if r.createdGte != nil {
		localVarQueryParams.Add("created__gte", parameterToString(*r.createdGte, ""))
	}
	if r.createdLte != nil {
		localVarQueryParams.Add("created__lte", parameterToString(*r.createdLte, ""))
	}
	if r.lastUpdated != nil {
		localVarQueryParams.Add("last_updated", parameterToString(*r.lastUpdated, ""))
	}
	if r.lastUpdatedGte != nil {
		localVarQueryParams.Add("last_updated__gte", parameterToString(*r.lastUpdatedGte, ""))
	}
	if r.lastUpdatedLte != nil {
		localVarQueryParams.Add("last_updated__lte", parameterToString(*r.lastUpdatedLte, ""))
	}
	if r.q != nil {
		localVarQueryParams.Add("q", parameterToString(*r.q, ""))
	}
	if r.regionId != nil {
		localVarQueryParams.Add("region_id", parameterToString(*r.regionId, ""))
	}
	if r.region != nil {
		localVarQueryParams.Add("region", parameterToString(*r.region, ""))
	}
	if r.siteGroupId != nil {
		localVarQueryParams.Add("site_group_id", parameterToString(*r.siteGroupId, ""))
	}
	if r.siteGroup != nil {
		localVarQueryParams.Add("site_group", parameterToString(*r.siteGroup, ""))
	}
	if r.siteId != nil {
		localVarQueryParams.Add("site_id", parameterToString(*r.siteId, ""))
	}
	if r.site != nil {
		localVarQueryParams.Add("site", parameterToString(*r.site, ""))
	}
	if r.deviceId != nil {
		localVarQueryParams.Add("device_id", parameterToString(*r.deviceId, ""))
	}
	if r.device != nil {
		localVarQueryParams.Add("device", parameterToString(*r.device, ""))
	}
	if r.tag != nil {
		localVarQueryParams.Add("tag", parameterToString(*r.tag, ""))
	}
	if r.cabled != nil {
		localVarQueryParams.Add("cabled", parameterToString(*r.cabled, ""))
	}
	if r.connected != nil {
		localVarQueryParams.Add("connected", parameterToString(*r.connected, ""))
	}
	if r.kind != nil {
		localVarQueryParams.Add("kind", parameterToString(*r.kind, ""))
	}
	if r.parentId != nil {
		localVarQueryParams.Add("parent_id", parameterToString(*r.parentId, ""))
	}
	if r.lagId != nil {
		localVarQueryParams.Add("lag_id", parameterToString(*r.lagId, ""))
	}
	if r.macAddress != nil {
		localVarQueryParams.Add("mac_address", parameterToString(*r.macAddress, ""))
	}
	if r.vlanId != nil {
		localVarQueryParams.Add("vlan_id", parameterToString(*r.vlanId, ""))
	}
	if r.vlan != nil {
		localVarQueryParams.Add("vlan", parameterToString(*r.vlan, ""))
	}
	if r.idN != nil {
		localVarQueryParams.Add("id__n", parameterToString(*r.idN, ""))
	}
	if r.idLte != nil {
		localVarQueryParams.Add("id__lte", parameterToString(*r.idLte, ""))
	}
	if r.idLt != nil {
		localVarQueryParams.Add("id__lt", parameterToString(*r.idLt, ""))
	}
	if r.idGte != nil {
		localVarQueryParams.Add("id__gte", parameterToString(*r.idGte, ""))
	}
	if r.idGt != nil {
		localVarQueryParams.Add("id__gt", parameterToString(*r.idGt, ""))
	}
	if r.nameN != nil {
		localVarQueryParams.Add("name__n", parameterToString(*r.nameN, ""))
	}
	if r.nameIc != nil {
		localVarQueryParams.Add("name__ic", parameterToString(*r.nameIc, ""))
	}
	if r.nameNic != nil {
		localVarQueryParams.Add("name__nic", parameterToString(*r.nameNic, ""))
	}
	if r.nameIew != nil {
		localVarQueryParams.Add("name__iew", parameterToString(*r.nameIew, ""))
	}
	if r.nameNiew != nil {
		localVarQueryParams.Add("name__niew", parameterToString(*r.nameNiew, ""))
	}
	if r.nameIsw != nil {
		localVarQueryParams.Add("name__isw", parameterToString(*r.nameIsw, ""))
	}
	if r.nameNisw != nil {
		localVarQueryParams.Add("name__nisw", parameterToString(*r.nameNisw, ""))
	}
	if r.nameIe != nil {
		localVarQueryParams.Add("name__ie", parameterToString(*r.nameIe, ""))
	}
	if r.nameNie != nil {
		localVarQueryParams.Add("name__nie", parameterToString(*r.nameNie, ""))
	}
	if r.nameEmpty != nil {
		localVarQueryParams.Add("name__empty", parameterToString(*r.nameEmpty, ""))
	}
	if r.labelN != nil {
		localVarQueryParams.Add("label__n", parameterToString(*r.labelN, ""))
	}
	if r.labelIc != nil {
		localVarQueryParams.Add("label__ic", parameterToString(*r.labelIc, ""))
	}
	if r.labelNic != nil {
		localVarQueryParams.Add("label__nic", parameterToString(*r.labelNic, ""))
	}
	if r.labelIew != nil {
		localVarQueryParams.Add("label__iew", parameterToString(*r.labelIew, ""))
	}
	if r.labelNiew != nil {
		localVarQueryParams.Add("label__niew", parameterToString(*r.labelNiew, ""))
	}
	if r.labelIsw != nil {
		localVarQueryParams.Add("label__isw", parameterToString(*r.labelIsw, ""))
	}
	if r.labelNisw != nil {
		localVarQueryParams.Add("label__nisw", parameterToString(*r.labelNisw, ""))
	}
	if r.labelIe != nil {
		localVarQueryParams.Add("label__ie", parameterToString(*r.labelIe, ""))
	}
	if r.labelNie != nil {
		localVarQueryParams.Add("label__nie", parameterToString(*r.labelNie, ""))
	}
	if r.labelEmpty != nil {
		localVarQueryParams.Add("label__empty", parameterToString(*r.labelEmpty, ""))
	}
	if r.typeN != nil {
		localVarQueryParams.Add("type__n", parameterToString(*r.typeN, ""))
	}
	if r.mtuN != nil {
		localVarQueryParams.Add("mtu__n", parameterToString(*r.mtuN, ""))
	}
	if r.mtuLte != nil {
		localVarQueryParams.Add("mtu__lte", parameterToString(*r.mtuLte, ""))
	}
	if r.mtuLt != nil {
		localVarQueryParams.Add("mtu__lt", parameterToString(*r.mtuLt, ""))
	}
	if r.mtuGte != nil {
		localVarQueryParams.Add("mtu__gte", parameterToString(*r.mtuGte, ""))
	}
	if r.mtuGt != nil {
		localVarQueryParams.Add("mtu__gt", parameterToString(*r.mtuGt, ""))
	}
	if r.modeN != nil {
		localVarQueryParams.Add("mode__n", parameterToString(*r.modeN, ""))
	}
	if r.descriptionN != nil {
		localVarQueryParams.Add("description__n", parameterToString(*r.descriptionN, ""))
	}
	if r.descriptionIc != nil {
		localVarQueryParams.Add("description__ic", parameterToString(*r.descriptionIc, ""))
	}
	if r.descriptionNic != nil {
		localVarQueryParams.Add("description__nic", parameterToString(*r.descriptionNic, ""))
	}
	if r.descriptionIew != nil {
		localVarQueryParams.Add("description__iew", parameterToString(*r.descriptionIew, ""))
	}
	if r.descriptionNiew != nil {
		localVarQueryParams.Add("description__niew", parameterToString(*r.descriptionNiew, ""))
	}
	if r.descriptionIsw != nil {
		localVarQueryParams.Add("description__isw", parameterToString(*r.descriptionIsw, ""))
	}
	if r.descriptionNisw != nil {
		localVarQueryParams.Add("description__nisw", parameterToString(*r.descriptionNisw, ""))
	}
	if r.descriptionIe != nil {
		localVarQueryParams.Add("description__ie", parameterToString(*r.descriptionIe, ""))
	}
	if r.descriptionNie != nil {
		localVarQueryParams.Add("description__nie", parameterToString(*r.descriptionNie, ""))
	}
	if r.descriptionEmpty != nil {
		localVarQueryParams.Add("description__empty", parameterToString(*r.descriptionEmpty, ""))
	}
	if r.regionIdN != nil {
		localVarQueryParams.Add("region_id__n", parameterToString(*r.regionIdN, ""))
	}
	if r.regionN != nil {
		localVarQueryParams.Add("region__n", parameterToString(*r.regionN, ""))
	}
	if r.siteGroupIdN != nil {
		localVarQueryParams.Add("site_group_id__n", parameterToString(*r.siteGroupIdN, ""))
	}
	if r.siteGroupN != nil {
		localVarQueryParams.Add("site_group__n", parameterToString(*r.siteGroupN, ""))
	}
	if r.siteIdN != nil {
		localVarQueryParams.Add("site_id__n", parameterToString(*r.siteIdN, ""))
	}
	if r.siteN != nil {
		localVarQueryParams.Add("site__n", parameterToString(*r.siteN, ""))
	}
	if r.tagN != nil {
		localVarQueryParams.Add("tag__n", parameterToString(*r.tagN, ""))
	}
	if r.parentIdN != nil {
		localVarQueryParams.Add("parent_id__n", parameterToString(*r.parentIdN, ""))
	}
	if r.lagIdN != nil {
		localVarQueryParams.Add("lag_id__n", parameterToString(*r.lagIdN, ""))
	}
	if r.macAddressN != nil {
		localVarQueryParams.Add("mac_address__n", parameterToString(*r.macAddressN, ""))
	}
	if r.macAddressIc != nil {
		localVarQueryParams.Add("mac_address__ic", parameterToString(*r.macAddressIc, ""))
	}
	if r.macAddressNic != nil {
		localVarQueryParams.Add("mac_address__nic", parameterToString(*r.macAddressNic, ""))
	}
	if r.macAddressIew != nil {
		localVarQueryParams.Add("mac_address__iew", parameterToString(*r.macAddressIew, ""))
	}
	if r.macAddressNiew != nil {
		localVarQueryParams.Add("mac_address__niew", parameterToString(*r.macAddressNiew, ""))
	}
	if r.macAddressIsw != nil {
		localVarQueryParams.Add("mac_address__isw", parameterToString(*r.macAddressIsw, ""))
	}
	if r.macAddressNisw != nil {
		localVarQueryParams.Add("mac_address__nisw", parameterToString(*r.macAddressNisw, ""))
	}
	if r.macAddressIe != nil {
		localVarQueryParams.Add("mac_address__ie", parameterToString(*r.macAddressIe, ""))
	}
	if r.macAddressNie != nil {
		localVarQueryParams.Add("mac_address__nie", parameterToString(*r.macAddressNie, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimInterfacesPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
	data *WritableInterface
}

func (r ApiDcimInterfacesPartialUpdateRequest) Data(data WritableInterface) ApiDcimInterfacesPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimInterfacesPartialUpdateRequest) Execute() (*Interface, *http.Response, error) {
	return r.ApiService.DcimInterfacesPartialUpdateExecute(r)
}

/*
DcimInterfacesPartialUpdate Method for DcimInterfacesPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this interface.
 @return ApiDcimInterfacesPartialUpdateRequest
*/
func (a *DcimApiService) DcimInterfacesPartialUpdate(ctx context.Context, id int32) ApiDcimInterfacesPartialUpdateRequest {
	return ApiDcimInterfacesPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Interface
func (a *DcimApiService) DcimInterfacesPartialUpdateExecute(r ApiDcimInterfacesPartialUpdateRequest) (*Interface, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Interface
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimInterfacesPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/interfaces/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimInterfacesReadRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
}

func (r ApiDcimInterfacesReadRequest) Execute() (*Interface, *http.Response, error) {
	return r.ApiService.DcimInterfacesReadExecute(r)
}

/*
DcimInterfacesRead Method for DcimInterfacesRead

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this interface.
 @return ApiDcimInterfacesReadRequest
*/
func (a *DcimApiService) DcimInterfacesRead(ctx context.Context, id int32) ApiDcimInterfacesReadRequest {
	return ApiDcimInterfacesReadRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Interface
func (a *DcimApiService) DcimInterfacesReadExecute(r ApiDcimInterfacesReadRequest) (*Interface, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Interface
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimInterfacesRead")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/interfaces/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimInterfacesTraceRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
}

func (r ApiDcimInterfacesTraceRequest) Execute() (*Interface, *http.Response, error) {
	return r.ApiService.DcimInterfacesTraceExecute(r)
}

/*
DcimInterfacesTrace Method for DcimInterfacesTrace

Trace a complete cable path and return each segment as a three-tuple of (termination, cable, termination).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this interface.
 @return ApiDcimInterfacesTraceRequest
*/
func (a *DcimApiService) DcimInterfacesTrace(ctx context.Context, id int32) ApiDcimInterfacesTraceRequest {
	return ApiDcimInterfacesTraceRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Interface
func (a *DcimApiService) DcimInterfacesTraceExecute(r ApiDcimInterfacesTraceRequest) (*Interface, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Interface
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimInterfacesTrace")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/interfaces/{id}/trace/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimInterfacesUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
	data *WritableInterface
}

func (r ApiDcimInterfacesUpdateRequest) Data(data WritableInterface) ApiDcimInterfacesUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimInterfacesUpdateRequest) Execute() (*Interface, *http.Response, error) {
	return r.ApiService.DcimInterfacesUpdateExecute(r)
}

/*
DcimInterfacesUpdate Method for DcimInterfacesUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this interface.
 @return ApiDcimInterfacesUpdateRequest
*/
func (a *DcimApiService) DcimInterfacesUpdate(ctx context.Context, id int32) ApiDcimInterfacesUpdateRequest {
	return ApiDcimInterfacesUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Interface
func (a *DcimApiService) DcimInterfacesUpdateExecute(r ApiDcimInterfacesUpdateRequest) (*Interface, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Interface
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimInterfacesUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/interfaces/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimInventoryItemsBulkDeleteRequest struct {
	ctx context.Context
	ApiService *DcimApiService
}

func (r ApiDcimInventoryItemsBulkDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimInventoryItemsBulkDeleteExecute(r)
}

/*
DcimInventoryItemsBulkDelete Method for DcimInventoryItemsBulkDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimInventoryItemsBulkDeleteRequest
*/
func (a *DcimApiService) DcimInventoryItemsBulkDelete(ctx context.Context) ApiDcimInventoryItemsBulkDeleteRequest {
	return ApiDcimInventoryItemsBulkDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DcimApiService) DcimInventoryItemsBulkDeleteExecute(r ApiDcimInventoryItemsBulkDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimInventoryItemsBulkDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/inventory-items/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimInventoryItemsBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	data *WritableInventoryItem
}

func (r ApiDcimInventoryItemsBulkPartialUpdateRequest) Data(data WritableInventoryItem) ApiDcimInventoryItemsBulkPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimInventoryItemsBulkPartialUpdateRequest) Execute() (*InventoryItem, *http.Response, error) {
	return r.ApiService.DcimInventoryItemsBulkPartialUpdateExecute(r)
}

/*
DcimInventoryItemsBulkPartialUpdate Method for DcimInventoryItemsBulkPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimInventoryItemsBulkPartialUpdateRequest
*/
func (a *DcimApiService) DcimInventoryItemsBulkPartialUpdate(ctx context.Context) ApiDcimInventoryItemsBulkPartialUpdateRequest {
	return ApiDcimInventoryItemsBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InventoryItem
func (a *DcimApiService) DcimInventoryItemsBulkPartialUpdateExecute(r ApiDcimInventoryItemsBulkPartialUpdateRequest) (*InventoryItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InventoryItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimInventoryItemsBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/inventory-items/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimInventoryItemsBulkUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	data *WritableInventoryItem
}

func (r ApiDcimInventoryItemsBulkUpdateRequest) Data(data WritableInventoryItem) ApiDcimInventoryItemsBulkUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimInventoryItemsBulkUpdateRequest) Execute() (*InventoryItem, *http.Response, error) {
	return r.ApiService.DcimInventoryItemsBulkUpdateExecute(r)
}

/*
DcimInventoryItemsBulkUpdate Method for DcimInventoryItemsBulkUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimInventoryItemsBulkUpdateRequest
*/
func (a *DcimApiService) DcimInventoryItemsBulkUpdate(ctx context.Context) ApiDcimInventoryItemsBulkUpdateRequest {
	return ApiDcimInventoryItemsBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InventoryItem
func (a *DcimApiService) DcimInventoryItemsBulkUpdateExecute(r ApiDcimInventoryItemsBulkUpdateRequest) (*InventoryItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InventoryItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimInventoryItemsBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/inventory-items/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimInventoryItemsCreateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	data *WritableInventoryItem
}

func (r ApiDcimInventoryItemsCreateRequest) Data(data WritableInventoryItem) ApiDcimInventoryItemsCreateRequest {
	r.data = &data
	return r
}

func (r ApiDcimInventoryItemsCreateRequest) Execute() (*InventoryItem, *http.Response, error) {
	return r.ApiService.DcimInventoryItemsCreateExecute(r)
}

/*
DcimInventoryItemsCreate Method for DcimInventoryItemsCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimInventoryItemsCreateRequest
*/
func (a *DcimApiService) DcimInventoryItemsCreate(ctx context.Context) ApiDcimInventoryItemsCreateRequest {
	return ApiDcimInventoryItemsCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InventoryItem
func (a *DcimApiService) DcimInventoryItemsCreateExecute(r ApiDcimInventoryItemsCreateRequest) (*InventoryItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InventoryItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimInventoryItemsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/inventory-items/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimInventoryItemsDeleteRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
}

func (r ApiDcimInventoryItemsDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimInventoryItemsDeleteExecute(r)
}

/*
DcimInventoryItemsDelete Method for DcimInventoryItemsDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this inventory item.
 @return ApiDcimInventoryItemsDeleteRequest
*/
func (a *DcimApiService) DcimInventoryItemsDelete(ctx context.Context, id int32) ApiDcimInventoryItemsDeleteRequest {
	return ApiDcimInventoryItemsDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DcimApiService) DcimInventoryItemsDeleteExecute(r ApiDcimInventoryItemsDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimInventoryItemsDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/inventory-items/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimInventoryItemsListRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id *string
	name *string
	label *string
	partId *string
	assetTag *string
	discovered *string
	created *string
	createdGte *string
	createdLte *string
	lastUpdated *string
	lastUpdatedGte *string
	lastUpdatedLte *string
	q *string
	regionId *string
	region *string
	siteGroupId *string
	siteGroup *string
	siteId *string
	site *string
	deviceId *string
	device *string
	tag *string
	parentId *string
	manufacturerId *string
	manufacturer *string
	serial *string
	idN *string
	idLte *string
	idLt *string
	idGte *string
	idGt *string
	nameN *string
	nameIc *string
	nameNic *string
	nameIew *string
	nameNiew *string
	nameIsw *string
	nameNisw *string
	nameIe *string
	nameNie *string
	nameEmpty *string
	labelN *string
	labelIc *string
	labelNic *string
	labelIew *string
	labelNiew *string
	labelIsw *string
	labelNisw *string
	labelIe *string
	labelNie *string
	labelEmpty *string
	partIdN *string
	partIdIc *string
	partIdNic *string
	partIdIew *string
	partIdNiew *string
	partIdIsw *string
	partIdNisw *string
	partIdIe *string
	partIdNie *string
	partIdEmpty *string
	assetTagN *string
	assetTagIc *string
	assetTagNic *string
	assetTagIew *string
	assetTagNiew *string
	assetTagIsw *string
	assetTagNisw *string
	assetTagIe *string
	assetTagNie *string
	assetTagEmpty *string
	regionIdN *string
	regionN *string
	siteGroupIdN *string
	siteGroupN *string
	siteIdN *string
	siteN *string
	deviceIdN *string
	deviceN *string
	tagN *string
	parentIdN *string
	manufacturerIdN *string
	manufacturerN *string
	limit *int32
	offset *int32
}

func (r ApiDcimInventoryItemsListRequest) Id(id string) ApiDcimInventoryItemsListRequest {
	r.id = &id
	return r
}

func (r ApiDcimInventoryItemsListRequest) Name(name string) ApiDcimInventoryItemsListRequest {
	r.name = &name
	return r
}

func (r ApiDcimInventoryItemsListRequest) Label(label string) ApiDcimInventoryItemsListRequest {
	r.label = &label
	return r
}

func (r ApiDcimInventoryItemsListRequest) PartId(partId string) ApiDcimInventoryItemsListRequest {
	r.partId = &partId
	return r
}

func (r ApiDcimInventoryItemsListRequest) AssetTag(assetTag string) ApiDcimInventoryItemsListRequest {
	r.assetTag = &assetTag
	return r
}

func (r ApiDcimInventoryItemsListRequest) Discovered(discovered string) ApiDcimInventoryItemsListRequest {
	r.discovered = &discovered
	return r
}

func (r ApiDcimInventoryItemsListRequest) Created(created string) ApiDcimInventoryItemsListRequest {
	r.created = &created
	return r
}

func (r ApiDcimInventoryItemsListRequest) CreatedGte(createdGte string) ApiDcimInventoryItemsListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiDcimInventoryItemsListRequest) CreatedLte(createdLte string) ApiDcimInventoryItemsListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiDcimInventoryItemsListRequest) LastUpdated(lastUpdated string) ApiDcimInventoryItemsListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiDcimInventoryItemsListRequest) LastUpdatedGte(lastUpdatedGte string) ApiDcimInventoryItemsListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiDcimInventoryItemsListRequest) LastUpdatedLte(lastUpdatedLte string) ApiDcimInventoryItemsListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiDcimInventoryItemsListRequest) Q(q string) ApiDcimInventoryItemsListRequest {
	r.q = &q
	return r
}

func (r ApiDcimInventoryItemsListRequest) RegionId(regionId string) ApiDcimInventoryItemsListRequest {
	r.regionId = &regionId
	return r
}

func (r ApiDcimInventoryItemsListRequest) Region(region string) ApiDcimInventoryItemsListRequest {
	r.region = &region
	return r
}

func (r ApiDcimInventoryItemsListRequest) SiteGroupId(siteGroupId string) ApiDcimInventoryItemsListRequest {
	r.siteGroupId = &siteGroupId
	return r
}

func (r ApiDcimInventoryItemsListRequest) SiteGroup(siteGroup string) ApiDcimInventoryItemsListRequest {
	r.siteGroup = &siteGroup
	return r
}

func (r ApiDcimInventoryItemsListRequest) SiteId(siteId string) ApiDcimInventoryItemsListRequest {
	r.siteId = &siteId
	return r
}

func (r ApiDcimInventoryItemsListRequest) Site(site string) ApiDcimInventoryItemsListRequest {
	r.site = &site
	return r
}

func (r ApiDcimInventoryItemsListRequest) DeviceId(deviceId string) ApiDcimInventoryItemsListRequest {
	r.deviceId = &deviceId
	return r
}

func (r ApiDcimInventoryItemsListRequest) Device(device string) ApiDcimInventoryItemsListRequest {
	r.device = &device
	return r
}

func (r ApiDcimInventoryItemsListRequest) Tag(tag string) ApiDcimInventoryItemsListRequest {
	r.tag = &tag
	return r
}

func (r ApiDcimInventoryItemsListRequest) ParentId(parentId string) ApiDcimInventoryItemsListRequest {
	r.parentId = &parentId
	return r
}

func (r ApiDcimInventoryItemsListRequest) ManufacturerId(manufacturerId string) ApiDcimInventoryItemsListRequest {
	r.manufacturerId = &manufacturerId
	return r
}

func (r ApiDcimInventoryItemsListRequest) Manufacturer(manufacturer string) ApiDcimInventoryItemsListRequest {
	r.manufacturer = &manufacturer
	return r
}

func (r ApiDcimInventoryItemsListRequest) Serial(serial string) ApiDcimInventoryItemsListRequest {
	r.serial = &serial
	return r
}

func (r ApiDcimInventoryItemsListRequest) IdN(idN string) ApiDcimInventoryItemsListRequest {
	r.idN = &idN
	return r
}

func (r ApiDcimInventoryItemsListRequest) IdLte(idLte string) ApiDcimInventoryItemsListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiDcimInventoryItemsListRequest) IdLt(idLt string) ApiDcimInventoryItemsListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiDcimInventoryItemsListRequest) IdGte(idGte string) ApiDcimInventoryItemsListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiDcimInventoryItemsListRequest) IdGt(idGt string) ApiDcimInventoryItemsListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiDcimInventoryItemsListRequest) NameN(nameN string) ApiDcimInventoryItemsListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiDcimInventoryItemsListRequest) NameIc(nameIc string) ApiDcimInventoryItemsListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiDcimInventoryItemsListRequest) NameNic(nameNic string) ApiDcimInventoryItemsListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiDcimInventoryItemsListRequest) NameIew(nameIew string) ApiDcimInventoryItemsListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiDcimInventoryItemsListRequest) NameNiew(nameNiew string) ApiDcimInventoryItemsListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiDcimInventoryItemsListRequest) NameIsw(nameIsw string) ApiDcimInventoryItemsListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiDcimInventoryItemsListRequest) NameNisw(nameNisw string) ApiDcimInventoryItemsListRequest {
	r.nameNisw = &nameNisw
	return r
}

func (r ApiDcimInventoryItemsListRequest) NameIe(nameIe string) ApiDcimInventoryItemsListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiDcimInventoryItemsListRequest) NameNie(nameNie string) ApiDcimInventoryItemsListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiDcimInventoryItemsListRequest) NameEmpty(nameEmpty string) ApiDcimInventoryItemsListRequest {
	r.nameEmpty = &nameEmpty
	return r
}

func (r ApiDcimInventoryItemsListRequest) LabelN(labelN string) ApiDcimInventoryItemsListRequest {
	r.labelN = &labelN
	return r
}

func (r ApiDcimInventoryItemsListRequest) LabelIc(labelIc string) ApiDcimInventoryItemsListRequest {
	r.labelIc = &labelIc
	return r
}

func (r ApiDcimInventoryItemsListRequest) LabelNic(labelNic string) ApiDcimInventoryItemsListRequest {
	r.labelNic = &labelNic
	return r
}

func (r ApiDcimInventoryItemsListRequest) LabelIew(labelIew string) ApiDcimInventoryItemsListRequest {
	r.labelIew = &labelIew
	return r
}

func (r ApiDcimInventoryItemsListRequest) LabelNiew(labelNiew string) ApiDcimInventoryItemsListRequest {
	r.labelNiew = &labelNiew
	return r
}

func (r ApiDcimInventoryItemsListRequest) LabelIsw(labelIsw string) ApiDcimInventoryItemsListRequest {
	r.labelIsw = &labelIsw
	return r
}

func (r ApiDcimInventoryItemsListRequest) LabelNisw(labelNisw string) ApiDcimInventoryItemsListRequest {
	r.labelNisw = &labelNisw
	return r
}

func (r ApiDcimInventoryItemsListRequest) LabelIe(labelIe string) ApiDcimInventoryItemsListRequest {
	r.labelIe = &labelIe
	return r
}

func (r ApiDcimInventoryItemsListRequest) LabelNie(labelNie string) ApiDcimInventoryItemsListRequest {
	r.labelNie = &labelNie
	return r
}

func (r ApiDcimInventoryItemsListRequest) LabelEmpty(labelEmpty string) ApiDcimInventoryItemsListRequest {
	r.labelEmpty = &labelEmpty
	return r
}

func (r ApiDcimInventoryItemsListRequest) PartIdN(partIdN string) ApiDcimInventoryItemsListRequest {
	r.partIdN = &partIdN
	return r
}

func (r ApiDcimInventoryItemsListRequest) PartIdIc(partIdIc string) ApiDcimInventoryItemsListRequest {
	r.partIdIc = &partIdIc
	return r
}

func (r ApiDcimInventoryItemsListRequest) PartIdNic(partIdNic string) ApiDcimInventoryItemsListRequest {
	r.partIdNic = &partIdNic
	return r
}

func (r ApiDcimInventoryItemsListRequest) PartIdIew(partIdIew string) ApiDcimInventoryItemsListRequest {
	r.partIdIew = &partIdIew
	return r
}

func (r ApiDcimInventoryItemsListRequest) PartIdNiew(partIdNiew string) ApiDcimInventoryItemsListRequest {
	r.partIdNiew = &partIdNiew
	return r
}

func (r ApiDcimInventoryItemsListRequest) PartIdIsw(partIdIsw string) ApiDcimInventoryItemsListRequest {
	r.partIdIsw = &partIdIsw
	return r
}

func (r ApiDcimInventoryItemsListRequest) PartIdNisw(partIdNisw string) ApiDcimInventoryItemsListRequest {
	r.partIdNisw = &partIdNisw
	return r
}

func (r ApiDcimInventoryItemsListRequest) PartIdIe(partIdIe string) ApiDcimInventoryItemsListRequest {
	r.partIdIe = &partIdIe
	return r
}

func (r ApiDcimInventoryItemsListRequest) PartIdNie(partIdNie string) ApiDcimInventoryItemsListRequest {
	r.partIdNie = &partIdNie
	return r
}

func (r ApiDcimInventoryItemsListRequest) PartIdEmpty(partIdEmpty string) ApiDcimInventoryItemsListRequest {
	r.partIdEmpty = &partIdEmpty
	return r
}

func (r ApiDcimInventoryItemsListRequest) AssetTagN(assetTagN string) ApiDcimInventoryItemsListRequest {
	r.assetTagN = &assetTagN
	return r
}

func (r ApiDcimInventoryItemsListRequest) AssetTagIc(assetTagIc string) ApiDcimInventoryItemsListRequest {
	r.assetTagIc = &assetTagIc
	return r
}

func (r ApiDcimInventoryItemsListRequest) AssetTagNic(assetTagNic string) ApiDcimInventoryItemsListRequest {
	r.assetTagNic = &assetTagNic
	return r
}

func (r ApiDcimInventoryItemsListRequest) AssetTagIew(assetTagIew string) ApiDcimInventoryItemsListRequest {
	r.assetTagIew = &assetTagIew
	return r
}

func (r ApiDcimInventoryItemsListRequest) AssetTagNiew(assetTagNiew string) ApiDcimInventoryItemsListRequest {
	r.assetTagNiew = &assetTagNiew
	return r
}

func (r ApiDcimInventoryItemsListRequest) AssetTagIsw(assetTagIsw string) ApiDcimInventoryItemsListRequest {
	r.assetTagIsw = &assetTagIsw
	return r
}

func (r ApiDcimInventoryItemsListRequest) AssetTagNisw(assetTagNisw string) ApiDcimInventoryItemsListRequest {
	r.assetTagNisw = &assetTagNisw
	return r
}

func (r ApiDcimInventoryItemsListRequest) AssetTagIe(assetTagIe string) ApiDcimInventoryItemsListRequest {
	r.assetTagIe = &assetTagIe
	return r
}

func (r ApiDcimInventoryItemsListRequest) AssetTagNie(assetTagNie string) ApiDcimInventoryItemsListRequest {
	r.assetTagNie = &assetTagNie
	return r
}

func (r ApiDcimInventoryItemsListRequest) AssetTagEmpty(assetTagEmpty string) ApiDcimInventoryItemsListRequest {
	r.assetTagEmpty = &assetTagEmpty
	return r
}

func (r ApiDcimInventoryItemsListRequest) RegionIdN(regionIdN string) ApiDcimInventoryItemsListRequest {
	r.regionIdN = &regionIdN
	return r
}

func (r ApiDcimInventoryItemsListRequest) RegionN(regionN string) ApiDcimInventoryItemsListRequest {
	r.regionN = &regionN
	return r
}

func (r ApiDcimInventoryItemsListRequest) SiteGroupIdN(siteGroupIdN string) ApiDcimInventoryItemsListRequest {
	r.siteGroupIdN = &siteGroupIdN
	return r
}

func (r ApiDcimInventoryItemsListRequest) SiteGroupN(siteGroupN string) ApiDcimInventoryItemsListRequest {
	r.siteGroupN = &siteGroupN
	return r
}

func (r ApiDcimInventoryItemsListRequest) SiteIdN(siteIdN string) ApiDcimInventoryItemsListRequest {
	r.siteIdN = &siteIdN
	return r
}

func (r ApiDcimInventoryItemsListRequest) SiteN(siteN string) ApiDcimInventoryItemsListRequest {
	r.siteN = &siteN
	return r
}

func (r ApiDcimInventoryItemsListRequest) DeviceIdN(deviceIdN string) ApiDcimInventoryItemsListRequest {
	r.deviceIdN = &deviceIdN
	return r
}

func (r ApiDcimInventoryItemsListRequest) DeviceN(deviceN string) ApiDcimInventoryItemsListRequest {
	r.deviceN = &deviceN
	return r
}

func (r ApiDcimInventoryItemsListRequest) TagN(tagN string) ApiDcimInventoryItemsListRequest {
	r.tagN = &tagN
	return r
}

func (r ApiDcimInventoryItemsListRequest) ParentIdN(parentIdN string) ApiDcimInventoryItemsListRequest {
	r.parentIdN = &parentIdN
	return r
}

func (r ApiDcimInventoryItemsListRequest) ManufacturerIdN(manufacturerIdN string) ApiDcimInventoryItemsListRequest {
	r.manufacturerIdN = &manufacturerIdN
	return r
}

func (r ApiDcimInventoryItemsListRequest) ManufacturerN(manufacturerN string) ApiDcimInventoryItemsListRequest {
	r.manufacturerN = &manufacturerN
	return r
}

// Number of results to return per page.
func (r ApiDcimInventoryItemsListRequest) Limit(limit int32) ApiDcimInventoryItemsListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiDcimInventoryItemsListRequest) Offset(offset int32) ApiDcimInventoryItemsListRequest {
	r.offset = &offset
	return r
}

func (r ApiDcimInventoryItemsListRequest) Execute() (*DcimInventoryItemsList200Response, *http.Response, error) {
	return r.ApiService.DcimInventoryItemsListExecute(r)
}

/*
DcimInventoryItemsList Method for DcimInventoryItemsList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimInventoryItemsListRequest
*/
func (a *DcimApiService) DcimInventoryItemsList(ctx context.Context) ApiDcimInventoryItemsListRequest {
	return ApiDcimInventoryItemsListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DcimInventoryItemsList200Response
func (a *DcimApiService) DcimInventoryItemsListExecute(r ApiDcimInventoryItemsListRequest) (*DcimInventoryItemsList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DcimInventoryItemsList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimInventoryItemsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/inventory-items/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.label != nil {
		localVarQueryParams.Add("label", parameterToString(*r.label, ""))
	}
	if r.partId != nil {
		localVarQueryParams.Add("part_id", parameterToString(*r.partId, ""))
	}
	if r.assetTag != nil {
		localVarQueryParams.Add("asset_tag", parameterToString(*r.assetTag, ""))
	}
	if r.discovered != nil {
		localVarQueryParams.Add("discovered", parameterToString(*r.discovered, ""))
	}
	if r.created != nil {
		localVarQueryParams.Add("created", parameterToString(*r.created, ""))
	}
	if r.createdGte != nil {
		localVarQueryParams.Add("created__gte", parameterToString(*r.createdGte, ""))
	}
	if r.createdLte != nil {
		localVarQueryParams.Add("created__lte", parameterToString(*r.createdLte, ""))
	}
	if r.lastUpdated != nil {
		localVarQueryParams.Add("last_updated", parameterToString(*r.lastUpdated, ""))
	}
	if r.lastUpdatedGte != nil {
		localVarQueryParams.Add("last_updated__gte", parameterToString(*r.lastUpdatedGte, ""))
	}
	if r.lastUpdatedLte != nil {
		localVarQueryParams.Add("last_updated__lte", parameterToString(*r.lastUpdatedLte, ""))
	}
	if r.q != nil {
		localVarQueryParams.Add("q", parameterToString(*r.q, ""))
	}
	if r.regionId != nil {
		localVarQueryParams.Add("region_id", parameterToString(*r.regionId, ""))
	}
	if r.region != nil {
		localVarQueryParams.Add("region", parameterToString(*r.region, ""))
	}
	if r.siteGroupId != nil {
		localVarQueryParams.Add("site_group_id", parameterToString(*r.siteGroupId, ""))
	}
	if r.siteGroup != nil {
		localVarQueryParams.Add("site_group", parameterToString(*r.siteGroup, ""))
	}
	if r.siteId != nil {
		localVarQueryParams.Add("site_id", parameterToString(*r.siteId, ""))
	}
	if r.site != nil {
		localVarQueryParams.Add("site", parameterToString(*r.site, ""))
	}
	if r.deviceId != nil {
		localVarQueryParams.Add("device_id", parameterToString(*r.deviceId, ""))
	}
	if r.device != nil {
		localVarQueryParams.Add("device", parameterToString(*r.device, ""))
	}
	if r.tag != nil {
		localVarQueryParams.Add("tag", parameterToString(*r.tag, ""))
	}
	if r.parentId != nil {
		localVarQueryParams.Add("parent_id", parameterToString(*r.parentId, ""))
	}
	if r.manufacturerId != nil {
		localVarQueryParams.Add("manufacturer_id", parameterToString(*r.manufacturerId, ""))
	}
	if r.manufacturer != nil {
		localVarQueryParams.Add("manufacturer", parameterToString(*r.manufacturer, ""))
	}
	if r.serial != nil {
		localVarQueryParams.Add("serial", parameterToString(*r.serial, ""))
	}
	if r.idN != nil {
		localVarQueryParams.Add("id__n", parameterToString(*r.idN, ""))
	}
	if r.idLte != nil {
		localVarQueryParams.Add("id__lte", parameterToString(*r.idLte, ""))
	}
	if r.idLt != nil {
		localVarQueryParams.Add("id__lt", parameterToString(*r.idLt, ""))
	}
	if r.idGte != nil {
		localVarQueryParams.Add("id__gte", parameterToString(*r.idGte, ""))
	}
	if r.idGt != nil {
		localVarQueryParams.Add("id__gt", parameterToString(*r.idGt, ""))
	}
	if r.nameN != nil {
		localVarQueryParams.Add("name__n", parameterToString(*r.nameN, ""))
	}
	if r.nameIc != nil {
		localVarQueryParams.Add("name__ic", parameterToString(*r.nameIc, ""))
	}
	if r.nameNic != nil {
		localVarQueryParams.Add("name__nic", parameterToString(*r.nameNic, ""))
	}
	if r.nameIew != nil {
		localVarQueryParams.Add("name__iew", parameterToString(*r.nameIew, ""))
	}
	if r.nameNiew != nil {
		localVarQueryParams.Add("name__niew", parameterToString(*r.nameNiew, ""))
	}
	if r.nameIsw != nil {
		localVarQueryParams.Add("name__isw", parameterToString(*r.nameIsw, ""))
	}
	if r.nameNisw != nil {
		localVarQueryParams.Add("name__nisw", parameterToString(*r.nameNisw, ""))
	}
	if r.nameIe != nil {
		localVarQueryParams.Add("name__ie", parameterToString(*r.nameIe, ""))
	}
	if r.nameNie != nil {
		localVarQueryParams.Add("name__nie", parameterToString(*r.nameNie, ""))
	}
	if r.nameEmpty != nil {
		localVarQueryParams.Add("name__empty", parameterToString(*r.nameEmpty, ""))
	}
	if r.labelN != nil {
		localVarQueryParams.Add("label__n", parameterToString(*r.labelN, ""))
	}
	if r.labelIc != nil {
		localVarQueryParams.Add("label__ic", parameterToString(*r.labelIc, ""))
	}
	if r.labelNic != nil {
		localVarQueryParams.Add("label__nic", parameterToString(*r.labelNic, ""))
	}
	if r.labelIew != nil {
		localVarQueryParams.Add("label__iew", parameterToString(*r.labelIew, ""))
	}
	if r.labelNiew != nil {
		localVarQueryParams.Add("label__niew", parameterToString(*r.labelNiew, ""))
	}
	if r.labelIsw != nil {
		localVarQueryParams.Add("label__isw", parameterToString(*r.labelIsw, ""))
	}
	if r.labelNisw != nil {
		localVarQueryParams.Add("label__nisw", parameterToString(*r.labelNisw, ""))
	}
	if r.labelIe != nil {
		localVarQueryParams.Add("label__ie", parameterToString(*r.labelIe, ""))
	}
	if r.labelNie != nil {
		localVarQueryParams.Add("label__nie", parameterToString(*r.labelNie, ""))
	}
	if r.labelEmpty != nil {
		localVarQueryParams.Add("label__empty", parameterToString(*r.labelEmpty, ""))
	}
	if r.partIdN != nil {
		localVarQueryParams.Add("part_id__n", parameterToString(*r.partIdN, ""))
	}
	if r.partIdIc != nil {
		localVarQueryParams.Add("part_id__ic", parameterToString(*r.partIdIc, ""))
	}
	if r.partIdNic != nil {
		localVarQueryParams.Add("part_id__nic", parameterToString(*r.partIdNic, ""))
	}
	if r.partIdIew != nil {
		localVarQueryParams.Add("part_id__iew", parameterToString(*r.partIdIew, ""))
	}
	if r.partIdNiew != nil {
		localVarQueryParams.Add("part_id__niew", parameterToString(*r.partIdNiew, ""))
	}
	if r.partIdIsw != nil {
		localVarQueryParams.Add("part_id__isw", parameterToString(*r.partIdIsw, ""))
	}
	if r.partIdNisw != nil {
		localVarQueryParams.Add("part_id__nisw", parameterToString(*r.partIdNisw, ""))
	}
	if r.partIdIe != nil {
		localVarQueryParams.Add("part_id__ie", parameterToString(*r.partIdIe, ""))
	}
	if r.partIdNie != nil {
		localVarQueryParams.Add("part_id__nie", parameterToString(*r.partIdNie, ""))
	}
	if r.partIdEmpty != nil {
		localVarQueryParams.Add("part_id__empty", parameterToString(*r.partIdEmpty, ""))
	}
	if r.assetTagN != nil {
		localVarQueryParams.Add("asset_tag__n", parameterToString(*r.assetTagN, ""))
	}
	if r.assetTagIc != nil {
		localVarQueryParams.Add("asset_tag__ic", parameterToString(*r.assetTagIc, ""))
	}
	if r.assetTagNic != nil {
		localVarQueryParams.Add("asset_tag__nic", parameterToString(*r.assetTagNic, ""))
	}
	if r.assetTagIew != nil {
		localVarQueryParams.Add("asset_tag__iew", parameterToString(*r.assetTagIew, ""))
	}
	if r.assetTagNiew != nil {
		localVarQueryParams.Add("asset_tag__niew", parameterToString(*r.assetTagNiew, ""))
	}
	if r.assetTagIsw != nil {
		localVarQueryParams.Add("asset_tag__isw", parameterToString(*r.assetTagIsw, ""))
	}
	if r.assetTagNisw != nil {
		localVarQueryParams.Add("asset_tag__nisw", parameterToString(*r.assetTagNisw, ""))
	}
	if r.assetTagIe != nil {
		localVarQueryParams.Add("asset_tag__ie", parameterToString(*r.assetTagIe, ""))
	}
	if r.assetTagNie != nil {
		localVarQueryParams.Add("asset_tag__nie", parameterToString(*r.assetTagNie, ""))
	}
	if r.assetTagEmpty != nil {
		localVarQueryParams.Add("asset_tag__empty", parameterToString(*r.assetTagEmpty, ""))
	}
	if r.regionIdN != nil {
		localVarQueryParams.Add("region_id__n", parameterToString(*r.regionIdN, ""))
	}
	if r.regionN != nil {
		localVarQueryParams.Add("region__n", parameterToString(*r.regionN, ""))
	}
	if r.siteGroupIdN != nil {
		localVarQueryParams.Add("site_group_id__n", parameterToString(*r.siteGroupIdN, ""))
	}
	if r.siteGroupN != nil {
		localVarQueryParams.Add("site_group__n", parameterToString(*r.siteGroupN, ""))
	}
	if r.siteIdN != nil {
		localVarQueryParams.Add("site_id__n", parameterToString(*r.siteIdN, ""))
	}
	if r.siteN != nil {
		localVarQueryParams.Add("site__n", parameterToString(*r.siteN, ""))
	}
	if r.deviceIdN != nil {
		localVarQueryParams.Add("device_id__n", parameterToString(*r.deviceIdN, ""))
	}
	if r.deviceN != nil {
		localVarQueryParams.Add("device__n", parameterToString(*r.deviceN, ""))
	}
	if r.tagN != nil {
		localVarQueryParams.Add("tag__n", parameterToString(*r.tagN, ""))
	}
	if r.parentIdN != nil {
		localVarQueryParams.Add("parent_id__n", parameterToString(*r.parentIdN, ""))
	}
	if r.manufacturerIdN != nil {
		localVarQueryParams.Add("manufacturer_id__n", parameterToString(*r.manufacturerIdN, ""))
	}
	if r.manufacturerN != nil {
		localVarQueryParams.Add("manufacturer__n", parameterToString(*r.manufacturerN, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimInventoryItemsPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
	data *WritableInventoryItem
}

func (r ApiDcimInventoryItemsPartialUpdateRequest) Data(data WritableInventoryItem) ApiDcimInventoryItemsPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimInventoryItemsPartialUpdateRequest) Execute() (*InventoryItem, *http.Response, error) {
	return r.ApiService.DcimInventoryItemsPartialUpdateExecute(r)
}

/*
DcimInventoryItemsPartialUpdate Method for DcimInventoryItemsPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this inventory item.
 @return ApiDcimInventoryItemsPartialUpdateRequest
*/
func (a *DcimApiService) DcimInventoryItemsPartialUpdate(ctx context.Context, id int32) ApiDcimInventoryItemsPartialUpdateRequest {
	return ApiDcimInventoryItemsPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return InventoryItem
func (a *DcimApiService) DcimInventoryItemsPartialUpdateExecute(r ApiDcimInventoryItemsPartialUpdateRequest) (*InventoryItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InventoryItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimInventoryItemsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/inventory-items/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimInventoryItemsReadRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
}

func (r ApiDcimInventoryItemsReadRequest) Execute() (*InventoryItem, *http.Response, error) {
	return r.ApiService.DcimInventoryItemsReadExecute(r)
}

/*
DcimInventoryItemsRead Method for DcimInventoryItemsRead

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this inventory item.
 @return ApiDcimInventoryItemsReadRequest
*/
func (a *DcimApiService) DcimInventoryItemsRead(ctx context.Context, id int32) ApiDcimInventoryItemsReadRequest {
	return ApiDcimInventoryItemsReadRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return InventoryItem
func (a *DcimApiService) DcimInventoryItemsReadExecute(r ApiDcimInventoryItemsReadRequest) (*InventoryItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InventoryItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimInventoryItemsRead")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/inventory-items/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimInventoryItemsUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
	data *WritableInventoryItem
}

func (r ApiDcimInventoryItemsUpdateRequest) Data(data WritableInventoryItem) ApiDcimInventoryItemsUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimInventoryItemsUpdateRequest) Execute() (*InventoryItem, *http.Response, error) {
	return r.ApiService.DcimInventoryItemsUpdateExecute(r)
}

/*
DcimInventoryItemsUpdate Method for DcimInventoryItemsUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this inventory item.
 @return ApiDcimInventoryItemsUpdateRequest
*/
func (a *DcimApiService) DcimInventoryItemsUpdate(ctx context.Context, id int32) ApiDcimInventoryItemsUpdateRequest {
	return ApiDcimInventoryItemsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return InventoryItem
func (a *DcimApiService) DcimInventoryItemsUpdateExecute(r ApiDcimInventoryItemsUpdateRequest) (*InventoryItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InventoryItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimInventoryItemsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/inventory-items/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimLocationsBulkDeleteRequest struct {
	ctx context.Context
	ApiService *DcimApiService
}

func (r ApiDcimLocationsBulkDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimLocationsBulkDeleteExecute(r)
}

/*
DcimLocationsBulkDelete Method for DcimLocationsBulkDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimLocationsBulkDeleteRequest
*/
func (a *DcimApiService) DcimLocationsBulkDelete(ctx context.Context) ApiDcimLocationsBulkDeleteRequest {
	return ApiDcimLocationsBulkDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DcimApiService) DcimLocationsBulkDeleteExecute(r ApiDcimLocationsBulkDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimLocationsBulkDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/locations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimLocationsBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	data *WritableLocation
}

func (r ApiDcimLocationsBulkPartialUpdateRequest) Data(data WritableLocation) ApiDcimLocationsBulkPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimLocationsBulkPartialUpdateRequest) Execute() (*Location, *http.Response, error) {
	return r.ApiService.DcimLocationsBulkPartialUpdateExecute(r)
}

/*
DcimLocationsBulkPartialUpdate Method for DcimLocationsBulkPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimLocationsBulkPartialUpdateRequest
*/
func (a *DcimApiService) DcimLocationsBulkPartialUpdate(ctx context.Context) ApiDcimLocationsBulkPartialUpdateRequest {
	return ApiDcimLocationsBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Location
func (a *DcimApiService) DcimLocationsBulkPartialUpdateExecute(r ApiDcimLocationsBulkPartialUpdateRequest) (*Location, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Location
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimLocationsBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/locations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimLocationsBulkUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	data *WritableLocation
}

func (r ApiDcimLocationsBulkUpdateRequest) Data(data WritableLocation) ApiDcimLocationsBulkUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimLocationsBulkUpdateRequest) Execute() (*Location, *http.Response, error) {
	return r.ApiService.DcimLocationsBulkUpdateExecute(r)
}

/*
DcimLocationsBulkUpdate Method for DcimLocationsBulkUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimLocationsBulkUpdateRequest
*/
func (a *DcimApiService) DcimLocationsBulkUpdate(ctx context.Context) ApiDcimLocationsBulkUpdateRequest {
	return ApiDcimLocationsBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Location
func (a *DcimApiService) DcimLocationsBulkUpdateExecute(r ApiDcimLocationsBulkUpdateRequest) (*Location, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Location
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimLocationsBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/locations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimLocationsCreateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	data *WritableLocation
}

func (r ApiDcimLocationsCreateRequest) Data(data WritableLocation) ApiDcimLocationsCreateRequest {
	r.data = &data
	return r
}

func (r ApiDcimLocationsCreateRequest) Execute() (*Location, *http.Response, error) {
	return r.ApiService.DcimLocationsCreateExecute(r)
}

/*
DcimLocationsCreate Method for DcimLocationsCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimLocationsCreateRequest
*/
func (a *DcimApiService) DcimLocationsCreate(ctx context.Context) ApiDcimLocationsCreateRequest {
	return ApiDcimLocationsCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Location
func (a *DcimApiService) DcimLocationsCreateExecute(r ApiDcimLocationsCreateRequest) (*Location, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Location
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimLocationsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/locations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimLocationsDeleteRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
}

func (r ApiDcimLocationsDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimLocationsDeleteExecute(r)
}

/*
DcimLocationsDelete Method for DcimLocationsDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this location.
 @return ApiDcimLocationsDeleteRequest
*/
func (a *DcimApiService) DcimLocationsDelete(ctx context.Context, id int32) ApiDcimLocationsDeleteRequest {
	return ApiDcimLocationsDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DcimApiService) DcimLocationsDeleteExecute(r ApiDcimLocationsDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimLocationsDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/locations/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimLocationsListRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id *string
	name *string
	slug *string
	description *string
	created *string
	createdGte *string
	createdLte *string
	lastUpdated *string
	lastUpdatedGte *string
	lastUpdatedLte *string
	q *string
	regionId *string
	region *string
	siteGroupId *string
	siteGroup *string
	siteId *string
	site *string
	parentId *string
	parent *string
	idN *string
	idLte *string
	idLt *string
	idGte *string
	idGt *string
	nameN *string
	nameIc *string
	nameNic *string
	nameIew *string
	nameNiew *string
	nameIsw *string
	nameNisw *string
	nameIe *string
	nameNie *string
	nameEmpty *string
	slugN *string
	slugIc *string
	slugNic *string
	slugIew *string
	slugNiew *string
	slugIsw *string
	slugNisw *string
	slugIe *string
	slugNie *string
	slugEmpty *string
	descriptionN *string
	descriptionIc *string
	descriptionNic *string
	descriptionIew *string
	descriptionNiew *string
	descriptionIsw *string
	descriptionNisw *string
	descriptionIe *string
	descriptionNie *string
	descriptionEmpty *string
	regionIdN *string
	regionN *string
	siteGroupIdN *string
	siteGroupN *string
	siteIdN *string
	siteN *string
	parentIdN *string
	parentN *string
	limit *int32
	offset *int32
}

func (r ApiDcimLocationsListRequest) Id(id string) ApiDcimLocationsListRequest {
	r.id = &id
	return r
}

func (r ApiDcimLocationsListRequest) Name(name string) ApiDcimLocationsListRequest {
	r.name = &name
	return r
}

func (r ApiDcimLocationsListRequest) Slug(slug string) ApiDcimLocationsListRequest {
	r.slug = &slug
	return r
}

func (r ApiDcimLocationsListRequest) Description(description string) ApiDcimLocationsListRequest {
	r.description = &description
	return r
}

func (r ApiDcimLocationsListRequest) Created(created string) ApiDcimLocationsListRequest {
	r.created = &created
	return r
}

func (r ApiDcimLocationsListRequest) CreatedGte(createdGte string) ApiDcimLocationsListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiDcimLocationsListRequest) CreatedLte(createdLte string) ApiDcimLocationsListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiDcimLocationsListRequest) LastUpdated(lastUpdated string) ApiDcimLocationsListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiDcimLocationsListRequest) LastUpdatedGte(lastUpdatedGte string) ApiDcimLocationsListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiDcimLocationsListRequest) LastUpdatedLte(lastUpdatedLte string) ApiDcimLocationsListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiDcimLocationsListRequest) Q(q string) ApiDcimLocationsListRequest {
	r.q = &q
	return r
}

func (r ApiDcimLocationsListRequest) RegionId(regionId string) ApiDcimLocationsListRequest {
	r.regionId = &regionId
	return r
}

func (r ApiDcimLocationsListRequest) Region(region string) ApiDcimLocationsListRequest {
	r.region = &region
	return r
}

func (r ApiDcimLocationsListRequest) SiteGroupId(siteGroupId string) ApiDcimLocationsListRequest {
	r.siteGroupId = &siteGroupId
	return r
}

func (r ApiDcimLocationsListRequest) SiteGroup(siteGroup string) ApiDcimLocationsListRequest {
	r.siteGroup = &siteGroup
	return r
}

func (r ApiDcimLocationsListRequest) SiteId(siteId string) ApiDcimLocationsListRequest {
	r.siteId = &siteId
	return r
}

func (r ApiDcimLocationsListRequest) Site(site string) ApiDcimLocationsListRequest {
	r.site = &site
	return r
}

func (r ApiDcimLocationsListRequest) ParentId(parentId string) ApiDcimLocationsListRequest {
	r.parentId = &parentId
	return r
}

func (r ApiDcimLocationsListRequest) Parent(parent string) ApiDcimLocationsListRequest {
	r.parent = &parent
	return r
}

func (r ApiDcimLocationsListRequest) IdN(idN string) ApiDcimLocationsListRequest {
	r.idN = &idN
	return r
}

func (r ApiDcimLocationsListRequest) IdLte(idLte string) ApiDcimLocationsListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiDcimLocationsListRequest) IdLt(idLt string) ApiDcimLocationsListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiDcimLocationsListRequest) IdGte(idGte string) ApiDcimLocationsListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiDcimLocationsListRequest) IdGt(idGt string) ApiDcimLocationsListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiDcimLocationsListRequest) NameN(nameN string) ApiDcimLocationsListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiDcimLocationsListRequest) NameIc(nameIc string) ApiDcimLocationsListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiDcimLocationsListRequest) NameNic(nameNic string) ApiDcimLocationsListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiDcimLocationsListRequest) NameIew(nameIew string) ApiDcimLocationsListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiDcimLocationsListRequest) NameNiew(nameNiew string) ApiDcimLocationsListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiDcimLocationsListRequest) NameIsw(nameIsw string) ApiDcimLocationsListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiDcimLocationsListRequest) NameNisw(nameNisw string) ApiDcimLocationsListRequest {
	r.nameNisw = &nameNisw
	return r
}

func (r ApiDcimLocationsListRequest) NameIe(nameIe string) ApiDcimLocationsListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiDcimLocationsListRequest) NameNie(nameNie string) ApiDcimLocationsListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiDcimLocationsListRequest) NameEmpty(nameEmpty string) ApiDcimLocationsListRequest {
	r.nameEmpty = &nameEmpty
	return r
}

func (r ApiDcimLocationsListRequest) SlugN(slugN string) ApiDcimLocationsListRequest {
	r.slugN = &slugN
	return r
}

func (r ApiDcimLocationsListRequest) SlugIc(slugIc string) ApiDcimLocationsListRequest {
	r.slugIc = &slugIc
	return r
}

func (r ApiDcimLocationsListRequest) SlugNic(slugNic string) ApiDcimLocationsListRequest {
	r.slugNic = &slugNic
	return r
}

func (r ApiDcimLocationsListRequest) SlugIew(slugIew string) ApiDcimLocationsListRequest {
	r.slugIew = &slugIew
	return r
}

func (r ApiDcimLocationsListRequest) SlugNiew(slugNiew string) ApiDcimLocationsListRequest {
	r.slugNiew = &slugNiew
	return r
}

func (r ApiDcimLocationsListRequest) SlugIsw(slugIsw string) ApiDcimLocationsListRequest {
	r.slugIsw = &slugIsw
	return r
}

func (r ApiDcimLocationsListRequest) SlugNisw(slugNisw string) ApiDcimLocationsListRequest {
	r.slugNisw = &slugNisw
	return r
}

func (r ApiDcimLocationsListRequest) SlugIe(slugIe string) ApiDcimLocationsListRequest {
	r.slugIe = &slugIe
	return r
}

func (r ApiDcimLocationsListRequest) SlugNie(slugNie string) ApiDcimLocationsListRequest {
	r.slugNie = &slugNie
	return r
}

func (r ApiDcimLocationsListRequest) SlugEmpty(slugEmpty string) ApiDcimLocationsListRequest {
	r.slugEmpty = &slugEmpty
	return r
}

func (r ApiDcimLocationsListRequest) DescriptionN(descriptionN string) ApiDcimLocationsListRequest {
	r.descriptionN = &descriptionN
	return r
}

func (r ApiDcimLocationsListRequest) DescriptionIc(descriptionIc string) ApiDcimLocationsListRequest {
	r.descriptionIc = &descriptionIc
	return r
}

func (r ApiDcimLocationsListRequest) DescriptionNic(descriptionNic string) ApiDcimLocationsListRequest {
	r.descriptionNic = &descriptionNic
	return r
}

func (r ApiDcimLocationsListRequest) DescriptionIew(descriptionIew string) ApiDcimLocationsListRequest {
	r.descriptionIew = &descriptionIew
	return r
}

func (r ApiDcimLocationsListRequest) DescriptionNiew(descriptionNiew string) ApiDcimLocationsListRequest {
	r.descriptionNiew = &descriptionNiew
	return r
}

func (r ApiDcimLocationsListRequest) DescriptionIsw(descriptionIsw string) ApiDcimLocationsListRequest {
	r.descriptionIsw = &descriptionIsw
	return r
}

func (r ApiDcimLocationsListRequest) DescriptionNisw(descriptionNisw string) ApiDcimLocationsListRequest {
	r.descriptionNisw = &descriptionNisw
	return r
}

func (r ApiDcimLocationsListRequest) DescriptionIe(descriptionIe string) ApiDcimLocationsListRequest {
	r.descriptionIe = &descriptionIe
	return r
}

func (r ApiDcimLocationsListRequest) DescriptionNie(descriptionNie string) ApiDcimLocationsListRequest {
	r.descriptionNie = &descriptionNie
	return r
}

func (r ApiDcimLocationsListRequest) DescriptionEmpty(descriptionEmpty string) ApiDcimLocationsListRequest {
	r.descriptionEmpty = &descriptionEmpty
	return r
}

func (r ApiDcimLocationsListRequest) RegionIdN(regionIdN string) ApiDcimLocationsListRequest {
	r.regionIdN = &regionIdN
	return r
}

func (r ApiDcimLocationsListRequest) RegionN(regionN string) ApiDcimLocationsListRequest {
	r.regionN = &regionN
	return r
}

func (r ApiDcimLocationsListRequest) SiteGroupIdN(siteGroupIdN string) ApiDcimLocationsListRequest {
	r.siteGroupIdN = &siteGroupIdN
	return r
}

func (r ApiDcimLocationsListRequest) SiteGroupN(siteGroupN string) ApiDcimLocationsListRequest {
	r.siteGroupN = &siteGroupN
	return r
}

func (r ApiDcimLocationsListRequest) SiteIdN(siteIdN string) ApiDcimLocationsListRequest {
	r.siteIdN = &siteIdN
	return r
}

func (r ApiDcimLocationsListRequest) SiteN(siteN string) ApiDcimLocationsListRequest {
	r.siteN = &siteN
	return r
}

func (r ApiDcimLocationsListRequest) ParentIdN(parentIdN string) ApiDcimLocationsListRequest {
	r.parentIdN = &parentIdN
	return r
}

func (r ApiDcimLocationsListRequest) ParentN(parentN string) ApiDcimLocationsListRequest {
	r.parentN = &parentN
	return r
}

// Number of results to return per page.
func (r ApiDcimLocationsListRequest) Limit(limit int32) ApiDcimLocationsListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiDcimLocationsListRequest) Offset(offset int32) ApiDcimLocationsListRequest {
	r.offset = &offset
	return r
}

func (r ApiDcimLocationsListRequest) Execute() (*DcimLocationsList200Response, *http.Response, error) {
	return r.ApiService.DcimLocationsListExecute(r)
}

/*
DcimLocationsList Method for DcimLocationsList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimLocationsListRequest
*/
func (a *DcimApiService) DcimLocationsList(ctx context.Context) ApiDcimLocationsListRequest {
	return ApiDcimLocationsListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DcimLocationsList200Response
func (a *DcimApiService) DcimLocationsListExecute(r ApiDcimLocationsListRequest) (*DcimLocationsList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DcimLocationsList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimLocationsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/locations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.slug != nil {
		localVarQueryParams.Add("slug", parameterToString(*r.slug, ""))
	}
	if r.description != nil {
		localVarQueryParams.Add("description", parameterToString(*r.description, ""))
	}
	if r.created != nil {
		localVarQueryParams.Add("created", parameterToString(*r.created, ""))
	}
	if r.createdGte != nil {
		localVarQueryParams.Add("created__gte", parameterToString(*r.createdGte, ""))
	}
	if r.createdLte != nil {
		localVarQueryParams.Add("created__lte", parameterToString(*r.createdLte, ""))
	}
	if r.lastUpdated != nil {
		localVarQueryParams.Add("last_updated", parameterToString(*r.lastUpdated, ""))
	}
	if r.lastUpdatedGte != nil {
		localVarQueryParams.Add("last_updated__gte", parameterToString(*r.lastUpdatedGte, ""))
	}
	if r.lastUpdatedLte != nil {
		localVarQueryParams.Add("last_updated__lte", parameterToString(*r.lastUpdatedLte, ""))
	}
	if r.q != nil {
		localVarQueryParams.Add("q", parameterToString(*r.q, ""))
	}
	if r.regionId != nil {
		localVarQueryParams.Add("region_id", parameterToString(*r.regionId, ""))
	}
	if r.region != nil {
		localVarQueryParams.Add("region", parameterToString(*r.region, ""))
	}
	if r.siteGroupId != nil {
		localVarQueryParams.Add("site_group_id", parameterToString(*r.siteGroupId, ""))
	}
	if r.siteGroup != nil {
		localVarQueryParams.Add("site_group", parameterToString(*r.siteGroup, ""))
	}
	if r.siteId != nil {
		localVarQueryParams.Add("site_id", parameterToString(*r.siteId, ""))
	}
	if r.site != nil {
		localVarQueryParams.Add("site", parameterToString(*r.site, ""))
	}
	if r.parentId != nil {
		localVarQueryParams.Add("parent_id", parameterToString(*r.parentId, ""))
	}
	if r.parent != nil {
		localVarQueryParams.Add("parent", parameterToString(*r.parent, ""))
	}
	if r.idN != nil {
		localVarQueryParams.Add("id__n", parameterToString(*r.idN, ""))
	}
	if r.idLte != nil {
		localVarQueryParams.Add("id__lte", parameterToString(*r.idLte, ""))
	}
	if r.idLt != nil {
		localVarQueryParams.Add("id__lt", parameterToString(*r.idLt, ""))
	}
	if r.idGte != nil {
		localVarQueryParams.Add("id__gte", parameterToString(*r.idGte, ""))
	}
	if r.idGt != nil {
		localVarQueryParams.Add("id__gt", parameterToString(*r.idGt, ""))
	}
	if r.nameN != nil {
		localVarQueryParams.Add("name__n", parameterToString(*r.nameN, ""))
	}
	if r.nameIc != nil {
		localVarQueryParams.Add("name__ic", parameterToString(*r.nameIc, ""))
	}
	if r.nameNic != nil {
		localVarQueryParams.Add("name__nic", parameterToString(*r.nameNic, ""))
	}
	if r.nameIew != nil {
		localVarQueryParams.Add("name__iew", parameterToString(*r.nameIew, ""))
	}
	if r.nameNiew != nil {
		localVarQueryParams.Add("name__niew", parameterToString(*r.nameNiew, ""))
	}
	if r.nameIsw != nil {
		localVarQueryParams.Add("name__isw", parameterToString(*r.nameIsw, ""))
	}
	if r.nameNisw != nil {
		localVarQueryParams.Add("name__nisw", parameterToString(*r.nameNisw, ""))
	}
	if r.nameIe != nil {
		localVarQueryParams.Add("name__ie", parameterToString(*r.nameIe, ""))
	}
	if r.nameNie != nil {
		localVarQueryParams.Add("name__nie", parameterToString(*r.nameNie, ""))
	}
	if r.nameEmpty != nil {
		localVarQueryParams.Add("name__empty", parameterToString(*r.nameEmpty, ""))
	}
	if r.slugN != nil {
		localVarQueryParams.Add("slug__n", parameterToString(*r.slugN, ""))
	}
	if r.slugIc != nil {
		localVarQueryParams.Add("slug__ic", parameterToString(*r.slugIc, ""))
	}
	if r.slugNic != nil {
		localVarQueryParams.Add("slug__nic", parameterToString(*r.slugNic, ""))
	}
	if r.slugIew != nil {
		localVarQueryParams.Add("slug__iew", parameterToString(*r.slugIew, ""))
	}
	if r.slugNiew != nil {
		localVarQueryParams.Add("slug__niew", parameterToString(*r.slugNiew, ""))
	}
	if r.slugIsw != nil {
		localVarQueryParams.Add("slug__isw", parameterToString(*r.slugIsw, ""))
	}
	if r.slugNisw != nil {
		localVarQueryParams.Add("slug__nisw", parameterToString(*r.slugNisw, ""))
	}
	if r.slugIe != nil {
		localVarQueryParams.Add("slug__ie", parameterToString(*r.slugIe, ""))
	}
	if r.slugNie != nil {
		localVarQueryParams.Add("slug__nie", parameterToString(*r.slugNie, ""))
	}
	if r.slugEmpty != nil {
		localVarQueryParams.Add("slug__empty", parameterToString(*r.slugEmpty, ""))
	}
	if r.descriptionN != nil {
		localVarQueryParams.Add("description__n", parameterToString(*r.descriptionN, ""))
	}
	if r.descriptionIc != nil {
		localVarQueryParams.Add("description__ic", parameterToString(*r.descriptionIc, ""))
	}
	if r.descriptionNic != nil {
		localVarQueryParams.Add("description__nic", parameterToString(*r.descriptionNic, ""))
	}
	if r.descriptionIew != nil {
		localVarQueryParams.Add("description__iew", parameterToString(*r.descriptionIew, ""))
	}
	if r.descriptionNiew != nil {
		localVarQueryParams.Add("description__niew", parameterToString(*r.descriptionNiew, ""))
	}
	if r.descriptionIsw != nil {
		localVarQueryParams.Add("description__isw", parameterToString(*r.descriptionIsw, ""))
	}
	if r.descriptionNisw != nil {
		localVarQueryParams.Add("description__nisw", parameterToString(*r.descriptionNisw, ""))
	}
	if r.descriptionIe != nil {
		localVarQueryParams.Add("description__ie", parameterToString(*r.descriptionIe, ""))
	}
	if r.descriptionNie != nil {
		localVarQueryParams.Add("description__nie", parameterToString(*r.descriptionNie, ""))
	}
	if r.descriptionEmpty != nil {
		localVarQueryParams.Add("description__empty", parameterToString(*r.descriptionEmpty, ""))
	}
	if r.regionIdN != nil {
		localVarQueryParams.Add("region_id__n", parameterToString(*r.regionIdN, ""))
	}
	if r.regionN != nil {
		localVarQueryParams.Add("region__n", parameterToString(*r.regionN, ""))
	}
	if r.siteGroupIdN != nil {
		localVarQueryParams.Add("site_group_id__n", parameterToString(*r.siteGroupIdN, ""))
	}
	if r.siteGroupN != nil {
		localVarQueryParams.Add("site_group__n", parameterToString(*r.siteGroupN, ""))
	}
	if r.siteIdN != nil {
		localVarQueryParams.Add("site_id__n", parameterToString(*r.siteIdN, ""))
	}
	if r.siteN != nil {
		localVarQueryParams.Add("site__n", parameterToString(*r.siteN, ""))
	}
	if r.parentIdN != nil {
		localVarQueryParams.Add("parent_id__n", parameterToString(*r.parentIdN, ""))
	}
	if r.parentN != nil {
		localVarQueryParams.Add("parent__n", parameterToString(*r.parentN, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimLocationsPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
	data *WritableLocation
}

func (r ApiDcimLocationsPartialUpdateRequest) Data(data WritableLocation) ApiDcimLocationsPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimLocationsPartialUpdateRequest) Execute() (*Location, *http.Response, error) {
	return r.ApiService.DcimLocationsPartialUpdateExecute(r)
}

/*
DcimLocationsPartialUpdate Method for DcimLocationsPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this location.
 @return ApiDcimLocationsPartialUpdateRequest
*/
func (a *DcimApiService) DcimLocationsPartialUpdate(ctx context.Context, id int32) ApiDcimLocationsPartialUpdateRequest {
	return ApiDcimLocationsPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Location
func (a *DcimApiService) DcimLocationsPartialUpdateExecute(r ApiDcimLocationsPartialUpdateRequest) (*Location, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Location
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimLocationsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/locations/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimLocationsReadRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
}

func (r ApiDcimLocationsReadRequest) Execute() (*Location, *http.Response, error) {
	return r.ApiService.DcimLocationsReadExecute(r)
}

/*
DcimLocationsRead Method for DcimLocationsRead

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this location.
 @return ApiDcimLocationsReadRequest
*/
func (a *DcimApiService) DcimLocationsRead(ctx context.Context, id int32) ApiDcimLocationsReadRequest {
	return ApiDcimLocationsReadRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Location
func (a *DcimApiService) DcimLocationsReadExecute(r ApiDcimLocationsReadRequest) (*Location, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Location
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimLocationsRead")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/locations/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimLocationsUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
	data *WritableLocation
}

func (r ApiDcimLocationsUpdateRequest) Data(data WritableLocation) ApiDcimLocationsUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimLocationsUpdateRequest) Execute() (*Location, *http.Response, error) {
	return r.ApiService.DcimLocationsUpdateExecute(r)
}

/*
DcimLocationsUpdate Method for DcimLocationsUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this location.
 @return ApiDcimLocationsUpdateRequest
*/
func (a *DcimApiService) DcimLocationsUpdate(ctx context.Context, id int32) ApiDcimLocationsUpdateRequest {
	return ApiDcimLocationsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Location
func (a *DcimApiService) DcimLocationsUpdateExecute(r ApiDcimLocationsUpdateRequest) (*Location, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Location
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimLocationsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/locations/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimManufacturersBulkDeleteRequest struct {
	ctx context.Context
	ApiService *DcimApiService
}

func (r ApiDcimManufacturersBulkDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimManufacturersBulkDeleteExecute(r)
}

/*
DcimManufacturersBulkDelete Method for DcimManufacturersBulkDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimManufacturersBulkDeleteRequest
*/
func (a *DcimApiService) DcimManufacturersBulkDelete(ctx context.Context) ApiDcimManufacturersBulkDeleteRequest {
	return ApiDcimManufacturersBulkDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DcimApiService) DcimManufacturersBulkDeleteExecute(r ApiDcimManufacturersBulkDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimManufacturersBulkDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/manufacturers/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimManufacturersBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	data *Manufacturer
}

func (r ApiDcimManufacturersBulkPartialUpdateRequest) Data(data Manufacturer) ApiDcimManufacturersBulkPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimManufacturersBulkPartialUpdateRequest) Execute() (*Manufacturer, *http.Response, error) {
	return r.ApiService.DcimManufacturersBulkPartialUpdateExecute(r)
}

/*
DcimManufacturersBulkPartialUpdate Method for DcimManufacturersBulkPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimManufacturersBulkPartialUpdateRequest
*/
func (a *DcimApiService) DcimManufacturersBulkPartialUpdate(ctx context.Context) ApiDcimManufacturersBulkPartialUpdateRequest {
	return ApiDcimManufacturersBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Manufacturer
func (a *DcimApiService) DcimManufacturersBulkPartialUpdateExecute(r ApiDcimManufacturersBulkPartialUpdateRequest) (*Manufacturer, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Manufacturer
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimManufacturersBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/manufacturers/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimManufacturersBulkUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	data *Manufacturer
}

func (r ApiDcimManufacturersBulkUpdateRequest) Data(data Manufacturer) ApiDcimManufacturersBulkUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimManufacturersBulkUpdateRequest) Execute() (*Manufacturer, *http.Response, error) {
	return r.ApiService.DcimManufacturersBulkUpdateExecute(r)
}

/*
DcimManufacturersBulkUpdate Method for DcimManufacturersBulkUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimManufacturersBulkUpdateRequest
*/
func (a *DcimApiService) DcimManufacturersBulkUpdate(ctx context.Context) ApiDcimManufacturersBulkUpdateRequest {
	return ApiDcimManufacturersBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Manufacturer
func (a *DcimApiService) DcimManufacturersBulkUpdateExecute(r ApiDcimManufacturersBulkUpdateRequest) (*Manufacturer, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Manufacturer
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimManufacturersBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/manufacturers/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimManufacturersCreateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	data *Manufacturer
}

func (r ApiDcimManufacturersCreateRequest) Data(data Manufacturer) ApiDcimManufacturersCreateRequest {
	r.data = &data
	return r
}

func (r ApiDcimManufacturersCreateRequest) Execute() (*Manufacturer, *http.Response, error) {
	return r.ApiService.DcimManufacturersCreateExecute(r)
}

/*
DcimManufacturersCreate Method for DcimManufacturersCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimManufacturersCreateRequest
*/
func (a *DcimApiService) DcimManufacturersCreate(ctx context.Context) ApiDcimManufacturersCreateRequest {
	return ApiDcimManufacturersCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Manufacturer
func (a *DcimApiService) DcimManufacturersCreateExecute(r ApiDcimManufacturersCreateRequest) (*Manufacturer, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Manufacturer
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimManufacturersCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/manufacturers/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimManufacturersDeleteRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
}

func (r ApiDcimManufacturersDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimManufacturersDeleteExecute(r)
}

/*
DcimManufacturersDelete Method for DcimManufacturersDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this manufacturer.
 @return ApiDcimManufacturersDeleteRequest
*/
func (a *DcimApiService) DcimManufacturersDelete(ctx context.Context, id int32) ApiDcimManufacturersDeleteRequest {
	return ApiDcimManufacturersDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DcimApiService) DcimManufacturersDeleteExecute(r ApiDcimManufacturersDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimManufacturersDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/manufacturers/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimManufacturersListRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id *string
	name *string
	slug *string
	description *string
	created *string
	createdGte *string
	createdLte *string
	lastUpdated *string
	lastUpdatedGte *string
	lastUpdatedLte *string
	q *string
	idN *string
	idLte *string
	idLt *string
	idGte *string
	idGt *string
	nameN *string
	nameIc *string
	nameNic *string
	nameIew *string
	nameNiew *string
	nameIsw *string
	nameNisw *string
	nameIe *string
	nameNie *string
	nameEmpty *string
	slugN *string
	slugIc *string
	slugNic *string
	slugIew *string
	slugNiew *string
	slugIsw *string
	slugNisw *string
	slugIe *string
	slugNie *string
	slugEmpty *string
	descriptionN *string
	descriptionIc *string
	descriptionNic *string
	descriptionIew *string
	descriptionNiew *string
	descriptionIsw *string
	descriptionNisw *string
	descriptionIe *string
	descriptionNie *string
	descriptionEmpty *string
	limit *int32
	offset *int32
}

func (r ApiDcimManufacturersListRequest) Id(id string) ApiDcimManufacturersListRequest {
	r.id = &id
	return r
}

func (r ApiDcimManufacturersListRequest) Name(name string) ApiDcimManufacturersListRequest {
	r.name = &name
	return r
}

func (r ApiDcimManufacturersListRequest) Slug(slug string) ApiDcimManufacturersListRequest {
	r.slug = &slug
	return r
}

func (r ApiDcimManufacturersListRequest) Description(description string) ApiDcimManufacturersListRequest {
	r.description = &description
	return r
}

func (r ApiDcimManufacturersListRequest) Created(created string) ApiDcimManufacturersListRequest {
	r.created = &created
	return r
}

func (r ApiDcimManufacturersListRequest) CreatedGte(createdGte string) ApiDcimManufacturersListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiDcimManufacturersListRequest) CreatedLte(createdLte string) ApiDcimManufacturersListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiDcimManufacturersListRequest) LastUpdated(lastUpdated string) ApiDcimManufacturersListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiDcimManufacturersListRequest) LastUpdatedGte(lastUpdatedGte string) ApiDcimManufacturersListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiDcimManufacturersListRequest) LastUpdatedLte(lastUpdatedLte string) ApiDcimManufacturersListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiDcimManufacturersListRequest) Q(q string) ApiDcimManufacturersListRequest {
	r.q = &q
	return r
}

func (r ApiDcimManufacturersListRequest) IdN(idN string) ApiDcimManufacturersListRequest {
	r.idN = &idN
	return r
}

func (r ApiDcimManufacturersListRequest) IdLte(idLte string) ApiDcimManufacturersListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiDcimManufacturersListRequest) IdLt(idLt string) ApiDcimManufacturersListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiDcimManufacturersListRequest) IdGte(idGte string) ApiDcimManufacturersListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiDcimManufacturersListRequest) IdGt(idGt string) ApiDcimManufacturersListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiDcimManufacturersListRequest) NameN(nameN string) ApiDcimManufacturersListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiDcimManufacturersListRequest) NameIc(nameIc string) ApiDcimManufacturersListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiDcimManufacturersListRequest) NameNic(nameNic string) ApiDcimManufacturersListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiDcimManufacturersListRequest) NameIew(nameIew string) ApiDcimManufacturersListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiDcimManufacturersListRequest) NameNiew(nameNiew string) ApiDcimManufacturersListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiDcimManufacturersListRequest) NameIsw(nameIsw string) ApiDcimManufacturersListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiDcimManufacturersListRequest) NameNisw(nameNisw string) ApiDcimManufacturersListRequest {
	r.nameNisw = &nameNisw
	return r
}

func (r ApiDcimManufacturersListRequest) NameIe(nameIe string) ApiDcimManufacturersListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiDcimManufacturersListRequest) NameNie(nameNie string) ApiDcimManufacturersListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiDcimManufacturersListRequest) NameEmpty(nameEmpty string) ApiDcimManufacturersListRequest {
	r.nameEmpty = &nameEmpty
	return r
}

func (r ApiDcimManufacturersListRequest) SlugN(slugN string) ApiDcimManufacturersListRequest {
	r.slugN = &slugN
	return r
}

func (r ApiDcimManufacturersListRequest) SlugIc(slugIc string) ApiDcimManufacturersListRequest {
	r.slugIc = &slugIc
	return r
}

func (r ApiDcimManufacturersListRequest) SlugNic(slugNic string) ApiDcimManufacturersListRequest {
	r.slugNic = &slugNic
	return r
}

func (r ApiDcimManufacturersListRequest) SlugIew(slugIew string) ApiDcimManufacturersListRequest {
	r.slugIew = &slugIew
	return r
}

func (r ApiDcimManufacturersListRequest) SlugNiew(slugNiew string) ApiDcimManufacturersListRequest {
	r.slugNiew = &slugNiew
	return r
}

func (r ApiDcimManufacturersListRequest) SlugIsw(slugIsw string) ApiDcimManufacturersListRequest {
	r.slugIsw = &slugIsw
	return r
}

func (r ApiDcimManufacturersListRequest) SlugNisw(slugNisw string) ApiDcimManufacturersListRequest {
	r.slugNisw = &slugNisw
	return r
}

func (r ApiDcimManufacturersListRequest) SlugIe(slugIe string) ApiDcimManufacturersListRequest {
	r.slugIe = &slugIe
	return r
}

func (r ApiDcimManufacturersListRequest) SlugNie(slugNie string) ApiDcimManufacturersListRequest {
	r.slugNie = &slugNie
	return r
}

func (r ApiDcimManufacturersListRequest) SlugEmpty(slugEmpty string) ApiDcimManufacturersListRequest {
	r.slugEmpty = &slugEmpty
	return r
}

func (r ApiDcimManufacturersListRequest) DescriptionN(descriptionN string) ApiDcimManufacturersListRequest {
	r.descriptionN = &descriptionN
	return r
}

func (r ApiDcimManufacturersListRequest) DescriptionIc(descriptionIc string) ApiDcimManufacturersListRequest {
	r.descriptionIc = &descriptionIc
	return r
}

func (r ApiDcimManufacturersListRequest) DescriptionNic(descriptionNic string) ApiDcimManufacturersListRequest {
	r.descriptionNic = &descriptionNic
	return r
}

func (r ApiDcimManufacturersListRequest) DescriptionIew(descriptionIew string) ApiDcimManufacturersListRequest {
	r.descriptionIew = &descriptionIew
	return r
}

func (r ApiDcimManufacturersListRequest) DescriptionNiew(descriptionNiew string) ApiDcimManufacturersListRequest {
	r.descriptionNiew = &descriptionNiew
	return r
}

func (r ApiDcimManufacturersListRequest) DescriptionIsw(descriptionIsw string) ApiDcimManufacturersListRequest {
	r.descriptionIsw = &descriptionIsw
	return r
}

func (r ApiDcimManufacturersListRequest) DescriptionNisw(descriptionNisw string) ApiDcimManufacturersListRequest {
	r.descriptionNisw = &descriptionNisw
	return r
}

func (r ApiDcimManufacturersListRequest) DescriptionIe(descriptionIe string) ApiDcimManufacturersListRequest {
	r.descriptionIe = &descriptionIe
	return r
}

func (r ApiDcimManufacturersListRequest) DescriptionNie(descriptionNie string) ApiDcimManufacturersListRequest {
	r.descriptionNie = &descriptionNie
	return r
}

func (r ApiDcimManufacturersListRequest) DescriptionEmpty(descriptionEmpty string) ApiDcimManufacturersListRequest {
	r.descriptionEmpty = &descriptionEmpty
	return r
}

// Number of results to return per page.
func (r ApiDcimManufacturersListRequest) Limit(limit int32) ApiDcimManufacturersListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiDcimManufacturersListRequest) Offset(offset int32) ApiDcimManufacturersListRequest {
	r.offset = &offset
	return r
}

func (r ApiDcimManufacturersListRequest) Execute() (*DcimManufacturersList200Response, *http.Response, error) {
	return r.ApiService.DcimManufacturersListExecute(r)
}

/*
DcimManufacturersList Method for DcimManufacturersList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimManufacturersListRequest
*/
func (a *DcimApiService) DcimManufacturersList(ctx context.Context) ApiDcimManufacturersListRequest {
	return ApiDcimManufacturersListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DcimManufacturersList200Response
func (a *DcimApiService) DcimManufacturersListExecute(r ApiDcimManufacturersListRequest) (*DcimManufacturersList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DcimManufacturersList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimManufacturersList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/manufacturers/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.slug != nil {
		localVarQueryParams.Add("slug", parameterToString(*r.slug, ""))
	}
	if r.description != nil {
		localVarQueryParams.Add("description", parameterToString(*r.description, ""))
	}
	if r.created != nil {
		localVarQueryParams.Add("created", parameterToString(*r.created, ""))
	}
	if r.createdGte != nil {
		localVarQueryParams.Add("created__gte", parameterToString(*r.createdGte, ""))
	}
	if r.createdLte != nil {
		localVarQueryParams.Add("created__lte", parameterToString(*r.createdLte, ""))
	}
	if r.lastUpdated != nil {
		localVarQueryParams.Add("last_updated", parameterToString(*r.lastUpdated, ""))
	}
	if r.lastUpdatedGte != nil {
		localVarQueryParams.Add("last_updated__gte", parameterToString(*r.lastUpdatedGte, ""))
	}
	if r.lastUpdatedLte != nil {
		localVarQueryParams.Add("last_updated__lte", parameterToString(*r.lastUpdatedLte, ""))
	}
	if r.q != nil {
		localVarQueryParams.Add("q", parameterToString(*r.q, ""))
	}
	if r.idN != nil {
		localVarQueryParams.Add("id__n", parameterToString(*r.idN, ""))
	}
	if r.idLte != nil {
		localVarQueryParams.Add("id__lte", parameterToString(*r.idLte, ""))
	}
	if r.idLt != nil {
		localVarQueryParams.Add("id__lt", parameterToString(*r.idLt, ""))
	}
	if r.idGte != nil {
		localVarQueryParams.Add("id__gte", parameterToString(*r.idGte, ""))
	}
	if r.idGt != nil {
		localVarQueryParams.Add("id__gt", parameterToString(*r.idGt, ""))
	}
	if r.nameN != nil {
		localVarQueryParams.Add("name__n", parameterToString(*r.nameN, ""))
	}
	if r.nameIc != nil {
		localVarQueryParams.Add("name__ic", parameterToString(*r.nameIc, ""))
	}
	if r.nameNic != nil {
		localVarQueryParams.Add("name__nic", parameterToString(*r.nameNic, ""))
	}
	if r.nameIew != nil {
		localVarQueryParams.Add("name__iew", parameterToString(*r.nameIew, ""))
	}
	if r.nameNiew != nil {
		localVarQueryParams.Add("name__niew", parameterToString(*r.nameNiew, ""))
	}
	if r.nameIsw != nil {
		localVarQueryParams.Add("name__isw", parameterToString(*r.nameIsw, ""))
	}
	if r.nameNisw != nil {
		localVarQueryParams.Add("name__nisw", parameterToString(*r.nameNisw, ""))
	}
	if r.nameIe != nil {
		localVarQueryParams.Add("name__ie", parameterToString(*r.nameIe, ""))
	}
	if r.nameNie != nil {
		localVarQueryParams.Add("name__nie", parameterToString(*r.nameNie, ""))
	}
	if r.nameEmpty != nil {
		localVarQueryParams.Add("name__empty", parameterToString(*r.nameEmpty, ""))
	}
	if r.slugN != nil {
		localVarQueryParams.Add("slug__n", parameterToString(*r.slugN, ""))
	}
	if r.slugIc != nil {
		localVarQueryParams.Add("slug__ic", parameterToString(*r.slugIc, ""))
	}
	if r.slugNic != nil {
		localVarQueryParams.Add("slug__nic", parameterToString(*r.slugNic, ""))
	}
	if r.slugIew != nil {
		localVarQueryParams.Add("slug__iew", parameterToString(*r.slugIew, ""))
	}
	if r.slugNiew != nil {
		localVarQueryParams.Add("slug__niew", parameterToString(*r.slugNiew, ""))
	}
	if r.slugIsw != nil {
		localVarQueryParams.Add("slug__isw", parameterToString(*r.slugIsw, ""))
	}
	if r.slugNisw != nil {
		localVarQueryParams.Add("slug__nisw", parameterToString(*r.slugNisw, ""))
	}
	if r.slugIe != nil {
		localVarQueryParams.Add("slug__ie", parameterToString(*r.slugIe, ""))
	}
	if r.slugNie != nil {
		localVarQueryParams.Add("slug__nie", parameterToString(*r.slugNie, ""))
	}
	if r.slugEmpty != nil {
		localVarQueryParams.Add("slug__empty", parameterToString(*r.slugEmpty, ""))
	}
	if r.descriptionN != nil {
		localVarQueryParams.Add("description__n", parameterToString(*r.descriptionN, ""))
	}
	if r.descriptionIc != nil {
		localVarQueryParams.Add("description__ic", parameterToString(*r.descriptionIc, ""))
	}
	if r.descriptionNic != nil {
		localVarQueryParams.Add("description__nic", parameterToString(*r.descriptionNic, ""))
	}
	if r.descriptionIew != nil {
		localVarQueryParams.Add("description__iew", parameterToString(*r.descriptionIew, ""))
	}
	if r.descriptionNiew != nil {
		localVarQueryParams.Add("description__niew", parameterToString(*r.descriptionNiew, ""))
	}
	if r.descriptionIsw != nil {
		localVarQueryParams.Add("description__isw", parameterToString(*r.descriptionIsw, ""))
	}
	if r.descriptionNisw != nil {
		localVarQueryParams.Add("description__nisw", parameterToString(*r.descriptionNisw, ""))
	}
	if r.descriptionIe != nil {
		localVarQueryParams.Add("description__ie", parameterToString(*r.descriptionIe, ""))
	}
	if r.descriptionNie != nil {
		localVarQueryParams.Add("description__nie", parameterToString(*r.descriptionNie, ""))
	}
	if r.descriptionEmpty != nil {
		localVarQueryParams.Add("description__empty", parameterToString(*r.descriptionEmpty, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimManufacturersPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
	data *Manufacturer
}

func (r ApiDcimManufacturersPartialUpdateRequest) Data(data Manufacturer) ApiDcimManufacturersPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimManufacturersPartialUpdateRequest) Execute() (*Manufacturer, *http.Response, error) {
	return r.ApiService.DcimManufacturersPartialUpdateExecute(r)
}

/*
DcimManufacturersPartialUpdate Method for DcimManufacturersPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this manufacturer.
 @return ApiDcimManufacturersPartialUpdateRequest
*/
func (a *DcimApiService) DcimManufacturersPartialUpdate(ctx context.Context, id int32) ApiDcimManufacturersPartialUpdateRequest {
	return ApiDcimManufacturersPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Manufacturer
func (a *DcimApiService) DcimManufacturersPartialUpdateExecute(r ApiDcimManufacturersPartialUpdateRequest) (*Manufacturer, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Manufacturer
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimManufacturersPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/manufacturers/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimManufacturersReadRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
}

func (r ApiDcimManufacturersReadRequest) Execute() (*Manufacturer, *http.Response, error) {
	return r.ApiService.DcimManufacturersReadExecute(r)
}

/*
DcimManufacturersRead Method for DcimManufacturersRead

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this manufacturer.
 @return ApiDcimManufacturersReadRequest
*/
func (a *DcimApiService) DcimManufacturersRead(ctx context.Context, id int32) ApiDcimManufacturersReadRequest {
	return ApiDcimManufacturersReadRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Manufacturer
func (a *DcimApiService) DcimManufacturersReadExecute(r ApiDcimManufacturersReadRequest) (*Manufacturer, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Manufacturer
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimManufacturersRead")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/manufacturers/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimManufacturersUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
	data *Manufacturer
}

func (r ApiDcimManufacturersUpdateRequest) Data(data Manufacturer) ApiDcimManufacturersUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimManufacturersUpdateRequest) Execute() (*Manufacturer, *http.Response, error) {
	return r.ApiService.DcimManufacturersUpdateExecute(r)
}

/*
DcimManufacturersUpdate Method for DcimManufacturersUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this manufacturer.
 @return ApiDcimManufacturersUpdateRequest
*/
func (a *DcimApiService) DcimManufacturersUpdate(ctx context.Context, id int32) ApiDcimManufacturersUpdateRequest {
	return ApiDcimManufacturersUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Manufacturer
func (a *DcimApiService) DcimManufacturersUpdateExecute(r ApiDcimManufacturersUpdateRequest) (*Manufacturer, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Manufacturer
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimManufacturersUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/manufacturers/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimPlatformsBulkDeleteRequest struct {
	ctx context.Context
	ApiService *DcimApiService
}

func (r ApiDcimPlatformsBulkDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimPlatformsBulkDeleteExecute(r)
}

/*
DcimPlatformsBulkDelete Method for DcimPlatformsBulkDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimPlatformsBulkDeleteRequest
*/
func (a *DcimApiService) DcimPlatformsBulkDelete(ctx context.Context) ApiDcimPlatformsBulkDeleteRequest {
	return ApiDcimPlatformsBulkDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DcimApiService) DcimPlatformsBulkDeleteExecute(r ApiDcimPlatformsBulkDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimPlatformsBulkDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/platforms/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimPlatformsBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	data *WritablePlatform
}

func (r ApiDcimPlatformsBulkPartialUpdateRequest) Data(data WritablePlatform) ApiDcimPlatformsBulkPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimPlatformsBulkPartialUpdateRequest) Execute() (*Platform, *http.Response, error) {
	return r.ApiService.DcimPlatformsBulkPartialUpdateExecute(r)
}

/*
DcimPlatformsBulkPartialUpdate Method for DcimPlatformsBulkPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimPlatformsBulkPartialUpdateRequest
*/
func (a *DcimApiService) DcimPlatformsBulkPartialUpdate(ctx context.Context) ApiDcimPlatformsBulkPartialUpdateRequest {
	return ApiDcimPlatformsBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Platform
func (a *DcimApiService) DcimPlatformsBulkPartialUpdateExecute(r ApiDcimPlatformsBulkPartialUpdateRequest) (*Platform, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Platform
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimPlatformsBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/platforms/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimPlatformsBulkUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	data *WritablePlatform
}

func (r ApiDcimPlatformsBulkUpdateRequest) Data(data WritablePlatform) ApiDcimPlatformsBulkUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimPlatformsBulkUpdateRequest) Execute() (*Platform, *http.Response, error) {
	return r.ApiService.DcimPlatformsBulkUpdateExecute(r)
}

/*
DcimPlatformsBulkUpdate Method for DcimPlatformsBulkUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimPlatformsBulkUpdateRequest
*/
func (a *DcimApiService) DcimPlatformsBulkUpdate(ctx context.Context) ApiDcimPlatformsBulkUpdateRequest {
	return ApiDcimPlatformsBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Platform
func (a *DcimApiService) DcimPlatformsBulkUpdateExecute(r ApiDcimPlatformsBulkUpdateRequest) (*Platform, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Platform
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimPlatformsBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/platforms/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimPlatformsCreateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	data *WritablePlatform
}

func (r ApiDcimPlatformsCreateRequest) Data(data WritablePlatform) ApiDcimPlatformsCreateRequest {
	r.data = &data
	return r
}

func (r ApiDcimPlatformsCreateRequest) Execute() (*Platform, *http.Response, error) {
	return r.ApiService.DcimPlatformsCreateExecute(r)
}

/*
DcimPlatformsCreate Method for DcimPlatformsCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimPlatformsCreateRequest
*/
func (a *DcimApiService) DcimPlatformsCreate(ctx context.Context) ApiDcimPlatformsCreateRequest {
	return ApiDcimPlatformsCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Platform
func (a *DcimApiService) DcimPlatformsCreateExecute(r ApiDcimPlatformsCreateRequest) (*Platform, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Platform
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimPlatformsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/platforms/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimPlatformsDeleteRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
}

func (r ApiDcimPlatformsDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimPlatformsDeleteExecute(r)
}

/*
DcimPlatformsDelete Method for DcimPlatformsDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this platform.
 @return ApiDcimPlatformsDeleteRequest
*/
func (a *DcimApiService) DcimPlatformsDelete(ctx context.Context, id int32) ApiDcimPlatformsDeleteRequest {
	return ApiDcimPlatformsDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DcimApiService) DcimPlatformsDeleteExecute(r ApiDcimPlatformsDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimPlatformsDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/platforms/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimPlatformsListRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id *string
	name *string
	slug *string
	napalmDriver *string
	description *string
	created *string
	createdGte *string
	createdLte *string
	lastUpdated *string
	lastUpdatedGte *string
	lastUpdatedLte *string
	q *string
	manufacturerId *string
	manufacturer *string
	idN *string
	idLte *string
	idLt *string
	idGte *string
	idGt *string
	nameN *string
	nameIc *string
	nameNic *string
	nameIew *string
	nameNiew *string
	nameIsw *string
	nameNisw *string
	nameIe *string
	nameNie *string
	nameEmpty *string
	slugN *string
	slugIc *string
	slugNic *string
	slugIew *string
	slugNiew *string
	slugIsw *string
	slugNisw *string
	slugIe *string
	slugNie *string
	slugEmpty *string
	napalmDriverN *string
	napalmDriverIc *string
	napalmDriverNic *string
	napalmDriverIew *string
	napalmDriverNiew *string
	napalmDriverIsw *string
	napalmDriverNisw *string
	napalmDriverIe *string
	napalmDriverNie *string
	napalmDriverEmpty *string
	descriptionN *string
	descriptionIc *string
	descriptionNic *string
	descriptionIew *string
	descriptionNiew *string
	descriptionIsw *string
	descriptionNisw *string
	descriptionIe *string
	descriptionNie *string
	descriptionEmpty *string
	manufacturerIdN *string
	manufacturerN *string
	limit *int32
	offset *int32
}

func (r ApiDcimPlatformsListRequest) Id(id string) ApiDcimPlatformsListRequest {
	r.id = &id
	return r
}

func (r ApiDcimPlatformsListRequest) Name(name string) ApiDcimPlatformsListRequest {
	r.name = &name
	return r
}

func (r ApiDcimPlatformsListRequest) Slug(slug string) ApiDcimPlatformsListRequest {
	r.slug = &slug
	return r
}

func (r ApiDcimPlatformsListRequest) NapalmDriver(napalmDriver string) ApiDcimPlatformsListRequest {
	r.napalmDriver = &napalmDriver
	return r
}

func (r ApiDcimPlatformsListRequest) Description(description string) ApiDcimPlatformsListRequest {
	r.description = &description
	return r
}

func (r ApiDcimPlatformsListRequest) Created(created string) ApiDcimPlatformsListRequest {
	r.created = &created
	return r
}

func (r ApiDcimPlatformsListRequest) CreatedGte(createdGte string) ApiDcimPlatformsListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiDcimPlatformsListRequest) CreatedLte(createdLte string) ApiDcimPlatformsListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiDcimPlatformsListRequest) LastUpdated(lastUpdated string) ApiDcimPlatformsListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiDcimPlatformsListRequest) LastUpdatedGte(lastUpdatedGte string) ApiDcimPlatformsListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiDcimPlatformsListRequest) LastUpdatedLte(lastUpdatedLte string) ApiDcimPlatformsListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiDcimPlatformsListRequest) Q(q string) ApiDcimPlatformsListRequest {
	r.q = &q
	return r
}

func (r ApiDcimPlatformsListRequest) ManufacturerId(manufacturerId string) ApiDcimPlatformsListRequest {
	r.manufacturerId = &manufacturerId
	return r
}

func (r ApiDcimPlatformsListRequest) Manufacturer(manufacturer string) ApiDcimPlatformsListRequest {
	r.manufacturer = &manufacturer
	return r
}

func (r ApiDcimPlatformsListRequest) IdN(idN string) ApiDcimPlatformsListRequest {
	r.idN = &idN
	return r
}

func (r ApiDcimPlatformsListRequest) IdLte(idLte string) ApiDcimPlatformsListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiDcimPlatformsListRequest) IdLt(idLt string) ApiDcimPlatformsListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiDcimPlatformsListRequest) IdGte(idGte string) ApiDcimPlatformsListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiDcimPlatformsListRequest) IdGt(idGt string) ApiDcimPlatformsListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiDcimPlatformsListRequest) NameN(nameN string) ApiDcimPlatformsListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiDcimPlatformsListRequest) NameIc(nameIc string) ApiDcimPlatformsListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiDcimPlatformsListRequest) NameNic(nameNic string) ApiDcimPlatformsListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiDcimPlatformsListRequest) NameIew(nameIew string) ApiDcimPlatformsListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiDcimPlatformsListRequest) NameNiew(nameNiew string) ApiDcimPlatformsListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiDcimPlatformsListRequest) NameIsw(nameIsw string) ApiDcimPlatformsListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiDcimPlatformsListRequest) NameNisw(nameNisw string) ApiDcimPlatformsListRequest {
	r.nameNisw = &nameNisw
	return r
}

func (r ApiDcimPlatformsListRequest) NameIe(nameIe string) ApiDcimPlatformsListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiDcimPlatformsListRequest) NameNie(nameNie string) ApiDcimPlatformsListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiDcimPlatformsListRequest) NameEmpty(nameEmpty string) ApiDcimPlatformsListRequest {
	r.nameEmpty = &nameEmpty
	return r
}

func (r ApiDcimPlatformsListRequest) SlugN(slugN string) ApiDcimPlatformsListRequest {
	r.slugN = &slugN
	return r
}

func (r ApiDcimPlatformsListRequest) SlugIc(slugIc string) ApiDcimPlatformsListRequest {
	r.slugIc = &slugIc
	return r
}

func (r ApiDcimPlatformsListRequest) SlugNic(slugNic string) ApiDcimPlatformsListRequest {
	r.slugNic = &slugNic
	return r
}

func (r ApiDcimPlatformsListRequest) SlugIew(slugIew string) ApiDcimPlatformsListRequest {
	r.slugIew = &slugIew
	return r
}

func (r ApiDcimPlatformsListRequest) SlugNiew(slugNiew string) ApiDcimPlatformsListRequest {
	r.slugNiew = &slugNiew
	return r
}

func (r ApiDcimPlatformsListRequest) SlugIsw(slugIsw string) ApiDcimPlatformsListRequest {
	r.slugIsw = &slugIsw
	return r
}

func (r ApiDcimPlatformsListRequest) SlugNisw(slugNisw string) ApiDcimPlatformsListRequest {
	r.slugNisw = &slugNisw
	return r
}

func (r ApiDcimPlatformsListRequest) SlugIe(slugIe string) ApiDcimPlatformsListRequest {
	r.slugIe = &slugIe
	return r
}

func (r ApiDcimPlatformsListRequest) SlugNie(slugNie string) ApiDcimPlatformsListRequest {
	r.slugNie = &slugNie
	return r
}

func (r ApiDcimPlatformsListRequest) SlugEmpty(slugEmpty string) ApiDcimPlatformsListRequest {
	r.slugEmpty = &slugEmpty
	return r
}

func (r ApiDcimPlatformsListRequest) NapalmDriverN(napalmDriverN string) ApiDcimPlatformsListRequest {
	r.napalmDriverN = &napalmDriverN
	return r
}

func (r ApiDcimPlatformsListRequest) NapalmDriverIc(napalmDriverIc string) ApiDcimPlatformsListRequest {
	r.napalmDriverIc = &napalmDriverIc
	return r
}

func (r ApiDcimPlatformsListRequest) NapalmDriverNic(napalmDriverNic string) ApiDcimPlatformsListRequest {
	r.napalmDriverNic = &napalmDriverNic
	return r
}

func (r ApiDcimPlatformsListRequest) NapalmDriverIew(napalmDriverIew string) ApiDcimPlatformsListRequest {
	r.napalmDriverIew = &napalmDriverIew
	return r
}

func (r ApiDcimPlatformsListRequest) NapalmDriverNiew(napalmDriverNiew string) ApiDcimPlatformsListRequest {
	r.napalmDriverNiew = &napalmDriverNiew
	return r
}

func (r ApiDcimPlatformsListRequest) NapalmDriverIsw(napalmDriverIsw string) ApiDcimPlatformsListRequest {
	r.napalmDriverIsw = &napalmDriverIsw
	return r
}

func (r ApiDcimPlatformsListRequest) NapalmDriverNisw(napalmDriverNisw string) ApiDcimPlatformsListRequest {
	r.napalmDriverNisw = &napalmDriverNisw
	return r
}

func (r ApiDcimPlatformsListRequest) NapalmDriverIe(napalmDriverIe string) ApiDcimPlatformsListRequest {
	r.napalmDriverIe = &napalmDriverIe
	return r
}

func (r ApiDcimPlatformsListRequest) NapalmDriverNie(napalmDriverNie string) ApiDcimPlatformsListRequest {
	r.napalmDriverNie = &napalmDriverNie
	return r
}

func (r ApiDcimPlatformsListRequest) NapalmDriverEmpty(napalmDriverEmpty string) ApiDcimPlatformsListRequest {
	r.napalmDriverEmpty = &napalmDriverEmpty
	return r
}

func (r ApiDcimPlatformsListRequest) DescriptionN(descriptionN string) ApiDcimPlatformsListRequest {
	r.descriptionN = &descriptionN
	return r
}

func (r ApiDcimPlatformsListRequest) DescriptionIc(descriptionIc string) ApiDcimPlatformsListRequest {
	r.descriptionIc = &descriptionIc
	return r
}

func (r ApiDcimPlatformsListRequest) DescriptionNic(descriptionNic string) ApiDcimPlatformsListRequest {
	r.descriptionNic = &descriptionNic
	return r
}

func (r ApiDcimPlatformsListRequest) DescriptionIew(descriptionIew string) ApiDcimPlatformsListRequest {
	r.descriptionIew = &descriptionIew
	return r
}

func (r ApiDcimPlatformsListRequest) DescriptionNiew(descriptionNiew string) ApiDcimPlatformsListRequest {
	r.descriptionNiew = &descriptionNiew
	return r
}

func (r ApiDcimPlatformsListRequest) DescriptionIsw(descriptionIsw string) ApiDcimPlatformsListRequest {
	r.descriptionIsw = &descriptionIsw
	return r
}

func (r ApiDcimPlatformsListRequest) DescriptionNisw(descriptionNisw string) ApiDcimPlatformsListRequest {
	r.descriptionNisw = &descriptionNisw
	return r
}

func (r ApiDcimPlatformsListRequest) DescriptionIe(descriptionIe string) ApiDcimPlatformsListRequest {
	r.descriptionIe = &descriptionIe
	return r
}

func (r ApiDcimPlatformsListRequest) DescriptionNie(descriptionNie string) ApiDcimPlatformsListRequest {
	r.descriptionNie = &descriptionNie
	return r
}

func (r ApiDcimPlatformsListRequest) DescriptionEmpty(descriptionEmpty string) ApiDcimPlatformsListRequest {
	r.descriptionEmpty = &descriptionEmpty
	return r
}

func (r ApiDcimPlatformsListRequest) ManufacturerIdN(manufacturerIdN string) ApiDcimPlatformsListRequest {
	r.manufacturerIdN = &manufacturerIdN
	return r
}

func (r ApiDcimPlatformsListRequest) ManufacturerN(manufacturerN string) ApiDcimPlatformsListRequest {
	r.manufacturerN = &manufacturerN
	return r
}

// Number of results to return per page.
func (r ApiDcimPlatformsListRequest) Limit(limit int32) ApiDcimPlatformsListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiDcimPlatformsListRequest) Offset(offset int32) ApiDcimPlatformsListRequest {
	r.offset = &offset
	return r
}

func (r ApiDcimPlatformsListRequest) Execute() (*DcimPlatformsList200Response, *http.Response, error) {
	return r.ApiService.DcimPlatformsListExecute(r)
}

/*
DcimPlatformsList Method for DcimPlatformsList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimPlatformsListRequest
*/
func (a *DcimApiService) DcimPlatformsList(ctx context.Context) ApiDcimPlatformsListRequest {
	return ApiDcimPlatformsListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DcimPlatformsList200Response
func (a *DcimApiService) DcimPlatformsListExecute(r ApiDcimPlatformsListRequest) (*DcimPlatformsList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DcimPlatformsList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimPlatformsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/platforms/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.slug != nil {
		localVarQueryParams.Add("slug", parameterToString(*r.slug, ""))
	}
	if r.napalmDriver != nil {
		localVarQueryParams.Add("napalm_driver", parameterToString(*r.napalmDriver, ""))
	}
	if r.description != nil {
		localVarQueryParams.Add("description", parameterToString(*r.description, ""))
	}
	if r.created != nil {
		localVarQueryParams.Add("created", parameterToString(*r.created, ""))
	}
	if r.createdGte != nil {
		localVarQueryParams.Add("created__gte", parameterToString(*r.createdGte, ""))
	}
	if r.createdLte != nil {
		localVarQueryParams.Add("created__lte", parameterToString(*r.createdLte, ""))
	}
	if r.lastUpdated != nil {
		localVarQueryParams.Add("last_updated", parameterToString(*r.lastUpdated, ""))
	}
	if r.lastUpdatedGte != nil {
		localVarQueryParams.Add("last_updated__gte", parameterToString(*r.lastUpdatedGte, ""))
	}
	if r.lastUpdatedLte != nil {
		localVarQueryParams.Add("last_updated__lte", parameterToString(*r.lastUpdatedLte, ""))
	}
	if r.q != nil {
		localVarQueryParams.Add("q", parameterToString(*r.q, ""))
	}
	if r.manufacturerId != nil {
		localVarQueryParams.Add("manufacturer_id", parameterToString(*r.manufacturerId, ""))
	}
	if r.manufacturer != nil {
		localVarQueryParams.Add("manufacturer", parameterToString(*r.manufacturer, ""))
	}
	if r.idN != nil {
		localVarQueryParams.Add("id__n", parameterToString(*r.idN, ""))
	}
	if r.idLte != nil {
		localVarQueryParams.Add("id__lte", parameterToString(*r.idLte, ""))
	}
	if r.idLt != nil {
		localVarQueryParams.Add("id__lt", parameterToString(*r.idLt, ""))
	}
	if r.idGte != nil {
		localVarQueryParams.Add("id__gte", parameterToString(*r.idGte, ""))
	}
	if r.idGt != nil {
		localVarQueryParams.Add("id__gt", parameterToString(*r.idGt, ""))
	}
	if r.nameN != nil {
		localVarQueryParams.Add("name__n", parameterToString(*r.nameN, ""))
	}
	if r.nameIc != nil {
		localVarQueryParams.Add("name__ic", parameterToString(*r.nameIc, ""))
	}
	if r.nameNic != nil {
		localVarQueryParams.Add("name__nic", parameterToString(*r.nameNic, ""))
	}
	if r.nameIew != nil {
		localVarQueryParams.Add("name__iew", parameterToString(*r.nameIew, ""))
	}
	if r.nameNiew != nil {
		localVarQueryParams.Add("name__niew", parameterToString(*r.nameNiew, ""))
	}
	if r.nameIsw != nil {
		localVarQueryParams.Add("name__isw", parameterToString(*r.nameIsw, ""))
	}
	if r.nameNisw != nil {
		localVarQueryParams.Add("name__nisw", parameterToString(*r.nameNisw, ""))
	}
	if r.nameIe != nil {
		localVarQueryParams.Add("name__ie", parameterToString(*r.nameIe, ""))
	}
	if r.nameNie != nil {
		localVarQueryParams.Add("name__nie", parameterToString(*r.nameNie, ""))
	}
	if r.nameEmpty != nil {
		localVarQueryParams.Add("name__empty", parameterToString(*r.nameEmpty, ""))
	}
	if r.slugN != nil {
		localVarQueryParams.Add("slug__n", parameterToString(*r.slugN, ""))
	}
	if r.slugIc != nil {
		localVarQueryParams.Add("slug__ic", parameterToString(*r.slugIc, ""))
	}
	if r.slugNic != nil {
		localVarQueryParams.Add("slug__nic", parameterToString(*r.slugNic, ""))
	}
	if r.slugIew != nil {
		localVarQueryParams.Add("slug__iew", parameterToString(*r.slugIew, ""))
	}
	if r.slugNiew != nil {
		localVarQueryParams.Add("slug__niew", parameterToString(*r.slugNiew, ""))
	}
	if r.slugIsw != nil {
		localVarQueryParams.Add("slug__isw", parameterToString(*r.slugIsw, ""))
	}
	if r.slugNisw != nil {
		localVarQueryParams.Add("slug__nisw", parameterToString(*r.slugNisw, ""))
	}
	if r.slugIe != nil {
		localVarQueryParams.Add("slug__ie", parameterToString(*r.slugIe, ""))
	}
	if r.slugNie != nil {
		localVarQueryParams.Add("slug__nie", parameterToString(*r.slugNie, ""))
	}
	if r.slugEmpty != nil {
		localVarQueryParams.Add("slug__empty", parameterToString(*r.slugEmpty, ""))
	}
	if r.napalmDriverN != nil {
		localVarQueryParams.Add("napalm_driver__n", parameterToString(*r.napalmDriverN, ""))
	}
	if r.napalmDriverIc != nil {
		localVarQueryParams.Add("napalm_driver__ic", parameterToString(*r.napalmDriverIc, ""))
	}
	if r.napalmDriverNic != nil {
		localVarQueryParams.Add("napalm_driver__nic", parameterToString(*r.napalmDriverNic, ""))
	}
	if r.napalmDriverIew != nil {
		localVarQueryParams.Add("napalm_driver__iew", parameterToString(*r.napalmDriverIew, ""))
	}
	if r.napalmDriverNiew != nil {
		localVarQueryParams.Add("napalm_driver__niew", parameterToString(*r.napalmDriverNiew, ""))
	}
	if r.napalmDriverIsw != nil {
		localVarQueryParams.Add("napalm_driver__isw", parameterToString(*r.napalmDriverIsw, ""))
	}
	if r.napalmDriverNisw != nil {
		localVarQueryParams.Add("napalm_driver__nisw", parameterToString(*r.napalmDriverNisw, ""))
	}
	if r.napalmDriverIe != nil {
		localVarQueryParams.Add("napalm_driver__ie", parameterToString(*r.napalmDriverIe, ""))
	}
	if r.napalmDriverNie != nil {
		localVarQueryParams.Add("napalm_driver__nie", parameterToString(*r.napalmDriverNie, ""))
	}
	if r.napalmDriverEmpty != nil {
		localVarQueryParams.Add("napalm_driver__empty", parameterToString(*r.napalmDriverEmpty, ""))
	}
	if r.descriptionN != nil {
		localVarQueryParams.Add("description__n", parameterToString(*r.descriptionN, ""))
	}
	if r.descriptionIc != nil {
		localVarQueryParams.Add("description__ic", parameterToString(*r.descriptionIc, ""))
	}
	if r.descriptionNic != nil {
		localVarQueryParams.Add("description__nic", parameterToString(*r.descriptionNic, ""))
	}
	if r.descriptionIew != nil {
		localVarQueryParams.Add("description__iew", parameterToString(*r.descriptionIew, ""))
	}
	if r.descriptionNiew != nil {
		localVarQueryParams.Add("description__niew", parameterToString(*r.descriptionNiew, ""))
	}
	if r.descriptionIsw != nil {
		localVarQueryParams.Add("description__isw", parameterToString(*r.descriptionIsw, ""))
	}
	if r.descriptionNisw != nil {
		localVarQueryParams.Add("description__nisw", parameterToString(*r.descriptionNisw, ""))
	}
	if r.descriptionIe != nil {
		localVarQueryParams.Add("description__ie", parameterToString(*r.descriptionIe, ""))
	}
	if r.descriptionNie != nil {
		localVarQueryParams.Add("description__nie", parameterToString(*r.descriptionNie, ""))
	}
	if r.descriptionEmpty != nil {
		localVarQueryParams.Add("description__empty", parameterToString(*r.descriptionEmpty, ""))
	}
	if r.manufacturerIdN != nil {
		localVarQueryParams.Add("manufacturer_id__n", parameterToString(*r.manufacturerIdN, ""))
	}
	if r.manufacturerN != nil {
		localVarQueryParams.Add("manufacturer__n", parameterToString(*r.manufacturerN, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimPlatformsPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
	data *WritablePlatform
}

func (r ApiDcimPlatformsPartialUpdateRequest) Data(data WritablePlatform) ApiDcimPlatformsPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimPlatformsPartialUpdateRequest) Execute() (*Platform, *http.Response, error) {
	return r.ApiService.DcimPlatformsPartialUpdateExecute(r)
}

/*
DcimPlatformsPartialUpdate Method for DcimPlatformsPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this platform.
 @return ApiDcimPlatformsPartialUpdateRequest
*/
func (a *DcimApiService) DcimPlatformsPartialUpdate(ctx context.Context, id int32) ApiDcimPlatformsPartialUpdateRequest {
	return ApiDcimPlatformsPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Platform
func (a *DcimApiService) DcimPlatformsPartialUpdateExecute(r ApiDcimPlatformsPartialUpdateRequest) (*Platform, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Platform
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimPlatformsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/platforms/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimPlatformsReadRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
}

func (r ApiDcimPlatformsReadRequest) Execute() (*Platform, *http.Response, error) {
	return r.ApiService.DcimPlatformsReadExecute(r)
}

/*
DcimPlatformsRead Method for DcimPlatformsRead

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this platform.
 @return ApiDcimPlatformsReadRequest
*/
func (a *DcimApiService) DcimPlatformsRead(ctx context.Context, id int32) ApiDcimPlatformsReadRequest {
	return ApiDcimPlatformsReadRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Platform
func (a *DcimApiService) DcimPlatformsReadExecute(r ApiDcimPlatformsReadRequest) (*Platform, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Platform
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimPlatformsRead")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/platforms/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimPlatformsUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
	data *WritablePlatform
}

func (r ApiDcimPlatformsUpdateRequest) Data(data WritablePlatform) ApiDcimPlatformsUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimPlatformsUpdateRequest) Execute() (*Platform, *http.Response, error) {
	return r.ApiService.DcimPlatformsUpdateExecute(r)
}

/*
DcimPlatformsUpdate Method for DcimPlatformsUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this platform.
 @return ApiDcimPlatformsUpdateRequest
*/
func (a *DcimApiService) DcimPlatformsUpdate(ctx context.Context, id int32) ApiDcimPlatformsUpdateRequest {
	return ApiDcimPlatformsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Platform
func (a *DcimApiService) DcimPlatformsUpdateExecute(r ApiDcimPlatformsUpdateRequest) (*Platform, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Platform
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimPlatformsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/platforms/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimPowerConnectionsListRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	name *string
	site *string
	deviceId *string
	device *string
	nameN *string
	nameIc *string
	nameNic *string
	nameIew *string
	nameNiew *string
	nameIsw *string
	nameNisw *string
	nameIe *string
	nameNie *string
	nameEmpty *string
	limit *int32
	offset *int32
}

func (r ApiDcimPowerConnectionsListRequest) Name(name string) ApiDcimPowerConnectionsListRequest {
	r.name = &name
	return r
}

func (r ApiDcimPowerConnectionsListRequest) Site(site string) ApiDcimPowerConnectionsListRequest {
	r.site = &site
	return r
}

func (r ApiDcimPowerConnectionsListRequest) DeviceId(deviceId string) ApiDcimPowerConnectionsListRequest {
	r.deviceId = &deviceId
	return r
}

func (r ApiDcimPowerConnectionsListRequest) Device(device string) ApiDcimPowerConnectionsListRequest {
	r.device = &device
	return r
}

func (r ApiDcimPowerConnectionsListRequest) NameN(nameN string) ApiDcimPowerConnectionsListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiDcimPowerConnectionsListRequest) NameIc(nameIc string) ApiDcimPowerConnectionsListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiDcimPowerConnectionsListRequest) NameNic(nameNic string) ApiDcimPowerConnectionsListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiDcimPowerConnectionsListRequest) NameIew(nameIew string) ApiDcimPowerConnectionsListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiDcimPowerConnectionsListRequest) NameNiew(nameNiew string) ApiDcimPowerConnectionsListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiDcimPowerConnectionsListRequest) NameIsw(nameIsw string) ApiDcimPowerConnectionsListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiDcimPowerConnectionsListRequest) NameNisw(nameNisw string) ApiDcimPowerConnectionsListRequest {
	r.nameNisw = &nameNisw
	return r
}

func (r ApiDcimPowerConnectionsListRequest) NameIe(nameIe string) ApiDcimPowerConnectionsListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiDcimPowerConnectionsListRequest) NameNie(nameNie string) ApiDcimPowerConnectionsListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiDcimPowerConnectionsListRequest) NameEmpty(nameEmpty string) ApiDcimPowerConnectionsListRequest {
	r.nameEmpty = &nameEmpty
	return r
}

// Number of results to return per page.
func (r ApiDcimPowerConnectionsListRequest) Limit(limit int32) ApiDcimPowerConnectionsListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiDcimPowerConnectionsListRequest) Offset(offset int32) ApiDcimPowerConnectionsListRequest {
	r.offset = &offset
	return r
}

func (r ApiDcimPowerConnectionsListRequest) Execute() (*DcimPowerConnectionsList200Response, *http.Response, error) {
	return r.ApiService.DcimPowerConnectionsListExecute(r)
}

/*
DcimPowerConnectionsList Method for DcimPowerConnectionsList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimPowerConnectionsListRequest
*/
func (a *DcimApiService) DcimPowerConnectionsList(ctx context.Context) ApiDcimPowerConnectionsListRequest {
	return ApiDcimPowerConnectionsListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DcimPowerConnectionsList200Response
func (a *DcimApiService) DcimPowerConnectionsListExecute(r ApiDcimPowerConnectionsListRequest) (*DcimPowerConnectionsList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DcimPowerConnectionsList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimPowerConnectionsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-connections/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.site != nil {
		localVarQueryParams.Add("site", parameterToString(*r.site, ""))
	}
	if r.deviceId != nil {
		localVarQueryParams.Add("device_id", parameterToString(*r.deviceId, ""))
	}
	if r.device != nil {
		localVarQueryParams.Add("device", parameterToString(*r.device, ""))
	}
	if r.nameN != nil {
		localVarQueryParams.Add("name__n", parameterToString(*r.nameN, ""))
	}
	if r.nameIc != nil {
		localVarQueryParams.Add("name__ic", parameterToString(*r.nameIc, ""))
	}
	if r.nameNic != nil {
		localVarQueryParams.Add("name__nic", parameterToString(*r.nameNic, ""))
	}
	if r.nameIew != nil {
		localVarQueryParams.Add("name__iew", parameterToString(*r.nameIew, ""))
	}
	if r.nameNiew != nil {
		localVarQueryParams.Add("name__niew", parameterToString(*r.nameNiew, ""))
	}
	if r.nameIsw != nil {
		localVarQueryParams.Add("name__isw", parameterToString(*r.nameIsw, ""))
	}
	if r.nameNisw != nil {
		localVarQueryParams.Add("name__nisw", parameterToString(*r.nameNisw, ""))
	}
	if r.nameIe != nil {
		localVarQueryParams.Add("name__ie", parameterToString(*r.nameIe, ""))
	}
	if r.nameNie != nil {
		localVarQueryParams.Add("name__nie", parameterToString(*r.nameNie, ""))
	}
	if r.nameEmpty != nil {
		localVarQueryParams.Add("name__empty", parameterToString(*r.nameEmpty, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimPowerFeedsBulkDeleteRequest struct {
	ctx context.Context
	ApiService *DcimApiService
}

func (r ApiDcimPowerFeedsBulkDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimPowerFeedsBulkDeleteExecute(r)
}

/*
DcimPowerFeedsBulkDelete Method for DcimPowerFeedsBulkDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimPowerFeedsBulkDeleteRequest
*/
func (a *DcimApiService) DcimPowerFeedsBulkDelete(ctx context.Context) ApiDcimPowerFeedsBulkDeleteRequest {
	return ApiDcimPowerFeedsBulkDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DcimApiService) DcimPowerFeedsBulkDeleteExecute(r ApiDcimPowerFeedsBulkDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimPowerFeedsBulkDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-feeds/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimPowerFeedsBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	data *WritablePowerFeed
}

func (r ApiDcimPowerFeedsBulkPartialUpdateRequest) Data(data WritablePowerFeed) ApiDcimPowerFeedsBulkPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimPowerFeedsBulkPartialUpdateRequest) Execute() (*PowerFeed, *http.Response, error) {
	return r.ApiService.DcimPowerFeedsBulkPartialUpdateExecute(r)
}

/*
DcimPowerFeedsBulkPartialUpdate Method for DcimPowerFeedsBulkPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimPowerFeedsBulkPartialUpdateRequest
*/
func (a *DcimApiService) DcimPowerFeedsBulkPartialUpdate(ctx context.Context) ApiDcimPowerFeedsBulkPartialUpdateRequest {
	return ApiDcimPowerFeedsBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PowerFeed
func (a *DcimApiService) DcimPowerFeedsBulkPartialUpdateExecute(r ApiDcimPowerFeedsBulkPartialUpdateRequest) (*PowerFeed, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PowerFeed
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimPowerFeedsBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-feeds/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimPowerFeedsBulkUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	data *WritablePowerFeed
}

func (r ApiDcimPowerFeedsBulkUpdateRequest) Data(data WritablePowerFeed) ApiDcimPowerFeedsBulkUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimPowerFeedsBulkUpdateRequest) Execute() (*PowerFeed, *http.Response, error) {
	return r.ApiService.DcimPowerFeedsBulkUpdateExecute(r)
}

/*
DcimPowerFeedsBulkUpdate Method for DcimPowerFeedsBulkUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimPowerFeedsBulkUpdateRequest
*/
func (a *DcimApiService) DcimPowerFeedsBulkUpdate(ctx context.Context) ApiDcimPowerFeedsBulkUpdateRequest {
	return ApiDcimPowerFeedsBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PowerFeed
func (a *DcimApiService) DcimPowerFeedsBulkUpdateExecute(r ApiDcimPowerFeedsBulkUpdateRequest) (*PowerFeed, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PowerFeed
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimPowerFeedsBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-feeds/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimPowerFeedsCreateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	data *WritablePowerFeed
}

func (r ApiDcimPowerFeedsCreateRequest) Data(data WritablePowerFeed) ApiDcimPowerFeedsCreateRequest {
	r.data = &data
	return r
}

func (r ApiDcimPowerFeedsCreateRequest) Execute() (*PowerFeed, *http.Response, error) {
	return r.ApiService.DcimPowerFeedsCreateExecute(r)
}

/*
DcimPowerFeedsCreate Method for DcimPowerFeedsCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimPowerFeedsCreateRequest
*/
func (a *DcimApiService) DcimPowerFeedsCreate(ctx context.Context) ApiDcimPowerFeedsCreateRequest {
	return ApiDcimPowerFeedsCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PowerFeed
func (a *DcimApiService) DcimPowerFeedsCreateExecute(r ApiDcimPowerFeedsCreateRequest) (*PowerFeed, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PowerFeed
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimPowerFeedsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-feeds/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimPowerFeedsDeleteRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
}

func (r ApiDcimPowerFeedsDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimPowerFeedsDeleteExecute(r)
}

/*
DcimPowerFeedsDelete Method for DcimPowerFeedsDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this power feed.
 @return ApiDcimPowerFeedsDeleteRequest
*/
func (a *DcimApiService) DcimPowerFeedsDelete(ctx context.Context, id int32) ApiDcimPowerFeedsDeleteRequest {
	return ApiDcimPowerFeedsDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DcimApiService) DcimPowerFeedsDeleteExecute(r ApiDcimPowerFeedsDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimPowerFeedsDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-feeds/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimPowerFeedsListRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id *string
	name *string
	status *string
	type_ *string
	supply *string
	phase *string
	voltage *string
	amperage *string
	maxUtilization *string
	created *string
	createdGte *string
	createdLte *string
	lastUpdated *string
	lastUpdatedGte *string
	lastUpdatedLte *string
	cabled *string
	connected *string
	q *string
	regionId *string
	region *string
	siteGroupId *string
	siteGroup *string
	siteId *string
	site *string
	powerPanelId *string
	rackId *string
	tag *string
	idN *string
	idLte *string
	idLt *string
	idGte *string
	idGt *string
	nameN *string
	nameIc *string
	nameNic *string
	nameIew *string
	nameNiew *string
	nameIsw *string
	nameNisw *string
	nameIe *string
	nameNie *string
	nameEmpty *string
	statusN *string
	typeN *string
	supplyN *string
	phaseN *string
	voltageN *string
	voltageLte *string
	voltageLt *string
	voltageGte *string
	voltageGt *string
	amperageN *string
	amperageLte *string
	amperageLt *string
	amperageGte *string
	amperageGt *string
	maxUtilizationN *string
	maxUtilizationLte *string
	maxUtilizationLt *string
	maxUtilizationGte *string
	maxUtilizationGt *string
	regionIdN *string
	regionN *string
	siteGroupIdN *string
	siteGroupN *string
	siteIdN *string
	siteN *string
	powerPanelIdN *string
	rackIdN *string
	tagN *string
	limit *int32
	offset *int32
}

func (r ApiDcimPowerFeedsListRequest) Id(id string) ApiDcimPowerFeedsListRequest {
	r.id = &id
	return r
}

func (r ApiDcimPowerFeedsListRequest) Name(name string) ApiDcimPowerFeedsListRequest {
	r.name = &name
	return r
}

func (r ApiDcimPowerFeedsListRequest) Status(status string) ApiDcimPowerFeedsListRequest {
	r.status = &status
	return r
}

func (r ApiDcimPowerFeedsListRequest) Type_(type_ string) ApiDcimPowerFeedsListRequest {
	r.type_ = &type_
	return r
}

func (r ApiDcimPowerFeedsListRequest) Supply(supply string) ApiDcimPowerFeedsListRequest {
	r.supply = &supply
	return r
}

func (r ApiDcimPowerFeedsListRequest) Phase(phase string) ApiDcimPowerFeedsListRequest {
	r.phase = &phase
	return r
}

func (r ApiDcimPowerFeedsListRequest) Voltage(voltage string) ApiDcimPowerFeedsListRequest {
	r.voltage = &voltage
	return r
}

func (r ApiDcimPowerFeedsListRequest) Amperage(amperage string) ApiDcimPowerFeedsListRequest {
	r.amperage = &amperage
	return r
}

func (r ApiDcimPowerFeedsListRequest) MaxUtilization(maxUtilization string) ApiDcimPowerFeedsListRequest {
	r.maxUtilization = &maxUtilization
	return r
}

func (r ApiDcimPowerFeedsListRequest) Created(created string) ApiDcimPowerFeedsListRequest {
	r.created = &created
	return r
}

func (r ApiDcimPowerFeedsListRequest) CreatedGte(createdGte string) ApiDcimPowerFeedsListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiDcimPowerFeedsListRequest) CreatedLte(createdLte string) ApiDcimPowerFeedsListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiDcimPowerFeedsListRequest) LastUpdated(lastUpdated string) ApiDcimPowerFeedsListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiDcimPowerFeedsListRequest) LastUpdatedGte(lastUpdatedGte string) ApiDcimPowerFeedsListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiDcimPowerFeedsListRequest) LastUpdatedLte(lastUpdatedLte string) ApiDcimPowerFeedsListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiDcimPowerFeedsListRequest) Cabled(cabled string) ApiDcimPowerFeedsListRequest {
	r.cabled = &cabled
	return r
}

func (r ApiDcimPowerFeedsListRequest) Connected(connected string) ApiDcimPowerFeedsListRequest {
	r.connected = &connected
	return r
}

func (r ApiDcimPowerFeedsListRequest) Q(q string) ApiDcimPowerFeedsListRequest {
	r.q = &q
	return r
}

func (r ApiDcimPowerFeedsListRequest) RegionId(regionId string) ApiDcimPowerFeedsListRequest {
	r.regionId = &regionId
	return r
}

func (r ApiDcimPowerFeedsListRequest) Region(region string) ApiDcimPowerFeedsListRequest {
	r.region = &region
	return r
}

func (r ApiDcimPowerFeedsListRequest) SiteGroupId(siteGroupId string) ApiDcimPowerFeedsListRequest {
	r.siteGroupId = &siteGroupId
	return r
}

func (r ApiDcimPowerFeedsListRequest) SiteGroup(siteGroup string) ApiDcimPowerFeedsListRequest {
	r.siteGroup = &siteGroup
	return r
}

func (r ApiDcimPowerFeedsListRequest) SiteId(siteId string) ApiDcimPowerFeedsListRequest {
	r.siteId = &siteId
	return r
}

func (r ApiDcimPowerFeedsListRequest) Site(site string) ApiDcimPowerFeedsListRequest {
	r.site = &site
	return r
}

func (r ApiDcimPowerFeedsListRequest) PowerPanelId(powerPanelId string) ApiDcimPowerFeedsListRequest {
	r.powerPanelId = &powerPanelId
	return r
}

func (r ApiDcimPowerFeedsListRequest) RackId(rackId string) ApiDcimPowerFeedsListRequest {
	r.rackId = &rackId
	return r
}

func (r ApiDcimPowerFeedsListRequest) Tag(tag string) ApiDcimPowerFeedsListRequest {
	r.tag = &tag
	return r
}

func (r ApiDcimPowerFeedsListRequest) IdN(idN string) ApiDcimPowerFeedsListRequest {
	r.idN = &idN
	return r
}

func (r ApiDcimPowerFeedsListRequest) IdLte(idLte string) ApiDcimPowerFeedsListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiDcimPowerFeedsListRequest) IdLt(idLt string) ApiDcimPowerFeedsListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiDcimPowerFeedsListRequest) IdGte(idGte string) ApiDcimPowerFeedsListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiDcimPowerFeedsListRequest) IdGt(idGt string) ApiDcimPowerFeedsListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiDcimPowerFeedsListRequest) NameN(nameN string) ApiDcimPowerFeedsListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiDcimPowerFeedsListRequest) NameIc(nameIc string) ApiDcimPowerFeedsListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiDcimPowerFeedsListRequest) NameNic(nameNic string) ApiDcimPowerFeedsListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiDcimPowerFeedsListRequest) NameIew(nameIew string) ApiDcimPowerFeedsListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiDcimPowerFeedsListRequest) NameNiew(nameNiew string) ApiDcimPowerFeedsListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiDcimPowerFeedsListRequest) NameIsw(nameIsw string) ApiDcimPowerFeedsListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiDcimPowerFeedsListRequest) NameNisw(nameNisw string) ApiDcimPowerFeedsListRequest {
	r.nameNisw = &nameNisw
	return r
}

func (r ApiDcimPowerFeedsListRequest) NameIe(nameIe string) ApiDcimPowerFeedsListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiDcimPowerFeedsListRequest) NameNie(nameNie string) ApiDcimPowerFeedsListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiDcimPowerFeedsListRequest) NameEmpty(nameEmpty string) ApiDcimPowerFeedsListRequest {
	r.nameEmpty = &nameEmpty
	return r
}

func (r ApiDcimPowerFeedsListRequest) StatusN(statusN string) ApiDcimPowerFeedsListRequest {
	r.statusN = &statusN
	return r
}

func (r ApiDcimPowerFeedsListRequest) TypeN(typeN string) ApiDcimPowerFeedsListRequest {
	r.typeN = &typeN
	return r
}

func (r ApiDcimPowerFeedsListRequest) SupplyN(supplyN string) ApiDcimPowerFeedsListRequest {
	r.supplyN = &supplyN
	return r
}

func (r ApiDcimPowerFeedsListRequest) PhaseN(phaseN string) ApiDcimPowerFeedsListRequest {
	r.phaseN = &phaseN
	return r
}

func (r ApiDcimPowerFeedsListRequest) VoltageN(voltageN string) ApiDcimPowerFeedsListRequest {
	r.voltageN = &voltageN
	return r
}

func (r ApiDcimPowerFeedsListRequest) VoltageLte(voltageLte string) ApiDcimPowerFeedsListRequest {
	r.voltageLte = &voltageLte
	return r
}

func (r ApiDcimPowerFeedsListRequest) VoltageLt(voltageLt string) ApiDcimPowerFeedsListRequest {
	r.voltageLt = &voltageLt
	return r
}

func (r ApiDcimPowerFeedsListRequest) VoltageGte(voltageGte string) ApiDcimPowerFeedsListRequest {
	r.voltageGte = &voltageGte
	return r
}

func (r ApiDcimPowerFeedsListRequest) VoltageGt(voltageGt string) ApiDcimPowerFeedsListRequest {
	r.voltageGt = &voltageGt
	return r
}

func (r ApiDcimPowerFeedsListRequest) AmperageN(amperageN string) ApiDcimPowerFeedsListRequest {
	r.amperageN = &amperageN
	return r
}

func (r ApiDcimPowerFeedsListRequest) AmperageLte(amperageLte string) ApiDcimPowerFeedsListRequest {
	r.amperageLte = &amperageLte
	return r
}

func (r ApiDcimPowerFeedsListRequest) AmperageLt(amperageLt string) ApiDcimPowerFeedsListRequest {
	r.amperageLt = &amperageLt
	return r
}

func (r ApiDcimPowerFeedsListRequest) AmperageGte(amperageGte string) ApiDcimPowerFeedsListRequest {
	r.amperageGte = &amperageGte
	return r
}

func (r ApiDcimPowerFeedsListRequest) AmperageGt(amperageGt string) ApiDcimPowerFeedsListRequest {
	r.amperageGt = &amperageGt
	return r
}

func (r ApiDcimPowerFeedsListRequest) MaxUtilizationN(maxUtilizationN string) ApiDcimPowerFeedsListRequest {
	r.maxUtilizationN = &maxUtilizationN
	return r
}

func (r ApiDcimPowerFeedsListRequest) MaxUtilizationLte(maxUtilizationLte string) ApiDcimPowerFeedsListRequest {
	r.maxUtilizationLte = &maxUtilizationLte
	return r
}

func (r ApiDcimPowerFeedsListRequest) MaxUtilizationLt(maxUtilizationLt string) ApiDcimPowerFeedsListRequest {
	r.maxUtilizationLt = &maxUtilizationLt
	return r
}

func (r ApiDcimPowerFeedsListRequest) MaxUtilizationGte(maxUtilizationGte string) ApiDcimPowerFeedsListRequest {
	r.maxUtilizationGte = &maxUtilizationGte
	return r
}

func (r ApiDcimPowerFeedsListRequest) MaxUtilizationGt(maxUtilizationGt string) ApiDcimPowerFeedsListRequest {
	r.maxUtilizationGt = &maxUtilizationGt
	return r
}

func (r ApiDcimPowerFeedsListRequest) RegionIdN(regionIdN string) ApiDcimPowerFeedsListRequest {
	r.regionIdN = &regionIdN
	return r
}

func (r ApiDcimPowerFeedsListRequest) RegionN(regionN string) ApiDcimPowerFeedsListRequest {
	r.regionN = &regionN
	return r
}

func (r ApiDcimPowerFeedsListRequest) SiteGroupIdN(siteGroupIdN string) ApiDcimPowerFeedsListRequest {
	r.siteGroupIdN = &siteGroupIdN
	return r
}

func (r ApiDcimPowerFeedsListRequest) SiteGroupN(siteGroupN string) ApiDcimPowerFeedsListRequest {
	r.siteGroupN = &siteGroupN
	return r
}

func (r ApiDcimPowerFeedsListRequest) SiteIdN(siteIdN string) ApiDcimPowerFeedsListRequest {
	r.siteIdN = &siteIdN
	return r
}

func (r ApiDcimPowerFeedsListRequest) SiteN(siteN string) ApiDcimPowerFeedsListRequest {
	r.siteN = &siteN
	return r
}

func (r ApiDcimPowerFeedsListRequest) PowerPanelIdN(powerPanelIdN string) ApiDcimPowerFeedsListRequest {
	r.powerPanelIdN = &powerPanelIdN
	return r
}

func (r ApiDcimPowerFeedsListRequest) RackIdN(rackIdN string) ApiDcimPowerFeedsListRequest {
	r.rackIdN = &rackIdN
	return r
}

func (r ApiDcimPowerFeedsListRequest) TagN(tagN string) ApiDcimPowerFeedsListRequest {
	r.tagN = &tagN
	return r
}

// Number of results to return per page.
func (r ApiDcimPowerFeedsListRequest) Limit(limit int32) ApiDcimPowerFeedsListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiDcimPowerFeedsListRequest) Offset(offset int32) ApiDcimPowerFeedsListRequest {
	r.offset = &offset
	return r
}

func (r ApiDcimPowerFeedsListRequest) Execute() (*DcimPowerFeedsList200Response, *http.Response, error) {
	return r.ApiService.DcimPowerFeedsListExecute(r)
}

/*
DcimPowerFeedsList Method for DcimPowerFeedsList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimPowerFeedsListRequest
*/
func (a *DcimApiService) DcimPowerFeedsList(ctx context.Context) ApiDcimPowerFeedsListRequest {
	return ApiDcimPowerFeedsListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DcimPowerFeedsList200Response
func (a *DcimApiService) DcimPowerFeedsListExecute(r ApiDcimPowerFeedsListRequest) (*DcimPowerFeedsList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DcimPowerFeedsList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimPowerFeedsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-feeds/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.status != nil {
		localVarQueryParams.Add("status", parameterToString(*r.status, ""))
	}
	if r.type_ != nil {
		localVarQueryParams.Add("type", parameterToString(*r.type_, ""))
	}
	if r.supply != nil {
		localVarQueryParams.Add("supply", parameterToString(*r.supply, ""))
	}
	if r.phase != nil {
		localVarQueryParams.Add("phase", parameterToString(*r.phase, ""))
	}
	if r.voltage != nil {
		localVarQueryParams.Add("voltage", parameterToString(*r.voltage, ""))
	}
	if r.amperage != nil {
		localVarQueryParams.Add("amperage", parameterToString(*r.amperage, ""))
	}
	if r.maxUtilization != nil {
		localVarQueryParams.Add("max_utilization", parameterToString(*r.maxUtilization, ""))
	}
	if r.created != nil {
		localVarQueryParams.Add("created", parameterToString(*r.created, ""))
	}
	if r.createdGte != nil {
		localVarQueryParams.Add("created__gte", parameterToString(*r.createdGte, ""))
	}
	if r.createdLte != nil {
		localVarQueryParams.Add("created__lte", parameterToString(*r.createdLte, ""))
	}
	if r.lastUpdated != nil {
		localVarQueryParams.Add("last_updated", parameterToString(*r.lastUpdated, ""))
	}
	if r.lastUpdatedGte != nil {
		localVarQueryParams.Add("last_updated__gte", parameterToString(*r.lastUpdatedGte, ""))
	}
	if r.lastUpdatedLte != nil {
		localVarQueryParams.Add("last_updated__lte", parameterToString(*r.lastUpdatedLte, ""))
	}
	if r.cabled != nil {
		localVarQueryParams.Add("cabled", parameterToString(*r.cabled, ""))
	}
	if r.connected != nil {
		localVarQueryParams.Add("connected", parameterToString(*r.connected, ""))
	}
	if r.q != nil {
		localVarQueryParams.Add("q", parameterToString(*r.q, ""))
	}
	if r.regionId != nil {
		localVarQueryParams.Add("region_id", parameterToString(*r.regionId, ""))
	}
	if r.region != nil {
		localVarQueryParams.Add("region", parameterToString(*r.region, ""))
	}
	if r.siteGroupId != nil {
		localVarQueryParams.Add("site_group_id", parameterToString(*r.siteGroupId, ""))
	}
	if r.siteGroup != nil {
		localVarQueryParams.Add("site_group", parameterToString(*r.siteGroup, ""))
	}
	if r.siteId != nil {
		localVarQueryParams.Add("site_id", parameterToString(*r.siteId, ""))
	}
	if r.site != nil {
		localVarQueryParams.Add("site", parameterToString(*r.site, ""))
	}
	if r.powerPanelId != nil {
		localVarQueryParams.Add("power_panel_id", parameterToString(*r.powerPanelId, ""))
	}
	if r.rackId != nil {
		localVarQueryParams.Add("rack_id", parameterToString(*r.rackId, ""))
	}
	if r.tag != nil {
		localVarQueryParams.Add("tag", parameterToString(*r.tag, ""))
	}
	if r.idN != nil {
		localVarQueryParams.Add("id__n", parameterToString(*r.idN, ""))
	}
	if r.idLte != nil {
		localVarQueryParams.Add("id__lte", parameterToString(*r.idLte, ""))
	}
	if r.idLt != nil {
		localVarQueryParams.Add("id__lt", parameterToString(*r.idLt, ""))
	}
	if r.idGte != nil {
		localVarQueryParams.Add("id__gte", parameterToString(*r.idGte, ""))
	}
	if r.idGt != nil {
		localVarQueryParams.Add("id__gt", parameterToString(*r.idGt, ""))
	}
	if r.nameN != nil {
		localVarQueryParams.Add("name__n", parameterToString(*r.nameN, ""))
	}
	if r.nameIc != nil {
		localVarQueryParams.Add("name__ic", parameterToString(*r.nameIc, ""))
	}
	if r.nameNic != nil {
		localVarQueryParams.Add("name__nic", parameterToString(*r.nameNic, ""))
	}
	if r.nameIew != nil {
		localVarQueryParams.Add("name__iew", parameterToString(*r.nameIew, ""))
	}
	if r.nameNiew != nil {
		localVarQueryParams.Add("name__niew", parameterToString(*r.nameNiew, ""))
	}
	if r.nameIsw != nil {
		localVarQueryParams.Add("name__isw", parameterToString(*r.nameIsw, ""))
	}
	if r.nameNisw != nil {
		localVarQueryParams.Add("name__nisw", parameterToString(*r.nameNisw, ""))
	}
	if r.nameIe != nil {
		localVarQueryParams.Add("name__ie", parameterToString(*r.nameIe, ""))
	}
	if r.nameNie != nil {
		localVarQueryParams.Add("name__nie", parameterToString(*r.nameNie, ""))
	}
	if r.nameEmpty != nil {
		localVarQueryParams.Add("name__empty", parameterToString(*r.nameEmpty, ""))
	}
	if r.statusN != nil {
		localVarQueryParams.Add("status__n", parameterToString(*r.statusN, ""))
	}
	if r.typeN != nil {
		localVarQueryParams.Add("type__n", parameterToString(*r.typeN, ""))
	}
	if r.supplyN != nil {
		localVarQueryParams.Add("supply__n", parameterToString(*r.supplyN, ""))
	}
	if r.phaseN != nil {
		localVarQueryParams.Add("phase__n", parameterToString(*r.phaseN, ""))
	}
	if r.voltageN != nil {
		localVarQueryParams.Add("voltage__n", parameterToString(*r.voltageN, ""))
	}
	if r.voltageLte != nil {
		localVarQueryParams.Add("voltage__lte", parameterToString(*r.voltageLte, ""))
	}
	if r.voltageLt != nil {
		localVarQueryParams.Add("voltage__lt", parameterToString(*r.voltageLt, ""))
	}
	if r.voltageGte != nil {
		localVarQueryParams.Add("voltage__gte", parameterToString(*r.voltageGte, ""))
	}
	if r.voltageGt != nil {
		localVarQueryParams.Add("voltage__gt", parameterToString(*r.voltageGt, ""))
	}
	if r.amperageN != nil {
		localVarQueryParams.Add("amperage__n", parameterToString(*r.amperageN, ""))
	}
	if r.amperageLte != nil {
		localVarQueryParams.Add("amperage__lte", parameterToString(*r.amperageLte, ""))
	}
	if r.amperageLt != nil {
		localVarQueryParams.Add("amperage__lt", parameterToString(*r.amperageLt, ""))
	}
	if r.amperageGte != nil {
		localVarQueryParams.Add("amperage__gte", parameterToString(*r.amperageGte, ""))
	}
	if r.amperageGt != nil {
		localVarQueryParams.Add("amperage__gt", parameterToString(*r.amperageGt, ""))
	}
	if r.maxUtilizationN != nil {
		localVarQueryParams.Add("max_utilization__n", parameterToString(*r.maxUtilizationN, ""))
	}
	if r.maxUtilizationLte != nil {
		localVarQueryParams.Add("max_utilization__lte", parameterToString(*r.maxUtilizationLte, ""))
	}
	if r.maxUtilizationLt != nil {
		localVarQueryParams.Add("max_utilization__lt", parameterToString(*r.maxUtilizationLt, ""))
	}
	if r.maxUtilizationGte != nil {
		localVarQueryParams.Add("max_utilization__gte", parameterToString(*r.maxUtilizationGte, ""))
	}
	if r.maxUtilizationGt != nil {
		localVarQueryParams.Add("max_utilization__gt", parameterToString(*r.maxUtilizationGt, ""))
	}
	if r.regionIdN != nil {
		localVarQueryParams.Add("region_id__n", parameterToString(*r.regionIdN, ""))
	}
	if r.regionN != nil {
		localVarQueryParams.Add("region__n", parameterToString(*r.regionN, ""))
	}
	if r.siteGroupIdN != nil {
		localVarQueryParams.Add("site_group_id__n", parameterToString(*r.siteGroupIdN, ""))
	}
	if r.siteGroupN != nil {
		localVarQueryParams.Add("site_group__n", parameterToString(*r.siteGroupN, ""))
	}
	if r.siteIdN != nil {
		localVarQueryParams.Add("site_id__n", parameterToString(*r.siteIdN, ""))
	}
	if r.siteN != nil {
		localVarQueryParams.Add("site__n", parameterToString(*r.siteN, ""))
	}
	if r.powerPanelIdN != nil {
		localVarQueryParams.Add("power_panel_id__n", parameterToString(*r.powerPanelIdN, ""))
	}
	if r.rackIdN != nil {
		localVarQueryParams.Add("rack_id__n", parameterToString(*r.rackIdN, ""))
	}
	if r.tagN != nil {
		localVarQueryParams.Add("tag__n", parameterToString(*r.tagN, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimPowerFeedsPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
	data *WritablePowerFeed
}

func (r ApiDcimPowerFeedsPartialUpdateRequest) Data(data WritablePowerFeed) ApiDcimPowerFeedsPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimPowerFeedsPartialUpdateRequest) Execute() (*PowerFeed, *http.Response, error) {
	return r.ApiService.DcimPowerFeedsPartialUpdateExecute(r)
}

/*
DcimPowerFeedsPartialUpdate Method for DcimPowerFeedsPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this power feed.
 @return ApiDcimPowerFeedsPartialUpdateRequest
*/
func (a *DcimApiService) DcimPowerFeedsPartialUpdate(ctx context.Context, id int32) ApiDcimPowerFeedsPartialUpdateRequest {
	return ApiDcimPowerFeedsPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PowerFeed
func (a *DcimApiService) DcimPowerFeedsPartialUpdateExecute(r ApiDcimPowerFeedsPartialUpdateRequest) (*PowerFeed, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PowerFeed
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimPowerFeedsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-feeds/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimPowerFeedsReadRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
}

func (r ApiDcimPowerFeedsReadRequest) Execute() (*PowerFeed, *http.Response, error) {
	return r.ApiService.DcimPowerFeedsReadExecute(r)
}

/*
DcimPowerFeedsRead Method for DcimPowerFeedsRead

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this power feed.
 @return ApiDcimPowerFeedsReadRequest
*/
func (a *DcimApiService) DcimPowerFeedsRead(ctx context.Context, id int32) ApiDcimPowerFeedsReadRequest {
	return ApiDcimPowerFeedsReadRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PowerFeed
func (a *DcimApiService) DcimPowerFeedsReadExecute(r ApiDcimPowerFeedsReadRequest) (*PowerFeed, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PowerFeed
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimPowerFeedsRead")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-feeds/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimPowerFeedsTraceRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
}

func (r ApiDcimPowerFeedsTraceRequest) Execute() (*PowerFeed, *http.Response, error) {
	return r.ApiService.DcimPowerFeedsTraceExecute(r)
}

/*
DcimPowerFeedsTrace Method for DcimPowerFeedsTrace

Trace a complete cable path and return each segment as a three-tuple of (termination, cable, termination).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this power feed.
 @return ApiDcimPowerFeedsTraceRequest
*/
func (a *DcimApiService) DcimPowerFeedsTrace(ctx context.Context, id int32) ApiDcimPowerFeedsTraceRequest {
	return ApiDcimPowerFeedsTraceRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PowerFeed
func (a *DcimApiService) DcimPowerFeedsTraceExecute(r ApiDcimPowerFeedsTraceRequest) (*PowerFeed, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PowerFeed
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimPowerFeedsTrace")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-feeds/{id}/trace/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimPowerFeedsUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
	data *WritablePowerFeed
}

func (r ApiDcimPowerFeedsUpdateRequest) Data(data WritablePowerFeed) ApiDcimPowerFeedsUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimPowerFeedsUpdateRequest) Execute() (*PowerFeed, *http.Response, error) {
	return r.ApiService.DcimPowerFeedsUpdateExecute(r)
}

/*
DcimPowerFeedsUpdate Method for DcimPowerFeedsUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this power feed.
 @return ApiDcimPowerFeedsUpdateRequest
*/
func (a *DcimApiService) DcimPowerFeedsUpdate(ctx context.Context, id int32) ApiDcimPowerFeedsUpdateRequest {
	return ApiDcimPowerFeedsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PowerFeed
func (a *DcimApiService) DcimPowerFeedsUpdateExecute(r ApiDcimPowerFeedsUpdateRequest) (*PowerFeed, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PowerFeed
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimPowerFeedsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-feeds/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimPowerOutletTemplatesBulkDeleteRequest struct {
	ctx context.Context
	ApiService *DcimApiService
}

func (r ApiDcimPowerOutletTemplatesBulkDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimPowerOutletTemplatesBulkDeleteExecute(r)
}

/*
DcimPowerOutletTemplatesBulkDelete Method for DcimPowerOutletTemplatesBulkDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimPowerOutletTemplatesBulkDeleteRequest
*/
func (a *DcimApiService) DcimPowerOutletTemplatesBulkDelete(ctx context.Context) ApiDcimPowerOutletTemplatesBulkDeleteRequest {
	return ApiDcimPowerOutletTemplatesBulkDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DcimApiService) DcimPowerOutletTemplatesBulkDeleteExecute(r ApiDcimPowerOutletTemplatesBulkDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimPowerOutletTemplatesBulkDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-outlet-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimPowerOutletTemplatesBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	data *WritablePowerOutletTemplate
}

func (r ApiDcimPowerOutletTemplatesBulkPartialUpdateRequest) Data(data WritablePowerOutletTemplate) ApiDcimPowerOutletTemplatesBulkPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimPowerOutletTemplatesBulkPartialUpdateRequest) Execute() (*PowerOutletTemplate, *http.Response, error) {
	return r.ApiService.DcimPowerOutletTemplatesBulkPartialUpdateExecute(r)
}

/*
DcimPowerOutletTemplatesBulkPartialUpdate Method for DcimPowerOutletTemplatesBulkPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimPowerOutletTemplatesBulkPartialUpdateRequest
*/
func (a *DcimApiService) DcimPowerOutletTemplatesBulkPartialUpdate(ctx context.Context) ApiDcimPowerOutletTemplatesBulkPartialUpdateRequest {
	return ApiDcimPowerOutletTemplatesBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PowerOutletTemplate
func (a *DcimApiService) DcimPowerOutletTemplatesBulkPartialUpdateExecute(r ApiDcimPowerOutletTemplatesBulkPartialUpdateRequest) (*PowerOutletTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PowerOutletTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimPowerOutletTemplatesBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-outlet-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimPowerOutletTemplatesBulkUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	data *WritablePowerOutletTemplate
}

func (r ApiDcimPowerOutletTemplatesBulkUpdateRequest) Data(data WritablePowerOutletTemplate) ApiDcimPowerOutletTemplatesBulkUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimPowerOutletTemplatesBulkUpdateRequest) Execute() (*PowerOutletTemplate, *http.Response, error) {
	return r.ApiService.DcimPowerOutletTemplatesBulkUpdateExecute(r)
}

/*
DcimPowerOutletTemplatesBulkUpdate Method for DcimPowerOutletTemplatesBulkUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimPowerOutletTemplatesBulkUpdateRequest
*/
func (a *DcimApiService) DcimPowerOutletTemplatesBulkUpdate(ctx context.Context) ApiDcimPowerOutletTemplatesBulkUpdateRequest {
	return ApiDcimPowerOutletTemplatesBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PowerOutletTemplate
func (a *DcimApiService) DcimPowerOutletTemplatesBulkUpdateExecute(r ApiDcimPowerOutletTemplatesBulkUpdateRequest) (*PowerOutletTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PowerOutletTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimPowerOutletTemplatesBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-outlet-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimPowerOutletTemplatesCreateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	data *WritablePowerOutletTemplate
}

func (r ApiDcimPowerOutletTemplatesCreateRequest) Data(data WritablePowerOutletTemplate) ApiDcimPowerOutletTemplatesCreateRequest {
	r.data = &data
	return r
}

func (r ApiDcimPowerOutletTemplatesCreateRequest) Execute() (*PowerOutletTemplate, *http.Response, error) {
	return r.ApiService.DcimPowerOutletTemplatesCreateExecute(r)
}

/*
DcimPowerOutletTemplatesCreate Method for DcimPowerOutletTemplatesCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimPowerOutletTemplatesCreateRequest
*/
func (a *DcimApiService) DcimPowerOutletTemplatesCreate(ctx context.Context) ApiDcimPowerOutletTemplatesCreateRequest {
	return ApiDcimPowerOutletTemplatesCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PowerOutletTemplate
func (a *DcimApiService) DcimPowerOutletTemplatesCreateExecute(r ApiDcimPowerOutletTemplatesCreateRequest) (*PowerOutletTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PowerOutletTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimPowerOutletTemplatesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-outlet-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimPowerOutletTemplatesDeleteRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
}

func (r ApiDcimPowerOutletTemplatesDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimPowerOutletTemplatesDeleteExecute(r)
}

/*
DcimPowerOutletTemplatesDelete Method for DcimPowerOutletTemplatesDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this power outlet template.
 @return ApiDcimPowerOutletTemplatesDeleteRequest
*/
func (a *DcimApiService) DcimPowerOutletTemplatesDelete(ctx context.Context, id int32) ApiDcimPowerOutletTemplatesDeleteRequest {
	return ApiDcimPowerOutletTemplatesDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DcimApiService) DcimPowerOutletTemplatesDeleteExecute(r ApiDcimPowerOutletTemplatesDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimPowerOutletTemplatesDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-outlet-templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimPowerOutletTemplatesListRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id *string
	name *string
	type_ *string
	feedLeg *string
	created *string
	createdGte *string
	createdLte *string
	lastUpdated *string
	lastUpdatedGte *string
	lastUpdatedLte *string
	devicetypeId *string
	idN *string
	idLte *string
	idLt *string
	idGte *string
	idGt *string
	nameN *string
	nameIc *string
	nameNic *string
	nameIew *string
	nameNiew *string
	nameIsw *string
	nameNisw *string
	nameIe *string
	nameNie *string
	nameEmpty *string
	typeN *string
	feedLegN *string
	devicetypeIdN *string
	limit *int32
	offset *int32
}

func (r ApiDcimPowerOutletTemplatesListRequest) Id(id string) ApiDcimPowerOutletTemplatesListRequest {
	r.id = &id
	return r
}

func (r ApiDcimPowerOutletTemplatesListRequest) Name(name string) ApiDcimPowerOutletTemplatesListRequest {
	r.name = &name
	return r
}

func (r ApiDcimPowerOutletTemplatesListRequest) Type_(type_ string) ApiDcimPowerOutletTemplatesListRequest {
	r.type_ = &type_
	return r
}

func (r ApiDcimPowerOutletTemplatesListRequest) FeedLeg(feedLeg string) ApiDcimPowerOutletTemplatesListRequest {
	r.feedLeg = &feedLeg
	return r
}

func (r ApiDcimPowerOutletTemplatesListRequest) Created(created string) ApiDcimPowerOutletTemplatesListRequest {
	r.created = &created
	return r
}

func (r ApiDcimPowerOutletTemplatesListRequest) CreatedGte(createdGte string) ApiDcimPowerOutletTemplatesListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiDcimPowerOutletTemplatesListRequest) CreatedLte(createdLte string) ApiDcimPowerOutletTemplatesListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiDcimPowerOutletTemplatesListRequest) LastUpdated(lastUpdated string) ApiDcimPowerOutletTemplatesListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiDcimPowerOutletTemplatesListRequest) LastUpdatedGte(lastUpdatedGte string) ApiDcimPowerOutletTemplatesListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiDcimPowerOutletTemplatesListRequest) LastUpdatedLte(lastUpdatedLte string) ApiDcimPowerOutletTemplatesListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiDcimPowerOutletTemplatesListRequest) DevicetypeId(devicetypeId string) ApiDcimPowerOutletTemplatesListRequest {
	r.devicetypeId = &devicetypeId
	return r
}

func (r ApiDcimPowerOutletTemplatesListRequest) IdN(idN string) ApiDcimPowerOutletTemplatesListRequest {
	r.idN = &idN
	return r
}

func (r ApiDcimPowerOutletTemplatesListRequest) IdLte(idLte string) ApiDcimPowerOutletTemplatesListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiDcimPowerOutletTemplatesListRequest) IdLt(idLt string) ApiDcimPowerOutletTemplatesListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiDcimPowerOutletTemplatesListRequest) IdGte(idGte string) ApiDcimPowerOutletTemplatesListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiDcimPowerOutletTemplatesListRequest) IdGt(idGt string) ApiDcimPowerOutletTemplatesListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiDcimPowerOutletTemplatesListRequest) NameN(nameN string) ApiDcimPowerOutletTemplatesListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiDcimPowerOutletTemplatesListRequest) NameIc(nameIc string) ApiDcimPowerOutletTemplatesListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiDcimPowerOutletTemplatesListRequest) NameNic(nameNic string) ApiDcimPowerOutletTemplatesListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiDcimPowerOutletTemplatesListRequest) NameIew(nameIew string) ApiDcimPowerOutletTemplatesListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiDcimPowerOutletTemplatesListRequest) NameNiew(nameNiew string) ApiDcimPowerOutletTemplatesListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiDcimPowerOutletTemplatesListRequest) NameIsw(nameIsw string) ApiDcimPowerOutletTemplatesListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiDcimPowerOutletTemplatesListRequest) NameNisw(nameNisw string) ApiDcimPowerOutletTemplatesListRequest {
	r.nameNisw = &nameNisw
	return r
}

func (r ApiDcimPowerOutletTemplatesListRequest) NameIe(nameIe string) ApiDcimPowerOutletTemplatesListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiDcimPowerOutletTemplatesListRequest) NameNie(nameNie string) ApiDcimPowerOutletTemplatesListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiDcimPowerOutletTemplatesListRequest) NameEmpty(nameEmpty string) ApiDcimPowerOutletTemplatesListRequest {
	r.nameEmpty = &nameEmpty
	return r
}

func (r ApiDcimPowerOutletTemplatesListRequest) TypeN(typeN string) ApiDcimPowerOutletTemplatesListRequest {
	r.typeN = &typeN
	return r
}

func (r ApiDcimPowerOutletTemplatesListRequest) FeedLegN(feedLegN string) ApiDcimPowerOutletTemplatesListRequest {
	r.feedLegN = &feedLegN
	return r
}

func (r ApiDcimPowerOutletTemplatesListRequest) DevicetypeIdN(devicetypeIdN string) ApiDcimPowerOutletTemplatesListRequest {
	r.devicetypeIdN = &devicetypeIdN
	return r
}

// Number of results to return per page.
func (r ApiDcimPowerOutletTemplatesListRequest) Limit(limit int32) ApiDcimPowerOutletTemplatesListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiDcimPowerOutletTemplatesListRequest) Offset(offset int32) ApiDcimPowerOutletTemplatesListRequest {
	r.offset = &offset
	return r
}

func (r ApiDcimPowerOutletTemplatesListRequest) Execute() (*DcimPowerOutletTemplatesList200Response, *http.Response, error) {
	return r.ApiService.DcimPowerOutletTemplatesListExecute(r)
}

/*
DcimPowerOutletTemplatesList Method for DcimPowerOutletTemplatesList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimPowerOutletTemplatesListRequest
*/
func (a *DcimApiService) DcimPowerOutletTemplatesList(ctx context.Context) ApiDcimPowerOutletTemplatesListRequest {
	return ApiDcimPowerOutletTemplatesListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DcimPowerOutletTemplatesList200Response
func (a *DcimApiService) DcimPowerOutletTemplatesListExecute(r ApiDcimPowerOutletTemplatesListRequest) (*DcimPowerOutletTemplatesList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DcimPowerOutletTemplatesList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimPowerOutletTemplatesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-outlet-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.type_ != nil {
		localVarQueryParams.Add("type", parameterToString(*r.type_, ""))
	}
	if r.feedLeg != nil {
		localVarQueryParams.Add("feed_leg", parameterToString(*r.feedLeg, ""))
	}
	if r.created != nil {
		localVarQueryParams.Add("created", parameterToString(*r.created, ""))
	}
	if r.createdGte != nil {
		localVarQueryParams.Add("created__gte", parameterToString(*r.createdGte, ""))
	}
	if r.createdLte != nil {
		localVarQueryParams.Add("created__lte", parameterToString(*r.createdLte, ""))
	}
	if r.lastUpdated != nil {
		localVarQueryParams.Add("last_updated", parameterToString(*r.lastUpdated, ""))
	}
	if r.lastUpdatedGte != nil {
		localVarQueryParams.Add("last_updated__gte", parameterToString(*r.lastUpdatedGte, ""))
	}
	if r.lastUpdatedLte != nil {
		localVarQueryParams.Add("last_updated__lte", parameterToString(*r.lastUpdatedLte, ""))
	}
	if r.devicetypeId != nil {
		localVarQueryParams.Add("devicetype_id", parameterToString(*r.devicetypeId, ""))
	}
	if r.idN != nil {
		localVarQueryParams.Add("id__n", parameterToString(*r.idN, ""))
	}
	if r.idLte != nil {
		localVarQueryParams.Add("id__lte", parameterToString(*r.idLte, ""))
	}
	if r.idLt != nil {
		localVarQueryParams.Add("id__lt", parameterToString(*r.idLt, ""))
	}
	if r.idGte != nil {
		localVarQueryParams.Add("id__gte", parameterToString(*r.idGte, ""))
	}
	if r.idGt != nil {
		localVarQueryParams.Add("id__gt", parameterToString(*r.idGt, ""))
	}
	if r.nameN != nil {
		localVarQueryParams.Add("name__n", parameterToString(*r.nameN, ""))
	}
	if r.nameIc != nil {
		localVarQueryParams.Add("name__ic", parameterToString(*r.nameIc, ""))
	}
	if r.nameNic != nil {
		localVarQueryParams.Add("name__nic", parameterToString(*r.nameNic, ""))
	}
	if r.nameIew != nil {
		localVarQueryParams.Add("name__iew", parameterToString(*r.nameIew, ""))
	}
	if r.nameNiew != nil {
		localVarQueryParams.Add("name__niew", parameterToString(*r.nameNiew, ""))
	}
	if r.nameIsw != nil {
		localVarQueryParams.Add("name__isw", parameterToString(*r.nameIsw, ""))
	}
	if r.nameNisw != nil {
		localVarQueryParams.Add("name__nisw", parameterToString(*r.nameNisw, ""))
	}
	if r.nameIe != nil {
		localVarQueryParams.Add("name__ie", parameterToString(*r.nameIe, ""))
	}
	if r.nameNie != nil {
		localVarQueryParams.Add("name__nie", parameterToString(*r.nameNie, ""))
	}
	if r.nameEmpty != nil {
		localVarQueryParams.Add("name__empty", parameterToString(*r.nameEmpty, ""))
	}
	if r.typeN != nil {
		localVarQueryParams.Add("type__n", parameterToString(*r.typeN, ""))
	}
	if r.feedLegN != nil {
		localVarQueryParams.Add("feed_leg__n", parameterToString(*r.feedLegN, ""))
	}
	if r.devicetypeIdN != nil {
		localVarQueryParams.Add("devicetype_id__n", parameterToString(*r.devicetypeIdN, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimPowerOutletTemplatesPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
	data *WritablePowerOutletTemplate
}

func (r ApiDcimPowerOutletTemplatesPartialUpdateRequest) Data(data WritablePowerOutletTemplate) ApiDcimPowerOutletTemplatesPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimPowerOutletTemplatesPartialUpdateRequest) Execute() (*PowerOutletTemplate, *http.Response, error) {
	return r.ApiService.DcimPowerOutletTemplatesPartialUpdateExecute(r)
}

/*
DcimPowerOutletTemplatesPartialUpdate Method for DcimPowerOutletTemplatesPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this power outlet template.
 @return ApiDcimPowerOutletTemplatesPartialUpdateRequest
*/
func (a *DcimApiService) DcimPowerOutletTemplatesPartialUpdate(ctx context.Context, id int32) ApiDcimPowerOutletTemplatesPartialUpdateRequest {
	return ApiDcimPowerOutletTemplatesPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PowerOutletTemplate
func (a *DcimApiService) DcimPowerOutletTemplatesPartialUpdateExecute(r ApiDcimPowerOutletTemplatesPartialUpdateRequest) (*PowerOutletTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PowerOutletTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimPowerOutletTemplatesPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-outlet-templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimPowerOutletTemplatesReadRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
}

func (r ApiDcimPowerOutletTemplatesReadRequest) Execute() (*PowerOutletTemplate, *http.Response, error) {
	return r.ApiService.DcimPowerOutletTemplatesReadExecute(r)
}

/*
DcimPowerOutletTemplatesRead Method for DcimPowerOutletTemplatesRead

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this power outlet template.
 @return ApiDcimPowerOutletTemplatesReadRequest
*/
func (a *DcimApiService) DcimPowerOutletTemplatesRead(ctx context.Context, id int32) ApiDcimPowerOutletTemplatesReadRequest {
	return ApiDcimPowerOutletTemplatesReadRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PowerOutletTemplate
func (a *DcimApiService) DcimPowerOutletTemplatesReadExecute(r ApiDcimPowerOutletTemplatesReadRequest) (*PowerOutletTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PowerOutletTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimPowerOutletTemplatesRead")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-outlet-templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimPowerOutletTemplatesUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
	data *WritablePowerOutletTemplate
}

func (r ApiDcimPowerOutletTemplatesUpdateRequest) Data(data WritablePowerOutletTemplate) ApiDcimPowerOutletTemplatesUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimPowerOutletTemplatesUpdateRequest) Execute() (*PowerOutletTemplate, *http.Response, error) {
	return r.ApiService.DcimPowerOutletTemplatesUpdateExecute(r)
}

/*
DcimPowerOutletTemplatesUpdate Method for DcimPowerOutletTemplatesUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this power outlet template.
 @return ApiDcimPowerOutletTemplatesUpdateRequest
*/
func (a *DcimApiService) DcimPowerOutletTemplatesUpdate(ctx context.Context, id int32) ApiDcimPowerOutletTemplatesUpdateRequest {
	return ApiDcimPowerOutletTemplatesUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PowerOutletTemplate
func (a *DcimApiService) DcimPowerOutletTemplatesUpdateExecute(r ApiDcimPowerOutletTemplatesUpdateRequest) (*PowerOutletTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PowerOutletTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimPowerOutletTemplatesUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-outlet-templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimPowerOutletsBulkDeleteRequest struct {
	ctx context.Context
	ApiService *DcimApiService
}

func (r ApiDcimPowerOutletsBulkDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimPowerOutletsBulkDeleteExecute(r)
}

/*
DcimPowerOutletsBulkDelete Method for DcimPowerOutletsBulkDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimPowerOutletsBulkDeleteRequest
*/
func (a *DcimApiService) DcimPowerOutletsBulkDelete(ctx context.Context) ApiDcimPowerOutletsBulkDeleteRequest {
	return ApiDcimPowerOutletsBulkDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DcimApiService) DcimPowerOutletsBulkDeleteExecute(r ApiDcimPowerOutletsBulkDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimPowerOutletsBulkDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-outlets/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimPowerOutletsBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	data *WritablePowerOutlet
}

func (r ApiDcimPowerOutletsBulkPartialUpdateRequest) Data(data WritablePowerOutlet) ApiDcimPowerOutletsBulkPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimPowerOutletsBulkPartialUpdateRequest) Execute() (*PowerOutlet, *http.Response, error) {
	return r.ApiService.DcimPowerOutletsBulkPartialUpdateExecute(r)
}

/*
DcimPowerOutletsBulkPartialUpdate Method for DcimPowerOutletsBulkPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimPowerOutletsBulkPartialUpdateRequest
*/
func (a *DcimApiService) DcimPowerOutletsBulkPartialUpdate(ctx context.Context) ApiDcimPowerOutletsBulkPartialUpdateRequest {
	return ApiDcimPowerOutletsBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PowerOutlet
func (a *DcimApiService) DcimPowerOutletsBulkPartialUpdateExecute(r ApiDcimPowerOutletsBulkPartialUpdateRequest) (*PowerOutlet, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PowerOutlet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimPowerOutletsBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-outlets/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimPowerOutletsBulkUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	data *WritablePowerOutlet
}

func (r ApiDcimPowerOutletsBulkUpdateRequest) Data(data WritablePowerOutlet) ApiDcimPowerOutletsBulkUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimPowerOutletsBulkUpdateRequest) Execute() (*PowerOutlet, *http.Response, error) {
	return r.ApiService.DcimPowerOutletsBulkUpdateExecute(r)
}

/*
DcimPowerOutletsBulkUpdate Method for DcimPowerOutletsBulkUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimPowerOutletsBulkUpdateRequest
*/
func (a *DcimApiService) DcimPowerOutletsBulkUpdate(ctx context.Context) ApiDcimPowerOutletsBulkUpdateRequest {
	return ApiDcimPowerOutletsBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PowerOutlet
func (a *DcimApiService) DcimPowerOutletsBulkUpdateExecute(r ApiDcimPowerOutletsBulkUpdateRequest) (*PowerOutlet, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PowerOutlet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimPowerOutletsBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-outlets/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimPowerOutletsCreateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	data *WritablePowerOutlet
}

func (r ApiDcimPowerOutletsCreateRequest) Data(data WritablePowerOutlet) ApiDcimPowerOutletsCreateRequest {
	r.data = &data
	return r
}

func (r ApiDcimPowerOutletsCreateRequest) Execute() (*PowerOutlet, *http.Response, error) {
	return r.ApiService.DcimPowerOutletsCreateExecute(r)
}

/*
DcimPowerOutletsCreate Method for DcimPowerOutletsCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimPowerOutletsCreateRequest
*/
func (a *DcimApiService) DcimPowerOutletsCreate(ctx context.Context) ApiDcimPowerOutletsCreateRequest {
	return ApiDcimPowerOutletsCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PowerOutlet
func (a *DcimApiService) DcimPowerOutletsCreateExecute(r ApiDcimPowerOutletsCreateRequest) (*PowerOutlet, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PowerOutlet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimPowerOutletsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-outlets/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimPowerOutletsDeleteRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
}

func (r ApiDcimPowerOutletsDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimPowerOutletsDeleteExecute(r)
}

/*
DcimPowerOutletsDelete Method for DcimPowerOutletsDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this power outlet.
 @return ApiDcimPowerOutletsDeleteRequest
*/
func (a *DcimApiService) DcimPowerOutletsDelete(ctx context.Context, id int32) ApiDcimPowerOutletsDeleteRequest {
	return ApiDcimPowerOutletsDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DcimApiService) DcimPowerOutletsDeleteExecute(r ApiDcimPowerOutletsDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimPowerOutletsDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-outlets/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimPowerOutletsListRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id *string
	name *string
	label *string
	feedLeg *string
	description *string
	created *string
	createdGte *string
	createdLte *string
	lastUpdated *string
	lastUpdatedGte *string
	lastUpdatedLte *string
	q *string
	regionId *string
	region *string
	siteGroupId *string
	siteGroup *string
	siteId *string
	site *string
	deviceId *string
	device *string
	tag *string
	cabled *string
	connected *string
	type_ *string
	idN *string
	idLte *string
	idLt *string
	idGte *string
	idGt *string
	nameN *string
	nameIc *string
	nameNic *string
	nameIew *string
	nameNiew *string
	nameIsw *string
	nameNisw *string
	nameIe *string
	nameNie *string
	nameEmpty *string
	labelN *string
	labelIc *string
	labelNic *string
	labelIew *string
	labelNiew *string
	labelIsw *string
	labelNisw *string
	labelIe *string
	labelNie *string
	labelEmpty *string
	feedLegN *string
	descriptionN *string
	descriptionIc *string
	descriptionNic *string
	descriptionIew *string
	descriptionNiew *string
	descriptionIsw *string
	descriptionNisw *string
	descriptionIe *string
	descriptionNie *string
	descriptionEmpty *string
	regionIdN *string
	regionN *string
	siteGroupIdN *string
	siteGroupN *string
	siteIdN *string
	siteN *string
	deviceIdN *string
	deviceN *string
	tagN *string
	typeN *string
	limit *int32
	offset *int32
}

func (r ApiDcimPowerOutletsListRequest) Id(id string) ApiDcimPowerOutletsListRequest {
	r.id = &id
	return r
}

func (r ApiDcimPowerOutletsListRequest) Name(name string) ApiDcimPowerOutletsListRequest {
	r.name = &name
	return r
}

func (r ApiDcimPowerOutletsListRequest) Label(label string) ApiDcimPowerOutletsListRequest {
	r.label = &label
	return r
}

func (r ApiDcimPowerOutletsListRequest) FeedLeg(feedLeg string) ApiDcimPowerOutletsListRequest {
	r.feedLeg = &feedLeg
	return r
}

func (r ApiDcimPowerOutletsListRequest) Description(description string) ApiDcimPowerOutletsListRequest {
	r.description = &description
	return r
}

func (r ApiDcimPowerOutletsListRequest) Created(created string) ApiDcimPowerOutletsListRequest {
	r.created = &created
	return r
}

func (r ApiDcimPowerOutletsListRequest) CreatedGte(createdGte string) ApiDcimPowerOutletsListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiDcimPowerOutletsListRequest) CreatedLte(createdLte string) ApiDcimPowerOutletsListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiDcimPowerOutletsListRequest) LastUpdated(lastUpdated string) ApiDcimPowerOutletsListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiDcimPowerOutletsListRequest) LastUpdatedGte(lastUpdatedGte string) ApiDcimPowerOutletsListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiDcimPowerOutletsListRequest) LastUpdatedLte(lastUpdatedLte string) ApiDcimPowerOutletsListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiDcimPowerOutletsListRequest) Q(q string) ApiDcimPowerOutletsListRequest {
	r.q = &q
	return r
}

func (r ApiDcimPowerOutletsListRequest) RegionId(regionId string) ApiDcimPowerOutletsListRequest {
	r.regionId = &regionId
	return r
}

func (r ApiDcimPowerOutletsListRequest) Region(region string) ApiDcimPowerOutletsListRequest {
	r.region = &region
	return r
}

func (r ApiDcimPowerOutletsListRequest) SiteGroupId(siteGroupId string) ApiDcimPowerOutletsListRequest {
	r.siteGroupId = &siteGroupId
	return r
}

func (r ApiDcimPowerOutletsListRequest) SiteGroup(siteGroup string) ApiDcimPowerOutletsListRequest {
	r.siteGroup = &siteGroup
	return r
}

func (r ApiDcimPowerOutletsListRequest) SiteId(siteId string) ApiDcimPowerOutletsListRequest {
	r.siteId = &siteId
	return r
}

func (r ApiDcimPowerOutletsListRequest) Site(site string) ApiDcimPowerOutletsListRequest {
	r.site = &site
	return r
}

func (r ApiDcimPowerOutletsListRequest) DeviceId(deviceId string) ApiDcimPowerOutletsListRequest {
	r.deviceId = &deviceId
	return r
}

func (r ApiDcimPowerOutletsListRequest) Device(device string) ApiDcimPowerOutletsListRequest {
	r.device = &device
	return r
}

func (r ApiDcimPowerOutletsListRequest) Tag(tag string) ApiDcimPowerOutletsListRequest {
	r.tag = &tag
	return r
}

func (r ApiDcimPowerOutletsListRequest) Cabled(cabled string) ApiDcimPowerOutletsListRequest {
	r.cabled = &cabled
	return r
}

func (r ApiDcimPowerOutletsListRequest) Connected(connected string) ApiDcimPowerOutletsListRequest {
	r.connected = &connected
	return r
}

func (r ApiDcimPowerOutletsListRequest) Type_(type_ string) ApiDcimPowerOutletsListRequest {
	r.type_ = &type_
	return r
}

func (r ApiDcimPowerOutletsListRequest) IdN(idN string) ApiDcimPowerOutletsListRequest {
	r.idN = &idN
	return r
}

func (r ApiDcimPowerOutletsListRequest) IdLte(idLte string) ApiDcimPowerOutletsListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiDcimPowerOutletsListRequest) IdLt(idLt string) ApiDcimPowerOutletsListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiDcimPowerOutletsListRequest) IdGte(idGte string) ApiDcimPowerOutletsListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiDcimPowerOutletsListRequest) IdGt(idGt string) ApiDcimPowerOutletsListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiDcimPowerOutletsListRequest) NameN(nameN string) ApiDcimPowerOutletsListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiDcimPowerOutletsListRequest) NameIc(nameIc string) ApiDcimPowerOutletsListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiDcimPowerOutletsListRequest) NameNic(nameNic string) ApiDcimPowerOutletsListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiDcimPowerOutletsListRequest) NameIew(nameIew string) ApiDcimPowerOutletsListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiDcimPowerOutletsListRequest) NameNiew(nameNiew string) ApiDcimPowerOutletsListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiDcimPowerOutletsListRequest) NameIsw(nameIsw string) ApiDcimPowerOutletsListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiDcimPowerOutletsListRequest) NameNisw(nameNisw string) ApiDcimPowerOutletsListRequest {
	r.nameNisw = &nameNisw
	return r
}

func (r ApiDcimPowerOutletsListRequest) NameIe(nameIe string) ApiDcimPowerOutletsListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiDcimPowerOutletsListRequest) NameNie(nameNie string) ApiDcimPowerOutletsListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiDcimPowerOutletsListRequest) NameEmpty(nameEmpty string) ApiDcimPowerOutletsListRequest {
	r.nameEmpty = &nameEmpty
	return r
}

func (r ApiDcimPowerOutletsListRequest) LabelN(labelN string) ApiDcimPowerOutletsListRequest {
	r.labelN = &labelN
	return r
}

func (r ApiDcimPowerOutletsListRequest) LabelIc(labelIc string) ApiDcimPowerOutletsListRequest {
	r.labelIc = &labelIc
	return r
}

func (r ApiDcimPowerOutletsListRequest) LabelNic(labelNic string) ApiDcimPowerOutletsListRequest {
	r.labelNic = &labelNic
	return r
}

func (r ApiDcimPowerOutletsListRequest) LabelIew(labelIew string) ApiDcimPowerOutletsListRequest {
	r.labelIew = &labelIew
	return r
}

func (r ApiDcimPowerOutletsListRequest) LabelNiew(labelNiew string) ApiDcimPowerOutletsListRequest {
	r.labelNiew = &labelNiew
	return r
}

func (r ApiDcimPowerOutletsListRequest) LabelIsw(labelIsw string) ApiDcimPowerOutletsListRequest {
	r.labelIsw = &labelIsw
	return r
}

func (r ApiDcimPowerOutletsListRequest) LabelNisw(labelNisw string) ApiDcimPowerOutletsListRequest {
	r.labelNisw = &labelNisw
	return r
}

func (r ApiDcimPowerOutletsListRequest) LabelIe(labelIe string) ApiDcimPowerOutletsListRequest {
	r.labelIe = &labelIe
	return r
}

func (r ApiDcimPowerOutletsListRequest) LabelNie(labelNie string) ApiDcimPowerOutletsListRequest {
	r.labelNie = &labelNie
	return r
}

func (r ApiDcimPowerOutletsListRequest) LabelEmpty(labelEmpty string) ApiDcimPowerOutletsListRequest {
	r.labelEmpty = &labelEmpty
	return r
}

func (r ApiDcimPowerOutletsListRequest) FeedLegN(feedLegN string) ApiDcimPowerOutletsListRequest {
	r.feedLegN = &feedLegN
	return r
}

func (r ApiDcimPowerOutletsListRequest) DescriptionN(descriptionN string) ApiDcimPowerOutletsListRequest {
	r.descriptionN = &descriptionN
	return r
}

func (r ApiDcimPowerOutletsListRequest) DescriptionIc(descriptionIc string) ApiDcimPowerOutletsListRequest {
	r.descriptionIc = &descriptionIc
	return r
}

func (r ApiDcimPowerOutletsListRequest) DescriptionNic(descriptionNic string) ApiDcimPowerOutletsListRequest {
	r.descriptionNic = &descriptionNic
	return r
}

func (r ApiDcimPowerOutletsListRequest) DescriptionIew(descriptionIew string) ApiDcimPowerOutletsListRequest {
	r.descriptionIew = &descriptionIew
	return r
}

func (r ApiDcimPowerOutletsListRequest) DescriptionNiew(descriptionNiew string) ApiDcimPowerOutletsListRequest {
	r.descriptionNiew = &descriptionNiew
	return r
}

func (r ApiDcimPowerOutletsListRequest) DescriptionIsw(descriptionIsw string) ApiDcimPowerOutletsListRequest {
	r.descriptionIsw = &descriptionIsw
	return r
}

func (r ApiDcimPowerOutletsListRequest) DescriptionNisw(descriptionNisw string) ApiDcimPowerOutletsListRequest {
	r.descriptionNisw = &descriptionNisw
	return r
}

func (r ApiDcimPowerOutletsListRequest) DescriptionIe(descriptionIe string) ApiDcimPowerOutletsListRequest {
	r.descriptionIe = &descriptionIe
	return r
}

func (r ApiDcimPowerOutletsListRequest) DescriptionNie(descriptionNie string) ApiDcimPowerOutletsListRequest {
	r.descriptionNie = &descriptionNie
	return r
}

func (r ApiDcimPowerOutletsListRequest) DescriptionEmpty(descriptionEmpty string) ApiDcimPowerOutletsListRequest {
	r.descriptionEmpty = &descriptionEmpty
	return r
}

func (r ApiDcimPowerOutletsListRequest) RegionIdN(regionIdN string) ApiDcimPowerOutletsListRequest {
	r.regionIdN = &regionIdN
	return r
}

func (r ApiDcimPowerOutletsListRequest) RegionN(regionN string) ApiDcimPowerOutletsListRequest {
	r.regionN = &regionN
	return r
}

func (r ApiDcimPowerOutletsListRequest) SiteGroupIdN(siteGroupIdN string) ApiDcimPowerOutletsListRequest {
	r.siteGroupIdN = &siteGroupIdN
	return r
}

func (r ApiDcimPowerOutletsListRequest) SiteGroupN(siteGroupN string) ApiDcimPowerOutletsListRequest {
	r.siteGroupN = &siteGroupN
	return r
}

func (r ApiDcimPowerOutletsListRequest) SiteIdN(siteIdN string) ApiDcimPowerOutletsListRequest {
	r.siteIdN = &siteIdN
	return r
}

func (r ApiDcimPowerOutletsListRequest) SiteN(siteN string) ApiDcimPowerOutletsListRequest {
	r.siteN = &siteN
	return r
}

func (r ApiDcimPowerOutletsListRequest) DeviceIdN(deviceIdN string) ApiDcimPowerOutletsListRequest {
	r.deviceIdN = &deviceIdN
	return r
}

func (r ApiDcimPowerOutletsListRequest) DeviceN(deviceN string) ApiDcimPowerOutletsListRequest {
	r.deviceN = &deviceN
	return r
}

func (r ApiDcimPowerOutletsListRequest) TagN(tagN string) ApiDcimPowerOutletsListRequest {
	r.tagN = &tagN
	return r
}

func (r ApiDcimPowerOutletsListRequest) TypeN(typeN string) ApiDcimPowerOutletsListRequest {
	r.typeN = &typeN
	return r
}

// Number of results to return per page.
func (r ApiDcimPowerOutletsListRequest) Limit(limit int32) ApiDcimPowerOutletsListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiDcimPowerOutletsListRequest) Offset(offset int32) ApiDcimPowerOutletsListRequest {
	r.offset = &offset
	return r
}

func (r ApiDcimPowerOutletsListRequest) Execute() (*DcimPowerOutletsList200Response, *http.Response, error) {
	return r.ApiService.DcimPowerOutletsListExecute(r)
}

/*
DcimPowerOutletsList Method for DcimPowerOutletsList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimPowerOutletsListRequest
*/
func (a *DcimApiService) DcimPowerOutletsList(ctx context.Context) ApiDcimPowerOutletsListRequest {
	return ApiDcimPowerOutletsListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DcimPowerOutletsList200Response
func (a *DcimApiService) DcimPowerOutletsListExecute(r ApiDcimPowerOutletsListRequest) (*DcimPowerOutletsList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DcimPowerOutletsList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimPowerOutletsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-outlets/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.label != nil {
		localVarQueryParams.Add("label", parameterToString(*r.label, ""))
	}
	if r.feedLeg != nil {
		localVarQueryParams.Add("feed_leg", parameterToString(*r.feedLeg, ""))
	}
	if r.description != nil {
		localVarQueryParams.Add("description", parameterToString(*r.description, ""))
	}
	if r.created != nil {
		localVarQueryParams.Add("created", parameterToString(*r.created, ""))
	}
	if r.createdGte != nil {
		localVarQueryParams.Add("created__gte", parameterToString(*r.createdGte, ""))
	}
	if r.createdLte != nil {
		localVarQueryParams.Add("created__lte", parameterToString(*r.createdLte, ""))
	}
	if r.lastUpdated != nil {
		localVarQueryParams.Add("last_updated", parameterToString(*r.lastUpdated, ""))
	}
	if r.lastUpdatedGte != nil {
		localVarQueryParams.Add("last_updated__gte", parameterToString(*r.lastUpdatedGte, ""))
	}
	if r.lastUpdatedLte != nil {
		localVarQueryParams.Add("last_updated__lte", parameterToString(*r.lastUpdatedLte, ""))
	}
	if r.q != nil {
		localVarQueryParams.Add("q", parameterToString(*r.q, ""))
	}
	if r.regionId != nil {
		localVarQueryParams.Add("region_id", parameterToString(*r.regionId, ""))
	}
	if r.region != nil {
		localVarQueryParams.Add("region", parameterToString(*r.region, ""))
	}
	if r.siteGroupId != nil {
		localVarQueryParams.Add("site_group_id", parameterToString(*r.siteGroupId, ""))
	}
	if r.siteGroup != nil {
		localVarQueryParams.Add("site_group", parameterToString(*r.siteGroup, ""))
	}
	if r.siteId != nil {
		localVarQueryParams.Add("site_id", parameterToString(*r.siteId, ""))
	}
	if r.site != nil {
		localVarQueryParams.Add("site", parameterToString(*r.site, ""))
	}
	if r.deviceId != nil {
		localVarQueryParams.Add("device_id", parameterToString(*r.deviceId, ""))
	}
	if r.device != nil {
		localVarQueryParams.Add("device", parameterToString(*r.device, ""))
	}
	if r.tag != nil {
		localVarQueryParams.Add("tag", parameterToString(*r.tag, ""))
	}
	if r.cabled != nil {
		localVarQueryParams.Add("cabled", parameterToString(*r.cabled, ""))
	}
	if r.connected != nil {
		localVarQueryParams.Add("connected", parameterToString(*r.connected, ""))
	}
	if r.type_ != nil {
		localVarQueryParams.Add("type", parameterToString(*r.type_, ""))
	}
	if r.idN != nil {
		localVarQueryParams.Add("id__n", parameterToString(*r.idN, ""))
	}
	if r.idLte != nil {
		localVarQueryParams.Add("id__lte", parameterToString(*r.idLte, ""))
	}
	if r.idLt != nil {
		localVarQueryParams.Add("id__lt", parameterToString(*r.idLt, ""))
	}
	if r.idGte != nil {
		localVarQueryParams.Add("id__gte", parameterToString(*r.idGte, ""))
	}
	if r.idGt != nil {
		localVarQueryParams.Add("id__gt", parameterToString(*r.idGt, ""))
	}
	if r.nameN != nil {
		localVarQueryParams.Add("name__n", parameterToString(*r.nameN, ""))
	}
	if r.nameIc != nil {
		localVarQueryParams.Add("name__ic", parameterToString(*r.nameIc, ""))
	}
	if r.nameNic != nil {
		localVarQueryParams.Add("name__nic", parameterToString(*r.nameNic, ""))
	}
	if r.nameIew != nil {
		localVarQueryParams.Add("name__iew", parameterToString(*r.nameIew, ""))
	}
	if r.nameNiew != nil {
		localVarQueryParams.Add("name__niew", parameterToString(*r.nameNiew, ""))
	}
	if r.nameIsw != nil {
		localVarQueryParams.Add("name__isw", parameterToString(*r.nameIsw, ""))
	}
	if r.nameNisw != nil {
		localVarQueryParams.Add("name__nisw", parameterToString(*r.nameNisw, ""))
	}
	if r.nameIe != nil {
		localVarQueryParams.Add("name__ie", parameterToString(*r.nameIe, ""))
	}
	if r.nameNie != nil {
		localVarQueryParams.Add("name__nie", parameterToString(*r.nameNie, ""))
	}
	if r.nameEmpty != nil {
		localVarQueryParams.Add("name__empty", parameterToString(*r.nameEmpty, ""))
	}
	if r.labelN != nil {
		localVarQueryParams.Add("label__n", parameterToString(*r.labelN, ""))
	}
	if r.labelIc != nil {
		localVarQueryParams.Add("label__ic", parameterToString(*r.labelIc, ""))
	}
	if r.labelNic != nil {
		localVarQueryParams.Add("label__nic", parameterToString(*r.labelNic, ""))
	}
	if r.labelIew != nil {
		localVarQueryParams.Add("label__iew", parameterToString(*r.labelIew, ""))
	}
	if r.labelNiew != nil {
		localVarQueryParams.Add("label__niew", parameterToString(*r.labelNiew, ""))
	}
	if r.labelIsw != nil {
		localVarQueryParams.Add("label__isw", parameterToString(*r.labelIsw, ""))
	}
	if r.labelNisw != nil {
		localVarQueryParams.Add("label__nisw", parameterToString(*r.labelNisw, ""))
	}
	if r.labelIe != nil {
		localVarQueryParams.Add("label__ie", parameterToString(*r.labelIe, ""))
	}
	if r.labelNie != nil {
		localVarQueryParams.Add("label__nie", parameterToString(*r.labelNie, ""))
	}
	if r.labelEmpty != nil {
		localVarQueryParams.Add("label__empty", parameterToString(*r.labelEmpty, ""))
	}
	if r.feedLegN != nil {
		localVarQueryParams.Add("feed_leg__n", parameterToString(*r.feedLegN, ""))
	}
	if r.descriptionN != nil {
		localVarQueryParams.Add("description__n", parameterToString(*r.descriptionN, ""))
	}
	if r.descriptionIc != nil {
		localVarQueryParams.Add("description__ic", parameterToString(*r.descriptionIc, ""))
	}
	if r.descriptionNic != nil {
		localVarQueryParams.Add("description__nic", parameterToString(*r.descriptionNic, ""))
	}
	if r.descriptionIew != nil {
		localVarQueryParams.Add("description__iew", parameterToString(*r.descriptionIew, ""))
	}
	if r.descriptionNiew != nil {
		localVarQueryParams.Add("description__niew", parameterToString(*r.descriptionNiew, ""))
	}
	if r.descriptionIsw != nil {
		localVarQueryParams.Add("description__isw", parameterToString(*r.descriptionIsw, ""))
	}
	if r.descriptionNisw != nil {
		localVarQueryParams.Add("description__nisw", parameterToString(*r.descriptionNisw, ""))
	}
	if r.descriptionIe != nil {
		localVarQueryParams.Add("description__ie", parameterToString(*r.descriptionIe, ""))
	}
	if r.descriptionNie != nil {
		localVarQueryParams.Add("description__nie", parameterToString(*r.descriptionNie, ""))
	}
	if r.descriptionEmpty != nil {
		localVarQueryParams.Add("description__empty", parameterToString(*r.descriptionEmpty, ""))
	}
	if r.regionIdN != nil {
		localVarQueryParams.Add("region_id__n", parameterToString(*r.regionIdN, ""))
	}
	if r.regionN != nil {
		localVarQueryParams.Add("region__n", parameterToString(*r.regionN, ""))
	}
	if r.siteGroupIdN != nil {
		localVarQueryParams.Add("site_group_id__n", parameterToString(*r.siteGroupIdN, ""))
	}
	if r.siteGroupN != nil {
		localVarQueryParams.Add("site_group__n", parameterToString(*r.siteGroupN, ""))
	}
	if r.siteIdN != nil {
		localVarQueryParams.Add("site_id__n", parameterToString(*r.siteIdN, ""))
	}
	if r.siteN != nil {
		localVarQueryParams.Add("site__n", parameterToString(*r.siteN, ""))
	}
	if r.deviceIdN != nil {
		localVarQueryParams.Add("device_id__n", parameterToString(*r.deviceIdN, ""))
	}
	if r.deviceN != nil {
		localVarQueryParams.Add("device__n", parameterToString(*r.deviceN, ""))
	}
	if r.tagN != nil {
		localVarQueryParams.Add("tag__n", parameterToString(*r.tagN, ""))
	}
	if r.typeN != nil {
		localVarQueryParams.Add("type__n", parameterToString(*r.typeN, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimPowerOutletsPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
	data *WritablePowerOutlet
}

func (r ApiDcimPowerOutletsPartialUpdateRequest) Data(data WritablePowerOutlet) ApiDcimPowerOutletsPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimPowerOutletsPartialUpdateRequest) Execute() (*PowerOutlet, *http.Response, error) {
	return r.ApiService.DcimPowerOutletsPartialUpdateExecute(r)
}

/*
DcimPowerOutletsPartialUpdate Method for DcimPowerOutletsPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this power outlet.
 @return ApiDcimPowerOutletsPartialUpdateRequest
*/
func (a *DcimApiService) DcimPowerOutletsPartialUpdate(ctx context.Context, id int32) ApiDcimPowerOutletsPartialUpdateRequest {
	return ApiDcimPowerOutletsPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PowerOutlet
func (a *DcimApiService) DcimPowerOutletsPartialUpdateExecute(r ApiDcimPowerOutletsPartialUpdateRequest) (*PowerOutlet, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PowerOutlet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimPowerOutletsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-outlets/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimPowerOutletsReadRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
}

func (r ApiDcimPowerOutletsReadRequest) Execute() (*PowerOutlet, *http.Response, error) {
	return r.ApiService.DcimPowerOutletsReadExecute(r)
}

/*
DcimPowerOutletsRead Method for DcimPowerOutletsRead

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this power outlet.
 @return ApiDcimPowerOutletsReadRequest
*/
func (a *DcimApiService) DcimPowerOutletsRead(ctx context.Context, id int32) ApiDcimPowerOutletsReadRequest {
	return ApiDcimPowerOutletsReadRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PowerOutlet
func (a *DcimApiService) DcimPowerOutletsReadExecute(r ApiDcimPowerOutletsReadRequest) (*PowerOutlet, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PowerOutlet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimPowerOutletsRead")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-outlets/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimPowerOutletsTraceRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
}

func (r ApiDcimPowerOutletsTraceRequest) Execute() (*PowerOutlet, *http.Response, error) {
	return r.ApiService.DcimPowerOutletsTraceExecute(r)
}

/*
DcimPowerOutletsTrace Method for DcimPowerOutletsTrace

Trace a complete cable path and return each segment as a three-tuple of (termination, cable, termination).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this power outlet.
 @return ApiDcimPowerOutletsTraceRequest
*/
func (a *DcimApiService) DcimPowerOutletsTrace(ctx context.Context, id int32) ApiDcimPowerOutletsTraceRequest {
	return ApiDcimPowerOutletsTraceRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PowerOutlet
func (a *DcimApiService) DcimPowerOutletsTraceExecute(r ApiDcimPowerOutletsTraceRequest) (*PowerOutlet, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PowerOutlet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimPowerOutletsTrace")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-outlets/{id}/trace/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimPowerOutletsUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
	data *WritablePowerOutlet
}

func (r ApiDcimPowerOutletsUpdateRequest) Data(data WritablePowerOutlet) ApiDcimPowerOutletsUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimPowerOutletsUpdateRequest) Execute() (*PowerOutlet, *http.Response, error) {
	return r.ApiService.DcimPowerOutletsUpdateExecute(r)
}

/*
DcimPowerOutletsUpdate Method for DcimPowerOutletsUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this power outlet.
 @return ApiDcimPowerOutletsUpdateRequest
*/
func (a *DcimApiService) DcimPowerOutletsUpdate(ctx context.Context, id int32) ApiDcimPowerOutletsUpdateRequest {
	return ApiDcimPowerOutletsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PowerOutlet
func (a *DcimApiService) DcimPowerOutletsUpdateExecute(r ApiDcimPowerOutletsUpdateRequest) (*PowerOutlet, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PowerOutlet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimPowerOutletsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-outlets/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimPowerPanelsBulkDeleteRequest struct {
	ctx context.Context
	ApiService *DcimApiService
}

func (r ApiDcimPowerPanelsBulkDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimPowerPanelsBulkDeleteExecute(r)
}

/*
DcimPowerPanelsBulkDelete Method for DcimPowerPanelsBulkDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimPowerPanelsBulkDeleteRequest
*/
func (a *DcimApiService) DcimPowerPanelsBulkDelete(ctx context.Context) ApiDcimPowerPanelsBulkDeleteRequest {
	return ApiDcimPowerPanelsBulkDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DcimApiService) DcimPowerPanelsBulkDeleteExecute(r ApiDcimPowerPanelsBulkDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimPowerPanelsBulkDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-panels/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimPowerPanelsBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	data *WritablePowerPanel
}

func (r ApiDcimPowerPanelsBulkPartialUpdateRequest) Data(data WritablePowerPanel) ApiDcimPowerPanelsBulkPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimPowerPanelsBulkPartialUpdateRequest) Execute() (*PowerPanel, *http.Response, error) {
	return r.ApiService.DcimPowerPanelsBulkPartialUpdateExecute(r)
}

/*
DcimPowerPanelsBulkPartialUpdate Method for DcimPowerPanelsBulkPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimPowerPanelsBulkPartialUpdateRequest
*/
func (a *DcimApiService) DcimPowerPanelsBulkPartialUpdate(ctx context.Context) ApiDcimPowerPanelsBulkPartialUpdateRequest {
	return ApiDcimPowerPanelsBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PowerPanel
func (a *DcimApiService) DcimPowerPanelsBulkPartialUpdateExecute(r ApiDcimPowerPanelsBulkPartialUpdateRequest) (*PowerPanel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PowerPanel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimPowerPanelsBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-panels/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimPowerPanelsBulkUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	data *WritablePowerPanel
}

func (r ApiDcimPowerPanelsBulkUpdateRequest) Data(data WritablePowerPanel) ApiDcimPowerPanelsBulkUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimPowerPanelsBulkUpdateRequest) Execute() (*PowerPanel, *http.Response, error) {
	return r.ApiService.DcimPowerPanelsBulkUpdateExecute(r)
}

/*
DcimPowerPanelsBulkUpdate Method for DcimPowerPanelsBulkUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimPowerPanelsBulkUpdateRequest
*/
func (a *DcimApiService) DcimPowerPanelsBulkUpdate(ctx context.Context) ApiDcimPowerPanelsBulkUpdateRequest {
	return ApiDcimPowerPanelsBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PowerPanel
func (a *DcimApiService) DcimPowerPanelsBulkUpdateExecute(r ApiDcimPowerPanelsBulkUpdateRequest) (*PowerPanel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PowerPanel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimPowerPanelsBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-panels/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimPowerPanelsCreateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	data *WritablePowerPanel
}

func (r ApiDcimPowerPanelsCreateRequest) Data(data WritablePowerPanel) ApiDcimPowerPanelsCreateRequest {
	r.data = &data
	return r
}

func (r ApiDcimPowerPanelsCreateRequest) Execute() (*PowerPanel, *http.Response, error) {
	return r.ApiService.DcimPowerPanelsCreateExecute(r)
}

/*
DcimPowerPanelsCreate Method for DcimPowerPanelsCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimPowerPanelsCreateRequest
*/
func (a *DcimApiService) DcimPowerPanelsCreate(ctx context.Context) ApiDcimPowerPanelsCreateRequest {
	return ApiDcimPowerPanelsCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PowerPanel
func (a *DcimApiService) DcimPowerPanelsCreateExecute(r ApiDcimPowerPanelsCreateRequest) (*PowerPanel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PowerPanel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimPowerPanelsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-panels/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimPowerPanelsDeleteRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
}

func (r ApiDcimPowerPanelsDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimPowerPanelsDeleteExecute(r)
}

/*
DcimPowerPanelsDelete Method for DcimPowerPanelsDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this power panel.
 @return ApiDcimPowerPanelsDeleteRequest
*/
func (a *DcimApiService) DcimPowerPanelsDelete(ctx context.Context, id int32) ApiDcimPowerPanelsDeleteRequest {
	return ApiDcimPowerPanelsDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DcimApiService) DcimPowerPanelsDeleteExecute(r ApiDcimPowerPanelsDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimPowerPanelsDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-panels/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimPowerPanelsListRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id *string
	name *string
	created *string
	createdGte *string
	createdLte *string
	lastUpdated *string
	lastUpdatedGte *string
	lastUpdatedLte *string
	q *string
	regionId *string
	region *string
	siteGroupId *string
	siteGroup *string
	siteId *string
	site *string
	locationId *string
	tag *string
	idN *string
	idLte *string
	idLt *string
	idGte *string
	idGt *string
	nameN *string
	nameIc *string
	nameNic *string
	nameIew *string
	nameNiew *string
	nameIsw *string
	nameNisw *string
	nameIe *string
	nameNie *string
	nameEmpty *string
	regionIdN *string
	regionN *string
	siteGroupIdN *string
	siteGroupN *string
	siteIdN *string
	siteN *string
	locationIdN *string
	tagN *string
	limit *int32
	offset *int32
}

func (r ApiDcimPowerPanelsListRequest) Id(id string) ApiDcimPowerPanelsListRequest {
	r.id = &id
	return r
}

func (r ApiDcimPowerPanelsListRequest) Name(name string) ApiDcimPowerPanelsListRequest {
	r.name = &name
	return r
}

func (r ApiDcimPowerPanelsListRequest) Created(created string) ApiDcimPowerPanelsListRequest {
	r.created = &created
	return r
}

func (r ApiDcimPowerPanelsListRequest) CreatedGte(createdGte string) ApiDcimPowerPanelsListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiDcimPowerPanelsListRequest) CreatedLte(createdLte string) ApiDcimPowerPanelsListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiDcimPowerPanelsListRequest) LastUpdated(lastUpdated string) ApiDcimPowerPanelsListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiDcimPowerPanelsListRequest) LastUpdatedGte(lastUpdatedGte string) ApiDcimPowerPanelsListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiDcimPowerPanelsListRequest) LastUpdatedLte(lastUpdatedLte string) ApiDcimPowerPanelsListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiDcimPowerPanelsListRequest) Q(q string) ApiDcimPowerPanelsListRequest {
	r.q = &q
	return r
}

func (r ApiDcimPowerPanelsListRequest) RegionId(regionId string) ApiDcimPowerPanelsListRequest {
	r.regionId = &regionId
	return r
}

func (r ApiDcimPowerPanelsListRequest) Region(region string) ApiDcimPowerPanelsListRequest {
	r.region = &region
	return r
}

func (r ApiDcimPowerPanelsListRequest) SiteGroupId(siteGroupId string) ApiDcimPowerPanelsListRequest {
	r.siteGroupId = &siteGroupId
	return r
}

func (r ApiDcimPowerPanelsListRequest) SiteGroup(siteGroup string) ApiDcimPowerPanelsListRequest {
	r.siteGroup = &siteGroup
	return r
}

func (r ApiDcimPowerPanelsListRequest) SiteId(siteId string) ApiDcimPowerPanelsListRequest {
	r.siteId = &siteId
	return r
}

func (r ApiDcimPowerPanelsListRequest) Site(site string) ApiDcimPowerPanelsListRequest {
	r.site = &site
	return r
}

func (r ApiDcimPowerPanelsListRequest) LocationId(locationId string) ApiDcimPowerPanelsListRequest {
	r.locationId = &locationId
	return r
}

func (r ApiDcimPowerPanelsListRequest) Tag(tag string) ApiDcimPowerPanelsListRequest {
	r.tag = &tag
	return r
}

func (r ApiDcimPowerPanelsListRequest) IdN(idN string) ApiDcimPowerPanelsListRequest {
	r.idN = &idN
	return r
}

func (r ApiDcimPowerPanelsListRequest) IdLte(idLte string) ApiDcimPowerPanelsListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiDcimPowerPanelsListRequest) IdLt(idLt string) ApiDcimPowerPanelsListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiDcimPowerPanelsListRequest) IdGte(idGte string) ApiDcimPowerPanelsListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiDcimPowerPanelsListRequest) IdGt(idGt string) ApiDcimPowerPanelsListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiDcimPowerPanelsListRequest) NameN(nameN string) ApiDcimPowerPanelsListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiDcimPowerPanelsListRequest) NameIc(nameIc string) ApiDcimPowerPanelsListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiDcimPowerPanelsListRequest) NameNic(nameNic string) ApiDcimPowerPanelsListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiDcimPowerPanelsListRequest) NameIew(nameIew string) ApiDcimPowerPanelsListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiDcimPowerPanelsListRequest) NameNiew(nameNiew string) ApiDcimPowerPanelsListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiDcimPowerPanelsListRequest) NameIsw(nameIsw string) ApiDcimPowerPanelsListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiDcimPowerPanelsListRequest) NameNisw(nameNisw string) ApiDcimPowerPanelsListRequest {
	r.nameNisw = &nameNisw
	return r
}

func (r ApiDcimPowerPanelsListRequest) NameIe(nameIe string) ApiDcimPowerPanelsListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiDcimPowerPanelsListRequest) NameNie(nameNie string) ApiDcimPowerPanelsListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiDcimPowerPanelsListRequest) NameEmpty(nameEmpty string) ApiDcimPowerPanelsListRequest {
	r.nameEmpty = &nameEmpty
	return r
}

func (r ApiDcimPowerPanelsListRequest) RegionIdN(regionIdN string) ApiDcimPowerPanelsListRequest {
	r.regionIdN = &regionIdN
	return r
}

func (r ApiDcimPowerPanelsListRequest) RegionN(regionN string) ApiDcimPowerPanelsListRequest {
	r.regionN = &regionN
	return r
}

func (r ApiDcimPowerPanelsListRequest) SiteGroupIdN(siteGroupIdN string) ApiDcimPowerPanelsListRequest {
	r.siteGroupIdN = &siteGroupIdN
	return r
}

func (r ApiDcimPowerPanelsListRequest) SiteGroupN(siteGroupN string) ApiDcimPowerPanelsListRequest {
	r.siteGroupN = &siteGroupN
	return r
}

func (r ApiDcimPowerPanelsListRequest) SiteIdN(siteIdN string) ApiDcimPowerPanelsListRequest {
	r.siteIdN = &siteIdN
	return r
}

func (r ApiDcimPowerPanelsListRequest) SiteN(siteN string) ApiDcimPowerPanelsListRequest {
	r.siteN = &siteN
	return r
}

func (r ApiDcimPowerPanelsListRequest) LocationIdN(locationIdN string) ApiDcimPowerPanelsListRequest {
	r.locationIdN = &locationIdN
	return r
}

func (r ApiDcimPowerPanelsListRequest) TagN(tagN string) ApiDcimPowerPanelsListRequest {
	r.tagN = &tagN
	return r
}

// Number of results to return per page.
func (r ApiDcimPowerPanelsListRequest) Limit(limit int32) ApiDcimPowerPanelsListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiDcimPowerPanelsListRequest) Offset(offset int32) ApiDcimPowerPanelsListRequest {
	r.offset = &offset
	return r
}

func (r ApiDcimPowerPanelsListRequest) Execute() (*DcimPowerPanelsList200Response, *http.Response, error) {
	return r.ApiService.DcimPowerPanelsListExecute(r)
}

/*
DcimPowerPanelsList Method for DcimPowerPanelsList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimPowerPanelsListRequest
*/
func (a *DcimApiService) DcimPowerPanelsList(ctx context.Context) ApiDcimPowerPanelsListRequest {
	return ApiDcimPowerPanelsListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DcimPowerPanelsList200Response
func (a *DcimApiService) DcimPowerPanelsListExecute(r ApiDcimPowerPanelsListRequest) (*DcimPowerPanelsList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DcimPowerPanelsList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimPowerPanelsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-panels/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.created != nil {
		localVarQueryParams.Add("created", parameterToString(*r.created, ""))
	}
	if r.createdGte != nil {
		localVarQueryParams.Add("created__gte", parameterToString(*r.createdGte, ""))
	}
	if r.createdLte != nil {
		localVarQueryParams.Add("created__lte", parameterToString(*r.createdLte, ""))
	}
	if r.lastUpdated != nil {
		localVarQueryParams.Add("last_updated", parameterToString(*r.lastUpdated, ""))
	}
	if r.lastUpdatedGte != nil {
		localVarQueryParams.Add("last_updated__gte", parameterToString(*r.lastUpdatedGte, ""))
	}
	if r.lastUpdatedLte != nil {
		localVarQueryParams.Add("last_updated__lte", parameterToString(*r.lastUpdatedLte, ""))
	}
	if r.q != nil {
		localVarQueryParams.Add("q", parameterToString(*r.q, ""))
	}
	if r.regionId != nil {
		localVarQueryParams.Add("region_id", parameterToString(*r.regionId, ""))
	}
	if r.region != nil {
		localVarQueryParams.Add("region", parameterToString(*r.region, ""))
	}
	if r.siteGroupId != nil {
		localVarQueryParams.Add("site_group_id", parameterToString(*r.siteGroupId, ""))
	}
	if r.siteGroup != nil {
		localVarQueryParams.Add("site_group", parameterToString(*r.siteGroup, ""))
	}
	if r.siteId != nil {
		localVarQueryParams.Add("site_id", parameterToString(*r.siteId, ""))
	}
	if r.site != nil {
		localVarQueryParams.Add("site", parameterToString(*r.site, ""))
	}
	if r.locationId != nil {
		localVarQueryParams.Add("location_id", parameterToString(*r.locationId, ""))
	}
	if r.tag != nil {
		localVarQueryParams.Add("tag", parameterToString(*r.tag, ""))
	}
	if r.idN != nil {
		localVarQueryParams.Add("id__n", parameterToString(*r.idN, ""))
	}
	if r.idLte != nil {
		localVarQueryParams.Add("id__lte", parameterToString(*r.idLte, ""))
	}
	if r.idLt != nil {
		localVarQueryParams.Add("id__lt", parameterToString(*r.idLt, ""))
	}
	if r.idGte != nil {
		localVarQueryParams.Add("id__gte", parameterToString(*r.idGte, ""))
	}
	if r.idGt != nil {
		localVarQueryParams.Add("id__gt", parameterToString(*r.idGt, ""))
	}
	if r.nameN != nil {
		localVarQueryParams.Add("name__n", parameterToString(*r.nameN, ""))
	}
	if r.nameIc != nil {
		localVarQueryParams.Add("name__ic", parameterToString(*r.nameIc, ""))
	}
	if r.nameNic != nil {
		localVarQueryParams.Add("name__nic", parameterToString(*r.nameNic, ""))
	}
	if r.nameIew != nil {
		localVarQueryParams.Add("name__iew", parameterToString(*r.nameIew, ""))
	}
	if r.nameNiew != nil {
		localVarQueryParams.Add("name__niew", parameterToString(*r.nameNiew, ""))
	}
	if r.nameIsw != nil {
		localVarQueryParams.Add("name__isw", parameterToString(*r.nameIsw, ""))
	}
	if r.nameNisw != nil {
		localVarQueryParams.Add("name__nisw", parameterToString(*r.nameNisw, ""))
	}
	if r.nameIe != nil {
		localVarQueryParams.Add("name__ie", parameterToString(*r.nameIe, ""))
	}
	if r.nameNie != nil {
		localVarQueryParams.Add("name__nie", parameterToString(*r.nameNie, ""))
	}
	if r.nameEmpty != nil {
		localVarQueryParams.Add("name__empty", parameterToString(*r.nameEmpty, ""))
	}
	if r.regionIdN != nil {
		localVarQueryParams.Add("region_id__n", parameterToString(*r.regionIdN, ""))
	}
	if r.regionN != nil {
		localVarQueryParams.Add("region__n", parameterToString(*r.regionN, ""))
	}
	if r.siteGroupIdN != nil {
		localVarQueryParams.Add("site_group_id__n", parameterToString(*r.siteGroupIdN, ""))
	}
	if r.siteGroupN != nil {
		localVarQueryParams.Add("site_group__n", parameterToString(*r.siteGroupN, ""))
	}
	if r.siteIdN != nil {
		localVarQueryParams.Add("site_id__n", parameterToString(*r.siteIdN, ""))
	}
	if r.siteN != nil {
		localVarQueryParams.Add("site__n", parameterToString(*r.siteN, ""))
	}
	if r.locationIdN != nil {
		localVarQueryParams.Add("location_id__n", parameterToString(*r.locationIdN, ""))
	}
	if r.tagN != nil {
		localVarQueryParams.Add("tag__n", parameterToString(*r.tagN, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimPowerPanelsPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
	data *WritablePowerPanel
}

func (r ApiDcimPowerPanelsPartialUpdateRequest) Data(data WritablePowerPanel) ApiDcimPowerPanelsPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimPowerPanelsPartialUpdateRequest) Execute() (*PowerPanel, *http.Response, error) {
	return r.ApiService.DcimPowerPanelsPartialUpdateExecute(r)
}

/*
DcimPowerPanelsPartialUpdate Method for DcimPowerPanelsPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this power panel.
 @return ApiDcimPowerPanelsPartialUpdateRequest
*/
func (a *DcimApiService) DcimPowerPanelsPartialUpdate(ctx context.Context, id int32) ApiDcimPowerPanelsPartialUpdateRequest {
	return ApiDcimPowerPanelsPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PowerPanel
func (a *DcimApiService) DcimPowerPanelsPartialUpdateExecute(r ApiDcimPowerPanelsPartialUpdateRequest) (*PowerPanel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PowerPanel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimPowerPanelsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-panels/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimPowerPanelsReadRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
}

func (r ApiDcimPowerPanelsReadRequest) Execute() (*PowerPanel, *http.Response, error) {
	return r.ApiService.DcimPowerPanelsReadExecute(r)
}

/*
DcimPowerPanelsRead Method for DcimPowerPanelsRead

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this power panel.
 @return ApiDcimPowerPanelsReadRequest
*/
func (a *DcimApiService) DcimPowerPanelsRead(ctx context.Context, id int32) ApiDcimPowerPanelsReadRequest {
	return ApiDcimPowerPanelsReadRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PowerPanel
func (a *DcimApiService) DcimPowerPanelsReadExecute(r ApiDcimPowerPanelsReadRequest) (*PowerPanel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PowerPanel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimPowerPanelsRead")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-panels/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimPowerPanelsUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
	data *WritablePowerPanel
}

func (r ApiDcimPowerPanelsUpdateRequest) Data(data WritablePowerPanel) ApiDcimPowerPanelsUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimPowerPanelsUpdateRequest) Execute() (*PowerPanel, *http.Response, error) {
	return r.ApiService.DcimPowerPanelsUpdateExecute(r)
}

/*
DcimPowerPanelsUpdate Method for DcimPowerPanelsUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this power panel.
 @return ApiDcimPowerPanelsUpdateRequest
*/
func (a *DcimApiService) DcimPowerPanelsUpdate(ctx context.Context, id int32) ApiDcimPowerPanelsUpdateRequest {
	return ApiDcimPowerPanelsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PowerPanel
func (a *DcimApiService) DcimPowerPanelsUpdateExecute(r ApiDcimPowerPanelsUpdateRequest) (*PowerPanel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PowerPanel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimPowerPanelsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-panels/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimPowerPortTemplatesBulkDeleteRequest struct {
	ctx context.Context
	ApiService *DcimApiService
}

func (r ApiDcimPowerPortTemplatesBulkDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimPowerPortTemplatesBulkDeleteExecute(r)
}

/*
DcimPowerPortTemplatesBulkDelete Method for DcimPowerPortTemplatesBulkDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimPowerPortTemplatesBulkDeleteRequest
*/
func (a *DcimApiService) DcimPowerPortTemplatesBulkDelete(ctx context.Context) ApiDcimPowerPortTemplatesBulkDeleteRequest {
	return ApiDcimPowerPortTemplatesBulkDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DcimApiService) DcimPowerPortTemplatesBulkDeleteExecute(r ApiDcimPowerPortTemplatesBulkDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimPowerPortTemplatesBulkDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-port-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimPowerPortTemplatesBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	data *WritablePowerPortTemplate
}

func (r ApiDcimPowerPortTemplatesBulkPartialUpdateRequest) Data(data WritablePowerPortTemplate) ApiDcimPowerPortTemplatesBulkPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimPowerPortTemplatesBulkPartialUpdateRequest) Execute() (*PowerPortTemplate, *http.Response, error) {
	return r.ApiService.DcimPowerPortTemplatesBulkPartialUpdateExecute(r)
}

/*
DcimPowerPortTemplatesBulkPartialUpdate Method for DcimPowerPortTemplatesBulkPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimPowerPortTemplatesBulkPartialUpdateRequest
*/
func (a *DcimApiService) DcimPowerPortTemplatesBulkPartialUpdate(ctx context.Context) ApiDcimPowerPortTemplatesBulkPartialUpdateRequest {
	return ApiDcimPowerPortTemplatesBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PowerPortTemplate
func (a *DcimApiService) DcimPowerPortTemplatesBulkPartialUpdateExecute(r ApiDcimPowerPortTemplatesBulkPartialUpdateRequest) (*PowerPortTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PowerPortTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimPowerPortTemplatesBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-port-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimPowerPortTemplatesBulkUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	data *WritablePowerPortTemplate
}

func (r ApiDcimPowerPortTemplatesBulkUpdateRequest) Data(data WritablePowerPortTemplate) ApiDcimPowerPortTemplatesBulkUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimPowerPortTemplatesBulkUpdateRequest) Execute() (*PowerPortTemplate, *http.Response, error) {
	return r.ApiService.DcimPowerPortTemplatesBulkUpdateExecute(r)
}

/*
DcimPowerPortTemplatesBulkUpdate Method for DcimPowerPortTemplatesBulkUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimPowerPortTemplatesBulkUpdateRequest
*/
func (a *DcimApiService) DcimPowerPortTemplatesBulkUpdate(ctx context.Context) ApiDcimPowerPortTemplatesBulkUpdateRequest {
	return ApiDcimPowerPortTemplatesBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PowerPortTemplate
func (a *DcimApiService) DcimPowerPortTemplatesBulkUpdateExecute(r ApiDcimPowerPortTemplatesBulkUpdateRequest) (*PowerPortTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PowerPortTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimPowerPortTemplatesBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-port-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimPowerPortTemplatesCreateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	data *WritablePowerPortTemplate
}

func (r ApiDcimPowerPortTemplatesCreateRequest) Data(data WritablePowerPortTemplate) ApiDcimPowerPortTemplatesCreateRequest {
	r.data = &data
	return r
}

func (r ApiDcimPowerPortTemplatesCreateRequest) Execute() (*PowerPortTemplate, *http.Response, error) {
	return r.ApiService.DcimPowerPortTemplatesCreateExecute(r)
}

/*
DcimPowerPortTemplatesCreate Method for DcimPowerPortTemplatesCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimPowerPortTemplatesCreateRequest
*/
func (a *DcimApiService) DcimPowerPortTemplatesCreate(ctx context.Context) ApiDcimPowerPortTemplatesCreateRequest {
	return ApiDcimPowerPortTemplatesCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PowerPortTemplate
func (a *DcimApiService) DcimPowerPortTemplatesCreateExecute(r ApiDcimPowerPortTemplatesCreateRequest) (*PowerPortTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PowerPortTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimPowerPortTemplatesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-port-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimPowerPortTemplatesDeleteRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
}

func (r ApiDcimPowerPortTemplatesDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimPowerPortTemplatesDeleteExecute(r)
}

/*
DcimPowerPortTemplatesDelete Method for DcimPowerPortTemplatesDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this power port template.
 @return ApiDcimPowerPortTemplatesDeleteRequest
*/
func (a *DcimApiService) DcimPowerPortTemplatesDelete(ctx context.Context, id int32) ApiDcimPowerPortTemplatesDeleteRequest {
	return ApiDcimPowerPortTemplatesDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DcimApiService) DcimPowerPortTemplatesDeleteExecute(r ApiDcimPowerPortTemplatesDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimPowerPortTemplatesDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-port-templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimPowerPortTemplatesListRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id *string
	name *string
	type_ *string
	maximumDraw *string
	allocatedDraw *string
	created *string
	createdGte *string
	createdLte *string
	lastUpdated *string
	lastUpdatedGte *string
	lastUpdatedLte *string
	devicetypeId *string
	idN *string
	idLte *string
	idLt *string
	idGte *string
	idGt *string
	nameN *string
	nameIc *string
	nameNic *string
	nameIew *string
	nameNiew *string
	nameIsw *string
	nameNisw *string
	nameIe *string
	nameNie *string
	nameEmpty *string
	typeN *string
	maximumDrawN *string
	maximumDrawLte *string
	maximumDrawLt *string
	maximumDrawGte *string
	maximumDrawGt *string
	allocatedDrawN *string
	allocatedDrawLte *string
	allocatedDrawLt *string
	allocatedDrawGte *string
	allocatedDrawGt *string
	devicetypeIdN *string
	limit *int32
	offset *int32
}

func (r ApiDcimPowerPortTemplatesListRequest) Id(id string) ApiDcimPowerPortTemplatesListRequest {
	r.id = &id
	return r
}

func (r ApiDcimPowerPortTemplatesListRequest) Name(name string) ApiDcimPowerPortTemplatesListRequest {
	r.name = &name
	return r
}

func (r ApiDcimPowerPortTemplatesListRequest) Type_(type_ string) ApiDcimPowerPortTemplatesListRequest {
	r.type_ = &type_
	return r
}

func (r ApiDcimPowerPortTemplatesListRequest) MaximumDraw(maximumDraw string) ApiDcimPowerPortTemplatesListRequest {
	r.maximumDraw = &maximumDraw
	return r
}

func (r ApiDcimPowerPortTemplatesListRequest) AllocatedDraw(allocatedDraw string) ApiDcimPowerPortTemplatesListRequest {
	r.allocatedDraw = &allocatedDraw
	return r
}

func (r ApiDcimPowerPortTemplatesListRequest) Created(created string) ApiDcimPowerPortTemplatesListRequest {
	r.created = &created
	return r
}

func (r ApiDcimPowerPortTemplatesListRequest) CreatedGte(createdGte string) ApiDcimPowerPortTemplatesListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiDcimPowerPortTemplatesListRequest) CreatedLte(createdLte string) ApiDcimPowerPortTemplatesListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiDcimPowerPortTemplatesListRequest) LastUpdated(lastUpdated string) ApiDcimPowerPortTemplatesListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiDcimPowerPortTemplatesListRequest) LastUpdatedGte(lastUpdatedGte string) ApiDcimPowerPortTemplatesListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiDcimPowerPortTemplatesListRequest) LastUpdatedLte(lastUpdatedLte string) ApiDcimPowerPortTemplatesListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiDcimPowerPortTemplatesListRequest) DevicetypeId(devicetypeId string) ApiDcimPowerPortTemplatesListRequest {
	r.devicetypeId = &devicetypeId
	return r
}

func (r ApiDcimPowerPortTemplatesListRequest) IdN(idN string) ApiDcimPowerPortTemplatesListRequest {
	r.idN = &idN
	return r
}

func (r ApiDcimPowerPortTemplatesListRequest) IdLte(idLte string) ApiDcimPowerPortTemplatesListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiDcimPowerPortTemplatesListRequest) IdLt(idLt string) ApiDcimPowerPortTemplatesListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiDcimPowerPortTemplatesListRequest) IdGte(idGte string) ApiDcimPowerPortTemplatesListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiDcimPowerPortTemplatesListRequest) IdGt(idGt string) ApiDcimPowerPortTemplatesListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiDcimPowerPortTemplatesListRequest) NameN(nameN string) ApiDcimPowerPortTemplatesListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiDcimPowerPortTemplatesListRequest) NameIc(nameIc string) ApiDcimPowerPortTemplatesListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiDcimPowerPortTemplatesListRequest) NameNic(nameNic string) ApiDcimPowerPortTemplatesListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiDcimPowerPortTemplatesListRequest) NameIew(nameIew string) ApiDcimPowerPortTemplatesListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiDcimPowerPortTemplatesListRequest) NameNiew(nameNiew string) ApiDcimPowerPortTemplatesListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiDcimPowerPortTemplatesListRequest) NameIsw(nameIsw string) ApiDcimPowerPortTemplatesListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiDcimPowerPortTemplatesListRequest) NameNisw(nameNisw string) ApiDcimPowerPortTemplatesListRequest {
	r.nameNisw = &nameNisw
	return r
}

func (r ApiDcimPowerPortTemplatesListRequest) NameIe(nameIe string) ApiDcimPowerPortTemplatesListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiDcimPowerPortTemplatesListRequest) NameNie(nameNie string) ApiDcimPowerPortTemplatesListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiDcimPowerPortTemplatesListRequest) NameEmpty(nameEmpty string) ApiDcimPowerPortTemplatesListRequest {
	r.nameEmpty = &nameEmpty
	return r
}

func (r ApiDcimPowerPortTemplatesListRequest) TypeN(typeN string) ApiDcimPowerPortTemplatesListRequest {
	r.typeN = &typeN
	return r
}

func (r ApiDcimPowerPortTemplatesListRequest) MaximumDrawN(maximumDrawN string) ApiDcimPowerPortTemplatesListRequest {
	r.maximumDrawN = &maximumDrawN
	return r
}

func (r ApiDcimPowerPortTemplatesListRequest) MaximumDrawLte(maximumDrawLte string) ApiDcimPowerPortTemplatesListRequest {
	r.maximumDrawLte = &maximumDrawLte
	return r
}

func (r ApiDcimPowerPortTemplatesListRequest) MaximumDrawLt(maximumDrawLt string) ApiDcimPowerPortTemplatesListRequest {
	r.maximumDrawLt = &maximumDrawLt
	return r
}

func (r ApiDcimPowerPortTemplatesListRequest) MaximumDrawGte(maximumDrawGte string) ApiDcimPowerPortTemplatesListRequest {
	r.maximumDrawGte = &maximumDrawGte
	return r
}

func (r ApiDcimPowerPortTemplatesListRequest) MaximumDrawGt(maximumDrawGt string) ApiDcimPowerPortTemplatesListRequest {
	r.maximumDrawGt = &maximumDrawGt
	return r
}

func (r ApiDcimPowerPortTemplatesListRequest) AllocatedDrawN(allocatedDrawN string) ApiDcimPowerPortTemplatesListRequest {
	r.allocatedDrawN = &allocatedDrawN
	return r
}

func (r ApiDcimPowerPortTemplatesListRequest) AllocatedDrawLte(allocatedDrawLte string) ApiDcimPowerPortTemplatesListRequest {
	r.allocatedDrawLte = &allocatedDrawLte
	return r
}

func (r ApiDcimPowerPortTemplatesListRequest) AllocatedDrawLt(allocatedDrawLt string) ApiDcimPowerPortTemplatesListRequest {
	r.allocatedDrawLt = &allocatedDrawLt
	return r
}

func (r ApiDcimPowerPortTemplatesListRequest) AllocatedDrawGte(allocatedDrawGte string) ApiDcimPowerPortTemplatesListRequest {
	r.allocatedDrawGte = &allocatedDrawGte
	return r
}

func (r ApiDcimPowerPortTemplatesListRequest) AllocatedDrawGt(allocatedDrawGt string) ApiDcimPowerPortTemplatesListRequest {
	r.allocatedDrawGt = &allocatedDrawGt
	return r
}

func (r ApiDcimPowerPortTemplatesListRequest) DevicetypeIdN(devicetypeIdN string) ApiDcimPowerPortTemplatesListRequest {
	r.devicetypeIdN = &devicetypeIdN
	return r
}

// Number of results to return per page.
func (r ApiDcimPowerPortTemplatesListRequest) Limit(limit int32) ApiDcimPowerPortTemplatesListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiDcimPowerPortTemplatesListRequest) Offset(offset int32) ApiDcimPowerPortTemplatesListRequest {
	r.offset = &offset
	return r
}

func (r ApiDcimPowerPortTemplatesListRequest) Execute() (*DcimPowerPortTemplatesList200Response, *http.Response, error) {
	return r.ApiService.DcimPowerPortTemplatesListExecute(r)
}

/*
DcimPowerPortTemplatesList Method for DcimPowerPortTemplatesList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimPowerPortTemplatesListRequest
*/
func (a *DcimApiService) DcimPowerPortTemplatesList(ctx context.Context) ApiDcimPowerPortTemplatesListRequest {
	return ApiDcimPowerPortTemplatesListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DcimPowerPortTemplatesList200Response
func (a *DcimApiService) DcimPowerPortTemplatesListExecute(r ApiDcimPowerPortTemplatesListRequest) (*DcimPowerPortTemplatesList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DcimPowerPortTemplatesList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimPowerPortTemplatesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-port-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.type_ != nil {
		localVarQueryParams.Add("type", parameterToString(*r.type_, ""))
	}
	if r.maximumDraw != nil {
		localVarQueryParams.Add("maximum_draw", parameterToString(*r.maximumDraw, ""))
	}
	if r.allocatedDraw != nil {
		localVarQueryParams.Add("allocated_draw", parameterToString(*r.allocatedDraw, ""))
	}
	if r.created != nil {
		localVarQueryParams.Add("created", parameterToString(*r.created, ""))
	}
	if r.createdGte != nil {
		localVarQueryParams.Add("created__gte", parameterToString(*r.createdGte, ""))
	}
	if r.createdLte != nil {
		localVarQueryParams.Add("created__lte", parameterToString(*r.createdLte, ""))
	}
	if r.lastUpdated != nil {
		localVarQueryParams.Add("last_updated", parameterToString(*r.lastUpdated, ""))
	}
	if r.lastUpdatedGte != nil {
		localVarQueryParams.Add("last_updated__gte", parameterToString(*r.lastUpdatedGte, ""))
	}
	if r.lastUpdatedLte != nil {
		localVarQueryParams.Add("last_updated__lte", parameterToString(*r.lastUpdatedLte, ""))
	}
	if r.devicetypeId != nil {
		localVarQueryParams.Add("devicetype_id", parameterToString(*r.devicetypeId, ""))
	}
	if r.idN != nil {
		localVarQueryParams.Add("id__n", parameterToString(*r.idN, ""))
	}
	if r.idLte != nil {
		localVarQueryParams.Add("id__lte", parameterToString(*r.idLte, ""))
	}
	if r.idLt != nil {
		localVarQueryParams.Add("id__lt", parameterToString(*r.idLt, ""))
	}
	if r.idGte != nil {
		localVarQueryParams.Add("id__gte", parameterToString(*r.idGte, ""))
	}
	if r.idGt != nil {
		localVarQueryParams.Add("id__gt", parameterToString(*r.idGt, ""))
	}
	if r.nameN != nil {
		localVarQueryParams.Add("name__n", parameterToString(*r.nameN, ""))
	}
	if r.nameIc != nil {
		localVarQueryParams.Add("name__ic", parameterToString(*r.nameIc, ""))
	}
	if r.nameNic != nil {
		localVarQueryParams.Add("name__nic", parameterToString(*r.nameNic, ""))
	}
	if r.nameIew != nil {
		localVarQueryParams.Add("name__iew", parameterToString(*r.nameIew, ""))
	}
	if r.nameNiew != nil {
		localVarQueryParams.Add("name__niew", parameterToString(*r.nameNiew, ""))
	}
	if r.nameIsw != nil {
		localVarQueryParams.Add("name__isw", parameterToString(*r.nameIsw, ""))
	}
	if r.nameNisw != nil {
		localVarQueryParams.Add("name__nisw", parameterToString(*r.nameNisw, ""))
	}
	if r.nameIe != nil {
		localVarQueryParams.Add("name__ie", parameterToString(*r.nameIe, ""))
	}
	if r.nameNie != nil {
		localVarQueryParams.Add("name__nie", parameterToString(*r.nameNie, ""))
	}
	if r.nameEmpty != nil {
		localVarQueryParams.Add("name__empty", parameterToString(*r.nameEmpty, ""))
	}
	if r.typeN != nil {
		localVarQueryParams.Add("type__n", parameterToString(*r.typeN, ""))
	}
	if r.maximumDrawN != nil {
		localVarQueryParams.Add("maximum_draw__n", parameterToString(*r.maximumDrawN, ""))
	}
	if r.maximumDrawLte != nil {
		localVarQueryParams.Add("maximum_draw__lte", parameterToString(*r.maximumDrawLte, ""))
	}
	if r.maximumDrawLt != nil {
		localVarQueryParams.Add("maximum_draw__lt", parameterToString(*r.maximumDrawLt, ""))
	}
	if r.maximumDrawGte != nil {
		localVarQueryParams.Add("maximum_draw__gte", parameterToString(*r.maximumDrawGte, ""))
	}
	if r.maximumDrawGt != nil {
		localVarQueryParams.Add("maximum_draw__gt", parameterToString(*r.maximumDrawGt, ""))
	}
	if r.allocatedDrawN != nil {
		localVarQueryParams.Add("allocated_draw__n", parameterToString(*r.allocatedDrawN, ""))
	}
	if r.allocatedDrawLte != nil {
		localVarQueryParams.Add("allocated_draw__lte", parameterToString(*r.allocatedDrawLte, ""))
	}
	if r.allocatedDrawLt != nil {
		localVarQueryParams.Add("allocated_draw__lt", parameterToString(*r.allocatedDrawLt, ""))
	}
	if r.allocatedDrawGte != nil {
		localVarQueryParams.Add("allocated_draw__gte", parameterToString(*r.allocatedDrawGte, ""))
	}
	if r.allocatedDrawGt != nil {
		localVarQueryParams.Add("allocated_draw__gt", parameterToString(*r.allocatedDrawGt, ""))
	}
	if r.devicetypeIdN != nil {
		localVarQueryParams.Add("devicetype_id__n", parameterToString(*r.devicetypeIdN, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimPowerPortTemplatesPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
	data *WritablePowerPortTemplate
}

func (r ApiDcimPowerPortTemplatesPartialUpdateRequest) Data(data WritablePowerPortTemplate) ApiDcimPowerPortTemplatesPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimPowerPortTemplatesPartialUpdateRequest) Execute() (*PowerPortTemplate, *http.Response, error) {
	return r.ApiService.DcimPowerPortTemplatesPartialUpdateExecute(r)
}

/*
DcimPowerPortTemplatesPartialUpdate Method for DcimPowerPortTemplatesPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this power port template.
 @return ApiDcimPowerPortTemplatesPartialUpdateRequest
*/
func (a *DcimApiService) DcimPowerPortTemplatesPartialUpdate(ctx context.Context, id int32) ApiDcimPowerPortTemplatesPartialUpdateRequest {
	return ApiDcimPowerPortTemplatesPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PowerPortTemplate
func (a *DcimApiService) DcimPowerPortTemplatesPartialUpdateExecute(r ApiDcimPowerPortTemplatesPartialUpdateRequest) (*PowerPortTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PowerPortTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimPowerPortTemplatesPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-port-templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimPowerPortTemplatesReadRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
}

func (r ApiDcimPowerPortTemplatesReadRequest) Execute() (*PowerPortTemplate, *http.Response, error) {
	return r.ApiService.DcimPowerPortTemplatesReadExecute(r)
}

/*
DcimPowerPortTemplatesRead Method for DcimPowerPortTemplatesRead

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this power port template.
 @return ApiDcimPowerPortTemplatesReadRequest
*/
func (a *DcimApiService) DcimPowerPortTemplatesRead(ctx context.Context, id int32) ApiDcimPowerPortTemplatesReadRequest {
	return ApiDcimPowerPortTemplatesReadRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PowerPortTemplate
func (a *DcimApiService) DcimPowerPortTemplatesReadExecute(r ApiDcimPowerPortTemplatesReadRequest) (*PowerPortTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PowerPortTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimPowerPortTemplatesRead")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-port-templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimPowerPortTemplatesUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
	data *WritablePowerPortTemplate
}

func (r ApiDcimPowerPortTemplatesUpdateRequest) Data(data WritablePowerPortTemplate) ApiDcimPowerPortTemplatesUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimPowerPortTemplatesUpdateRequest) Execute() (*PowerPortTemplate, *http.Response, error) {
	return r.ApiService.DcimPowerPortTemplatesUpdateExecute(r)
}

/*
DcimPowerPortTemplatesUpdate Method for DcimPowerPortTemplatesUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this power port template.
 @return ApiDcimPowerPortTemplatesUpdateRequest
*/
func (a *DcimApiService) DcimPowerPortTemplatesUpdate(ctx context.Context, id int32) ApiDcimPowerPortTemplatesUpdateRequest {
	return ApiDcimPowerPortTemplatesUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PowerPortTemplate
func (a *DcimApiService) DcimPowerPortTemplatesUpdateExecute(r ApiDcimPowerPortTemplatesUpdateRequest) (*PowerPortTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PowerPortTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimPowerPortTemplatesUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-port-templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimPowerPortsBulkDeleteRequest struct {
	ctx context.Context
	ApiService *DcimApiService
}

func (r ApiDcimPowerPortsBulkDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimPowerPortsBulkDeleteExecute(r)
}

/*
DcimPowerPortsBulkDelete Method for DcimPowerPortsBulkDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimPowerPortsBulkDeleteRequest
*/
func (a *DcimApiService) DcimPowerPortsBulkDelete(ctx context.Context) ApiDcimPowerPortsBulkDeleteRequest {
	return ApiDcimPowerPortsBulkDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DcimApiService) DcimPowerPortsBulkDeleteExecute(r ApiDcimPowerPortsBulkDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimPowerPortsBulkDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-ports/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimPowerPortsBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	data *WritablePowerPort
}

func (r ApiDcimPowerPortsBulkPartialUpdateRequest) Data(data WritablePowerPort) ApiDcimPowerPortsBulkPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimPowerPortsBulkPartialUpdateRequest) Execute() (*PowerPort, *http.Response, error) {
	return r.ApiService.DcimPowerPortsBulkPartialUpdateExecute(r)
}

/*
DcimPowerPortsBulkPartialUpdate Method for DcimPowerPortsBulkPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimPowerPortsBulkPartialUpdateRequest
*/
func (a *DcimApiService) DcimPowerPortsBulkPartialUpdate(ctx context.Context) ApiDcimPowerPortsBulkPartialUpdateRequest {
	return ApiDcimPowerPortsBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PowerPort
func (a *DcimApiService) DcimPowerPortsBulkPartialUpdateExecute(r ApiDcimPowerPortsBulkPartialUpdateRequest) (*PowerPort, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PowerPort
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimPowerPortsBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-ports/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimPowerPortsBulkUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	data *WritablePowerPort
}

func (r ApiDcimPowerPortsBulkUpdateRequest) Data(data WritablePowerPort) ApiDcimPowerPortsBulkUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimPowerPortsBulkUpdateRequest) Execute() (*PowerPort, *http.Response, error) {
	return r.ApiService.DcimPowerPortsBulkUpdateExecute(r)
}

/*
DcimPowerPortsBulkUpdate Method for DcimPowerPortsBulkUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimPowerPortsBulkUpdateRequest
*/
func (a *DcimApiService) DcimPowerPortsBulkUpdate(ctx context.Context) ApiDcimPowerPortsBulkUpdateRequest {
	return ApiDcimPowerPortsBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PowerPort
func (a *DcimApiService) DcimPowerPortsBulkUpdateExecute(r ApiDcimPowerPortsBulkUpdateRequest) (*PowerPort, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PowerPort
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimPowerPortsBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-ports/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimPowerPortsCreateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	data *WritablePowerPort
}

func (r ApiDcimPowerPortsCreateRequest) Data(data WritablePowerPort) ApiDcimPowerPortsCreateRequest {
	r.data = &data
	return r
}

func (r ApiDcimPowerPortsCreateRequest) Execute() (*PowerPort, *http.Response, error) {
	return r.ApiService.DcimPowerPortsCreateExecute(r)
}

/*
DcimPowerPortsCreate Method for DcimPowerPortsCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimPowerPortsCreateRequest
*/
func (a *DcimApiService) DcimPowerPortsCreate(ctx context.Context) ApiDcimPowerPortsCreateRequest {
	return ApiDcimPowerPortsCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PowerPort
func (a *DcimApiService) DcimPowerPortsCreateExecute(r ApiDcimPowerPortsCreateRequest) (*PowerPort, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PowerPort
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimPowerPortsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-ports/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimPowerPortsDeleteRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
}

func (r ApiDcimPowerPortsDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimPowerPortsDeleteExecute(r)
}

/*
DcimPowerPortsDelete Method for DcimPowerPortsDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this power port.
 @return ApiDcimPowerPortsDeleteRequest
*/
func (a *DcimApiService) DcimPowerPortsDelete(ctx context.Context, id int32) ApiDcimPowerPortsDeleteRequest {
	return ApiDcimPowerPortsDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DcimApiService) DcimPowerPortsDeleteExecute(r ApiDcimPowerPortsDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimPowerPortsDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-ports/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimPowerPortsListRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id *string
	name *string
	label *string
	maximumDraw *string
	allocatedDraw *string
	description *string
	created *string
	createdGte *string
	createdLte *string
	lastUpdated *string
	lastUpdatedGte *string
	lastUpdatedLte *string
	q *string
	regionId *string
	region *string
	siteGroupId *string
	siteGroup *string
	siteId *string
	site *string
	deviceId *string
	device *string
	tag *string
	cabled *string
	connected *string
	type_ *string
	idN *string
	idLte *string
	idLt *string
	idGte *string
	idGt *string
	nameN *string
	nameIc *string
	nameNic *string
	nameIew *string
	nameNiew *string
	nameIsw *string
	nameNisw *string
	nameIe *string
	nameNie *string
	nameEmpty *string
	labelN *string
	labelIc *string
	labelNic *string
	labelIew *string
	labelNiew *string
	labelIsw *string
	labelNisw *string
	labelIe *string
	labelNie *string
	labelEmpty *string
	maximumDrawN *string
	maximumDrawLte *string
	maximumDrawLt *string
	maximumDrawGte *string
	maximumDrawGt *string
	allocatedDrawN *string
	allocatedDrawLte *string
	allocatedDrawLt *string
	allocatedDrawGte *string
	allocatedDrawGt *string
	descriptionN *string
	descriptionIc *string
	descriptionNic *string
	descriptionIew *string
	descriptionNiew *string
	descriptionIsw *string
	descriptionNisw *string
	descriptionIe *string
	descriptionNie *string
	descriptionEmpty *string
	regionIdN *string
	regionN *string
	siteGroupIdN *string
	siteGroupN *string
	siteIdN *string
	siteN *string
	deviceIdN *string
	deviceN *string
	tagN *string
	typeN *string
	limit *int32
	offset *int32
}

func (r ApiDcimPowerPortsListRequest) Id(id string) ApiDcimPowerPortsListRequest {
	r.id = &id
	return r
}

func (r ApiDcimPowerPortsListRequest) Name(name string) ApiDcimPowerPortsListRequest {
	r.name = &name
	return r
}

func (r ApiDcimPowerPortsListRequest) Label(label string) ApiDcimPowerPortsListRequest {
	r.label = &label
	return r
}

func (r ApiDcimPowerPortsListRequest) MaximumDraw(maximumDraw string) ApiDcimPowerPortsListRequest {
	r.maximumDraw = &maximumDraw
	return r
}

func (r ApiDcimPowerPortsListRequest) AllocatedDraw(allocatedDraw string) ApiDcimPowerPortsListRequest {
	r.allocatedDraw = &allocatedDraw
	return r
}

func (r ApiDcimPowerPortsListRequest) Description(description string) ApiDcimPowerPortsListRequest {
	r.description = &description
	return r
}

func (r ApiDcimPowerPortsListRequest) Created(created string) ApiDcimPowerPortsListRequest {
	r.created = &created
	return r
}

func (r ApiDcimPowerPortsListRequest) CreatedGte(createdGte string) ApiDcimPowerPortsListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiDcimPowerPortsListRequest) CreatedLte(createdLte string) ApiDcimPowerPortsListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiDcimPowerPortsListRequest) LastUpdated(lastUpdated string) ApiDcimPowerPortsListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiDcimPowerPortsListRequest) LastUpdatedGte(lastUpdatedGte string) ApiDcimPowerPortsListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiDcimPowerPortsListRequest) LastUpdatedLte(lastUpdatedLte string) ApiDcimPowerPortsListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiDcimPowerPortsListRequest) Q(q string) ApiDcimPowerPortsListRequest {
	r.q = &q
	return r
}

func (r ApiDcimPowerPortsListRequest) RegionId(regionId string) ApiDcimPowerPortsListRequest {
	r.regionId = &regionId
	return r
}

func (r ApiDcimPowerPortsListRequest) Region(region string) ApiDcimPowerPortsListRequest {
	r.region = &region
	return r
}

func (r ApiDcimPowerPortsListRequest) SiteGroupId(siteGroupId string) ApiDcimPowerPortsListRequest {
	r.siteGroupId = &siteGroupId
	return r
}

func (r ApiDcimPowerPortsListRequest) SiteGroup(siteGroup string) ApiDcimPowerPortsListRequest {
	r.siteGroup = &siteGroup
	return r
}

func (r ApiDcimPowerPortsListRequest) SiteId(siteId string) ApiDcimPowerPortsListRequest {
	r.siteId = &siteId
	return r
}

func (r ApiDcimPowerPortsListRequest) Site(site string) ApiDcimPowerPortsListRequest {
	r.site = &site
	return r
}

func (r ApiDcimPowerPortsListRequest) DeviceId(deviceId string) ApiDcimPowerPortsListRequest {
	r.deviceId = &deviceId
	return r
}

func (r ApiDcimPowerPortsListRequest) Device(device string) ApiDcimPowerPortsListRequest {
	r.device = &device
	return r
}

func (r ApiDcimPowerPortsListRequest) Tag(tag string) ApiDcimPowerPortsListRequest {
	r.tag = &tag
	return r
}

func (r ApiDcimPowerPortsListRequest) Cabled(cabled string) ApiDcimPowerPortsListRequest {
	r.cabled = &cabled
	return r
}

func (r ApiDcimPowerPortsListRequest) Connected(connected string) ApiDcimPowerPortsListRequest {
	r.connected = &connected
	return r
}

func (r ApiDcimPowerPortsListRequest) Type_(type_ string) ApiDcimPowerPortsListRequest {
	r.type_ = &type_
	return r
}

func (r ApiDcimPowerPortsListRequest) IdN(idN string) ApiDcimPowerPortsListRequest {
	r.idN = &idN
	return r
}

func (r ApiDcimPowerPortsListRequest) IdLte(idLte string) ApiDcimPowerPortsListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiDcimPowerPortsListRequest) IdLt(idLt string) ApiDcimPowerPortsListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiDcimPowerPortsListRequest) IdGte(idGte string) ApiDcimPowerPortsListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiDcimPowerPortsListRequest) IdGt(idGt string) ApiDcimPowerPortsListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiDcimPowerPortsListRequest) NameN(nameN string) ApiDcimPowerPortsListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiDcimPowerPortsListRequest) NameIc(nameIc string) ApiDcimPowerPortsListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiDcimPowerPortsListRequest) NameNic(nameNic string) ApiDcimPowerPortsListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiDcimPowerPortsListRequest) NameIew(nameIew string) ApiDcimPowerPortsListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiDcimPowerPortsListRequest) NameNiew(nameNiew string) ApiDcimPowerPortsListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiDcimPowerPortsListRequest) NameIsw(nameIsw string) ApiDcimPowerPortsListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiDcimPowerPortsListRequest) NameNisw(nameNisw string) ApiDcimPowerPortsListRequest {
	r.nameNisw = &nameNisw
	return r
}

func (r ApiDcimPowerPortsListRequest) NameIe(nameIe string) ApiDcimPowerPortsListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiDcimPowerPortsListRequest) NameNie(nameNie string) ApiDcimPowerPortsListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiDcimPowerPortsListRequest) NameEmpty(nameEmpty string) ApiDcimPowerPortsListRequest {
	r.nameEmpty = &nameEmpty
	return r
}

func (r ApiDcimPowerPortsListRequest) LabelN(labelN string) ApiDcimPowerPortsListRequest {
	r.labelN = &labelN
	return r
}

func (r ApiDcimPowerPortsListRequest) LabelIc(labelIc string) ApiDcimPowerPortsListRequest {
	r.labelIc = &labelIc
	return r
}

func (r ApiDcimPowerPortsListRequest) LabelNic(labelNic string) ApiDcimPowerPortsListRequest {
	r.labelNic = &labelNic
	return r
}

func (r ApiDcimPowerPortsListRequest) LabelIew(labelIew string) ApiDcimPowerPortsListRequest {
	r.labelIew = &labelIew
	return r
}

func (r ApiDcimPowerPortsListRequest) LabelNiew(labelNiew string) ApiDcimPowerPortsListRequest {
	r.labelNiew = &labelNiew
	return r
}

func (r ApiDcimPowerPortsListRequest) LabelIsw(labelIsw string) ApiDcimPowerPortsListRequest {
	r.labelIsw = &labelIsw
	return r
}

func (r ApiDcimPowerPortsListRequest) LabelNisw(labelNisw string) ApiDcimPowerPortsListRequest {
	r.labelNisw = &labelNisw
	return r
}

func (r ApiDcimPowerPortsListRequest) LabelIe(labelIe string) ApiDcimPowerPortsListRequest {
	r.labelIe = &labelIe
	return r
}

func (r ApiDcimPowerPortsListRequest) LabelNie(labelNie string) ApiDcimPowerPortsListRequest {
	r.labelNie = &labelNie
	return r
}

func (r ApiDcimPowerPortsListRequest) LabelEmpty(labelEmpty string) ApiDcimPowerPortsListRequest {
	r.labelEmpty = &labelEmpty
	return r
}

func (r ApiDcimPowerPortsListRequest) MaximumDrawN(maximumDrawN string) ApiDcimPowerPortsListRequest {
	r.maximumDrawN = &maximumDrawN
	return r
}

func (r ApiDcimPowerPortsListRequest) MaximumDrawLte(maximumDrawLte string) ApiDcimPowerPortsListRequest {
	r.maximumDrawLte = &maximumDrawLte
	return r
}

func (r ApiDcimPowerPortsListRequest) MaximumDrawLt(maximumDrawLt string) ApiDcimPowerPortsListRequest {
	r.maximumDrawLt = &maximumDrawLt
	return r
}

func (r ApiDcimPowerPortsListRequest) MaximumDrawGte(maximumDrawGte string) ApiDcimPowerPortsListRequest {
	r.maximumDrawGte = &maximumDrawGte
	return r
}

func (r ApiDcimPowerPortsListRequest) MaximumDrawGt(maximumDrawGt string) ApiDcimPowerPortsListRequest {
	r.maximumDrawGt = &maximumDrawGt
	return r
}

func (r ApiDcimPowerPortsListRequest) AllocatedDrawN(allocatedDrawN string) ApiDcimPowerPortsListRequest {
	r.allocatedDrawN = &allocatedDrawN
	return r
}

func (r ApiDcimPowerPortsListRequest) AllocatedDrawLte(allocatedDrawLte string) ApiDcimPowerPortsListRequest {
	r.allocatedDrawLte = &allocatedDrawLte
	return r
}

func (r ApiDcimPowerPortsListRequest) AllocatedDrawLt(allocatedDrawLt string) ApiDcimPowerPortsListRequest {
	r.allocatedDrawLt = &allocatedDrawLt
	return r
}

func (r ApiDcimPowerPortsListRequest) AllocatedDrawGte(allocatedDrawGte string) ApiDcimPowerPortsListRequest {
	r.allocatedDrawGte = &allocatedDrawGte
	return r
}

func (r ApiDcimPowerPortsListRequest) AllocatedDrawGt(allocatedDrawGt string) ApiDcimPowerPortsListRequest {
	r.allocatedDrawGt = &allocatedDrawGt
	return r
}

func (r ApiDcimPowerPortsListRequest) DescriptionN(descriptionN string) ApiDcimPowerPortsListRequest {
	r.descriptionN = &descriptionN
	return r
}

func (r ApiDcimPowerPortsListRequest) DescriptionIc(descriptionIc string) ApiDcimPowerPortsListRequest {
	r.descriptionIc = &descriptionIc
	return r
}

func (r ApiDcimPowerPortsListRequest) DescriptionNic(descriptionNic string) ApiDcimPowerPortsListRequest {
	r.descriptionNic = &descriptionNic
	return r
}

func (r ApiDcimPowerPortsListRequest) DescriptionIew(descriptionIew string) ApiDcimPowerPortsListRequest {
	r.descriptionIew = &descriptionIew
	return r
}

func (r ApiDcimPowerPortsListRequest) DescriptionNiew(descriptionNiew string) ApiDcimPowerPortsListRequest {
	r.descriptionNiew = &descriptionNiew
	return r
}

func (r ApiDcimPowerPortsListRequest) DescriptionIsw(descriptionIsw string) ApiDcimPowerPortsListRequest {
	r.descriptionIsw = &descriptionIsw
	return r
}

func (r ApiDcimPowerPortsListRequest) DescriptionNisw(descriptionNisw string) ApiDcimPowerPortsListRequest {
	r.descriptionNisw = &descriptionNisw
	return r
}

func (r ApiDcimPowerPortsListRequest) DescriptionIe(descriptionIe string) ApiDcimPowerPortsListRequest {
	r.descriptionIe = &descriptionIe
	return r
}

func (r ApiDcimPowerPortsListRequest) DescriptionNie(descriptionNie string) ApiDcimPowerPortsListRequest {
	r.descriptionNie = &descriptionNie
	return r
}

func (r ApiDcimPowerPortsListRequest) DescriptionEmpty(descriptionEmpty string) ApiDcimPowerPortsListRequest {
	r.descriptionEmpty = &descriptionEmpty
	return r
}

func (r ApiDcimPowerPortsListRequest) RegionIdN(regionIdN string) ApiDcimPowerPortsListRequest {
	r.regionIdN = &regionIdN
	return r
}

func (r ApiDcimPowerPortsListRequest) RegionN(regionN string) ApiDcimPowerPortsListRequest {
	r.regionN = &regionN
	return r
}

func (r ApiDcimPowerPortsListRequest) SiteGroupIdN(siteGroupIdN string) ApiDcimPowerPortsListRequest {
	r.siteGroupIdN = &siteGroupIdN
	return r
}

func (r ApiDcimPowerPortsListRequest) SiteGroupN(siteGroupN string) ApiDcimPowerPortsListRequest {
	r.siteGroupN = &siteGroupN
	return r
}

func (r ApiDcimPowerPortsListRequest) SiteIdN(siteIdN string) ApiDcimPowerPortsListRequest {
	r.siteIdN = &siteIdN
	return r
}

func (r ApiDcimPowerPortsListRequest) SiteN(siteN string) ApiDcimPowerPortsListRequest {
	r.siteN = &siteN
	return r
}

func (r ApiDcimPowerPortsListRequest) DeviceIdN(deviceIdN string) ApiDcimPowerPortsListRequest {
	r.deviceIdN = &deviceIdN
	return r
}

func (r ApiDcimPowerPortsListRequest) DeviceN(deviceN string) ApiDcimPowerPortsListRequest {
	r.deviceN = &deviceN
	return r
}

func (r ApiDcimPowerPortsListRequest) TagN(tagN string) ApiDcimPowerPortsListRequest {
	r.tagN = &tagN
	return r
}

func (r ApiDcimPowerPortsListRequest) TypeN(typeN string) ApiDcimPowerPortsListRequest {
	r.typeN = &typeN
	return r
}

// Number of results to return per page.
func (r ApiDcimPowerPortsListRequest) Limit(limit int32) ApiDcimPowerPortsListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiDcimPowerPortsListRequest) Offset(offset int32) ApiDcimPowerPortsListRequest {
	r.offset = &offset
	return r
}

func (r ApiDcimPowerPortsListRequest) Execute() (*DcimPowerConnectionsList200Response, *http.Response, error) {
	return r.ApiService.DcimPowerPortsListExecute(r)
}

/*
DcimPowerPortsList Method for DcimPowerPortsList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimPowerPortsListRequest
*/
func (a *DcimApiService) DcimPowerPortsList(ctx context.Context) ApiDcimPowerPortsListRequest {
	return ApiDcimPowerPortsListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DcimPowerConnectionsList200Response
func (a *DcimApiService) DcimPowerPortsListExecute(r ApiDcimPowerPortsListRequest) (*DcimPowerConnectionsList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DcimPowerConnectionsList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimPowerPortsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-ports/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.label != nil {
		localVarQueryParams.Add("label", parameterToString(*r.label, ""))
	}
	if r.maximumDraw != nil {
		localVarQueryParams.Add("maximum_draw", parameterToString(*r.maximumDraw, ""))
	}
	if r.allocatedDraw != nil {
		localVarQueryParams.Add("allocated_draw", parameterToString(*r.allocatedDraw, ""))
	}
	if r.description != nil {
		localVarQueryParams.Add("description", parameterToString(*r.description, ""))
	}
	if r.created != nil {
		localVarQueryParams.Add("created", parameterToString(*r.created, ""))
	}
	if r.createdGte != nil {
		localVarQueryParams.Add("created__gte", parameterToString(*r.createdGte, ""))
	}
	if r.createdLte != nil {
		localVarQueryParams.Add("created__lte", parameterToString(*r.createdLte, ""))
	}
	if r.lastUpdated != nil {
		localVarQueryParams.Add("last_updated", parameterToString(*r.lastUpdated, ""))
	}
	if r.lastUpdatedGte != nil {
		localVarQueryParams.Add("last_updated__gte", parameterToString(*r.lastUpdatedGte, ""))
	}
	if r.lastUpdatedLte != nil {
		localVarQueryParams.Add("last_updated__lte", parameterToString(*r.lastUpdatedLte, ""))
	}
	if r.q != nil {
		localVarQueryParams.Add("q", parameterToString(*r.q, ""))
	}
	if r.regionId != nil {
		localVarQueryParams.Add("region_id", parameterToString(*r.regionId, ""))
	}
	if r.region != nil {
		localVarQueryParams.Add("region", parameterToString(*r.region, ""))
	}
	if r.siteGroupId != nil {
		localVarQueryParams.Add("site_group_id", parameterToString(*r.siteGroupId, ""))
	}
	if r.siteGroup != nil {
		localVarQueryParams.Add("site_group", parameterToString(*r.siteGroup, ""))
	}
	if r.siteId != nil {
		localVarQueryParams.Add("site_id", parameterToString(*r.siteId, ""))
	}
	if r.site != nil {
		localVarQueryParams.Add("site", parameterToString(*r.site, ""))
	}
	if r.deviceId != nil {
		localVarQueryParams.Add("device_id", parameterToString(*r.deviceId, ""))
	}
	if r.device != nil {
		localVarQueryParams.Add("device", parameterToString(*r.device, ""))
	}
	if r.tag != nil {
		localVarQueryParams.Add("tag", parameterToString(*r.tag, ""))
	}
	if r.cabled != nil {
		localVarQueryParams.Add("cabled", parameterToString(*r.cabled, ""))
	}
	if r.connected != nil {
		localVarQueryParams.Add("connected", parameterToString(*r.connected, ""))
	}
	if r.type_ != nil {
		localVarQueryParams.Add("type", parameterToString(*r.type_, ""))
	}
	if r.idN != nil {
		localVarQueryParams.Add("id__n", parameterToString(*r.idN, ""))
	}
	if r.idLte != nil {
		localVarQueryParams.Add("id__lte", parameterToString(*r.idLte, ""))
	}
	if r.idLt != nil {
		localVarQueryParams.Add("id__lt", parameterToString(*r.idLt, ""))
	}
	if r.idGte != nil {
		localVarQueryParams.Add("id__gte", parameterToString(*r.idGte, ""))
	}
	if r.idGt != nil {
		localVarQueryParams.Add("id__gt", parameterToString(*r.idGt, ""))
	}
	if r.nameN != nil {
		localVarQueryParams.Add("name__n", parameterToString(*r.nameN, ""))
	}
	if r.nameIc != nil {
		localVarQueryParams.Add("name__ic", parameterToString(*r.nameIc, ""))
	}
	if r.nameNic != nil {
		localVarQueryParams.Add("name__nic", parameterToString(*r.nameNic, ""))
	}
	if r.nameIew != nil {
		localVarQueryParams.Add("name__iew", parameterToString(*r.nameIew, ""))
	}
	if r.nameNiew != nil {
		localVarQueryParams.Add("name__niew", parameterToString(*r.nameNiew, ""))
	}
	if r.nameIsw != nil {
		localVarQueryParams.Add("name__isw", parameterToString(*r.nameIsw, ""))
	}
	if r.nameNisw != nil {
		localVarQueryParams.Add("name__nisw", parameterToString(*r.nameNisw, ""))
	}
	if r.nameIe != nil {
		localVarQueryParams.Add("name__ie", parameterToString(*r.nameIe, ""))
	}
	if r.nameNie != nil {
		localVarQueryParams.Add("name__nie", parameterToString(*r.nameNie, ""))
	}
	if r.nameEmpty != nil {
		localVarQueryParams.Add("name__empty", parameterToString(*r.nameEmpty, ""))
	}
	if r.labelN != nil {
		localVarQueryParams.Add("label__n", parameterToString(*r.labelN, ""))
	}
	if r.labelIc != nil {
		localVarQueryParams.Add("label__ic", parameterToString(*r.labelIc, ""))
	}
	if r.labelNic != nil {
		localVarQueryParams.Add("label__nic", parameterToString(*r.labelNic, ""))
	}
	if r.labelIew != nil {
		localVarQueryParams.Add("label__iew", parameterToString(*r.labelIew, ""))
	}
	if r.labelNiew != nil {
		localVarQueryParams.Add("label__niew", parameterToString(*r.labelNiew, ""))
	}
	if r.labelIsw != nil {
		localVarQueryParams.Add("label__isw", parameterToString(*r.labelIsw, ""))
	}
	if r.labelNisw != nil {
		localVarQueryParams.Add("label__nisw", parameterToString(*r.labelNisw, ""))
	}
	if r.labelIe != nil {
		localVarQueryParams.Add("label__ie", parameterToString(*r.labelIe, ""))
	}
	if r.labelNie != nil {
		localVarQueryParams.Add("label__nie", parameterToString(*r.labelNie, ""))
	}
	if r.labelEmpty != nil {
		localVarQueryParams.Add("label__empty", parameterToString(*r.labelEmpty, ""))
	}
	if r.maximumDrawN != nil {
		localVarQueryParams.Add("maximum_draw__n", parameterToString(*r.maximumDrawN, ""))
	}
	if r.maximumDrawLte != nil {
		localVarQueryParams.Add("maximum_draw__lte", parameterToString(*r.maximumDrawLte, ""))
	}
	if r.maximumDrawLt != nil {
		localVarQueryParams.Add("maximum_draw__lt", parameterToString(*r.maximumDrawLt, ""))
	}
	if r.maximumDrawGte != nil {
		localVarQueryParams.Add("maximum_draw__gte", parameterToString(*r.maximumDrawGte, ""))
	}
	if r.maximumDrawGt != nil {
		localVarQueryParams.Add("maximum_draw__gt", parameterToString(*r.maximumDrawGt, ""))
	}
	if r.allocatedDrawN != nil {
		localVarQueryParams.Add("allocated_draw__n", parameterToString(*r.allocatedDrawN, ""))
	}
	if r.allocatedDrawLte != nil {
		localVarQueryParams.Add("allocated_draw__lte", parameterToString(*r.allocatedDrawLte, ""))
	}
	if r.allocatedDrawLt != nil {
		localVarQueryParams.Add("allocated_draw__lt", parameterToString(*r.allocatedDrawLt, ""))
	}
	if r.allocatedDrawGte != nil {
		localVarQueryParams.Add("allocated_draw__gte", parameterToString(*r.allocatedDrawGte, ""))
	}
	if r.allocatedDrawGt != nil {
		localVarQueryParams.Add("allocated_draw__gt", parameterToString(*r.allocatedDrawGt, ""))
	}
	if r.descriptionN != nil {
		localVarQueryParams.Add("description__n", parameterToString(*r.descriptionN, ""))
	}
	if r.descriptionIc != nil {
		localVarQueryParams.Add("description__ic", parameterToString(*r.descriptionIc, ""))
	}
	if r.descriptionNic != nil {
		localVarQueryParams.Add("description__nic", parameterToString(*r.descriptionNic, ""))
	}
	if r.descriptionIew != nil {
		localVarQueryParams.Add("description__iew", parameterToString(*r.descriptionIew, ""))
	}
	if r.descriptionNiew != nil {
		localVarQueryParams.Add("description__niew", parameterToString(*r.descriptionNiew, ""))
	}
	if r.descriptionIsw != nil {
		localVarQueryParams.Add("description__isw", parameterToString(*r.descriptionIsw, ""))
	}
	if r.descriptionNisw != nil {
		localVarQueryParams.Add("description__nisw", parameterToString(*r.descriptionNisw, ""))
	}
	if r.descriptionIe != nil {
		localVarQueryParams.Add("description__ie", parameterToString(*r.descriptionIe, ""))
	}
	if r.descriptionNie != nil {
		localVarQueryParams.Add("description__nie", parameterToString(*r.descriptionNie, ""))
	}
	if r.descriptionEmpty != nil {
		localVarQueryParams.Add("description__empty", parameterToString(*r.descriptionEmpty, ""))
	}
	if r.regionIdN != nil {
		localVarQueryParams.Add("region_id__n", parameterToString(*r.regionIdN, ""))
	}
	if r.regionN != nil {
		localVarQueryParams.Add("region__n", parameterToString(*r.regionN, ""))
	}
	if r.siteGroupIdN != nil {
		localVarQueryParams.Add("site_group_id__n", parameterToString(*r.siteGroupIdN, ""))
	}
	if r.siteGroupN != nil {
		localVarQueryParams.Add("site_group__n", parameterToString(*r.siteGroupN, ""))
	}
	if r.siteIdN != nil {
		localVarQueryParams.Add("site_id__n", parameterToString(*r.siteIdN, ""))
	}
	if r.siteN != nil {
		localVarQueryParams.Add("site__n", parameterToString(*r.siteN, ""))
	}
	if r.deviceIdN != nil {
		localVarQueryParams.Add("device_id__n", parameterToString(*r.deviceIdN, ""))
	}
	if r.deviceN != nil {
		localVarQueryParams.Add("device__n", parameterToString(*r.deviceN, ""))
	}
	if r.tagN != nil {
		localVarQueryParams.Add("tag__n", parameterToString(*r.tagN, ""))
	}
	if r.typeN != nil {
		localVarQueryParams.Add("type__n", parameterToString(*r.typeN, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimPowerPortsPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
	data *WritablePowerPort
}

func (r ApiDcimPowerPortsPartialUpdateRequest) Data(data WritablePowerPort) ApiDcimPowerPortsPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimPowerPortsPartialUpdateRequest) Execute() (*PowerPort, *http.Response, error) {
	return r.ApiService.DcimPowerPortsPartialUpdateExecute(r)
}

/*
DcimPowerPortsPartialUpdate Method for DcimPowerPortsPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this power port.
 @return ApiDcimPowerPortsPartialUpdateRequest
*/
func (a *DcimApiService) DcimPowerPortsPartialUpdate(ctx context.Context, id int32) ApiDcimPowerPortsPartialUpdateRequest {
	return ApiDcimPowerPortsPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PowerPort
func (a *DcimApiService) DcimPowerPortsPartialUpdateExecute(r ApiDcimPowerPortsPartialUpdateRequest) (*PowerPort, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PowerPort
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimPowerPortsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-ports/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimPowerPortsReadRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
}

func (r ApiDcimPowerPortsReadRequest) Execute() (*PowerPort, *http.Response, error) {
	return r.ApiService.DcimPowerPortsReadExecute(r)
}

/*
DcimPowerPortsRead Method for DcimPowerPortsRead

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this power port.
 @return ApiDcimPowerPortsReadRequest
*/
func (a *DcimApiService) DcimPowerPortsRead(ctx context.Context, id int32) ApiDcimPowerPortsReadRequest {
	return ApiDcimPowerPortsReadRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PowerPort
func (a *DcimApiService) DcimPowerPortsReadExecute(r ApiDcimPowerPortsReadRequest) (*PowerPort, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PowerPort
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimPowerPortsRead")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-ports/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimPowerPortsTraceRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
}

func (r ApiDcimPowerPortsTraceRequest) Execute() (*PowerPort, *http.Response, error) {
	return r.ApiService.DcimPowerPortsTraceExecute(r)
}

/*
DcimPowerPortsTrace Method for DcimPowerPortsTrace

Trace a complete cable path and return each segment as a three-tuple of (termination, cable, termination).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this power port.
 @return ApiDcimPowerPortsTraceRequest
*/
func (a *DcimApiService) DcimPowerPortsTrace(ctx context.Context, id int32) ApiDcimPowerPortsTraceRequest {
	return ApiDcimPowerPortsTraceRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PowerPort
func (a *DcimApiService) DcimPowerPortsTraceExecute(r ApiDcimPowerPortsTraceRequest) (*PowerPort, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PowerPort
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimPowerPortsTrace")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-ports/{id}/trace/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimPowerPortsUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
	data *WritablePowerPort
}

func (r ApiDcimPowerPortsUpdateRequest) Data(data WritablePowerPort) ApiDcimPowerPortsUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimPowerPortsUpdateRequest) Execute() (*PowerPort, *http.Response, error) {
	return r.ApiService.DcimPowerPortsUpdateExecute(r)
}

/*
DcimPowerPortsUpdate Method for DcimPowerPortsUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this power port.
 @return ApiDcimPowerPortsUpdateRequest
*/
func (a *DcimApiService) DcimPowerPortsUpdate(ctx context.Context, id int32) ApiDcimPowerPortsUpdateRequest {
	return ApiDcimPowerPortsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PowerPort
func (a *DcimApiService) DcimPowerPortsUpdateExecute(r ApiDcimPowerPortsUpdateRequest) (*PowerPort, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PowerPort
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimPowerPortsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-ports/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimRackReservationsBulkDeleteRequest struct {
	ctx context.Context
	ApiService *DcimApiService
}

func (r ApiDcimRackReservationsBulkDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimRackReservationsBulkDeleteExecute(r)
}

/*
DcimRackReservationsBulkDelete Method for DcimRackReservationsBulkDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimRackReservationsBulkDeleteRequest
*/
func (a *DcimApiService) DcimRackReservationsBulkDelete(ctx context.Context) ApiDcimRackReservationsBulkDeleteRequest {
	return ApiDcimRackReservationsBulkDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DcimApiService) DcimRackReservationsBulkDeleteExecute(r ApiDcimRackReservationsBulkDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimRackReservationsBulkDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/rack-reservations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimRackReservationsBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	data *WritableRackReservation
}

func (r ApiDcimRackReservationsBulkPartialUpdateRequest) Data(data WritableRackReservation) ApiDcimRackReservationsBulkPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimRackReservationsBulkPartialUpdateRequest) Execute() (*RackReservation, *http.Response, error) {
	return r.ApiService.DcimRackReservationsBulkPartialUpdateExecute(r)
}

/*
DcimRackReservationsBulkPartialUpdate Method for DcimRackReservationsBulkPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimRackReservationsBulkPartialUpdateRequest
*/
func (a *DcimApiService) DcimRackReservationsBulkPartialUpdate(ctx context.Context) ApiDcimRackReservationsBulkPartialUpdateRequest {
	return ApiDcimRackReservationsBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RackReservation
func (a *DcimApiService) DcimRackReservationsBulkPartialUpdateExecute(r ApiDcimRackReservationsBulkPartialUpdateRequest) (*RackReservation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RackReservation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimRackReservationsBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/rack-reservations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimRackReservationsBulkUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	data *WritableRackReservation
}

func (r ApiDcimRackReservationsBulkUpdateRequest) Data(data WritableRackReservation) ApiDcimRackReservationsBulkUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimRackReservationsBulkUpdateRequest) Execute() (*RackReservation, *http.Response, error) {
	return r.ApiService.DcimRackReservationsBulkUpdateExecute(r)
}

/*
DcimRackReservationsBulkUpdate Method for DcimRackReservationsBulkUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimRackReservationsBulkUpdateRequest
*/
func (a *DcimApiService) DcimRackReservationsBulkUpdate(ctx context.Context) ApiDcimRackReservationsBulkUpdateRequest {
	return ApiDcimRackReservationsBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RackReservation
func (a *DcimApiService) DcimRackReservationsBulkUpdateExecute(r ApiDcimRackReservationsBulkUpdateRequest) (*RackReservation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RackReservation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimRackReservationsBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/rack-reservations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimRackReservationsCreateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	data *WritableRackReservation
}

func (r ApiDcimRackReservationsCreateRequest) Data(data WritableRackReservation) ApiDcimRackReservationsCreateRequest {
	r.data = &data
	return r
}

func (r ApiDcimRackReservationsCreateRequest) Execute() (*RackReservation, *http.Response, error) {
	return r.ApiService.DcimRackReservationsCreateExecute(r)
}

/*
DcimRackReservationsCreate Method for DcimRackReservationsCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimRackReservationsCreateRequest
*/
func (a *DcimApiService) DcimRackReservationsCreate(ctx context.Context) ApiDcimRackReservationsCreateRequest {
	return ApiDcimRackReservationsCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RackReservation
func (a *DcimApiService) DcimRackReservationsCreateExecute(r ApiDcimRackReservationsCreateRequest) (*RackReservation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RackReservation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimRackReservationsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/rack-reservations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimRackReservationsDeleteRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
}

func (r ApiDcimRackReservationsDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimRackReservationsDeleteExecute(r)
}

/*
DcimRackReservationsDelete Method for DcimRackReservationsDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this rack reservation.
 @return ApiDcimRackReservationsDeleteRequest
*/
func (a *DcimApiService) DcimRackReservationsDelete(ctx context.Context, id int32) ApiDcimRackReservationsDeleteRequest {
	return ApiDcimRackReservationsDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DcimApiService) DcimRackReservationsDeleteExecute(r ApiDcimRackReservationsDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimRackReservationsDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/rack-reservations/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimRackReservationsListRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id *string
	created *string
	createdGte *string
	createdLte *string
	lastUpdated *string
	lastUpdatedGte *string
	lastUpdatedLte *string
	tenantGroupId *string
	tenantGroup *string
	tenantId *string
	tenant *string
	q *string
	rackId *string
	siteId *string
	site *string
	locationId *string
	location *string
	userId *string
	user *string
	tag *string
	idN *string
	idLte *string
	idLt *string
	idGte *string
	idGt *string
	tenantGroupIdN *string
	tenantGroupN *string
	tenantIdN *string
	tenantN *string
	rackIdN *string
	siteIdN *string
	siteN *string
	locationIdN *string
	locationN *string
	userIdN *string
	userN *string
	tagN *string
	limit *int32
	offset *int32
}

func (r ApiDcimRackReservationsListRequest) Id(id string) ApiDcimRackReservationsListRequest {
	r.id = &id
	return r
}

func (r ApiDcimRackReservationsListRequest) Created(created string) ApiDcimRackReservationsListRequest {
	r.created = &created
	return r
}

func (r ApiDcimRackReservationsListRequest) CreatedGte(createdGte string) ApiDcimRackReservationsListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiDcimRackReservationsListRequest) CreatedLte(createdLte string) ApiDcimRackReservationsListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiDcimRackReservationsListRequest) LastUpdated(lastUpdated string) ApiDcimRackReservationsListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiDcimRackReservationsListRequest) LastUpdatedGte(lastUpdatedGte string) ApiDcimRackReservationsListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiDcimRackReservationsListRequest) LastUpdatedLte(lastUpdatedLte string) ApiDcimRackReservationsListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiDcimRackReservationsListRequest) TenantGroupId(tenantGroupId string) ApiDcimRackReservationsListRequest {
	r.tenantGroupId = &tenantGroupId
	return r
}

func (r ApiDcimRackReservationsListRequest) TenantGroup(tenantGroup string) ApiDcimRackReservationsListRequest {
	r.tenantGroup = &tenantGroup
	return r
}

func (r ApiDcimRackReservationsListRequest) TenantId(tenantId string) ApiDcimRackReservationsListRequest {
	r.tenantId = &tenantId
	return r
}

func (r ApiDcimRackReservationsListRequest) Tenant(tenant string) ApiDcimRackReservationsListRequest {
	r.tenant = &tenant
	return r
}

func (r ApiDcimRackReservationsListRequest) Q(q string) ApiDcimRackReservationsListRequest {
	r.q = &q
	return r
}

func (r ApiDcimRackReservationsListRequest) RackId(rackId string) ApiDcimRackReservationsListRequest {
	r.rackId = &rackId
	return r
}

func (r ApiDcimRackReservationsListRequest) SiteId(siteId string) ApiDcimRackReservationsListRequest {
	r.siteId = &siteId
	return r
}

func (r ApiDcimRackReservationsListRequest) Site(site string) ApiDcimRackReservationsListRequest {
	r.site = &site
	return r
}

func (r ApiDcimRackReservationsListRequest) LocationId(locationId string) ApiDcimRackReservationsListRequest {
	r.locationId = &locationId
	return r
}

func (r ApiDcimRackReservationsListRequest) Location(location string) ApiDcimRackReservationsListRequest {
	r.location = &location
	return r
}

func (r ApiDcimRackReservationsListRequest) UserId(userId string) ApiDcimRackReservationsListRequest {
	r.userId = &userId
	return r
}

func (r ApiDcimRackReservationsListRequest) User(user string) ApiDcimRackReservationsListRequest {
	r.user = &user
	return r
}

func (r ApiDcimRackReservationsListRequest) Tag(tag string) ApiDcimRackReservationsListRequest {
	r.tag = &tag
	return r
}

func (r ApiDcimRackReservationsListRequest) IdN(idN string) ApiDcimRackReservationsListRequest {
	r.idN = &idN
	return r
}

func (r ApiDcimRackReservationsListRequest) IdLte(idLte string) ApiDcimRackReservationsListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiDcimRackReservationsListRequest) IdLt(idLt string) ApiDcimRackReservationsListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiDcimRackReservationsListRequest) IdGte(idGte string) ApiDcimRackReservationsListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiDcimRackReservationsListRequest) IdGt(idGt string) ApiDcimRackReservationsListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiDcimRackReservationsListRequest) TenantGroupIdN(tenantGroupIdN string) ApiDcimRackReservationsListRequest {
	r.tenantGroupIdN = &tenantGroupIdN
	return r
}

func (r ApiDcimRackReservationsListRequest) TenantGroupN(tenantGroupN string) ApiDcimRackReservationsListRequest {
	r.tenantGroupN = &tenantGroupN
	return r
}

func (r ApiDcimRackReservationsListRequest) TenantIdN(tenantIdN string) ApiDcimRackReservationsListRequest {
	r.tenantIdN = &tenantIdN
	return r
}

func (r ApiDcimRackReservationsListRequest) TenantN(tenantN string) ApiDcimRackReservationsListRequest {
	r.tenantN = &tenantN
	return r
}

func (r ApiDcimRackReservationsListRequest) RackIdN(rackIdN string) ApiDcimRackReservationsListRequest {
	r.rackIdN = &rackIdN
	return r
}

func (r ApiDcimRackReservationsListRequest) SiteIdN(siteIdN string) ApiDcimRackReservationsListRequest {
	r.siteIdN = &siteIdN
	return r
}

func (r ApiDcimRackReservationsListRequest) SiteN(siteN string) ApiDcimRackReservationsListRequest {
	r.siteN = &siteN
	return r
}

func (r ApiDcimRackReservationsListRequest) LocationIdN(locationIdN string) ApiDcimRackReservationsListRequest {
	r.locationIdN = &locationIdN
	return r
}

func (r ApiDcimRackReservationsListRequest) LocationN(locationN string) ApiDcimRackReservationsListRequest {
	r.locationN = &locationN
	return r
}

func (r ApiDcimRackReservationsListRequest) UserIdN(userIdN string) ApiDcimRackReservationsListRequest {
	r.userIdN = &userIdN
	return r
}

func (r ApiDcimRackReservationsListRequest) UserN(userN string) ApiDcimRackReservationsListRequest {
	r.userN = &userN
	return r
}

func (r ApiDcimRackReservationsListRequest) TagN(tagN string) ApiDcimRackReservationsListRequest {
	r.tagN = &tagN
	return r
}

// Number of results to return per page.
func (r ApiDcimRackReservationsListRequest) Limit(limit int32) ApiDcimRackReservationsListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiDcimRackReservationsListRequest) Offset(offset int32) ApiDcimRackReservationsListRequest {
	r.offset = &offset
	return r
}

func (r ApiDcimRackReservationsListRequest) Execute() (*DcimRackReservationsList200Response, *http.Response, error) {
	return r.ApiService.DcimRackReservationsListExecute(r)
}

/*
DcimRackReservationsList Method for DcimRackReservationsList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimRackReservationsListRequest
*/
func (a *DcimApiService) DcimRackReservationsList(ctx context.Context) ApiDcimRackReservationsListRequest {
	return ApiDcimRackReservationsListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DcimRackReservationsList200Response
func (a *DcimApiService) DcimRackReservationsListExecute(r ApiDcimRackReservationsListRequest) (*DcimRackReservationsList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DcimRackReservationsList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimRackReservationsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/rack-reservations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.created != nil {
		localVarQueryParams.Add("created", parameterToString(*r.created, ""))
	}
	if r.createdGte != nil {
		localVarQueryParams.Add("created__gte", parameterToString(*r.createdGte, ""))
	}
	if r.createdLte != nil {
		localVarQueryParams.Add("created__lte", parameterToString(*r.createdLte, ""))
	}
	if r.lastUpdated != nil {
		localVarQueryParams.Add("last_updated", parameterToString(*r.lastUpdated, ""))
	}
	if r.lastUpdatedGte != nil {
		localVarQueryParams.Add("last_updated__gte", parameterToString(*r.lastUpdatedGte, ""))
	}
	if r.lastUpdatedLte != nil {
		localVarQueryParams.Add("last_updated__lte", parameterToString(*r.lastUpdatedLte, ""))
	}
	if r.tenantGroupId != nil {
		localVarQueryParams.Add("tenant_group_id", parameterToString(*r.tenantGroupId, ""))
	}
	if r.tenantGroup != nil {
		localVarQueryParams.Add("tenant_group", parameterToString(*r.tenantGroup, ""))
	}
	if r.tenantId != nil {
		localVarQueryParams.Add("tenant_id", parameterToString(*r.tenantId, ""))
	}
	if r.tenant != nil {
		localVarQueryParams.Add("tenant", parameterToString(*r.tenant, ""))
	}
	if r.q != nil {
		localVarQueryParams.Add("q", parameterToString(*r.q, ""))
	}
	if r.rackId != nil {
		localVarQueryParams.Add("rack_id", parameterToString(*r.rackId, ""))
	}
	if r.siteId != nil {
		localVarQueryParams.Add("site_id", parameterToString(*r.siteId, ""))
	}
	if r.site != nil {
		localVarQueryParams.Add("site", parameterToString(*r.site, ""))
	}
	if r.locationId != nil {
		localVarQueryParams.Add("location_id", parameterToString(*r.locationId, ""))
	}
	if r.location != nil {
		localVarQueryParams.Add("location", parameterToString(*r.location, ""))
	}
	if r.userId != nil {
		localVarQueryParams.Add("user_id", parameterToString(*r.userId, ""))
	}
	if r.user != nil {
		localVarQueryParams.Add("user", parameterToString(*r.user, ""))
	}
	if r.tag != nil {
		localVarQueryParams.Add("tag", parameterToString(*r.tag, ""))
	}
	if r.idN != nil {
		localVarQueryParams.Add("id__n", parameterToString(*r.idN, ""))
	}
	if r.idLte != nil {
		localVarQueryParams.Add("id__lte", parameterToString(*r.idLte, ""))
	}
	if r.idLt != nil {
		localVarQueryParams.Add("id__lt", parameterToString(*r.idLt, ""))
	}
	if r.idGte != nil {
		localVarQueryParams.Add("id__gte", parameterToString(*r.idGte, ""))
	}
	if r.idGt != nil {
		localVarQueryParams.Add("id__gt", parameterToString(*r.idGt, ""))
	}
	if r.tenantGroupIdN != nil {
		localVarQueryParams.Add("tenant_group_id__n", parameterToString(*r.tenantGroupIdN, ""))
	}
	if r.tenantGroupN != nil {
		localVarQueryParams.Add("tenant_group__n", parameterToString(*r.tenantGroupN, ""))
	}
	if r.tenantIdN != nil {
		localVarQueryParams.Add("tenant_id__n", parameterToString(*r.tenantIdN, ""))
	}
	if r.tenantN != nil {
		localVarQueryParams.Add("tenant__n", parameterToString(*r.tenantN, ""))
	}
	if r.rackIdN != nil {
		localVarQueryParams.Add("rack_id__n", parameterToString(*r.rackIdN, ""))
	}
	if r.siteIdN != nil {
		localVarQueryParams.Add("site_id__n", parameterToString(*r.siteIdN, ""))
	}
	if r.siteN != nil {
		localVarQueryParams.Add("site__n", parameterToString(*r.siteN, ""))
	}
	if r.locationIdN != nil {
		localVarQueryParams.Add("location_id__n", parameterToString(*r.locationIdN, ""))
	}
	if r.locationN != nil {
		localVarQueryParams.Add("location__n", parameterToString(*r.locationN, ""))
	}
	if r.userIdN != nil {
		localVarQueryParams.Add("user_id__n", parameterToString(*r.userIdN, ""))
	}
	if r.userN != nil {
		localVarQueryParams.Add("user__n", parameterToString(*r.userN, ""))
	}
	if r.tagN != nil {
		localVarQueryParams.Add("tag__n", parameterToString(*r.tagN, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimRackReservationsPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
	data *WritableRackReservation
}

func (r ApiDcimRackReservationsPartialUpdateRequest) Data(data WritableRackReservation) ApiDcimRackReservationsPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimRackReservationsPartialUpdateRequest) Execute() (*RackReservation, *http.Response, error) {
	return r.ApiService.DcimRackReservationsPartialUpdateExecute(r)
}

/*
DcimRackReservationsPartialUpdate Method for DcimRackReservationsPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this rack reservation.
 @return ApiDcimRackReservationsPartialUpdateRequest
*/
func (a *DcimApiService) DcimRackReservationsPartialUpdate(ctx context.Context, id int32) ApiDcimRackReservationsPartialUpdateRequest {
	return ApiDcimRackReservationsPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return RackReservation
func (a *DcimApiService) DcimRackReservationsPartialUpdateExecute(r ApiDcimRackReservationsPartialUpdateRequest) (*RackReservation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RackReservation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimRackReservationsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/rack-reservations/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimRackReservationsReadRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
}

func (r ApiDcimRackReservationsReadRequest) Execute() (*RackReservation, *http.Response, error) {
	return r.ApiService.DcimRackReservationsReadExecute(r)
}

/*
DcimRackReservationsRead Method for DcimRackReservationsRead

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this rack reservation.
 @return ApiDcimRackReservationsReadRequest
*/
func (a *DcimApiService) DcimRackReservationsRead(ctx context.Context, id int32) ApiDcimRackReservationsReadRequest {
	return ApiDcimRackReservationsReadRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return RackReservation
func (a *DcimApiService) DcimRackReservationsReadExecute(r ApiDcimRackReservationsReadRequest) (*RackReservation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RackReservation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimRackReservationsRead")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/rack-reservations/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimRackReservationsUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
	data *WritableRackReservation
}

func (r ApiDcimRackReservationsUpdateRequest) Data(data WritableRackReservation) ApiDcimRackReservationsUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimRackReservationsUpdateRequest) Execute() (*RackReservation, *http.Response, error) {
	return r.ApiService.DcimRackReservationsUpdateExecute(r)
}

/*
DcimRackReservationsUpdate Method for DcimRackReservationsUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this rack reservation.
 @return ApiDcimRackReservationsUpdateRequest
*/
func (a *DcimApiService) DcimRackReservationsUpdate(ctx context.Context, id int32) ApiDcimRackReservationsUpdateRequest {
	return ApiDcimRackReservationsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return RackReservation
func (a *DcimApiService) DcimRackReservationsUpdateExecute(r ApiDcimRackReservationsUpdateRequest) (*RackReservation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RackReservation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimRackReservationsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/rack-reservations/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimRackRolesBulkDeleteRequest struct {
	ctx context.Context
	ApiService *DcimApiService
}

func (r ApiDcimRackRolesBulkDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimRackRolesBulkDeleteExecute(r)
}

/*
DcimRackRolesBulkDelete Method for DcimRackRolesBulkDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimRackRolesBulkDeleteRequest
*/
func (a *DcimApiService) DcimRackRolesBulkDelete(ctx context.Context) ApiDcimRackRolesBulkDeleteRequest {
	return ApiDcimRackRolesBulkDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DcimApiService) DcimRackRolesBulkDeleteExecute(r ApiDcimRackRolesBulkDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimRackRolesBulkDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/rack-roles/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimRackRolesBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	data *RackRole
}

func (r ApiDcimRackRolesBulkPartialUpdateRequest) Data(data RackRole) ApiDcimRackRolesBulkPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimRackRolesBulkPartialUpdateRequest) Execute() (*RackRole, *http.Response, error) {
	return r.ApiService.DcimRackRolesBulkPartialUpdateExecute(r)
}

/*
DcimRackRolesBulkPartialUpdate Method for DcimRackRolesBulkPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimRackRolesBulkPartialUpdateRequest
*/
func (a *DcimApiService) DcimRackRolesBulkPartialUpdate(ctx context.Context) ApiDcimRackRolesBulkPartialUpdateRequest {
	return ApiDcimRackRolesBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RackRole
func (a *DcimApiService) DcimRackRolesBulkPartialUpdateExecute(r ApiDcimRackRolesBulkPartialUpdateRequest) (*RackRole, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RackRole
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimRackRolesBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/rack-roles/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimRackRolesBulkUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	data *RackRole
}

func (r ApiDcimRackRolesBulkUpdateRequest) Data(data RackRole) ApiDcimRackRolesBulkUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimRackRolesBulkUpdateRequest) Execute() (*RackRole, *http.Response, error) {
	return r.ApiService.DcimRackRolesBulkUpdateExecute(r)
}

/*
DcimRackRolesBulkUpdate Method for DcimRackRolesBulkUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimRackRolesBulkUpdateRequest
*/
func (a *DcimApiService) DcimRackRolesBulkUpdate(ctx context.Context) ApiDcimRackRolesBulkUpdateRequest {
	return ApiDcimRackRolesBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RackRole
func (a *DcimApiService) DcimRackRolesBulkUpdateExecute(r ApiDcimRackRolesBulkUpdateRequest) (*RackRole, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RackRole
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimRackRolesBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/rack-roles/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimRackRolesCreateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	data *RackRole
}

func (r ApiDcimRackRolesCreateRequest) Data(data RackRole) ApiDcimRackRolesCreateRequest {
	r.data = &data
	return r
}

func (r ApiDcimRackRolesCreateRequest) Execute() (*RackRole, *http.Response, error) {
	return r.ApiService.DcimRackRolesCreateExecute(r)
}

/*
DcimRackRolesCreate Method for DcimRackRolesCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimRackRolesCreateRequest
*/
func (a *DcimApiService) DcimRackRolesCreate(ctx context.Context) ApiDcimRackRolesCreateRequest {
	return ApiDcimRackRolesCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RackRole
func (a *DcimApiService) DcimRackRolesCreateExecute(r ApiDcimRackRolesCreateRequest) (*RackRole, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RackRole
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimRackRolesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/rack-roles/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimRackRolesDeleteRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
}

func (r ApiDcimRackRolesDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimRackRolesDeleteExecute(r)
}

/*
DcimRackRolesDelete Method for DcimRackRolesDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this rack role.
 @return ApiDcimRackRolesDeleteRequest
*/
func (a *DcimApiService) DcimRackRolesDelete(ctx context.Context, id int32) ApiDcimRackRolesDeleteRequest {
	return ApiDcimRackRolesDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DcimApiService) DcimRackRolesDeleteExecute(r ApiDcimRackRolesDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimRackRolesDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/rack-roles/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimRackRolesListRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id *string
	name *string
	slug *string
	color *string
	created *string
	createdGte *string
	createdLte *string
	lastUpdated *string
	lastUpdatedGte *string
	lastUpdatedLte *string
	q *string
	idN *string
	idLte *string
	idLt *string
	idGte *string
	idGt *string
	nameN *string
	nameIc *string
	nameNic *string
	nameIew *string
	nameNiew *string
	nameIsw *string
	nameNisw *string
	nameIe *string
	nameNie *string
	nameEmpty *string
	slugN *string
	slugIc *string
	slugNic *string
	slugIew *string
	slugNiew *string
	slugIsw *string
	slugNisw *string
	slugIe *string
	slugNie *string
	slugEmpty *string
	colorN *string
	colorIc *string
	colorNic *string
	colorIew *string
	colorNiew *string
	colorIsw *string
	colorNisw *string
	colorIe *string
	colorNie *string
	colorEmpty *string
	limit *int32
	offset *int32
}

func (r ApiDcimRackRolesListRequest) Id(id string) ApiDcimRackRolesListRequest {
	r.id = &id
	return r
}

func (r ApiDcimRackRolesListRequest) Name(name string) ApiDcimRackRolesListRequest {
	r.name = &name
	return r
}

func (r ApiDcimRackRolesListRequest) Slug(slug string) ApiDcimRackRolesListRequest {
	r.slug = &slug
	return r
}

func (r ApiDcimRackRolesListRequest) Color(color string) ApiDcimRackRolesListRequest {
	r.color = &color
	return r
}

func (r ApiDcimRackRolesListRequest) Created(created string) ApiDcimRackRolesListRequest {
	r.created = &created
	return r
}

func (r ApiDcimRackRolesListRequest) CreatedGte(createdGte string) ApiDcimRackRolesListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiDcimRackRolesListRequest) CreatedLte(createdLte string) ApiDcimRackRolesListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiDcimRackRolesListRequest) LastUpdated(lastUpdated string) ApiDcimRackRolesListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiDcimRackRolesListRequest) LastUpdatedGte(lastUpdatedGte string) ApiDcimRackRolesListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiDcimRackRolesListRequest) LastUpdatedLte(lastUpdatedLte string) ApiDcimRackRolesListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiDcimRackRolesListRequest) Q(q string) ApiDcimRackRolesListRequest {
	r.q = &q
	return r
}

func (r ApiDcimRackRolesListRequest) IdN(idN string) ApiDcimRackRolesListRequest {
	r.idN = &idN
	return r
}

func (r ApiDcimRackRolesListRequest) IdLte(idLte string) ApiDcimRackRolesListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiDcimRackRolesListRequest) IdLt(idLt string) ApiDcimRackRolesListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiDcimRackRolesListRequest) IdGte(idGte string) ApiDcimRackRolesListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiDcimRackRolesListRequest) IdGt(idGt string) ApiDcimRackRolesListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiDcimRackRolesListRequest) NameN(nameN string) ApiDcimRackRolesListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiDcimRackRolesListRequest) NameIc(nameIc string) ApiDcimRackRolesListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiDcimRackRolesListRequest) NameNic(nameNic string) ApiDcimRackRolesListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiDcimRackRolesListRequest) NameIew(nameIew string) ApiDcimRackRolesListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiDcimRackRolesListRequest) NameNiew(nameNiew string) ApiDcimRackRolesListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiDcimRackRolesListRequest) NameIsw(nameIsw string) ApiDcimRackRolesListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiDcimRackRolesListRequest) NameNisw(nameNisw string) ApiDcimRackRolesListRequest {
	r.nameNisw = &nameNisw
	return r
}

func (r ApiDcimRackRolesListRequest) NameIe(nameIe string) ApiDcimRackRolesListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiDcimRackRolesListRequest) NameNie(nameNie string) ApiDcimRackRolesListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiDcimRackRolesListRequest) NameEmpty(nameEmpty string) ApiDcimRackRolesListRequest {
	r.nameEmpty = &nameEmpty
	return r
}

func (r ApiDcimRackRolesListRequest) SlugN(slugN string) ApiDcimRackRolesListRequest {
	r.slugN = &slugN
	return r
}

func (r ApiDcimRackRolesListRequest) SlugIc(slugIc string) ApiDcimRackRolesListRequest {
	r.slugIc = &slugIc
	return r
}

func (r ApiDcimRackRolesListRequest) SlugNic(slugNic string) ApiDcimRackRolesListRequest {
	r.slugNic = &slugNic
	return r
}

func (r ApiDcimRackRolesListRequest) SlugIew(slugIew string) ApiDcimRackRolesListRequest {
	r.slugIew = &slugIew
	return r
}

func (r ApiDcimRackRolesListRequest) SlugNiew(slugNiew string) ApiDcimRackRolesListRequest {
	r.slugNiew = &slugNiew
	return r
}

func (r ApiDcimRackRolesListRequest) SlugIsw(slugIsw string) ApiDcimRackRolesListRequest {
	r.slugIsw = &slugIsw
	return r
}

func (r ApiDcimRackRolesListRequest) SlugNisw(slugNisw string) ApiDcimRackRolesListRequest {
	r.slugNisw = &slugNisw
	return r
}

func (r ApiDcimRackRolesListRequest) SlugIe(slugIe string) ApiDcimRackRolesListRequest {
	r.slugIe = &slugIe
	return r
}

func (r ApiDcimRackRolesListRequest) SlugNie(slugNie string) ApiDcimRackRolesListRequest {
	r.slugNie = &slugNie
	return r
}

func (r ApiDcimRackRolesListRequest) SlugEmpty(slugEmpty string) ApiDcimRackRolesListRequest {
	r.slugEmpty = &slugEmpty
	return r
}

func (r ApiDcimRackRolesListRequest) ColorN(colorN string) ApiDcimRackRolesListRequest {
	r.colorN = &colorN
	return r
}

func (r ApiDcimRackRolesListRequest) ColorIc(colorIc string) ApiDcimRackRolesListRequest {
	r.colorIc = &colorIc
	return r
}

func (r ApiDcimRackRolesListRequest) ColorNic(colorNic string) ApiDcimRackRolesListRequest {
	r.colorNic = &colorNic
	return r
}

func (r ApiDcimRackRolesListRequest) ColorIew(colorIew string) ApiDcimRackRolesListRequest {
	r.colorIew = &colorIew
	return r
}

func (r ApiDcimRackRolesListRequest) ColorNiew(colorNiew string) ApiDcimRackRolesListRequest {
	r.colorNiew = &colorNiew
	return r
}

func (r ApiDcimRackRolesListRequest) ColorIsw(colorIsw string) ApiDcimRackRolesListRequest {
	r.colorIsw = &colorIsw
	return r
}

func (r ApiDcimRackRolesListRequest) ColorNisw(colorNisw string) ApiDcimRackRolesListRequest {
	r.colorNisw = &colorNisw
	return r
}

func (r ApiDcimRackRolesListRequest) ColorIe(colorIe string) ApiDcimRackRolesListRequest {
	r.colorIe = &colorIe
	return r
}

func (r ApiDcimRackRolesListRequest) ColorNie(colorNie string) ApiDcimRackRolesListRequest {
	r.colorNie = &colorNie
	return r
}

func (r ApiDcimRackRolesListRequest) ColorEmpty(colorEmpty string) ApiDcimRackRolesListRequest {
	r.colorEmpty = &colorEmpty
	return r
}

// Number of results to return per page.
func (r ApiDcimRackRolesListRequest) Limit(limit int32) ApiDcimRackRolesListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiDcimRackRolesListRequest) Offset(offset int32) ApiDcimRackRolesListRequest {
	r.offset = &offset
	return r
}

func (r ApiDcimRackRolesListRequest) Execute() (*DcimRackRolesList200Response, *http.Response, error) {
	return r.ApiService.DcimRackRolesListExecute(r)
}

/*
DcimRackRolesList Method for DcimRackRolesList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimRackRolesListRequest
*/
func (a *DcimApiService) DcimRackRolesList(ctx context.Context) ApiDcimRackRolesListRequest {
	return ApiDcimRackRolesListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DcimRackRolesList200Response
func (a *DcimApiService) DcimRackRolesListExecute(r ApiDcimRackRolesListRequest) (*DcimRackRolesList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DcimRackRolesList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimRackRolesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/rack-roles/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.slug != nil {
		localVarQueryParams.Add("slug", parameterToString(*r.slug, ""))
	}
	if r.color != nil {
		localVarQueryParams.Add("color", parameterToString(*r.color, ""))
	}
	if r.created != nil {
		localVarQueryParams.Add("created", parameterToString(*r.created, ""))
	}
	if r.createdGte != nil {
		localVarQueryParams.Add("created__gte", parameterToString(*r.createdGte, ""))
	}
	if r.createdLte != nil {
		localVarQueryParams.Add("created__lte", parameterToString(*r.createdLte, ""))
	}
	if r.lastUpdated != nil {
		localVarQueryParams.Add("last_updated", parameterToString(*r.lastUpdated, ""))
	}
	if r.lastUpdatedGte != nil {
		localVarQueryParams.Add("last_updated__gte", parameterToString(*r.lastUpdatedGte, ""))
	}
	if r.lastUpdatedLte != nil {
		localVarQueryParams.Add("last_updated__lte", parameterToString(*r.lastUpdatedLte, ""))
	}
	if r.q != nil {
		localVarQueryParams.Add("q", parameterToString(*r.q, ""))
	}
	if r.idN != nil {
		localVarQueryParams.Add("id__n", parameterToString(*r.idN, ""))
	}
	if r.idLte != nil {
		localVarQueryParams.Add("id__lte", parameterToString(*r.idLte, ""))
	}
	if r.idLt != nil {
		localVarQueryParams.Add("id__lt", parameterToString(*r.idLt, ""))
	}
	if r.idGte != nil {
		localVarQueryParams.Add("id__gte", parameterToString(*r.idGte, ""))
	}
	if r.idGt != nil {
		localVarQueryParams.Add("id__gt", parameterToString(*r.idGt, ""))
	}
	if r.nameN != nil {
		localVarQueryParams.Add("name__n", parameterToString(*r.nameN, ""))
	}
	if r.nameIc != nil {
		localVarQueryParams.Add("name__ic", parameterToString(*r.nameIc, ""))
	}
	if r.nameNic != nil {
		localVarQueryParams.Add("name__nic", parameterToString(*r.nameNic, ""))
	}
	if r.nameIew != nil {
		localVarQueryParams.Add("name__iew", parameterToString(*r.nameIew, ""))
	}
	if r.nameNiew != nil {
		localVarQueryParams.Add("name__niew", parameterToString(*r.nameNiew, ""))
	}
	if r.nameIsw != nil {
		localVarQueryParams.Add("name__isw", parameterToString(*r.nameIsw, ""))
	}
	if r.nameNisw != nil {
		localVarQueryParams.Add("name__nisw", parameterToString(*r.nameNisw, ""))
	}
	if r.nameIe != nil {
		localVarQueryParams.Add("name__ie", parameterToString(*r.nameIe, ""))
	}
	if r.nameNie != nil {
		localVarQueryParams.Add("name__nie", parameterToString(*r.nameNie, ""))
	}
	if r.nameEmpty != nil {
		localVarQueryParams.Add("name__empty", parameterToString(*r.nameEmpty, ""))
	}
	if r.slugN != nil {
		localVarQueryParams.Add("slug__n", parameterToString(*r.slugN, ""))
	}
	if r.slugIc != nil {
		localVarQueryParams.Add("slug__ic", parameterToString(*r.slugIc, ""))
	}
	if r.slugNic != nil {
		localVarQueryParams.Add("slug__nic", parameterToString(*r.slugNic, ""))
	}
	if r.slugIew != nil {
		localVarQueryParams.Add("slug__iew", parameterToString(*r.slugIew, ""))
	}
	if r.slugNiew != nil {
		localVarQueryParams.Add("slug__niew", parameterToString(*r.slugNiew, ""))
	}
	if r.slugIsw != nil {
		localVarQueryParams.Add("slug__isw", parameterToString(*r.slugIsw, ""))
	}
	if r.slugNisw != nil {
		localVarQueryParams.Add("slug__nisw", parameterToString(*r.slugNisw, ""))
	}
	if r.slugIe != nil {
		localVarQueryParams.Add("slug__ie", parameterToString(*r.slugIe, ""))
	}
	if r.slugNie != nil {
		localVarQueryParams.Add("slug__nie", parameterToString(*r.slugNie, ""))
	}
	if r.slugEmpty != nil {
		localVarQueryParams.Add("slug__empty", parameterToString(*r.slugEmpty, ""))
	}
	if r.colorN != nil {
		localVarQueryParams.Add("color__n", parameterToString(*r.colorN, ""))
	}
	if r.colorIc != nil {
		localVarQueryParams.Add("color__ic", parameterToString(*r.colorIc, ""))
	}
	if r.colorNic != nil {
		localVarQueryParams.Add("color__nic", parameterToString(*r.colorNic, ""))
	}
	if r.colorIew != nil {
		localVarQueryParams.Add("color__iew", parameterToString(*r.colorIew, ""))
	}
	if r.colorNiew != nil {
		localVarQueryParams.Add("color__niew", parameterToString(*r.colorNiew, ""))
	}
	if r.colorIsw != nil {
		localVarQueryParams.Add("color__isw", parameterToString(*r.colorIsw, ""))
	}
	if r.colorNisw != nil {
		localVarQueryParams.Add("color__nisw", parameterToString(*r.colorNisw, ""))
	}
	if r.colorIe != nil {
		localVarQueryParams.Add("color__ie", parameterToString(*r.colorIe, ""))
	}
	if r.colorNie != nil {
		localVarQueryParams.Add("color__nie", parameterToString(*r.colorNie, ""))
	}
	if r.colorEmpty != nil {
		localVarQueryParams.Add("color__empty", parameterToString(*r.colorEmpty, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimRackRolesPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
	data *RackRole
}

func (r ApiDcimRackRolesPartialUpdateRequest) Data(data RackRole) ApiDcimRackRolesPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimRackRolesPartialUpdateRequest) Execute() (*RackRole, *http.Response, error) {
	return r.ApiService.DcimRackRolesPartialUpdateExecute(r)
}

/*
DcimRackRolesPartialUpdate Method for DcimRackRolesPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this rack role.
 @return ApiDcimRackRolesPartialUpdateRequest
*/
func (a *DcimApiService) DcimRackRolesPartialUpdate(ctx context.Context, id int32) ApiDcimRackRolesPartialUpdateRequest {
	return ApiDcimRackRolesPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return RackRole
func (a *DcimApiService) DcimRackRolesPartialUpdateExecute(r ApiDcimRackRolesPartialUpdateRequest) (*RackRole, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RackRole
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimRackRolesPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/rack-roles/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimRackRolesReadRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
}

func (r ApiDcimRackRolesReadRequest) Execute() (*RackRole, *http.Response, error) {
	return r.ApiService.DcimRackRolesReadExecute(r)
}

/*
DcimRackRolesRead Method for DcimRackRolesRead

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this rack role.
 @return ApiDcimRackRolesReadRequest
*/
func (a *DcimApiService) DcimRackRolesRead(ctx context.Context, id int32) ApiDcimRackRolesReadRequest {
	return ApiDcimRackRolesReadRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return RackRole
func (a *DcimApiService) DcimRackRolesReadExecute(r ApiDcimRackRolesReadRequest) (*RackRole, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RackRole
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimRackRolesRead")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/rack-roles/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimRackRolesUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
	data *RackRole
}

func (r ApiDcimRackRolesUpdateRequest) Data(data RackRole) ApiDcimRackRolesUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimRackRolesUpdateRequest) Execute() (*RackRole, *http.Response, error) {
	return r.ApiService.DcimRackRolesUpdateExecute(r)
}

/*
DcimRackRolesUpdate Method for DcimRackRolesUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this rack role.
 @return ApiDcimRackRolesUpdateRequest
*/
func (a *DcimApiService) DcimRackRolesUpdate(ctx context.Context, id int32) ApiDcimRackRolesUpdateRequest {
	return ApiDcimRackRolesUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return RackRole
func (a *DcimApiService) DcimRackRolesUpdateExecute(r ApiDcimRackRolesUpdateRequest) (*RackRole, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RackRole
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimRackRolesUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/rack-roles/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimRacksBulkDeleteRequest struct {
	ctx context.Context
	ApiService *DcimApiService
}

func (r ApiDcimRacksBulkDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimRacksBulkDeleteExecute(r)
}

/*
DcimRacksBulkDelete Method for DcimRacksBulkDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimRacksBulkDeleteRequest
*/
func (a *DcimApiService) DcimRacksBulkDelete(ctx context.Context) ApiDcimRacksBulkDeleteRequest {
	return ApiDcimRacksBulkDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DcimApiService) DcimRacksBulkDeleteExecute(r ApiDcimRacksBulkDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimRacksBulkDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/racks/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimRacksBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	data *WritableRack
}

func (r ApiDcimRacksBulkPartialUpdateRequest) Data(data WritableRack) ApiDcimRacksBulkPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimRacksBulkPartialUpdateRequest) Execute() (*Rack, *http.Response, error) {
	return r.ApiService.DcimRacksBulkPartialUpdateExecute(r)
}

/*
DcimRacksBulkPartialUpdate Method for DcimRacksBulkPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimRacksBulkPartialUpdateRequest
*/
func (a *DcimApiService) DcimRacksBulkPartialUpdate(ctx context.Context) ApiDcimRacksBulkPartialUpdateRequest {
	return ApiDcimRacksBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Rack
func (a *DcimApiService) DcimRacksBulkPartialUpdateExecute(r ApiDcimRacksBulkPartialUpdateRequest) (*Rack, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Rack
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimRacksBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/racks/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimRacksBulkUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	data *WritableRack
}

func (r ApiDcimRacksBulkUpdateRequest) Data(data WritableRack) ApiDcimRacksBulkUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimRacksBulkUpdateRequest) Execute() (*Rack, *http.Response, error) {
	return r.ApiService.DcimRacksBulkUpdateExecute(r)
}

/*
DcimRacksBulkUpdate Method for DcimRacksBulkUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimRacksBulkUpdateRequest
*/
func (a *DcimApiService) DcimRacksBulkUpdate(ctx context.Context) ApiDcimRacksBulkUpdateRequest {
	return ApiDcimRacksBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Rack
func (a *DcimApiService) DcimRacksBulkUpdateExecute(r ApiDcimRacksBulkUpdateRequest) (*Rack, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Rack
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimRacksBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/racks/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimRacksCreateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	data *WritableRack
}

func (r ApiDcimRacksCreateRequest) Data(data WritableRack) ApiDcimRacksCreateRequest {
	r.data = &data
	return r
}

func (r ApiDcimRacksCreateRequest) Execute() (*Rack, *http.Response, error) {
	return r.ApiService.DcimRacksCreateExecute(r)
}

/*
DcimRacksCreate Method for DcimRacksCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimRacksCreateRequest
*/
func (a *DcimApiService) DcimRacksCreate(ctx context.Context) ApiDcimRacksCreateRequest {
	return ApiDcimRacksCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Rack
func (a *DcimApiService) DcimRacksCreateExecute(r ApiDcimRacksCreateRequest) (*Rack, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Rack
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimRacksCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/racks/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimRacksDeleteRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
}

func (r ApiDcimRacksDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimRacksDeleteExecute(r)
}

/*
DcimRacksDelete Method for DcimRacksDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this rack.
 @return ApiDcimRacksDeleteRequest
*/
func (a *DcimApiService) DcimRacksDelete(ctx context.Context, id int32) ApiDcimRacksDeleteRequest {
	return ApiDcimRacksDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DcimApiService) DcimRacksDeleteExecute(r ApiDcimRacksDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimRacksDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/racks/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimRacksElevationRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
	q *string
	face *string
	render *string
	unitWidth *int32
	unitHeight *int32
	legendWidth *int32
	exclude *int32
	expandDevices *bool
	includeImages *bool
}

func (r ApiDcimRacksElevationRequest) Q(q string) ApiDcimRacksElevationRequest {
	r.q = &q
	return r
}

func (r ApiDcimRacksElevationRequest) Face(face string) ApiDcimRacksElevationRequest {
	r.face = &face
	return r
}

func (r ApiDcimRacksElevationRequest) Render(render string) ApiDcimRacksElevationRequest {
	r.render = &render
	return r
}

func (r ApiDcimRacksElevationRequest) UnitWidth(unitWidth int32) ApiDcimRacksElevationRequest {
	r.unitWidth = &unitWidth
	return r
}

func (r ApiDcimRacksElevationRequest) UnitHeight(unitHeight int32) ApiDcimRacksElevationRequest {
	r.unitHeight = &unitHeight
	return r
}

func (r ApiDcimRacksElevationRequest) LegendWidth(legendWidth int32) ApiDcimRacksElevationRequest {
	r.legendWidth = &legendWidth
	return r
}

func (r ApiDcimRacksElevationRequest) Exclude(exclude int32) ApiDcimRacksElevationRequest {
	r.exclude = &exclude
	return r
}

func (r ApiDcimRacksElevationRequest) ExpandDevices(expandDevices bool) ApiDcimRacksElevationRequest {
	r.expandDevices = &expandDevices
	return r
}

func (r ApiDcimRacksElevationRequest) IncludeImages(includeImages bool) ApiDcimRacksElevationRequest {
	r.includeImages = &includeImages
	return r
}

func (r ApiDcimRacksElevationRequest) Execute() ([]RackUnit, *http.Response, error) {
	return r.ApiService.DcimRacksElevationExecute(r)
}

/*
DcimRacksElevation Method for DcimRacksElevation

Rack elevation representing the list of rack units. Also supports rendering the elevation as an SVG.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this rack.
 @return ApiDcimRacksElevationRequest
*/
func (a *DcimApiService) DcimRacksElevation(ctx context.Context, id int32) ApiDcimRacksElevationRequest {
	return ApiDcimRacksElevationRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return []RackUnit
func (a *DcimApiService) DcimRacksElevationExecute(r ApiDcimRacksElevationRequest) ([]RackUnit, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []RackUnit
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimRacksElevation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/racks/{id}/elevation/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.q != nil {
		localVarQueryParams.Add("q", parameterToString(*r.q, ""))
	}
	if r.face != nil {
		localVarQueryParams.Add("face", parameterToString(*r.face, ""))
	}
	if r.render != nil {
		localVarQueryParams.Add("render", parameterToString(*r.render, ""))
	}
	if r.unitWidth != nil {
		localVarQueryParams.Add("unit_width", parameterToString(*r.unitWidth, ""))
	}
	if r.unitHeight != nil {
		localVarQueryParams.Add("unit_height", parameterToString(*r.unitHeight, ""))
	}
	if r.legendWidth != nil {
		localVarQueryParams.Add("legend_width", parameterToString(*r.legendWidth, ""))
	}
	if r.exclude != nil {
		localVarQueryParams.Add("exclude", parameterToString(*r.exclude, ""))
	}
	if r.expandDevices != nil {
		localVarQueryParams.Add("expand_devices", parameterToString(*r.expandDevices, ""))
	}
	if r.includeImages != nil {
		localVarQueryParams.Add("include_images", parameterToString(*r.includeImages, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimRacksListRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id *string
	name *string
	facilityId *string
	assetTag *string
	uHeight *string
	descUnits *string
	outerWidth *string
	outerDepth *string
	outerUnit *string
	created *string
	createdGte *string
	createdLte *string
	lastUpdated *string
	lastUpdatedGte *string
	lastUpdatedLte *string
	tenantGroupId *string
	tenantGroup *string
	tenantId *string
	tenant *string
	q *string
	regionId *string
	region *string
	siteGroupId *string
	siteGroup *string
	siteId *string
	site *string
	locationId *string
	location *string
	status *string
	type_ *string
	width *string
	roleId *string
	role *string
	serial *string
	tag *string
	idN *string
	idLte *string
	idLt *string
	idGte *string
	idGt *string
	nameN *string
	nameIc *string
	nameNic *string
	nameIew *string
	nameNiew *string
	nameIsw *string
	nameNisw *string
	nameIe *string
	nameNie *string
	nameEmpty *string
	facilityIdN *string
	facilityIdIc *string
	facilityIdNic *string
	facilityIdIew *string
	facilityIdNiew *string
	facilityIdIsw *string
	facilityIdNisw *string
	facilityIdIe *string
	facilityIdNie *string
	facilityIdEmpty *string
	assetTagN *string
	assetTagIc *string
	assetTagNic *string
	assetTagIew *string
	assetTagNiew *string
	assetTagIsw *string
	assetTagNisw *string
	assetTagIe *string
	assetTagNie *string
	assetTagEmpty *string
	uHeightN *string
	uHeightLte *string
	uHeightLt *string
	uHeightGte *string
	uHeightGt *string
	outerWidthN *string
	outerWidthLte *string
	outerWidthLt *string
	outerWidthGte *string
	outerWidthGt *string
	outerDepthN *string
	outerDepthLte *string
	outerDepthLt *string
	outerDepthGte *string
	outerDepthGt *string
	outerUnitN *string
	tenantGroupIdN *string
	tenantGroupN *string
	tenantIdN *string
	tenantN *string
	regionIdN *string
	regionN *string
	siteGroupIdN *string
	siteGroupN *string
	siteIdN *string
	siteN *string
	locationIdN *string
	locationN *string
	statusN *string
	typeN *string
	widthN *string
	roleIdN *string
	roleN *string
	tagN *string
	limit *int32
	offset *int32
}

func (r ApiDcimRacksListRequest) Id(id string) ApiDcimRacksListRequest {
	r.id = &id
	return r
}

func (r ApiDcimRacksListRequest) Name(name string) ApiDcimRacksListRequest {
	r.name = &name
	return r
}

func (r ApiDcimRacksListRequest) FacilityId(facilityId string) ApiDcimRacksListRequest {
	r.facilityId = &facilityId
	return r
}

func (r ApiDcimRacksListRequest) AssetTag(assetTag string) ApiDcimRacksListRequest {
	r.assetTag = &assetTag
	return r
}

func (r ApiDcimRacksListRequest) UHeight(uHeight string) ApiDcimRacksListRequest {
	r.uHeight = &uHeight
	return r
}

func (r ApiDcimRacksListRequest) DescUnits(descUnits string) ApiDcimRacksListRequest {
	r.descUnits = &descUnits
	return r
}

func (r ApiDcimRacksListRequest) OuterWidth(outerWidth string) ApiDcimRacksListRequest {
	r.outerWidth = &outerWidth
	return r
}

func (r ApiDcimRacksListRequest) OuterDepth(outerDepth string) ApiDcimRacksListRequest {
	r.outerDepth = &outerDepth
	return r
}

func (r ApiDcimRacksListRequest) OuterUnit(outerUnit string) ApiDcimRacksListRequest {
	r.outerUnit = &outerUnit
	return r
}

func (r ApiDcimRacksListRequest) Created(created string) ApiDcimRacksListRequest {
	r.created = &created
	return r
}

func (r ApiDcimRacksListRequest) CreatedGte(createdGte string) ApiDcimRacksListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiDcimRacksListRequest) CreatedLte(createdLte string) ApiDcimRacksListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiDcimRacksListRequest) LastUpdated(lastUpdated string) ApiDcimRacksListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiDcimRacksListRequest) LastUpdatedGte(lastUpdatedGte string) ApiDcimRacksListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiDcimRacksListRequest) LastUpdatedLte(lastUpdatedLte string) ApiDcimRacksListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiDcimRacksListRequest) TenantGroupId(tenantGroupId string) ApiDcimRacksListRequest {
	r.tenantGroupId = &tenantGroupId
	return r
}

func (r ApiDcimRacksListRequest) TenantGroup(tenantGroup string) ApiDcimRacksListRequest {
	r.tenantGroup = &tenantGroup
	return r
}

func (r ApiDcimRacksListRequest) TenantId(tenantId string) ApiDcimRacksListRequest {
	r.tenantId = &tenantId
	return r
}

func (r ApiDcimRacksListRequest) Tenant(tenant string) ApiDcimRacksListRequest {
	r.tenant = &tenant
	return r
}

func (r ApiDcimRacksListRequest) Q(q string) ApiDcimRacksListRequest {
	r.q = &q
	return r
}

func (r ApiDcimRacksListRequest) RegionId(regionId string) ApiDcimRacksListRequest {
	r.regionId = &regionId
	return r
}

func (r ApiDcimRacksListRequest) Region(region string) ApiDcimRacksListRequest {
	r.region = &region
	return r
}

func (r ApiDcimRacksListRequest) SiteGroupId(siteGroupId string) ApiDcimRacksListRequest {
	r.siteGroupId = &siteGroupId
	return r
}

func (r ApiDcimRacksListRequest) SiteGroup(siteGroup string) ApiDcimRacksListRequest {
	r.siteGroup = &siteGroup
	return r
}

func (r ApiDcimRacksListRequest) SiteId(siteId string) ApiDcimRacksListRequest {
	r.siteId = &siteId
	return r
}

func (r ApiDcimRacksListRequest) Site(site string) ApiDcimRacksListRequest {
	r.site = &site
	return r
}

func (r ApiDcimRacksListRequest) LocationId(locationId string) ApiDcimRacksListRequest {
	r.locationId = &locationId
	return r
}

func (r ApiDcimRacksListRequest) Location(location string) ApiDcimRacksListRequest {
	r.location = &location
	return r
}

func (r ApiDcimRacksListRequest) Status(status string) ApiDcimRacksListRequest {
	r.status = &status
	return r
}

func (r ApiDcimRacksListRequest) Type_(type_ string) ApiDcimRacksListRequest {
	r.type_ = &type_
	return r
}

func (r ApiDcimRacksListRequest) Width(width string) ApiDcimRacksListRequest {
	r.width = &width
	return r
}

func (r ApiDcimRacksListRequest) RoleId(roleId string) ApiDcimRacksListRequest {
	r.roleId = &roleId
	return r
}

func (r ApiDcimRacksListRequest) Role(role string) ApiDcimRacksListRequest {
	r.role = &role
	return r
}

func (r ApiDcimRacksListRequest) Serial(serial string) ApiDcimRacksListRequest {
	r.serial = &serial
	return r
}

func (r ApiDcimRacksListRequest) Tag(tag string) ApiDcimRacksListRequest {
	r.tag = &tag
	return r
}

func (r ApiDcimRacksListRequest) IdN(idN string) ApiDcimRacksListRequest {
	r.idN = &idN
	return r
}

func (r ApiDcimRacksListRequest) IdLte(idLte string) ApiDcimRacksListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiDcimRacksListRequest) IdLt(idLt string) ApiDcimRacksListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiDcimRacksListRequest) IdGte(idGte string) ApiDcimRacksListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiDcimRacksListRequest) IdGt(idGt string) ApiDcimRacksListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiDcimRacksListRequest) NameN(nameN string) ApiDcimRacksListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiDcimRacksListRequest) NameIc(nameIc string) ApiDcimRacksListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiDcimRacksListRequest) NameNic(nameNic string) ApiDcimRacksListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiDcimRacksListRequest) NameIew(nameIew string) ApiDcimRacksListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiDcimRacksListRequest) NameNiew(nameNiew string) ApiDcimRacksListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiDcimRacksListRequest) NameIsw(nameIsw string) ApiDcimRacksListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiDcimRacksListRequest) NameNisw(nameNisw string) ApiDcimRacksListRequest {
	r.nameNisw = &nameNisw
	return r
}

func (r ApiDcimRacksListRequest) NameIe(nameIe string) ApiDcimRacksListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiDcimRacksListRequest) NameNie(nameNie string) ApiDcimRacksListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiDcimRacksListRequest) NameEmpty(nameEmpty string) ApiDcimRacksListRequest {
	r.nameEmpty = &nameEmpty
	return r
}

func (r ApiDcimRacksListRequest) FacilityIdN(facilityIdN string) ApiDcimRacksListRequest {
	r.facilityIdN = &facilityIdN
	return r
}

func (r ApiDcimRacksListRequest) FacilityIdIc(facilityIdIc string) ApiDcimRacksListRequest {
	r.facilityIdIc = &facilityIdIc
	return r
}

func (r ApiDcimRacksListRequest) FacilityIdNic(facilityIdNic string) ApiDcimRacksListRequest {
	r.facilityIdNic = &facilityIdNic
	return r
}

func (r ApiDcimRacksListRequest) FacilityIdIew(facilityIdIew string) ApiDcimRacksListRequest {
	r.facilityIdIew = &facilityIdIew
	return r
}

func (r ApiDcimRacksListRequest) FacilityIdNiew(facilityIdNiew string) ApiDcimRacksListRequest {
	r.facilityIdNiew = &facilityIdNiew
	return r
}

func (r ApiDcimRacksListRequest) FacilityIdIsw(facilityIdIsw string) ApiDcimRacksListRequest {
	r.facilityIdIsw = &facilityIdIsw
	return r
}

func (r ApiDcimRacksListRequest) FacilityIdNisw(facilityIdNisw string) ApiDcimRacksListRequest {
	r.facilityIdNisw = &facilityIdNisw
	return r
}

func (r ApiDcimRacksListRequest) FacilityIdIe(facilityIdIe string) ApiDcimRacksListRequest {
	r.facilityIdIe = &facilityIdIe
	return r
}

func (r ApiDcimRacksListRequest) FacilityIdNie(facilityIdNie string) ApiDcimRacksListRequest {
	r.facilityIdNie = &facilityIdNie
	return r
}

func (r ApiDcimRacksListRequest) FacilityIdEmpty(facilityIdEmpty string) ApiDcimRacksListRequest {
	r.facilityIdEmpty = &facilityIdEmpty
	return r
}

func (r ApiDcimRacksListRequest) AssetTagN(assetTagN string) ApiDcimRacksListRequest {
	r.assetTagN = &assetTagN
	return r
}

func (r ApiDcimRacksListRequest) AssetTagIc(assetTagIc string) ApiDcimRacksListRequest {
	r.assetTagIc = &assetTagIc
	return r
}

func (r ApiDcimRacksListRequest) AssetTagNic(assetTagNic string) ApiDcimRacksListRequest {
	r.assetTagNic = &assetTagNic
	return r
}

func (r ApiDcimRacksListRequest) AssetTagIew(assetTagIew string) ApiDcimRacksListRequest {
	r.assetTagIew = &assetTagIew
	return r
}

func (r ApiDcimRacksListRequest) AssetTagNiew(assetTagNiew string) ApiDcimRacksListRequest {
	r.assetTagNiew = &assetTagNiew
	return r
}

func (r ApiDcimRacksListRequest) AssetTagIsw(assetTagIsw string) ApiDcimRacksListRequest {
	r.assetTagIsw = &assetTagIsw
	return r
}

func (r ApiDcimRacksListRequest) AssetTagNisw(assetTagNisw string) ApiDcimRacksListRequest {
	r.assetTagNisw = &assetTagNisw
	return r
}

func (r ApiDcimRacksListRequest) AssetTagIe(assetTagIe string) ApiDcimRacksListRequest {
	r.assetTagIe = &assetTagIe
	return r
}

func (r ApiDcimRacksListRequest) AssetTagNie(assetTagNie string) ApiDcimRacksListRequest {
	r.assetTagNie = &assetTagNie
	return r
}

func (r ApiDcimRacksListRequest) AssetTagEmpty(assetTagEmpty string) ApiDcimRacksListRequest {
	r.assetTagEmpty = &assetTagEmpty
	return r
}

func (r ApiDcimRacksListRequest) UHeightN(uHeightN string) ApiDcimRacksListRequest {
	r.uHeightN = &uHeightN
	return r
}

func (r ApiDcimRacksListRequest) UHeightLte(uHeightLte string) ApiDcimRacksListRequest {
	r.uHeightLte = &uHeightLte
	return r
}

func (r ApiDcimRacksListRequest) UHeightLt(uHeightLt string) ApiDcimRacksListRequest {
	r.uHeightLt = &uHeightLt
	return r
}

func (r ApiDcimRacksListRequest) UHeightGte(uHeightGte string) ApiDcimRacksListRequest {
	r.uHeightGte = &uHeightGte
	return r
}

func (r ApiDcimRacksListRequest) UHeightGt(uHeightGt string) ApiDcimRacksListRequest {
	r.uHeightGt = &uHeightGt
	return r
}

func (r ApiDcimRacksListRequest) OuterWidthN(outerWidthN string) ApiDcimRacksListRequest {
	r.outerWidthN = &outerWidthN
	return r
}

func (r ApiDcimRacksListRequest) OuterWidthLte(outerWidthLte string) ApiDcimRacksListRequest {
	r.outerWidthLte = &outerWidthLte
	return r
}

func (r ApiDcimRacksListRequest) OuterWidthLt(outerWidthLt string) ApiDcimRacksListRequest {
	r.outerWidthLt = &outerWidthLt
	return r
}

func (r ApiDcimRacksListRequest) OuterWidthGte(outerWidthGte string) ApiDcimRacksListRequest {
	r.outerWidthGte = &outerWidthGte
	return r
}

func (r ApiDcimRacksListRequest) OuterWidthGt(outerWidthGt string) ApiDcimRacksListRequest {
	r.outerWidthGt = &outerWidthGt
	return r
}

func (r ApiDcimRacksListRequest) OuterDepthN(outerDepthN string) ApiDcimRacksListRequest {
	r.outerDepthN = &outerDepthN
	return r
}

func (r ApiDcimRacksListRequest) OuterDepthLte(outerDepthLte string) ApiDcimRacksListRequest {
	r.outerDepthLte = &outerDepthLte
	return r
}

func (r ApiDcimRacksListRequest) OuterDepthLt(outerDepthLt string) ApiDcimRacksListRequest {
	r.outerDepthLt = &outerDepthLt
	return r
}

func (r ApiDcimRacksListRequest) OuterDepthGte(outerDepthGte string) ApiDcimRacksListRequest {
	r.outerDepthGte = &outerDepthGte
	return r
}

func (r ApiDcimRacksListRequest) OuterDepthGt(outerDepthGt string) ApiDcimRacksListRequest {
	r.outerDepthGt = &outerDepthGt
	return r
}

func (r ApiDcimRacksListRequest) OuterUnitN(outerUnitN string) ApiDcimRacksListRequest {
	r.outerUnitN = &outerUnitN
	return r
}

func (r ApiDcimRacksListRequest) TenantGroupIdN(tenantGroupIdN string) ApiDcimRacksListRequest {
	r.tenantGroupIdN = &tenantGroupIdN
	return r
}

func (r ApiDcimRacksListRequest) TenantGroupN(tenantGroupN string) ApiDcimRacksListRequest {
	r.tenantGroupN = &tenantGroupN
	return r
}

func (r ApiDcimRacksListRequest) TenantIdN(tenantIdN string) ApiDcimRacksListRequest {
	r.tenantIdN = &tenantIdN
	return r
}

func (r ApiDcimRacksListRequest) TenantN(tenantN string) ApiDcimRacksListRequest {
	r.tenantN = &tenantN
	return r
}

func (r ApiDcimRacksListRequest) RegionIdN(regionIdN string) ApiDcimRacksListRequest {
	r.regionIdN = &regionIdN
	return r
}

func (r ApiDcimRacksListRequest) RegionN(regionN string) ApiDcimRacksListRequest {
	r.regionN = &regionN
	return r
}

func (r ApiDcimRacksListRequest) SiteGroupIdN(siteGroupIdN string) ApiDcimRacksListRequest {
	r.siteGroupIdN = &siteGroupIdN
	return r
}

func (r ApiDcimRacksListRequest) SiteGroupN(siteGroupN string) ApiDcimRacksListRequest {
	r.siteGroupN = &siteGroupN
	return r
}

func (r ApiDcimRacksListRequest) SiteIdN(siteIdN string) ApiDcimRacksListRequest {
	r.siteIdN = &siteIdN
	return r
}

func (r ApiDcimRacksListRequest) SiteN(siteN string) ApiDcimRacksListRequest {
	r.siteN = &siteN
	return r
}

func (r ApiDcimRacksListRequest) LocationIdN(locationIdN string) ApiDcimRacksListRequest {
	r.locationIdN = &locationIdN
	return r
}

func (r ApiDcimRacksListRequest) LocationN(locationN string) ApiDcimRacksListRequest {
	r.locationN = &locationN
	return r
}

func (r ApiDcimRacksListRequest) StatusN(statusN string) ApiDcimRacksListRequest {
	r.statusN = &statusN
	return r
}

func (r ApiDcimRacksListRequest) TypeN(typeN string) ApiDcimRacksListRequest {
	r.typeN = &typeN
	return r
}

func (r ApiDcimRacksListRequest) WidthN(widthN string) ApiDcimRacksListRequest {
	r.widthN = &widthN
	return r
}

func (r ApiDcimRacksListRequest) RoleIdN(roleIdN string) ApiDcimRacksListRequest {
	r.roleIdN = &roleIdN
	return r
}

func (r ApiDcimRacksListRequest) RoleN(roleN string) ApiDcimRacksListRequest {
	r.roleN = &roleN
	return r
}

func (r ApiDcimRacksListRequest) TagN(tagN string) ApiDcimRacksListRequest {
	r.tagN = &tagN
	return r
}

// Number of results to return per page.
func (r ApiDcimRacksListRequest) Limit(limit int32) ApiDcimRacksListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiDcimRacksListRequest) Offset(offset int32) ApiDcimRacksListRequest {
	r.offset = &offset
	return r
}

func (r ApiDcimRacksListRequest) Execute() (*DcimRacksList200Response, *http.Response, error) {
	return r.ApiService.DcimRacksListExecute(r)
}

/*
DcimRacksList Method for DcimRacksList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimRacksListRequest
*/
func (a *DcimApiService) DcimRacksList(ctx context.Context) ApiDcimRacksListRequest {
	return ApiDcimRacksListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DcimRacksList200Response
func (a *DcimApiService) DcimRacksListExecute(r ApiDcimRacksListRequest) (*DcimRacksList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DcimRacksList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimRacksList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/racks/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.facilityId != nil {
		localVarQueryParams.Add("facility_id", parameterToString(*r.facilityId, ""))
	}
	if r.assetTag != nil {
		localVarQueryParams.Add("asset_tag", parameterToString(*r.assetTag, ""))
	}
	if r.uHeight != nil {
		localVarQueryParams.Add("u_height", parameterToString(*r.uHeight, ""))
	}
	if r.descUnits != nil {
		localVarQueryParams.Add("desc_units", parameterToString(*r.descUnits, ""))
	}
	if r.outerWidth != nil {
		localVarQueryParams.Add("outer_width", parameterToString(*r.outerWidth, ""))
	}
	if r.outerDepth != nil {
		localVarQueryParams.Add("outer_depth", parameterToString(*r.outerDepth, ""))
	}
	if r.outerUnit != nil {
		localVarQueryParams.Add("outer_unit", parameterToString(*r.outerUnit, ""))
	}
	if r.created != nil {
		localVarQueryParams.Add("created", parameterToString(*r.created, ""))
	}
	if r.createdGte != nil {
		localVarQueryParams.Add("created__gte", parameterToString(*r.createdGte, ""))
	}
	if r.createdLte != nil {
		localVarQueryParams.Add("created__lte", parameterToString(*r.createdLte, ""))
	}
	if r.lastUpdated != nil {
		localVarQueryParams.Add("last_updated", parameterToString(*r.lastUpdated, ""))
	}
	if r.lastUpdatedGte != nil {
		localVarQueryParams.Add("last_updated__gte", parameterToString(*r.lastUpdatedGte, ""))
	}
	if r.lastUpdatedLte != nil {
		localVarQueryParams.Add("last_updated__lte", parameterToString(*r.lastUpdatedLte, ""))
	}
	if r.tenantGroupId != nil {
		localVarQueryParams.Add("tenant_group_id", parameterToString(*r.tenantGroupId, ""))
	}
	if r.tenantGroup != nil {
		localVarQueryParams.Add("tenant_group", parameterToString(*r.tenantGroup, ""))
	}
	if r.tenantId != nil {
		localVarQueryParams.Add("tenant_id", parameterToString(*r.tenantId, ""))
	}
	if r.tenant != nil {
		localVarQueryParams.Add("tenant", parameterToString(*r.tenant, ""))
	}
	if r.q != nil {
		localVarQueryParams.Add("q", parameterToString(*r.q, ""))
	}
	if r.regionId != nil {
		localVarQueryParams.Add("region_id", parameterToString(*r.regionId, ""))
	}
	if r.region != nil {
		localVarQueryParams.Add("region", parameterToString(*r.region, ""))
	}
	if r.siteGroupId != nil {
		localVarQueryParams.Add("site_group_id", parameterToString(*r.siteGroupId, ""))
	}
	if r.siteGroup != nil {
		localVarQueryParams.Add("site_group", parameterToString(*r.siteGroup, ""))
	}
	if r.siteId != nil {
		localVarQueryParams.Add("site_id", parameterToString(*r.siteId, ""))
	}
	if r.site != nil {
		localVarQueryParams.Add("site", parameterToString(*r.site, ""))
	}
	if r.locationId != nil {
		localVarQueryParams.Add("location_id", parameterToString(*r.locationId, ""))
	}
	if r.location != nil {
		localVarQueryParams.Add("location", parameterToString(*r.location, ""))
	}
	if r.status != nil {
		localVarQueryParams.Add("status", parameterToString(*r.status, ""))
	}
	if r.type_ != nil {
		localVarQueryParams.Add("type", parameterToString(*r.type_, ""))
	}
	if r.width != nil {
		localVarQueryParams.Add("width", parameterToString(*r.width, ""))
	}
	if r.roleId != nil {
		localVarQueryParams.Add("role_id", parameterToString(*r.roleId, ""))
	}
	if r.role != nil {
		localVarQueryParams.Add("role", parameterToString(*r.role, ""))
	}
	if r.serial != nil {
		localVarQueryParams.Add("serial", parameterToString(*r.serial, ""))
	}
	if r.tag != nil {
		localVarQueryParams.Add("tag", parameterToString(*r.tag, ""))
	}
	if r.idN != nil {
		localVarQueryParams.Add("id__n", parameterToString(*r.idN, ""))
	}
	if r.idLte != nil {
		localVarQueryParams.Add("id__lte", parameterToString(*r.idLte, ""))
	}
	if r.idLt != nil {
		localVarQueryParams.Add("id__lt", parameterToString(*r.idLt, ""))
	}
	if r.idGte != nil {
		localVarQueryParams.Add("id__gte", parameterToString(*r.idGte, ""))
	}
	if r.idGt != nil {
		localVarQueryParams.Add("id__gt", parameterToString(*r.idGt, ""))
	}
	if r.nameN != nil {
		localVarQueryParams.Add("name__n", parameterToString(*r.nameN, ""))
	}
	if r.nameIc != nil {
		localVarQueryParams.Add("name__ic", parameterToString(*r.nameIc, ""))
	}
	if r.nameNic != nil {
		localVarQueryParams.Add("name__nic", parameterToString(*r.nameNic, ""))
	}
	if r.nameIew != nil {
		localVarQueryParams.Add("name__iew", parameterToString(*r.nameIew, ""))
	}
	if r.nameNiew != nil {
		localVarQueryParams.Add("name__niew", parameterToString(*r.nameNiew, ""))
	}
	if r.nameIsw != nil {
		localVarQueryParams.Add("name__isw", parameterToString(*r.nameIsw, ""))
	}
	if r.nameNisw != nil {
		localVarQueryParams.Add("name__nisw", parameterToString(*r.nameNisw, ""))
	}
	if r.nameIe != nil {
		localVarQueryParams.Add("name__ie", parameterToString(*r.nameIe, ""))
	}
	if r.nameNie != nil {
		localVarQueryParams.Add("name__nie", parameterToString(*r.nameNie, ""))
	}
	if r.nameEmpty != nil {
		localVarQueryParams.Add("name__empty", parameterToString(*r.nameEmpty, ""))
	}
	if r.facilityIdN != nil {
		localVarQueryParams.Add("facility_id__n", parameterToString(*r.facilityIdN, ""))
	}
	if r.facilityIdIc != nil {
		localVarQueryParams.Add("facility_id__ic", parameterToString(*r.facilityIdIc, ""))
	}
	if r.facilityIdNic != nil {
		localVarQueryParams.Add("facility_id__nic", parameterToString(*r.facilityIdNic, ""))
	}
	if r.facilityIdIew != nil {
		localVarQueryParams.Add("facility_id__iew", parameterToString(*r.facilityIdIew, ""))
	}
	if r.facilityIdNiew != nil {
		localVarQueryParams.Add("facility_id__niew", parameterToString(*r.facilityIdNiew, ""))
	}
	if r.facilityIdIsw != nil {
		localVarQueryParams.Add("facility_id__isw", parameterToString(*r.facilityIdIsw, ""))
	}
	if r.facilityIdNisw != nil {
		localVarQueryParams.Add("facility_id__nisw", parameterToString(*r.facilityIdNisw, ""))
	}
	if r.facilityIdIe != nil {
		localVarQueryParams.Add("facility_id__ie", parameterToString(*r.facilityIdIe, ""))
	}
	if r.facilityIdNie != nil {
		localVarQueryParams.Add("facility_id__nie", parameterToString(*r.facilityIdNie, ""))
	}
	if r.facilityIdEmpty != nil {
		localVarQueryParams.Add("facility_id__empty", parameterToString(*r.facilityIdEmpty, ""))
	}
	if r.assetTagN != nil {
		localVarQueryParams.Add("asset_tag__n", parameterToString(*r.assetTagN, ""))
	}
	if r.assetTagIc != nil {
		localVarQueryParams.Add("asset_tag__ic", parameterToString(*r.assetTagIc, ""))
	}
	if r.assetTagNic != nil {
		localVarQueryParams.Add("asset_tag__nic", parameterToString(*r.assetTagNic, ""))
	}
	if r.assetTagIew != nil {
		localVarQueryParams.Add("asset_tag__iew", parameterToString(*r.assetTagIew, ""))
	}
	if r.assetTagNiew != nil {
		localVarQueryParams.Add("asset_tag__niew", parameterToString(*r.assetTagNiew, ""))
	}
	if r.assetTagIsw != nil {
		localVarQueryParams.Add("asset_tag__isw", parameterToString(*r.assetTagIsw, ""))
	}
	if r.assetTagNisw != nil {
		localVarQueryParams.Add("asset_tag__nisw", parameterToString(*r.assetTagNisw, ""))
	}
	if r.assetTagIe != nil {
		localVarQueryParams.Add("asset_tag__ie", parameterToString(*r.assetTagIe, ""))
	}
	if r.assetTagNie != nil {
		localVarQueryParams.Add("asset_tag__nie", parameterToString(*r.assetTagNie, ""))
	}
	if r.assetTagEmpty != nil {
		localVarQueryParams.Add("asset_tag__empty", parameterToString(*r.assetTagEmpty, ""))
	}
	if r.uHeightN != nil {
		localVarQueryParams.Add("u_height__n", parameterToString(*r.uHeightN, ""))
	}
	if r.uHeightLte != nil {
		localVarQueryParams.Add("u_height__lte", parameterToString(*r.uHeightLte, ""))
	}
	if r.uHeightLt != nil {
		localVarQueryParams.Add("u_height__lt", parameterToString(*r.uHeightLt, ""))
	}
	if r.uHeightGte != nil {
		localVarQueryParams.Add("u_height__gte", parameterToString(*r.uHeightGte, ""))
	}
	if r.uHeightGt != nil {
		localVarQueryParams.Add("u_height__gt", parameterToString(*r.uHeightGt, ""))
	}
	if r.outerWidthN != nil {
		localVarQueryParams.Add("outer_width__n", parameterToString(*r.outerWidthN, ""))
	}
	if r.outerWidthLte != nil {
		localVarQueryParams.Add("outer_width__lte", parameterToString(*r.outerWidthLte, ""))
	}
	if r.outerWidthLt != nil {
		localVarQueryParams.Add("outer_width__lt", parameterToString(*r.outerWidthLt, ""))
	}
	if r.outerWidthGte != nil {
		localVarQueryParams.Add("outer_width__gte", parameterToString(*r.outerWidthGte, ""))
	}
	if r.outerWidthGt != nil {
		localVarQueryParams.Add("outer_width__gt", parameterToString(*r.outerWidthGt, ""))
	}
	if r.outerDepthN != nil {
		localVarQueryParams.Add("outer_depth__n", parameterToString(*r.outerDepthN, ""))
	}
	if r.outerDepthLte != nil {
		localVarQueryParams.Add("outer_depth__lte", parameterToString(*r.outerDepthLte, ""))
	}
	if r.outerDepthLt != nil {
		localVarQueryParams.Add("outer_depth__lt", parameterToString(*r.outerDepthLt, ""))
	}
	if r.outerDepthGte != nil {
		localVarQueryParams.Add("outer_depth__gte", parameterToString(*r.outerDepthGte, ""))
	}
	if r.outerDepthGt != nil {
		localVarQueryParams.Add("outer_depth__gt", parameterToString(*r.outerDepthGt, ""))
	}
	if r.outerUnitN != nil {
		localVarQueryParams.Add("outer_unit__n", parameterToString(*r.outerUnitN, ""))
	}
	if r.tenantGroupIdN != nil {
		localVarQueryParams.Add("tenant_group_id__n", parameterToString(*r.tenantGroupIdN, ""))
	}
	if r.tenantGroupN != nil {
		localVarQueryParams.Add("tenant_group__n", parameterToString(*r.tenantGroupN, ""))
	}
	if r.tenantIdN != nil {
		localVarQueryParams.Add("tenant_id__n", parameterToString(*r.tenantIdN, ""))
	}
	if r.tenantN != nil {
		localVarQueryParams.Add("tenant__n", parameterToString(*r.tenantN, ""))
	}
	if r.regionIdN != nil {
		localVarQueryParams.Add("region_id__n", parameterToString(*r.regionIdN, ""))
	}
	if r.regionN != nil {
		localVarQueryParams.Add("region__n", parameterToString(*r.regionN, ""))
	}
	if r.siteGroupIdN != nil {
		localVarQueryParams.Add("site_group_id__n", parameterToString(*r.siteGroupIdN, ""))
	}
	if r.siteGroupN != nil {
		localVarQueryParams.Add("site_group__n", parameterToString(*r.siteGroupN, ""))
	}
	if r.siteIdN != nil {
		localVarQueryParams.Add("site_id__n", parameterToString(*r.siteIdN, ""))
	}
	if r.siteN != nil {
		localVarQueryParams.Add("site__n", parameterToString(*r.siteN, ""))
	}
	if r.locationIdN != nil {
		localVarQueryParams.Add("location_id__n", parameterToString(*r.locationIdN, ""))
	}
	if r.locationN != nil {
		localVarQueryParams.Add("location__n", parameterToString(*r.locationN, ""))
	}
	if r.statusN != nil {
		localVarQueryParams.Add("status__n", parameterToString(*r.statusN, ""))
	}
	if r.typeN != nil {
		localVarQueryParams.Add("type__n", parameterToString(*r.typeN, ""))
	}
	if r.widthN != nil {
		localVarQueryParams.Add("width__n", parameterToString(*r.widthN, ""))
	}
	if r.roleIdN != nil {
		localVarQueryParams.Add("role_id__n", parameterToString(*r.roleIdN, ""))
	}
	if r.roleN != nil {
		localVarQueryParams.Add("role__n", parameterToString(*r.roleN, ""))
	}
	if r.tagN != nil {
		localVarQueryParams.Add("tag__n", parameterToString(*r.tagN, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimRacksPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
	data *WritableRack
}

func (r ApiDcimRacksPartialUpdateRequest) Data(data WritableRack) ApiDcimRacksPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimRacksPartialUpdateRequest) Execute() (*Rack, *http.Response, error) {
	return r.ApiService.DcimRacksPartialUpdateExecute(r)
}

/*
DcimRacksPartialUpdate Method for DcimRacksPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this rack.
 @return ApiDcimRacksPartialUpdateRequest
*/
func (a *DcimApiService) DcimRacksPartialUpdate(ctx context.Context, id int32) ApiDcimRacksPartialUpdateRequest {
	return ApiDcimRacksPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Rack
func (a *DcimApiService) DcimRacksPartialUpdateExecute(r ApiDcimRacksPartialUpdateRequest) (*Rack, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Rack
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimRacksPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/racks/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimRacksReadRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
}

func (r ApiDcimRacksReadRequest) Execute() (*Rack, *http.Response, error) {
	return r.ApiService.DcimRacksReadExecute(r)
}

/*
DcimRacksRead Method for DcimRacksRead

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this rack.
 @return ApiDcimRacksReadRequest
*/
func (a *DcimApiService) DcimRacksRead(ctx context.Context, id int32) ApiDcimRacksReadRequest {
	return ApiDcimRacksReadRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Rack
func (a *DcimApiService) DcimRacksReadExecute(r ApiDcimRacksReadRequest) (*Rack, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Rack
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimRacksRead")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/racks/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimRacksUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
	data *WritableRack
}

func (r ApiDcimRacksUpdateRequest) Data(data WritableRack) ApiDcimRacksUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimRacksUpdateRequest) Execute() (*Rack, *http.Response, error) {
	return r.ApiService.DcimRacksUpdateExecute(r)
}

/*
DcimRacksUpdate Method for DcimRacksUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this rack.
 @return ApiDcimRacksUpdateRequest
*/
func (a *DcimApiService) DcimRacksUpdate(ctx context.Context, id int32) ApiDcimRacksUpdateRequest {
	return ApiDcimRacksUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Rack
func (a *DcimApiService) DcimRacksUpdateExecute(r ApiDcimRacksUpdateRequest) (*Rack, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Rack
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimRacksUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/racks/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimRearPortTemplatesBulkDeleteRequest struct {
	ctx context.Context
	ApiService *DcimApiService
}

func (r ApiDcimRearPortTemplatesBulkDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimRearPortTemplatesBulkDeleteExecute(r)
}

/*
DcimRearPortTemplatesBulkDelete Method for DcimRearPortTemplatesBulkDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimRearPortTemplatesBulkDeleteRequest
*/
func (a *DcimApiService) DcimRearPortTemplatesBulkDelete(ctx context.Context) ApiDcimRearPortTemplatesBulkDeleteRequest {
	return ApiDcimRearPortTemplatesBulkDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DcimApiService) DcimRearPortTemplatesBulkDeleteExecute(r ApiDcimRearPortTemplatesBulkDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimRearPortTemplatesBulkDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/rear-port-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimRearPortTemplatesBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	data *WritableRearPortTemplate
}

func (r ApiDcimRearPortTemplatesBulkPartialUpdateRequest) Data(data WritableRearPortTemplate) ApiDcimRearPortTemplatesBulkPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimRearPortTemplatesBulkPartialUpdateRequest) Execute() (*RearPortTemplate, *http.Response, error) {
	return r.ApiService.DcimRearPortTemplatesBulkPartialUpdateExecute(r)
}

/*
DcimRearPortTemplatesBulkPartialUpdate Method for DcimRearPortTemplatesBulkPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimRearPortTemplatesBulkPartialUpdateRequest
*/
func (a *DcimApiService) DcimRearPortTemplatesBulkPartialUpdate(ctx context.Context) ApiDcimRearPortTemplatesBulkPartialUpdateRequest {
	return ApiDcimRearPortTemplatesBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RearPortTemplate
func (a *DcimApiService) DcimRearPortTemplatesBulkPartialUpdateExecute(r ApiDcimRearPortTemplatesBulkPartialUpdateRequest) (*RearPortTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RearPortTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimRearPortTemplatesBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/rear-port-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimRearPortTemplatesBulkUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	data *WritableRearPortTemplate
}

func (r ApiDcimRearPortTemplatesBulkUpdateRequest) Data(data WritableRearPortTemplate) ApiDcimRearPortTemplatesBulkUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimRearPortTemplatesBulkUpdateRequest) Execute() (*RearPortTemplate, *http.Response, error) {
	return r.ApiService.DcimRearPortTemplatesBulkUpdateExecute(r)
}

/*
DcimRearPortTemplatesBulkUpdate Method for DcimRearPortTemplatesBulkUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimRearPortTemplatesBulkUpdateRequest
*/
func (a *DcimApiService) DcimRearPortTemplatesBulkUpdate(ctx context.Context) ApiDcimRearPortTemplatesBulkUpdateRequest {
	return ApiDcimRearPortTemplatesBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RearPortTemplate
func (a *DcimApiService) DcimRearPortTemplatesBulkUpdateExecute(r ApiDcimRearPortTemplatesBulkUpdateRequest) (*RearPortTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RearPortTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimRearPortTemplatesBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/rear-port-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimRearPortTemplatesCreateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	data *WritableRearPortTemplate
}

func (r ApiDcimRearPortTemplatesCreateRequest) Data(data WritableRearPortTemplate) ApiDcimRearPortTemplatesCreateRequest {
	r.data = &data
	return r
}

func (r ApiDcimRearPortTemplatesCreateRequest) Execute() (*RearPortTemplate, *http.Response, error) {
	return r.ApiService.DcimRearPortTemplatesCreateExecute(r)
}

/*
DcimRearPortTemplatesCreate Method for DcimRearPortTemplatesCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimRearPortTemplatesCreateRequest
*/
func (a *DcimApiService) DcimRearPortTemplatesCreate(ctx context.Context) ApiDcimRearPortTemplatesCreateRequest {
	return ApiDcimRearPortTemplatesCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RearPortTemplate
func (a *DcimApiService) DcimRearPortTemplatesCreateExecute(r ApiDcimRearPortTemplatesCreateRequest) (*RearPortTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RearPortTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimRearPortTemplatesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/rear-port-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimRearPortTemplatesDeleteRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
}

func (r ApiDcimRearPortTemplatesDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimRearPortTemplatesDeleteExecute(r)
}

/*
DcimRearPortTemplatesDelete Method for DcimRearPortTemplatesDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this rear port template.
 @return ApiDcimRearPortTemplatesDeleteRequest
*/
func (a *DcimApiService) DcimRearPortTemplatesDelete(ctx context.Context, id int32) ApiDcimRearPortTemplatesDeleteRequest {
	return ApiDcimRearPortTemplatesDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DcimApiService) DcimRearPortTemplatesDeleteExecute(r ApiDcimRearPortTemplatesDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimRearPortTemplatesDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/rear-port-templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimRearPortTemplatesListRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id *string
	name *string
	type_ *string
	positions *string
	created *string
	createdGte *string
	createdLte *string
	lastUpdated *string
	lastUpdatedGte *string
	lastUpdatedLte *string
	devicetypeId *string
	idN *string
	idLte *string
	idLt *string
	idGte *string
	idGt *string
	nameN *string
	nameIc *string
	nameNic *string
	nameIew *string
	nameNiew *string
	nameIsw *string
	nameNisw *string
	nameIe *string
	nameNie *string
	nameEmpty *string
	typeN *string
	positionsN *string
	positionsLte *string
	positionsLt *string
	positionsGte *string
	positionsGt *string
	devicetypeIdN *string
	limit *int32
	offset *int32
}

func (r ApiDcimRearPortTemplatesListRequest) Id(id string) ApiDcimRearPortTemplatesListRequest {
	r.id = &id
	return r
}

func (r ApiDcimRearPortTemplatesListRequest) Name(name string) ApiDcimRearPortTemplatesListRequest {
	r.name = &name
	return r
}

func (r ApiDcimRearPortTemplatesListRequest) Type_(type_ string) ApiDcimRearPortTemplatesListRequest {
	r.type_ = &type_
	return r
}

func (r ApiDcimRearPortTemplatesListRequest) Positions(positions string) ApiDcimRearPortTemplatesListRequest {
	r.positions = &positions
	return r
}

func (r ApiDcimRearPortTemplatesListRequest) Created(created string) ApiDcimRearPortTemplatesListRequest {
	r.created = &created
	return r
}

func (r ApiDcimRearPortTemplatesListRequest) CreatedGte(createdGte string) ApiDcimRearPortTemplatesListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiDcimRearPortTemplatesListRequest) CreatedLte(createdLte string) ApiDcimRearPortTemplatesListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiDcimRearPortTemplatesListRequest) LastUpdated(lastUpdated string) ApiDcimRearPortTemplatesListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiDcimRearPortTemplatesListRequest) LastUpdatedGte(lastUpdatedGte string) ApiDcimRearPortTemplatesListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiDcimRearPortTemplatesListRequest) LastUpdatedLte(lastUpdatedLte string) ApiDcimRearPortTemplatesListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiDcimRearPortTemplatesListRequest) DevicetypeId(devicetypeId string) ApiDcimRearPortTemplatesListRequest {
	r.devicetypeId = &devicetypeId
	return r
}

func (r ApiDcimRearPortTemplatesListRequest) IdN(idN string) ApiDcimRearPortTemplatesListRequest {
	r.idN = &idN
	return r
}

func (r ApiDcimRearPortTemplatesListRequest) IdLte(idLte string) ApiDcimRearPortTemplatesListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiDcimRearPortTemplatesListRequest) IdLt(idLt string) ApiDcimRearPortTemplatesListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiDcimRearPortTemplatesListRequest) IdGte(idGte string) ApiDcimRearPortTemplatesListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiDcimRearPortTemplatesListRequest) IdGt(idGt string) ApiDcimRearPortTemplatesListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiDcimRearPortTemplatesListRequest) NameN(nameN string) ApiDcimRearPortTemplatesListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiDcimRearPortTemplatesListRequest) NameIc(nameIc string) ApiDcimRearPortTemplatesListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiDcimRearPortTemplatesListRequest) NameNic(nameNic string) ApiDcimRearPortTemplatesListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiDcimRearPortTemplatesListRequest) NameIew(nameIew string) ApiDcimRearPortTemplatesListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiDcimRearPortTemplatesListRequest) NameNiew(nameNiew string) ApiDcimRearPortTemplatesListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiDcimRearPortTemplatesListRequest) NameIsw(nameIsw string) ApiDcimRearPortTemplatesListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiDcimRearPortTemplatesListRequest) NameNisw(nameNisw string) ApiDcimRearPortTemplatesListRequest {
	r.nameNisw = &nameNisw
	return r
}

func (r ApiDcimRearPortTemplatesListRequest) NameIe(nameIe string) ApiDcimRearPortTemplatesListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiDcimRearPortTemplatesListRequest) NameNie(nameNie string) ApiDcimRearPortTemplatesListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiDcimRearPortTemplatesListRequest) NameEmpty(nameEmpty string) ApiDcimRearPortTemplatesListRequest {
	r.nameEmpty = &nameEmpty
	return r
}

func (r ApiDcimRearPortTemplatesListRequest) TypeN(typeN string) ApiDcimRearPortTemplatesListRequest {
	r.typeN = &typeN
	return r
}

func (r ApiDcimRearPortTemplatesListRequest) PositionsN(positionsN string) ApiDcimRearPortTemplatesListRequest {
	r.positionsN = &positionsN
	return r
}

func (r ApiDcimRearPortTemplatesListRequest) PositionsLte(positionsLte string) ApiDcimRearPortTemplatesListRequest {
	r.positionsLte = &positionsLte
	return r
}

func (r ApiDcimRearPortTemplatesListRequest) PositionsLt(positionsLt string) ApiDcimRearPortTemplatesListRequest {
	r.positionsLt = &positionsLt
	return r
}

func (r ApiDcimRearPortTemplatesListRequest) PositionsGte(positionsGte string) ApiDcimRearPortTemplatesListRequest {
	r.positionsGte = &positionsGte
	return r
}

func (r ApiDcimRearPortTemplatesListRequest) PositionsGt(positionsGt string) ApiDcimRearPortTemplatesListRequest {
	r.positionsGt = &positionsGt
	return r
}

func (r ApiDcimRearPortTemplatesListRequest) DevicetypeIdN(devicetypeIdN string) ApiDcimRearPortTemplatesListRequest {
	r.devicetypeIdN = &devicetypeIdN
	return r
}

// Number of results to return per page.
func (r ApiDcimRearPortTemplatesListRequest) Limit(limit int32) ApiDcimRearPortTemplatesListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiDcimRearPortTemplatesListRequest) Offset(offset int32) ApiDcimRearPortTemplatesListRequest {
	r.offset = &offset
	return r
}

func (r ApiDcimRearPortTemplatesListRequest) Execute() (*DcimRearPortTemplatesList200Response, *http.Response, error) {
	return r.ApiService.DcimRearPortTemplatesListExecute(r)
}

/*
DcimRearPortTemplatesList Method for DcimRearPortTemplatesList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimRearPortTemplatesListRequest
*/
func (a *DcimApiService) DcimRearPortTemplatesList(ctx context.Context) ApiDcimRearPortTemplatesListRequest {
	return ApiDcimRearPortTemplatesListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DcimRearPortTemplatesList200Response
func (a *DcimApiService) DcimRearPortTemplatesListExecute(r ApiDcimRearPortTemplatesListRequest) (*DcimRearPortTemplatesList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DcimRearPortTemplatesList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimRearPortTemplatesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/rear-port-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.type_ != nil {
		localVarQueryParams.Add("type", parameterToString(*r.type_, ""))
	}
	if r.positions != nil {
		localVarQueryParams.Add("positions", parameterToString(*r.positions, ""))
	}
	if r.created != nil {
		localVarQueryParams.Add("created", parameterToString(*r.created, ""))
	}
	if r.createdGte != nil {
		localVarQueryParams.Add("created__gte", parameterToString(*r.createdGte, ""))
	}
	if r.createdLte != nil {
		localVarQueryParams.Add("created__lte", parameterToString(*r.createdLte, ""))
	}
	if r.lastUpdated != nil {
		localVarQueryParams.Add("last_updated", parameterToString(*r.lastUpdated, ""))
	}
	if r.lastUpdatedGte != nil {
		localVarQueryParams.Add("last_updated__gte", parameterToString(*r.lastUpdatedGte, ""))
	}
	if r.lastUpdatedLte != nil {
		localVarQueryParams.Add("last_updated__lte", parameterToString(*r.lastUpdatedLte, ""))
	}
	if r.devicetypeId != nil {
		localVarQueryParams.Add("devicetype_id", parameterToString(*r.devicetypeId, ""))
	}
	if r.idN != nil {
		localVarQueryParams.Add("id__n", parameterToString(*r.idN, ""))
	}
	if r.idLte != nil {
		localVarQueryParams.Add("id__lte", parameterToString(*r.idLte, ""))
	}
	if r.idLt != nil {
		localVarQueryParams.Add("id__lt", parameterToString(*r.idLt, ""))
	}
	if r.idGte != nil {
		localVarQueryParams.Add("id__gte", parameterToString(*r.idGte, ""))
	}
	if r.idGt != nil {
		localVarQueryParams.Add("id__gt", parameterToString(*r.idGt, ""))
	}
	if r.nameN != nil {
		localVarQueryParams.Add("name__n", parameterToString(*r.nameN, ""))
	}
	if r.nameIc != nil {
		localVarQueryParams.Add("name__ic", parameterToString(*r.nameIc, ""))
	}
	if r.nameNic != nil {
		localVarQueryParams.Add("name__nic", parameterToString(*r.nameNic, ""))
	}
	if r.nameIew != nil {
		localVarQueryParams.Add("name__iew", parameterToString(*r.nameIew, ""))
	}
	if r.nameNiew != nil {
		localVarQueryParams.Add("name__niew", parameterToString(*r.nameNiew, ""))
	}
	if r.nameIsw != nil {
		localVarQueryParams.Add("name__isw", parameterToString(*r.nameIsw, ""))
	}
	if r.nameNisw != nil {
		localVarQueryParams.Add("name__nisw", parameterToString(*r.nameNisw, ""))
	}
	if r.nameIe != nil {
		localVarQueryParams.Add("name__ie", parameterToString(*r.nameIe, ""))
	}
	if r.nameNie != nil {
		localVarQueryParams.Add("name__nie", parameterToString(*r.nameNie, ""))
	}
	if r.nameEmpty != nil {
		localVarQueryParams.Add("name__empty", parameterToString(*r.nameEmpty, ""))
	}
	if r.typeN != nil {
		localVarQueryParams.Add("type__n", parameterToString(*r.typeN, ""))
	}
	if r.positionsN != nil {
		localVarQueryParams.Add("positions__n", parameterToString(*r.positionsN, ""))
	}
	if r.positionsLte != nil {
		localVarQueryParams.Add("positions__lte", parameterToString(*r.positionsLte, ""))
	}
	if r.positionsLt != nil {
		localVarQueryParams.Add("positions__lt", parameterToString(*r.positionsLt, ""))
	}
	if r.positionsGte != nil {
		localVarQueryParams.Add("positions__gte", parameterToString(*r.positionsGte, ""))
	}
	if r.positionsGt != nil {
		localVarQueryParams.Add("positions__gt", parameterToString(*r.positionsGt, ""))
	}
	if r.devicetypeIdN != nil {
		localVarQueryParams.Add("devicetype_id__n", parameterToString(*r.devicetypeIdN, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimRearPortTemplatesPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
	data *WritableRearPortTemplate
}

func (r ApiDcimRearPortTemplatesPartialUpdateRequest) Data(data WritableRearPortTemplate) ApiDcimRearPortTemplatesPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimRearPortTemplatesPartialUpdateRequest) Execute() (*RearPortTemplate, *http.Response, error) {
	return r.ApiService.DcimRearPortTemplatesPartialUpdateExecute(r)
}

/*
DcimRearPortTemplatesPartialUpdate Method for DcimRearPortTemplatesPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this rear port template.
 @return ApiDcimRearPortTemplatesPartialUpdateRequest
*/
func (a *DcimApiService) DcimRearPortTemplatesPartialUpdate(ctx context.Context, id int32) ApiDcimRearPortTemplatesPartialUpdateRequest {
	return ApiDcimRearPortTemplatesPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return RearPortTemplate
func (a *DcimApiService) DcimRearPortTemplatesPartialUpdateExecute(r ApiDcimRearPortTemplatesPartialUpdateRequest) (*RearPortTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RearPortTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimRearPortTemplatesPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/rear-port-templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimRearPortTemplatesReadRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
}

func (r ApiDcimRearPortTemplatesReadRequest) Execute() (*RearPortTemplate, *http.Response, error) {
	return r.ApiService.DcimRearPortTemplatesReadExecute(r)
}

/*
DcimRearPortTemplatesRead Method for DcimRearPortTemplatesRead

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this rear port template.
 @return ApiDcimRearPortTemplatesReadRequest
*/
func (a *DcimApiService) DcimRearPortTemplatesRead(ctx context.Context, id int32) ApiDcimRearPortTemplatesReadRequest {
	return ApiDcimRearPortTemplatesReadRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return RearPortTemplate
func (a *DcimApiService) DcimRearPortTemplatesReadExecute(r ApiDcimRearPortTemplatesReadRequest) (*RearPortTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RearPortTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimRearPortTemplatesRead")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/rear-port-templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimRearPortTemplatesUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
	data *WritableRearPortTemplate
}

func (r ApiDcimRearPortTemplatesUpdateRequest) Data(data WritableRearPortTemplate) ApiDcimRearPortTemplatesUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimRearPortTemplatesUpdateRequest) Execute() (*RearPortTemplate, *http.Response, error) {
	return r.ApiService.DcimRearPortTemplatesUpdateExecute(r)
}

/*
DcimRearPortTemplatesUpdate Method for DcimRearPortTemplatesUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this rear port template.
 @return ApiDcimRearPortTemplatesUpdateRequest
*/
func (a *DcimApiService) DcimRearPortTemplatesUpdate(ctx context.Context, id int32) ApiDcimRearPortTemplatesUpdateRequest {
	return ApiDcimRearPortTemplatesUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return RearPortTemplate
func (a *DcimApiService) DcimRearPortTemplatesUpdateExecute(r ApiDcimRearPortTemplatesUpdateRequest) (*RearPortTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RearPortTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimRearPortTemplatesUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/rear-port-templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimRearPortsBulkDeleteRequest struct {
	ctx context.Context
	ApiService *DcimApiService
}

func (r ApiDcimRearPortsBulkDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimRearPortsBulkDeleteExecute(r)
}

/*
DcimRearPortsBulkDelete Method for DcimRearPortsBulkDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimRearPortsBulkDeleteRequest
*/
func (a *DcimApiService) DcimRearPortsBulkDelete(ctx context.Context) ApiDcimRearPortsBulkDeleteRequest {
	return ApiDcimRearPortsBulkDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DcimApiService) DcimRearPortsBulkDeleteExecute(r ApiDcimRearPortsBulkDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimRearPortsBulkDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/rear-ports/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimRearPortsBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	data *WritableRearPort
}

func (r ApiDcimRearPortsBulkPartialUpdateRequest) Data(data WritableRearPort) ApiDcimRearPortsBulkPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimRearPortsBulkPartialUpdateRequest) Execute() (*RearPort, *http.Response, error) {
	return r.ApiService.DcimRearPortsBulkPartialUpdateExecute(r)
}

/*
DcimRearPortsBulkPartialUpdate Method for DcimRearPortsBulkPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimRearPortsBulkPartialUpdateRequest
*/
func (a *DcimApiService) DcimRearPortsBulkPartialUpdate(ctx context.Context) ApiDcimRearPortsBulkPartialUpdateRequest {
	return ApiDcimRearPortsBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RearPort
func (a *DcimApiService) DcimRearPortsBulkPartialUpdateExecute(r ApiDcimRearPortsBulkPartialUpdateRequest) (*RearPort, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RearPort
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimRearPortsBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/rear-ports/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimRearPortsBulkUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	data *WritableRearPort
}

func (r ApiDcimRearPortsBulkUpdateRequest) Data(data WritableRearPort) ApiDcimRearPortsBulkUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimRearPortsBulkUpdateRequest) Execute() (*RearPort, *http.Response, error) {
	return r.ApiService.DcimRearPortsBulkUpdateExecute(r)
}

/*
DcimRearPortsBulkUpdate Method for DcimRearPortsBulkUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimRearPortsBulkUpdateRequest
*/
func (a *DcimApiService) DcimRearPortsBulkUpdate(ctx context.Context) ApiDcimRearPortsBulkUpdateRequest {
	return ApiDcimRearPortsBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RearPort
func (a *DcimApiService) DcimRearPortsBulkUpdateExecute(r ApiDcimRearPortsBulkUpdateRequest) (*RearPort, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RearPort
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimRearPortsBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/rear-ports/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimRearPortsCreateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	data *WritableRearPort
}

func (r ApiDcimRearPortsCreateRequest) Data(data WritableRearPort) ApiDcimRearPortsCreateRequest {
	r.data = &data
	return r
}

func (r ApiDcimRearPortsCreateRequest) Execute() (*RearPort, *http.Response, error) {
	return r.ApiService.DcimRearPortsCreateExecute(r)
}

/*
DcimRearPortsCreate Method for DcimRearPortsCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimRearPortsCreateRequest
*/
func (a *DcimApiService) DcimRearPortsCreate(ctx context.Context) ApiDcimRearPortsCreateRequest {
	return ApiDcimRearPortsCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RearPort
func (a *DcimApiService) DcimRearPortsCreateExecute(r ApiDcimRearPortsCreateRequest) (*RearPort, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RearPort
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimRearPortsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/rear-ports/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimRearPortsDeleteRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
}

func (r ApiDcimRearPortsDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimRearPortsDeleteExecute(r)
}

/*
DcimRearPortsDelete Method for DcimRearPortsDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this rear port.
 @return ApiDcimRearPortsDeleteRequest
*/
func (a *DcimApiService) DcimRearPortsDelete(ctx context.Context, id int32) ApiDcimRearPortsDeleteRequest {
	return ApiDcimRearPortsDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DcimApiService) DcimRearPortsDeleteExecute(r ApiDcimRearPortsDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimRearPortsDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/rear-ports/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimRearPortsListRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id *string
	name *string
	label *string
	type_ *string
	positions *string
	description *string
	created *string
	createdGte *string
	createdLte *string
	lastUpdated *string
	lastUpdatedGte *string
	lastUpdatedLte *string
	q *string
	regionId *string
	region *string
	siteGroupId *string
	siteGroup *string
	siteId *string
	site *string
	deviceId *string
	device *string
	tag *string
	cabled *string
	idN *string
	idLte *string
	idLt *string
	idGte *string
	idGt *string
	nameN *string
	nameIc *string
	nameNic *string
	nameIew *string
	nameNiew *string
	nameIsw *string
	nameNisw *string
	nameIe *string
	nameNie *string
	nameEmpty *string
	labelN *string
	labelIc *string
	labelNic *string
	labelIew *string
	labelNiew *string
	labelIsw *string
	labelNisw *string
	labelIe *string
	labelNie *string
	labelEmpty *string
	typeN *string
	positionsN *string
	positionsLte *string
	positionsLt *string
	positionsGte *string
	positionsGt *string
	descriptionN *string
	descriptionIc *string
	descriptionNic *string
	descriptionIew *string
	descriptionNiew *string
	descriptionIsw *string
	descriptionNisw *string
	descriptionIe *string
	descriptionNie *string
	descriptionEmpty *string
	regionIdN *string
	regionN *string
	siteGroupIdN *string
	siteGroupN *string
	siteIdN *string
	siteN *string
	deviceIdN *string
	deviceN *string
	tagN *string
	limit *int32
	offset *int32
}

func (r ApiDcimRearPortsListRequest) Id(id string) ApiDcimRearPortsListRequest {
	r.id = &id
	return r
}

func (r ApiDcimRearPortsListRequest) Name(name string) ApiDcimRearPortsListRequest {
	r.name = &name
	return r
}

func (r ApiDcimRearPortsListRequest) Label(label string) ApiDcimRearPortsListRequest {
	r.label = &label
	return r
}

func (r ApiDcimRearPortsListRequest) Type_(type_ string) ApiDcimRearPortsListRequest {
	r.type_ = &type_
	return r
}

func (r ApiDcimRearPortsListRequest) Positions(positions string) ApiDcimRearPortsListRequest {
	r.positions = &positions
	return r
}

func (r ApiDcimRearPortsListRequest) Description(description string) ApiDcimRearPortsListRequest {
	r.description = &description
	return r
}

func (r ApiDcimRearPortsListRequest) Created(created string) ApiDcimRearPortsListRequest {
	r.created = &created
	return r
}

func (r ApiDcimRearPortsListRequest) CreatedGte(createdGte string) ApiDcimRearPortsListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiDcimRearPortsListRequest) CreatedLte(createdLte string) ApiDcimRearPortsListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiDcimRearPortsListRequest) LastUpdated(lastUpdated string) ApiDcimRearPortsListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiDcimRearPortsListRequest) LastUpdatedGte(lastUpdatedGte string) ApiDcimRearPortsListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiDcimRearPortsListRequest) LastUpdatedLte(lastUpdatedLte string) ApiDcimRearPortsListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiDcimRearPortsListRequest) Q(q string) ApiDcimRearPortsListRequest {
	r.q = &q
	return r
}

func (r ApiDcimRearPortsListRequest) RegionId(regionId string) ApiDcimRearPortsListRequest {
	r.regionId = &regionId
	return r
}

func (r ApiDcimRearPortsListRequest) Region(region string) ApiDcimRearPortsListRequest {
	r.region = &region
	return r
}

func (r ApiDcimRearPortsListRequest) SiteGroupId(siteGroupId string) ApiDcimRearPortsListRequest {
	r.siteGroupId = &siteGroupId
	return r
}

func (r ApiDcimRearPortsListRequest) SiteGroup(siteGroup string) ApiDcimRearPortsListRequest {
	r.siteGroup = &siteGroup
	return r
}

func (r ApiDcimRearPortsListRequest) SiteId(siteId string) ApiDcimRearPortsListRequest {
	r.siteId = &siteId
	return r
}

func (r ApiDcimRearPortsListRequest) Site(site string) ApiDcimRearPortsListRequest {
	r.site = &site
	return r
}

func (r ApiDcimRearPortsListRequest) DeviceId(deviceId string) ApiDcimRearPortsListRequest {
	r.deviceId = &deviceId
	return r
}

func (r ApiDcimRearPortsListRequest) Device(device string) ApiDcimRearPortsListRequest {
	r.device = &device
	return r
}

func (r ApiDcimRearPortsListRequest) Tag(tag string) ApiDcimRearPortsListRequest {
	r.tag = &tag
	return r
}

func (r ApiDcimRearPortsListRequest) Cabled(cabled string) ApiDcimRearPortsListRequest {
	r.cabled = &cabled
	return r
}

func (r ApiDcimRearPortsListRequest) IdN(idN string) ApiDcimRearPortsListRequest {
	r.idN = &idN
	return r
}

func (r ApiDcimRearPortsListRequest) IdLte(idLte string) ApiDcimRearPortsListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiDcimRearPortsListRequest) IdLt(idLt string) ApiDcimRearPortsListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiDcimRearPortsListRequest) IdGte(idGte string) ApiDcimRearPortsListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiDcimRearPortsListRequest) IdGt(idGt string) ApiDcimRearPortsListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiDcimRearPortsListRequest) NameN(nameN string) ApiDcimRearPortsListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiDcimRearPortsListRequest) NameIc(nameIc string) ApiDcimRearPortsListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiDcimRearPortsListRequest) NameNic(nameNic string) ApiDcimRearPortsListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiDcimRearPortsListRequest) NameIew(nameIew string) ApiDcimRearPortsListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiDcimRearPortsListRequest) NameNiew(nameNiew string) ApiDcimRearPortsListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiDcimRearPortsListRequest) NameIsw(nameIsw string) ApiDcimRearPortsListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiDcimRearPortsListRequest) NameNisw(nameNisw string) ApiDcimRearPortsListRequest {
	r.nameNisw = &nameNisw
	return r
}

func (r ApiDcimRearPortsListRequest) NameIe(nameIe string) ApiDcimRearPortsListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiDcimRearPortsListRequest) NameNie(nameNie string) ApiDcimRearPortsListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiDcimRearPortsListRequest) NameEmpty(nameEmpty string) ApiDcimRearPortsListRequest {
	r.nameEmpty = &nameEmpty
	return r
}

func (r ApiDcimRearPortsListRequest) LabelN(labelN string) ApiDcimRearPortsListRequest {
	r.labelN = &labelN
	return r
}

func (r ApiDcimRearPortsListRequest) LabelIc(labelIc string) ApiDcimRearPortsListRequest {
	r.labelIc = &labelIc
	return r
}

func (r ApiDcimRearPortsListRequest) LabelNic(labelNic string) ApiDcimRearPortsListRequest {
	r.labelNic = &labelNic
	return r
}

func (r ApiDcimRearPortsListRequest) LabelIew(labelIew string) ApiDcimRearPortsListRequest {
	r.labelIew = &labelIew
	return r
}

func (r ApiDcimRearPortsListRequest) LabelNiew(labelNiew string) ApiDcimRearPortsListRequest {
	r.labelNiew = &labelNiew
	return r
}

func (r ApiDcimRearPortsListRequest) LabelIsw(labelIsw string) ApiDcimRearPortsListRequest {
	r.labelIsw = &labelIsw
	return r
}

func (r ApiDcimRearPortsListRequest) LabelNisw(labelNisw string) ApiDcimRearPortsListRequest {
	r.labelNisw = &labelNisw
	return r
}

func (r ApiDcimRearPortsListRequest) LabelIe(labelIe string) ApiDcimRearPortsListRequest {
	r.labelIe = &labelIe
	return r
}

func (r ApiDcimRearPortsListRequest) LabelNie(labelNie string) ApiDcimRearPortsListRequest {
	r.labelNie = &labelNie
	return r
}

func (r ApiDcimRearPortsListRequest) LabelEmpty(labelEmpty string) ApiDcimRearPortsListRequest {
	r.labelEmpty = &labelEmpty
	return r
}

func (r ApiDcimRearPortsListRequest) TypeN(typeN string) ApiDcimRearPortsListRequest {
	r.typeN = &typeN
	return r
}

func (r ApiDcimRearPortsListRequest) PositionsN(positionsN string) ApiDcimRearPortsListRequest {
	r.positionsN = &positionsN
	return r
}

func (r ApiDcimRearPortsListRequest) PositionsLte(positionsLte string) ApiDcimRearPortsListRequest {
	r.positionsLte = &positionsLte
	return r
}

func (r ApiDcimRearPortsListRequest) PositionsLt(positionsLt string) ApiDcimRearPortsListRequest {
	r.positionsLt = &positionsLt
	return r
}

func (r ApiDcimRearPortsListRequest) PositionsGte(positionsGte string) ApiDcimRearPortsListRequest {
	r.positionsGte = &positionsGte
	return r
}

func (r ApiDcimRearPortsListRequest) PositionsGt(positionsGt string) ApiDcimRearPortsListRequest {
	r.positionsGt = &positionsGt
	return r
}

func (r ApiDcimRearPortsListRequest) DescriptionN(descriptionN string) ApiDcimRearPortsListRequest {
	r.descriptionN = &descriptionN
	return r
}

func (r ApiDcimRearPortsListRequest) DescriptionIc(descriptionIc string) ApiDcimRearPortsListRequest {
	r.descriptionIc = &descriptionIc
	return r
}

func (r ApiDcimRearPortsListRequest) DescriptionNic(descriptionNic string) ApiDcimRearPortsListRequest {
	r.descriptionNic = &descriptionNic
	return r
}

func (r ApiDcimRearPortsListRequest) DescriptionIew(descriptionIew string) ApiDcimRearPortsListRequest {
	r.descriptionIew = &descriptionIew
	return r
}

func (r ApiDcimRearPortsListRequest) DescriptionNiew(descriptionNiew string) ApiDcimRearPortsListRequest {
	r.descriptionNiew = &descriptionNiew
	return r
}

func (r ApiDcimRearPortsListRequest) DescriptionIsw(descriptionIsw string) ApiDcimRearPortsListRequest {
	r.descriptionIsw = &descriptionIsw
	return r
}

func (r ApiDcimRearPortsListRequest) DescriptionNisw(descriptionNisw string) ApiDcimRearPortsListRequest {
	r.descriptionNisw = &descriptionNisw
	return r
}

func (r ApiDcimRearPortsListRequest) DescriptionIe(descriptionIe string) ApiDcimRearPortsListRequest {
	r.descriptionIe = &descriptionIe
	return r
}

func (r ApiDcimRearPortsListRequest) DescriptionNie(descriptionNie string) ApiDcimRearPortsListRequest {
	r.descriptionNie = &descriptionNie
	return r
}

func (r ApiDcimRearPortsListRequest) DescriptionEmpty(descriptionEmpty string) ApiDcimRearPortsListRequest {
	r.descriptionEmpty = &descriptionEmpty
	return r
}

func (r ApiDcimRearPortsListRequest) RegionIdN(regionIdN string) ApiDcimRearPortsListRequest {
	r.regionIdN = &regionIdN
	return r
}

func (r ApiDcimRearPortsListRequest) RegionN(regionN string) ApiDcimRearPortsListRequest {
	r.regionN = &regionN
	return r
}

func (r ApiDcimRearPortsListRequest) SiteGroupIdN(siteGroupIdN string) ApiDcimRearPortsListRequest {
	r.siteGroupIdN = &siteGroupIdN
	return r
}

func (r ApiDcimRearPortsListRequest) SiteGroupN(siteGroupN string) ApiDcimRearPortsListRequest {
	r.siteGroupN = &siteGroupN
	return r
}

func (r ApiDcimRearPortsListRequest) SiteIdN(siteIdN string) ApiDcimRearPortsListRequest {
	r.siteIdN = &siteIdN
	return r
}

func (r ApiDcimRearPortsListRequest) SiteN(siteN string) ApiDcimRearPortsListRequest {
	r.siteN = &siteN
	return r
}

func (r ApiDcimRearPortsListRequest) DeviceIdN(deviceIdN string) ApiDcimRearPortsListRequest {
	r.deviceIdN = &deviceIdN
	return r
}

func (r ApiDcimRearPortsListRequest) DeviceN(deviceN string) ApiDcimRearPortsListRequest {
	r.deviceN = &deviceN
	return r
}

func (r ApiDcimRearPortsListRequest) TagN(tagN string) ApiDcimRearPortsListRequest {
	r.tagN = &tagN
	return r
}

// Number of results to return per page.
func (r ApiDcimRearPortsListRequest) Limit(limit int32) ApiDcimRearPortsListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiDcimRearPortsListRequest) Offset(offset int32) ApiDcimRearPortsListRequest {
	r.offset = &offset
	return r
}

func (r ApiDcimRearPortsListRequest) Execute() (*DcimRearPortsList200Response, *http.Response, error) {
	return r.ApiService.DcimRearPortsListExecute(r)
}

/*
DcimRearPortsList Method for DcimRearPortsList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimRearPortsListRequest
*/
func (a *DcimApiService) DcimRearPortsList(ctx context.Context) ApiDcimRearPortsListRequest {
	return ApiDcimRearPortsListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DcimRearPortsList200Response
func (a *DcimApiService) DcimRearPortsListExecute(r ApiDcimRearPortsListRequest) (*DcimRearPortsList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DcimRearPortsList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimRearPortsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/rear-ports/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.label != nil {
		localVarQueryParams.Add("label", parameterToString(*r.label, ""))
	}
	if r.type_ != nil {
		localVarQueryParams.Add("type", parameterToString(*r.type_, ""))
	}
	if r.positions != nil {
		localVarQueryParams.Add("positions", parameterToString(*r.positions, ""))
	}
	if r.description != nil {
		localVarQueryParams.Add("description", parameterToString(*r.description, ""))
	}
	if r.created != nil {
		localVarQueryParams.Add("created", parameterToString(*r.created, ""))
	}
	if r.createdGte != nil {
		localVarQueryParams.Add("created__gte", parameterToString(*r.createdGte, ""))
	}
	if r.createdLte != nil {
		localVarQueryParams.Add("created__lte", parameterToString(*r.createdLte, ""))
	}
	if r.lastUpdated != nil {
		localVarQueryParams.Add("last_updated", parameterToString(*r.lastUpdated, ""))
	}
	if r.lastUpdatedGte != nil {
		localVarQueryParams.Add("last_updated__gte", parameterToString(*r.lastUpdatedGte, ""))
	}
	if r.lastUpdatedLte != nil {
		localVarQueryParams.Add("last_updated__lte", parameterToString(*r.lastUpdatedLte, ""))
	}
	if r.q != nil {
		localVarQueryParams.Add("q", parameterToString(*r.q, ""))
	}
	if r.regionId != nil {
		localVarQueryParams.Add("region_id", parameterToString(*r.regionId, ""))
	}
	if r.region != nil {
		localVarQueryParams.Add("region", parameterToString(*r.region, ""))
	}
	if r.siteGroupId != nil {
		localVarQueryParams.Add("site_group_id", parameterToString(*r.siteGroupId, ""))
	}
	if r.siteGroup != nil {
		localVarQueryParams.Add("site_group", parameterToString(*r.siteGroup, ""))
	}
	if r.siteId != nil {
		localVarQueryParams.Add("site_id", parameterToString(*r.siteId, ""))
	}
	if r.site != nil {
		localVarQueryParams.Add("site", parameterToString(*r.site, ""))
	}
	if r.deviceId != nil {
		localVarQueryParams.Add("device_id", parameterToString(*r.deviceId, ""))
	}
	if r.device != nil {
		localVarQueryParams.Add("device", parameterToString(*r.device, ""))
	}
	if r.tag != nil {
		localVarQueryParams.Add("tag", parameterToString(*r.tag, ""))
	}
	if r.cabled != nil {
		localVarQueryParams.Add("cabled", parameterToString(*r.cabled, ""))
	}
	if r.idN != nil {
		localVarQueryParams.Add("id__n", parameterToString(*r.idN, ""))
	}
	if r.idLte != nil {
		localVarQueryParams.Add("id__lte", parameterToString(*r.idLte, ""))
	}
	if r.idLt != nil {
		localVarQueryParams.Add("id__lt", parameterToString(*r.idLt, ""))
	}
	if r.idGte != nil {
		localVarQueryParams.Add("id__gte", parameterToString(*r.idGte, ""))
	}
	if r.idGt != nil {
		localVarQueryParams.Add("id__gt", parameterToString(*r.idGt, ""))
	}
	if r.nameN != nil {
		localVarQueryParams.Add("name__n", parameterToString(*r.nameN, ""))
	}
	if r.nameIc != nil {
		localVarQueryParams.Add("name__ic", parameterToString(*r.nameIc, ""))
	}
	if r.nameNic != nil {
		localVarQueryParams.Add("name__nic", parameterToString(*r.nameNic, ""))
	}
	if r.nameIew != nil {
		localVarQueryParams.Add("name__iew", parameterToString(*r.nameIew, ""))
	}
	if r.nameNiew != nil {
		localVarQueryParams.Add("name__niew", parameterToString(*r.nameNiew, ""))
	}
	if r.nameIsw != nil {
		localVarQueryParams.Add("name__isw", parameterToString(*r.nameIsw, ""))
	}
	if r.nameNisw != nil {
		localVarQueryParams.Add("name__nisw", parameterToString(*r.nameNisw, ""))
	}
	if r.nameIe != nil {
		localVarQueryParams.Add("name__ie", parameterToString(*r.nameIe, ""))
	}
	if r.nameNie != nil {
		localVarQueryParams.Add("name__nie", parameterToString(*r.nameNie, ""))
	}
	if r.nameEmpty != nil {
		localVarQueryParams.Add("name__empty", parameterToString(*r.nameEmpty, ""))
	}
	if r.labelN != nil {
		localVarQueryParams.Add("label__n", parameterToString(*r.labelN, ""))
	}
	if r.labelIc != nil {
		localVarQueryParams.Add("label__ic", parameterToString(*r.labelIc, ""))
	}
	if r.labelNic != nil {
		localVarQueryParams.Add("label__nic", parameterToString(*r.labelNic, ""))
	}
	if r.labelIew != nil {
		localVarQueryParams.Add("label__iew", parameterToString(*r.labelIew, ""))
	}
	if r.labelNiew != nil {
		localVarQueryParams.Add("label__niew", parameterToString(*r.labelNiew, ""))
	}
	if r.labelIsw != nil {
		localVarQueryParams.Add("label__isw", parameterToString(*r.labelIsw, ""))
	}
	if r.labelNisw != nil {
		localVarQueryParams.Add("label__nisw", parameterToString(*r.labelNisw, ""))
	}
	if r.labelIe != nil {
		localVarQueryParams.Add("label__ie", parameterToString(*r.labelIe, ""))
	}
	if r.labelNie != nil {
		localVarQueryParams.Add("label__nie", parameterToString(*r.labelNie, ""))
	}
	if r.labelEmpty != nil {
		localVarQueryParams.Add("label__empty", parameterToString(*r.labelEmpty, ""))
	}
	if r.typeN != nil {
		localVarQueryParams.Add("type__n", parameterToString(*r.typeN, ""))
	}
	if r.positionsN != nil {
		localVarQueryParams.Add("positions__n", parameterToString(*r.positionsN, ""))
	}
	if r.positionsLte != nil {
		localVarQueryParams.Add("positions__lte", parameterToString(*r.positionsLte, ""))
	}
	if r.positionsLt != nil {
		localVarQueryParams.Add("positions__lt", parameterToString(*r.positionsLt, ""))
	}
	if r.positionsGte != nil {
		localVarQueryParams.Add("positions__gte", parameterToString(*r.positionsGte, ""))
	}
	if r.positionsGt != nil {
		localVarQueryParams.Add("positions__gt", parameterToString(*r.positionsGt, ""))
	}
	if r.descriptionN != nil {
		localVarQueryParams.Add("description__n", parameterToString(*r.descriptionN, ""))
	}
	if r.descriptionIc != nil {
		localVarQueryParams.Add("description__ic", parameterToString(*r.descriptionIc, ""))
	}
	if r.descriptionNic != nil {
		localVarQueryParams.Add("description__nic", parameterToString(*r.descriptionNic, ""))
	}
	if r.descriptionIew != nil {
		localVarQueryParams.Add("description__iew", parameterToString(*r.descriptionIew, ""))
	}
	if r.descriptionNiew != nil {
		localVarQueryParams.Add("description__niew", parameterToString(*r.descriptionNiew, ""))
	}
	if r.descriptionIsw != nil {
		localVarQueryParams.Add("description__isw", parameterToString(*r.descriptionIsw, ""))
	}
	if r.descriptionNisw != nil {
		localVarQueryParams.Add("description__nisw", parameterToString(*r.descriptionNisw, ""))
	}
	if r.descriptionIe != nil {
		localVarQueryParams.Add("description__ie", parameterToString(*r.descriptionIe, ""))
	}
	if r.descriptionNie != nil {
		localVarQueryParams.Add("description__nie", parameterToString(*r.descriptionNie, ""))
	}
	if r.descriptionEmpty != nil {
		localVarQueryParams.Add("description__empty", parameterToString(*r.descriptionEmpty, ""))
	}
	if r.regionIdN != nil {
		localVarQueryParams.Add("region_id__n", parameterToString(*r.regionIdN, ""))
	}
	if r.regionN != nil {
		localVarQueryParams.Add("region__n", parameterToString(*r.regionN, ""))
	}
	if r.siteGroupIdN != nil {
		localVarQueryParams.Add("site_group_id__n", parameterToString(*r.siteGroupIdN, ""))
	}
	if r.siteGroupN != nil {
		localVarQueryParams.Add("site_group__n", parameterToString(*r.siteGroupN, ""))
	}
	if r.siteIdN != nil {
		localVarQueryParams.Add("site_id__n", parameterToString(*r.siteIdN, ""))
	}
	if r.siteN != nil {
		localVarQueryParams.Add("site__n", parameterToString(*r.siteN, ""))
	}
	if r.deviceIdN != nil {
		localVarQueryParams.Add("device_id__n", parameterToString(*r.deviceIdN, ""))
	}
	if r.deviceN != nil {
		localVarQueryParams.Add("device__n", parameterToString(*r.deviceN, ""))
	}
	if r.tagN != nil {
		localVarQueryParams.Add("tag__n", parameterToString(*r.tagN, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimRearPortsPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
	data *WritableRearPort
}

func (r ApiDcimRearPortsPartialUpdateRequest) Data(data WritableRearPort) ApiDcimRearPortsPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimRearPortsPartialUpdateRequest) Execute() (*RearPort, *http.Response, error) {
	return r.ApiService.DcimRearPortsPartialUpdateExecute(r)
}

/*
DcimRearPortsPartialUpdate Method for DcimRearPortsPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this rear port.
 @return ApiDcimRearPortsPartialUpdateRequest
*/
func (a *DcimApiService) DcimRearPortsPartialUpdate(ctx context.Context, id int32) ApiDcimRearPortsPartialUpdateRequest {
	return ApiDcimRearPortsPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return RearPort
func (a *DcimApiService) DcimRearPortsPartialUpdateExecute(r ApiDcimRearPortsPartialUpdateRequest) (*RearPort, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RearPort
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimRearPortsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/rear-ports/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimRearPortsPathsRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
}

func (r ApiDcimRearPortsPathsRequest) Execute() (*RearPort, *http.Response, error) {
	return r.ApiService.DcimRearPortsPathsExecute(r)
}

/*
DcimRearPortsPaths Method for DcimRearPortsPaths

Return all CablePaths which traverse a given pass-through port.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this rear port.
 @return ApiDcimRearPortsPathsRequest
*/
func (a *DcimApiService) DcimRearPortsPaths(ctx context.Context, id int32) ApiDcimRearPortsPathsRequest {
	return ApiDcimRearPortsPathsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return RearPort
func (a *DcimApiService) DcimRearPortsPathsExecute(r ApiDcimRearPortsPathsRequest) (*RearPort, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RearPort
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimRearPortsPaths")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/rear-ports/{id}/paths/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimRearPortsReadRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
}

func (r ApiDcimRearPortsReadRequest) Execute() (*RearPort, *http.Response, error) {
	return r.ApiService.DcimRearPortsReadExecute(r)
}

/*
DcimRearPortsRead Method for DcimRearPortsRead

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this rear port.
 @return ApiDcimRearPortsReadRequest
*/
func (a *DcimApiService) DcimRearPortsRead(ctx context.Context, id int32) ApiDcimRearPortsReadRequest {
	return ApiDcimRearPortsReadRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return RearPort
func (a *DcimApiService) DcimRearPortsReadExecute(r ApiDcimRearPortsReadRequest) (*RearPort, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RearPort
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimRearPortsRead")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/rear-ports/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimRearPortsUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
	data *WritableRearPort
}

func (r ApiDcimRearPortsUpdateRequest) Data(data WritableRearPort) ApiDcimRearPortsUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimRearPortsUpdateRequest) Execute() (*RearPort, *http.Response, error) {
	return r.ApiService.DcimRearPortsUpdateExecute(r)
}

/*
DcimRearPortsUpdate Method for DcimRearPortsUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this rear port.
 @return ApiDcimRearPortsUpdateRequest
*/
func (a *DcimApiService) DcimRearPortsUpdate(ctx context.Context, id int32) ApiDcimRearPortsUpdateRequest {
	return ApiDcimRearPortsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return RearPort
func (a *DcimApiService) DcimRearPortsUpdateExecute(r ApiDcimRearPortsUpdateRequest) (*RearPort, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RearPort
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimRearPortsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/rear-ports/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimRegionsBulkDeleteRequest struct {
	ctx context.Context
	ApiService *DcimApiService
}

func (r ApiDcimRegionsBulkDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimRegionsBulkDeleteExecute(r)
}

/*
DcimRegionsBulkDelete Method for DcimRegionsBulkDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimRegionsBulkDeleteRequest
*/
func (a *DcimApiService) DcimRegionsBulkDelete(ctx context.Context) ApiDcimRegionsBulkDeleteRequest {
	return ApiDcimRegionsBulkDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DcimApiService) DcimRegionsBulkDeleteExecute(r ApiDcimRegionsBulkDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimRegionsBulkDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/regions/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimRegionsBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	data *WritableRegion
}

func (r ApiDcimRegionsBulkPartialUpdateRequest) Data(data WritableRegion) ApiDcimRegionsBulkPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimRegionsBulkPartialUpdateRequest) Execute() (*Region, *http.Response, error) {
	return r.ApiService.DcimRegionsBulkPartialUpdateExecute(r)
}

/*
DcimRegionsBulkPartialUpdate Method for DcimRegionsBulkPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimRegionsBulkPartialUpdateRequest
*/
func (a *DcimApiService) DcimRegionsBulkPartialUpdate(ctx context.Context) ApiDcimRegionsBulkPartialUpdateRequest {
	return ApiDcimRegionsBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Region
func (a *DcimApiService) DcimRegionsBulkPartialUpdateExecute(r ApiDcimRegionsBulkPartialUpdateRequest) (*Region, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Region
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimRegionsBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/regions/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimRegionsBulkUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	data *WritableRegion
}

func (r ApiDcimRegionsBulkUpdateRequest) Data(data WritableRegion) ApiDcimRegionsBulkUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimRegionsBulkUpdateRequest) Execute() (*Region, *http.Response, error) {
	return r.ApiService.DcimRegionsBulkUpdateExecute(r)
}

/*
DcimRegionsBulkUpdate Method for DcimRegionsBulkUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimRegionsBulkUpdateRequest
*/
func (a *DcimApiService) DcimRegionsBulkUpdate(ctx context.Context) ApiDcimRegionsBulkUpdateRequest {
	return ApiDcimRegionsBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Region
func (a *DcimApiService) DcimRegionsBulkUpdateExecute(r ApiDcimRegionsBulkUpdateRequest) (*Region, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Region
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimRegionsBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/regions/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimRegionsCreateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	data *WritableRegion
}

func (r ApiDcimRegionsCreateRequest) Data(data WritableRegion) ApiDcimRegionsCreateRequest {
	r.data = &data
	return r
}

func (r ApiDcimRegionsCreateRequest) Execute() (*Region, *http.Response, error) {
	return r.ApiService.DcimRegionsCreateExecute(r)
}

/*
DcimRegionsCreate Method for DcimRegionsCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimRegionsCreateRequest
*/
func (a *DcimApiService) DcimRegionsCreate(ctx context.Context) ApiDcimRegionsCreateRequest {
	return ApiDcimRegionsCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Region
func (a *DcimApiService) DcimRegionsCreateExecute(r ApiDcimRegionsCreateRequest) (*Region, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Region
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimRegionsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/regions/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimRegionsDeleteRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
}

func (r ApiDcimRegionsDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimRegionsDeleteExecute(r)
}

/*
DcimRegionsDelete Method for DcimRegionsDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this region.
 @return ApiDcimRegionsDeleteRequest
*/
func (a *DcimApiService) DcimRegionsDelete(ctx context.Context, id int32) ApiDcimRegionsDeleteRequest {
	return ApiDcimRegionsDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DcimApiService) DcimRegionsDeleteExecute(r ApiDcimRegionsDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimRegionsDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/regions/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimRegionsListRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id *string
	name *string
	slug *string
	description *string
	created *string
	createdGte *string
	createdLte *string
	lastUpdated *string
	lastUpdatedGte *string
	lastUpdatedLte *string
	q *string
	parentId *string
	parent *string
	idN *string
	idLte *string
	idLt *string
	idGte *string
	idGt *string
	nameN *string
	nameIc *string
	nameNic *string
	nameIew *string
	nameNiew *string
	nameIsw *string
	nameNisw *string
	nameIe *string
	nameNie *string
	nameEmpty *string
	slugN *string
	slugIc *string
	slugNic *string
	slugIew *string
	slugNiew *string
	slugIsw *string
	slugNisw *string
	slugIe *string
	slugNie *string
	slugEmpty *string
	descriptionN *string
	descriptionIc *string
	descriptionNic *string
	descriptionIew *string
	descriptionNiew *string
	descriptionIsw *string
	descriptionNisw *string
	descriptionIe *string
	descriptionNie *string
	descriptionEmpty *string
	parentIdN *string
	parentN *string
	limit *int32
	offset *int32
}

func (r ApiDcimRegionsListRequest) Id(id string) ApiDcimRegionsListRequest {
	r.id = &id
	return r
}

func (r ApiDcimRegionsListRequest) Name(name string) ApiDcimRegionsListRequest {
	r.name = &name
	return r
}

func (r ApiDcimRegionsListRequest) Slug(slug string) ApiDcimRegionsListRequest {
	r.slug = &slug
	return r
}

func (r ApiDcimRegionsListRequest) Description(description string) ApiDcimRegionsListRequest {
	r.description = &description
	return r
}

func (r ApiDcimRegionsListRequest) Created(created string) ApiDcimRegionsListRequest {
	r.created = &created
	return r
}

func (r ApiDcimRegionsListRequest) CreatedGte(createdGte string) ApiDcimRegionsListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiDcimRegionsListRequest) CreatedLte(createdLte string) ApiDcimRegionsListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiDcimRegionsListRequest) LastUpdated(lastUpdated string) ApiDcimRegionsListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiDcimRegionsListRequest) LastUpdatedGte(lastUpdatedGte string) ApiDcimRegionsListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiDcimRegionsListRequest) LastUpdatedLte(lastUpdatedLte string) ApiDcimRegionsListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiDcimRegionsListRequest) Q(q string) ApiDcimRegionsListRequest {
	r.q = &q
	return r
}

func (r ApiDcimRegionsListRequest) ParentId(parentId string) ApiDcimRegionsListRequest {
	r.parentId = &parentId
	return r
}

func (r ApiDcimRegionsListRequest) Parent(parent string) ApiDcimRegionsListRequest {
	r.parent = &parent
	return r
}

func (r ApiDcimRegionsListRequest) IdN(idN string) ApiDcimRegionsListRequest {
	r.idN = &idN
	return r
}

func (r ApiDcimRegionsListRequest) IdLte(idLte string) ApiDcimRegionsListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiDcimRegionsListRequest) IdLt(idLt string) ApiDcimRegionsListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiDcimRegionsListRequest) IdGte(idGte string) ApiDcimRegionsListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiDcimRegionsListRequest) IdGt(idGt string) ApiDcimRegionsListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiDcimRegionsListRequest) NameN(nameN string) ApiDcimRegionsListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiDcimRegionsListRequest) NameIc(nameIc string) ApiDcimRegionsListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiDcimRegionsListRequest) NameNic(nameNic string) ApiDcimRegionsListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiDcimRegionsListRequest) NameIew(nameIew string) ApiDcimRegionsListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiDcimRegionsListRequest) NameNiew(nameNiew string) ApiDcimRegionsListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiDcimRegionsListRequest) NameIsw(nameIsw string) ApiDcimRegionsListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiDcimRegionsListRequest) NameNisw(nameNisw string) ApiDcimRegionsListRequest {
	r.nameNisw = &nameNisw
	return r
}

func (r ApiDcimRegionsListRequest) NameIe(nameIe string) ApiDcimRegionsListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiDcimRegionsListRequest) NameNie(nameNie string) ApiDcimRegionsListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiDcimRegionsListRequest) NameEmpty(nameEmpty string) ApiDcimRegionsListRequest {
	r.nameEmpty = &nameEmpty
	return r
}

func (r ApiDcimRegionsListRequest) SlugN(slugN string) ApiDcimRegionsListRequest {
	r.slugN = &slugN
	return r
}

func (r ApiDcimRegionsListRequest) SlugIc(slugIc string) ApiDcimRegionsListRequest {
	r.slugIc = &slugIc
	return r
}

func (r ApiDcimRegionsListRequest) SlugNic(slugNic string) ApiDcimRegionsListRequest {
	r.slugNic = &slugNic
	return r
}

func (r ApiDcimRegionsListRequest) SlugIew(slugIew string) ApiDcimRegionsListRequest {
	r.slugIew = &slugIew
	return r
}

func (r ApiDcimRegionsListRequest) SlugNiew(slugNiew string) ApiDcimRegionsListRequest {
	r.slugNiew = &slugNiew
	return r
}

func (r ApiDcimRegionsListRequest) SlugIsw(slugIsw string) ApiDcimRegionsListRequest {
	r.slugIsw = &slugIsw
	return r
}

func (r ApiDcimRegionsListRequest) SlugNisw(slugNisw string) ApiDcimRegionsListRequest {
	r.slugNisw = &slugNisw
	return r
}

func (r ApiDcimRegionsListRequest) SlugIe(slugIe string) ApiDcimRegionsListRequest {
	r.slugIe = &slugIe
	return r
}

func (r ApiDcimRegionsListRequest) SlugNie(slugNie string) ApiDcimRegionsListRequest {
	r.slugNie = &slugNie
	return r
}

func (r ApiDcimRegionsListRequest) SlugEmpty(slugEmpty string) ApiDcimRegionsListRequest {
	r.slugEmpty = &slugEmpty
	return r
}

func (r ApiDcimRegionsListRequest) DescriptionN(descriptionN string) ApiDcimRegionsListRequest {
	r.descriptionN = &descriptionN
	return r
}

func (r ApiDcimRegionsListRequest) DescriptionIc(descriptionIc string) ApiDcimRegionsListRequest {
	r.descriptionIc = &descriptionIc
	return r
}

func (r ApiDcimRegionsListRequest) DescriptionNic(descriptionNic string) ApiDcimRegionsListRequest {
	r.descriptionNic = &descriptionNic
	return r
}

func (r ApiDcimRegionsListRequest) DescriptionIew(descriptionIew string) ApiDcimRegionsListRequest {
	r.descriptionIew = &descriptionIew
	return r
}

func (r ApiDcimRegionsListRequest) DescriptionNiew(descriptionNiew string) ApiDcimRegionsListRequest {
	r.descriptionNiew = &descriptionNiew
	return r
}

func (r ApiDcimRegionsListRequest) DescriptionIsw(descriptionIsw string) ApiDcimRegionsListRequest {
	r.descriptionIsw = &descriptionIsw
	return r
}

func (r ApiDcimRegionsListRequest) DescriptionNisw(descriptionNisw string) ApiDcimRegionsListRequest {
	r.descriptionNisw = &descriptionNisw
	return r
}

func (r ApiDcimRegionsListRequest) DescriptionIe(descriptionIe string) ApiDcimRegionsListRequest {
	r.descriptionIe = &descriptionIe
	return r
}

func (r ApiDcimRegionsListRequest) DescriptionNie(descriptionNie string) ApiDcimRegionsListRequest {
	r.descriptionNie = &descriptionNie
	return r
}

func (r ApiDcimRegionsListRequest) DescriptionEmpty(descriptionEmpty string) ApiDcimRegionsListRequest {
	r.descriptionEmpty = &descriptionEmpty
	return r
}

func (r ApiDcimRegionsListRequest) ParentIdN(parentIdN string) ApiDcimRegionsListRequest {
	r.parentIdN = &parentIdN
	return r
}

func (r ApiDcimRegionsListRequest) ParentN(parentN string) ApiDcimRegionsListRequest {
	r.parentN = &parentN
	return r
}

// Number of results to return per page.
func (r ApiDcimRegionsListRequest) Limit(limit int32) ApiDcimRegionsListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiDcimRegionsListRequest) Offset(offset int32) ApiDcimRegionsListRequest {
	r.offset = &offset
	return r
}

func (r ApiDcimRegionsListRequest) Execute() (*DcimRegionsList200Response, *http.Response, error) {
	return r.ApiService.DcimRegionsListExecute(r)
}

/*
DcimRegionsList Method for DcimRegionsList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimRegionsListRequest
*/
func (a *DcimApiService) DcimRegionsList(ctx context.Context) ApiDcimRegionsListRequest {
	return ApiDcimRegionsListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DcimRegionsList200Response
func (a *DcimApiService) DcimRegionsListExecute(r ApiDcimRegionsListRequest) (*DcimRegionsList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DcimRegionsList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimRegionsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/regions/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.slug != nil {
		localVarQueryParams.Add("slug", parameterToString(*r.slug, ""))
	}
	if r.description != nil {
		localVarQueryParams.Add("description", parameterToString(*r.description, ""))
	}
	if r.created != nil {
		localVarQueryParams.Add("created", parameterToString(*r.created, ""))
	}
	if r.createdGte != nil {
		localVarQueryParams.Add("created__gte", parameterToString(*r.createdGte, ""))
	}
	if r.createdLte != nil {
		localVarQueryParams.Add("created__lte", parameterToString(*r.createdLte, ""))
	}
	if r.lastUpdated != nil {
		localVarQueryParams.Add("last_updated", parameterToString(*r.lastUpdated, ""))
	}
	if r.lastUpdatedGte != nil {
		localVarQueryParams.Add("last_updated__gte", parameterToString(*r.lastUpdatedGte, ""))
	}
	if r.lastUpdatedLte != nil {
		localVarQueryParams.Add("last_updated__lte", parameterToString(*r.lastUpdatedLte, ""))
	}
	if r.q != nil {
		localVarQueryParams.Add("q", parameterToString(*r.q, ""))
	}
	if r.parentId != nil {
		localVarQueryParams.Add("parent_id", parameterToString(*r.parentId, ""))
	}
	if r.parent != nil {
		localVarQueryParams.Add("parent", parameterToString(*r.parent, ""))
	}
	if r.idN != nil {
		localVarQueryParams.Add("id__n", parameterToString(*r.idN, ""))
	}
	if r.idLte != nil {
		localVarQueryParams.Add("id__lte", parameterToString(*r.idLte, ""))
	}
	if r.idLt != nil {
		localVarQueryParams.Add("id__lt", parameterToString(*r.idLt, ""))
	}
	if r.idGte != nil {
		localVarQueryParams.Add("id__gte", parameterToString(*r.idGte, ""))
	}
	if r.idGt != nil {
		localVarQueryParams.Add("id__gt", parameterToString(*r.idGt, ""))
	}
	if r.nameN != nil {
		localVarQueryParams.Add("name__n", parameterToString(*r.nameN, ""))
	}
	if r.nameIc != nil {
		localVarQueryParams.Add("name__ic", parameterToString(*r.nameIc, ""))
	}
	if r.nameNic != nil {
		localVarQueryParams.Add("name__nic", parameterToString(*r.nameNic, ""))
	}
	if r.nameIew != nil {
		localVarQueryParams.Add("name__iew", parameterToString(*r.nameIew, ""))
	}
	if r.nameNiew != nil {
		localVarQueryParams.Add("name__niew", parameterToString(*r.nameNiew, ""))
	}
	if r.nameIsw != nil {
		localVarQueryParams.Add("name__isw", parameterToString(*r.nameIsw, ""))
	}
	if r.nameNisw != nil {
		localVarQueryParams.Add("name__nisw", parameterToString(*r.nameNisw, ""))
	}
	if r.nameIe != nil {
		localVarQueryParams.Add("name__ie", parameterToString(*r.nameIe, ""))
	}
	if r.nameNie != nil {
		localVarQueryParams.Add("name__nie", parameterToString(*r.nameNie, ""))
	}
	if r.nameEmpty != nil {
		localVarQueryParams.Add("name__empty", parameterToString(*r.nameEmpty, ""))
	}
	if r.slugN != nil {
		localVarQueryParams.Add("slug__n", parameterToString(*r.slugN, ""))
	}
	if r.slugIc != nil {
		localVarQueryParams.Add("slug__ic", parameterToString(*r.slugIc, ""))
	}
	if r.slugNic != nil {
		localVarQueryParams.Add("slug__nic", parameterToString(*r.slugNic, ""))
	}
	if r.slugIew != nil {
		localVarQueryParams.Add("slug__iew", parameterToString(*r.slugIew, ""))
	}
	if r.slugNiew != nil {
		localVarQueryParams.Add("slug__niew", parameterToString(*r.slugNiew, ""))
	}
	if r.slugIsw != nil {
		localVarQueryParams.Add("slug__isw", parameterToString(*r.slugIsw, ""))
	}
	if r.slugNisw != nil {
		localVarQueryParams.Add("slug__nisw", parameterToString(*r.slugNisw, ""))
	}
	if r.slugIe != nil {
		localVarQueryParams.Add("slug__ie", parameterToString(*r.slugIe, ""))
	}
	if r.slugNie != nil {
		localVarQueryParams.Add("slug__nie", parameterToString(*r.slugNie, ""))
	}
	if r.slugEmpty != nil {
		localVarQueryParams.Add("slug__empty", parameterToString(*r.slugEmpty, ""))
	}
	if r.descriptionN != nil {
		localVarQueryParams.Add("description__n", parameterToString(*r.descriptionN, ""))
	}
	if r.descriptionIc != nil {
		localVarQueryParams.Add("description__ic", parameterToString(*r.descriptionIc, ""))
	}
	if r.descriptionNic != nil {
		localVarQueryParams.Add("description__nic", parameterToString(*r.descriptionNic, ""))
	}
	if r.descriptionIew != nil {
		localVarQueryParams.Add("description__iew", parameterToString(*r.descriptionIew, ""))
	}
	if r.descriptionNiew != nil {
		localVarQueryParams.Add("description__niew", parameterToString(*r.descriptionNiew, ""))
	}
	if r.descriptionIsw != nil {
		localVarQueryParams.Add("description__isw", parameterToString(*r.descriptionIsw, ""))
	}
	if r.descriptionNisw != nil {
		localVarQueryParams.Add("description__nisw", parameterToString(*r.descriptionNisw, ""))
	}
	if r.descriptionIe != nil {
		localVarQueryParams.Add("description__ie", parameterToString(*r.descriptionIe, ""))
	}
	if r.descriptionNie != nil {
		localVarQueryParams.Add("description__nie", parameterToString(*r.descriptionNie, ""))
	}
	if r.descriptionEmpty != nil {
		localVarQueryParams.Add("description__empty", parameterToString(*r.descriptionEmpty, ""))
	}
	if r.parentIdN != nil {
		localVarQueryParams.Add("parent_id__n", parameterToString(*r.parentIdN, ""))
	}
	if r.parentN != nil {
		localVarQueryParams.Add("parent__n", parameterToString(*r.parentN, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimRegionsPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
	data *WritableRegion
}

func (r ApiDcimRegionsPartialUpdateRequest) Data(data WritableRegion) ApiDcimRegionsPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimRegionsPartialUpdateRequest) Execute() (*Region, *http.Response, error) {
	return r.ApiService.DcimRegionsPartialUpdateExecute(r)
}

/*
DcimRegionsPartialUpdate Method for DcimRegionsPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this region.
 @return ApiDcimRegionsPartialUpdateRequest
*/
func (a *DcimApiService) DcimRegionsPartialUpdate(ctx context.Context, id int32) ApiDcimRegionsPartialUpdateRequest {
	return ApiDcimRegionsPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Region
func (a *DcimApiService) DcimRegionsPartialUpdateExecute(r ApiDcimRegionsPartialUpdateRequest) (*Region, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Region
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimRegionsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/regions/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimRegionsReadRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
}

func (r ApiDcimRegionsReadRequest) Execute() (*Region, *http.Response, error) {
	return r.ApiService.DcimRegionsReadExecute(r)
}

/*
DcimRegionsRead Method for DcimRegionsRead

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this region.
 @return ApiDcimRegionsReadRequest
*/
func (a *DcimApiService) DcimRegionsRead(ctx context.Context, id int32) ApiDcimRegionsReadRequest {
	return ApiDcimRegionsReadRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Region
func (a *DcimApiService) DcimRegionsReadExecute(r ApiDcimRegionsReadRequest) (*Region, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Region
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimRegionsRead")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/regions/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimRegionsUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
	data *WritableRegion
}

func (r ApiDcimRegionsUpdateRequest) Data(data WritableRegion) ApiDcimRegionsUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimRegionsUpdateRequest) Execute() (*Region, *http.Response, error) {
	return r.ApiService.DcimRegionsUpdateExecute(r)
}

/*
DcimRegionsUpdate Method for DcimRegionsUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this region.
 @return ApiDcimRegionsUpdateRequest
*/
func (a *DcimApiService) DcimRegionsUpdate(ctx context.Context, id int32) ApiDcimRegionsUpdateRequest {
	return ApiDcimRegionsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Region
func (a *DcimApiService) DcimRegionsUpdateExecute(r ApiDcimRegionsUpdateRequest) (*Region, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Region
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimRegionsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/regions/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimSiteGroupsBulkDeleteRequest struct {
	ctx context.Context
	ApiService *DcimApiService
}

func (r ApiDcimSiteGroupsBulkDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimSiteGroupsBulkDeleteExecute(r)
}

/*
DcimSiteGroupsBulkDelete Method for DcimSiteGroupsBulkDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimSiteGroupsBulkDeleteRequest
*/
func (a *DcimApiService) DcimSiteGroupsBulkDelete(ctx context.Context) ApiDcimSiteGroupsBulkDeleteRequest {
	return ApiDcimSiteGroupsBulkDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DcimApiService) DcimSiteGroupsBulkDeleteExecute(r ApiDcimSiteGroupsBulkDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimSiteGroupsBulkDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/site-groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimSiteGroupsBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	data *WritableSiteGroup
}

func (r ApiDcimSiteGroupsBulkPartialUpdateRequest) Data(data WritableSiteGroup) ApiDcimSiteGroupsBulkPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimSiteGroupsBulkPartialUpdateRequest) Execute() (*SiteGroup, *http.Response, error) {
	return r.ApiService.DcimSiteGroupsBulkPartialUpdateExecute(r)
}

/*
DcimSiteGroupsBulkPartialUpdate Method for DcimSiteGroupsBulkPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimSiteGroupsBulkPartialUpdateRequest
*/
func (a *DcimApiService) DcimSiteGroupsBulkPartialUpdate(ctx context.Context) ApiDcimSiteGroupsBulkPartialUpdateRequest {
	return ApiDcimSiteGroupsBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SiteGroup
func (a *DcimApiService) DcimSiteGroupsBulkPartialUpdateExecute(r ApiDcimSiteGroupsBulkPartialUpdateRequest) (*SiteGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SiteGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimSiteGroupsBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/site-groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimSiteGroupsBulkUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	data *WritableSiteGroup
}

func (r ApiDcimSiteGroupsBulkUpdateRequest) Data(data WritableSiteGroup) ApiDcimSiteGroupsBulkUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimSiteGroupsBulkUpdateRequest) Execute() (*SiteGroup, *http.Response, error) {
	return r.ApiService.DcimSiteGroupsBulkUpdateExecute(r)
}

/*
DcimSiteGroupsBulkUpdate Method for DcimSiteGroupsBulkUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimSiteGroupsBulkUpdateRequest
*/
func (a *DcimApiService) DcimSiteGroupsBulkUpdate(ctx context.Context) ApiDcimSiteGroupsBulkUpdateRequest {
	return ApiDcimSiteGroupsBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SiteGroup
func (a *DcimApiService) DcimSiteGroupsBulkUpdateExecute(r ApiDcimSiteGroupsBulkUpdateRequest) (*SiteGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SiteGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimSiteGroupsBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/site-groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimSiteGroupsCreateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	data *WritableSiteGroup
}

func (r ApiDcimSiteGroupsCreateRequest) Data(data WritableSiteGroup) ApiDcimSiteGroupsCreateRequest {
	r.data = &data
	return r
}

func (r ApiDcimSiteGroupsCreateRequest) Execute() (*SiteGroup, *http.Response, error) {
	return r.ApiService.DcimSiteGroupsCreateExecute(r)
}

/*
DcimSiteGroupsCreate Method for DcimSiteGroupsCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimSiteGroupsCreateRequest
*/
func (a *DcimApiService) DcimSiteGroupsCreate(ctx context.Context) ApiDcimSiteGroupsCreateRequest {
	return ApiDcimSiteGroupsCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SiteGroup
func (a *DcimApiService) DcimSiteGroupsCreateExecute(r ApiDcimSiteGroupsCreateRequest) (*SiteGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SiteGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimSiteGroupsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/site-groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimSiteGroupsDeleteRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
}

func (r ApiDcimSiteGroupsDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimSiteGroupsDeleteExecute(r)
}

/*
DcimSiteGroupsDelete Method for DcimSiteGroupsDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this site group.
 @return ApiDcimSiteGroupsDeleteRequest
*/
func (a *DcimApiService) DcimSiteGroupsDelete(ctx context.Context, id int32) ApiDcimSiteGroupsDeleteRequest {
	return ApiDcimSiteGroupsDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DcimApiService) DcimSiteGroupsDeleteExecute(r ApiDcimSiteGroupsDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimSiteGroupsDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/site-groups/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimSiteGroupsListRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id *string
	name *string
	slug *string
	description *string
	created *string
	createdGte *string
	createdLte *string
	lastUpdated *string
	lastUpdatedGte *string
	lastUpdatedLte *string
	q *string
	parentId *string
	parent *string
	idN *string
	idLte *string
	idLt *string
	idGte *string
	idGt *string
	nameN *string
	nameIc *string
	nameNic *string
	nameIew *string
	nameNiew *string
	nameIsw *string
	nameNisw *string
	nameIe *string
	nameNie *string
	nameEmpty *string
	slugN *string
	slugIc *string
	slugNic *string
	slugIew *string
	slugNiew *string
	slugIsw *string
	slugNisw *string
	slugIe *string
	slugNie *string
	slugEmpty *string
	descriptionN *string
	descriptionIc *string
	descriptionNic *string
	descriptionIew *string
	descriptionNiew *string
	descriptionIsw *string
	descriptionNisw *string
	descriptionIe *string
	descriptionNie *string
	descriptionEmpty *string
	parentIdN *string
	parentN *string
	limit *int32
	offset *int32
}

func (r ApiDcimSiteGroupsListRequest) Id(id string) ApiDcimSiteGroupsListRequest {
	r.id = &id
	return r
}

func (r ApiDcimSiteGroupsListRequest) Name(name string) ApiDcimSiteGroupsListRequest {
	r.name = &name
	return r
}

func (r ApiDcimSiteGroupsListRequest) Slug(slug string) ApiDcimSiteGroupsListRequest {
	r.slug = &slug
	return r
}

func (r ApiDcimSiteGroupsListRequest) Description(description string) ApiDcimSiteGroupsListRequest {
	r.description = &description
	return r
}

func (r ApiDcimSiteGroupsListRequest) Created(created string) ApiDcimSiteGroupsListRequest {
	r.created = &created
	return r
}

func (r ApiDcimSiteGroupsListRequest) CreatedGte(createdGte string) ApiDcimSiteGroupsListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiDcimSiteGroupsListRequest) CreatedLte(createdLte string) ApiDcimSiteGroupsListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiDcimSiteGroupsListRequest) LastUpdated(lastUpdated string) ApiDcimSiteGroupsListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiDcimSiteGroupsListRequest) LastUpdatedGte(lastUpdatedGte string) ApiDcimSiteGroupsListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiDcimSiteGroupsListRequest) LastUpdatedLte(lastUpdatedLte string) ApiDcimSiteGroupsListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiDcimSiteGroupsListRequest) Q(q string) ApiDcimSiteGroupsListRequest {
	r.q = &q
	return r
}

func (r ApiDcimSiteGroupsListRequest) ParentId(parentId string) ApiDcimSiteGroupsListRequest {
	r.parentId = &parentId
	return r
}

func (r ApiDcimSiteGroupsListRequest) Parent(parent string) ApiDcimSiteGroupsListRequest {
	r.parent = &parent
	return r
}

func (r ApiDcimSiteGroupsListRequest) IdN(idN string) ApiDcimSiteGroupsListRequest {
	r.idN = &idN
	return r
}

func (r ApiDcimSiteGroupsListRequest) IdLte(idLte string) ApiDcimSiteGroupsListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiDcimSiteGroupsListRequest) IdLt(idLt string) ApiDcimSiteGroupsListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiDcimSiteGroupsListRequest) IdGte(idGte string) ApiDcimSiteGroupsListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiDcimSiteGroupsListRequest) IdGt(idGt string) ApiDcimSiteGroupsListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiDcimSiteGroupsListRequest) NameN(nameN string) ApiDcimSiteGroupsListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiDcimSiteGroupsListRequest) NameIc(nameIc string) ApiDcimSiteGroupsListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiDcimSiteGroupsListRequest) NameNic(nameNic string) ApiDcimSiteGroupsListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiDcimSiteGroupsListRequest) NameIew(nameIew string) ApiDcimSiteGroupsListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiDcimSiteGroupsListRequest) NameNiew(nameNiew string) ApiDcimSiteGroupsListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiDcimSiteGroupsListRequest) NameIsw(nameIsw string) ApiDcimSiteGroupsListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiDcimSiteGroupsListRequest) NameNisw(nameNisw string) ApiDcimSiteGroupsListRequest {
	r.nameNisw = &nameNisw
	return r
}

func (r ApiDcimSiteGroupsListRequest) NameIe(nameIe string) ApiDcimSiteGroupsListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiDcimSiteGroupsListRequest) NameNie(nameNie string) ApiDcimSiteGroupsListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiDcimSiteGroupsListRequest) NameEmpty(nameEmpty string) ApiDcimSiteGroupsListRequest {
	r.nameEmpty = &nameEmpty
	return r
}

func (r ApiDcimSiteGroupsListRequest) SlugN(slugN string) ApiDcimSiteGroupsListRequest {
	r.slugN = &slugN
	return r
}

func (r ApiDcimSiteGroupsListRequest) SlugIc(slugIc string) ApiDcimSiteGroupsListRequest {
	r.slugIc = &slugIc
	return r
}

func (r ApiDcimSiteGroupsListRequest) SlugNic(slugNic string) ApiDcimSiteGroupsListRequest {
	r.slugNic = &slugNic
	return r
}

func (r ApiDcimSiteGroupsListRequest) SlugIew(slugIew string) ApiDcimSiteGroupsListRequest {
	r.slugIew = &slugIew
	return r
}

func (r ApiDcimSiteGroupsListRequest) SlugNiew(slugNiew string) ApiDcimSiteGroupsListRequest {
	r.slugNiew = &slugNiew
	return r
}

func (r ApiDcimSiteGroupsListRequest) SlugIsw(slugIsw string) ApiDcimSiteGroupsListRequest {
	r.slugIsw = &slugIsw
	return r
}

func (r ApiDcimSiteGroupsListRequest) SlugNisw(slugNisw string) ApiDcimSiteGroupsListRequest {
	r.slugNisw = &slugNisw
	return r
}

func (r ApiDcimSiteGroupsListRequest) SlugIe(slugIe string) ApiDcimSiteGroupsListRequest {
	r.slugIe = &slugIe
	return r
}

func (r ApiDcimSiteGroupsListRequest) SlugNie(slugNie string) ApiDcimSiteGroupsListRequest {
	r.slugNie = &slugNie
	return r
}

func (r ApiDcimSiteGroupsListRequest) SlugEmpty(slugEmpty string) ApiDcimSiteGroupsListRequest {
	r.slugEmpty = &slugEmpty
	return r
}

func (r ApiDcimSiteGroupsListRequest) DescriptionN(descriptionN string) ApiDcimSiteGroupsListRequest {
	r.descriptionN = &descriptionN
	return r
}

func (r ApiDcimSiteGroupsListRequest) DescriptionIc(descriptionIc string) ApiDcimSiteGroupsListRequest {
	r.descriptionIc = &descriptionIc
	return r
}

func (r ApiDcimSiteGroupsListRequest) DescriptionNic(descriptionNic string) ApiDcimSiteGroupsListRequest {
	r.descriptionNic = &descriptionNic
	return r
}

func (r ApiDcimSiteGroupsListRequest) DescriptionIew(descriptionIew string) ApiDcimSiteGroupsListRequest {
	r.descriptionIew = &descriptionIew
	return r
}

func (r ApiDcimSiteGroupsListRequest) DescriptionNiew(descriptionNiew string) ApiDcimSiteGroupsListRequest {
	r.descriptionNiew = &descriptionNiew
	return r
}

func (r ApiDcimSiteGroupsListRequest) DescriptionIsw(descriptionIsw string) ApiDcimSiteGroupsListRequest {
	r.descriptionIsw = &descriptionIsw
	return r
}

func (r ApiDcimSiteGroupsListRequest) DescriptionNisw(descriptionNisw string) ApiDcimSiteGroupsListRequest {
	r.descriptionNisw = &descriptionNisw
	return r
}

func (r ApiDcimSiteGroupsListRequest) DescriptionIe(descriptionIe string) ApiDcimSiteGroupsListRequest {
	r.descriptionIe = &descriptionIe
	return r
}

func (r ApiDcimSiteGroupsListRequest) DescriptionNie(descriptionNie string) ApiDcimSiteGroupsListRequest {
	r.descriptionNie = &descriptionNie
	return r
}

func (r ApiDcimSiteGroupsListRequest) DescriptionEmpty(descriptionEmpty string) ApiDcimSiteGroupsListRequest {
	r.descriptionEmpty = &descriptionEmpty
	return r
}

func (r ApiDcimSiteGroupsListRequest) ParentIdN(parentIdN string) ApiDcimSiteGroupsListRequest {
	r.parentIdN = &parentIdN
	return r
}

func (r ApiDcimSiteGroupsListRequest) ParentN(parentN string) ApiDcimSiteGroupsListRequest {
	r.parentN = &parentN
	return r
}

// Number of results to return per page.
func (r ApiDcimSiteGroupsListRequest) Limit(limit int32) ApiDcimSiteGroupsListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiDcimSiteGroupsListRequest) Offset(offset int32) ApiDcimSiteGroupsListRequest {
	r.offset = &offset
	return r
}

func (r ApiDcimSiteGroupsListRequest) Execute() (*DcimSiteGroupsList200Response, *http.Response, error) {
	return r.ApiService.DcimSiteGroupsListExecute(r)
}

/*
DcimSiteGroupsList Method for DcimSiteGroupsList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimSiteGroupsListRequest
*/
func (a *DcimApiService) DcimSiteGroupsList(ctx context.Context) ApiDcimSiteGroupsListRequest {
	return ApiDcimSiteGroupsListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DcimSiteGroupsList200Response
func (a *DcimApiService) DcimSiteGroupsListExecute(r ApiDcimSiteGroupsListRequest) (*DcimSiteGroupsList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DcimSiteGroupsList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimSiteGroupsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/site-groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.slug != nil {
		localVarQueryParams.Add("slug", parameterToString(*r.slug, ""))
	}
	if r.description != nil {
		localVarQueryParams.Add("description", parameterToString(*r.description, ""))
	}
	if r.created != nil {
		localVarQueryParams.Add("created", parameterToString(*r.created, ""))
	}
	if r.createdGte != nil {
		localVarQueryParams.Add("created__gte", parameterToString(*r.createdGte, ""))
	}
	if r.createdLte != nil {
		localVarQueryParams.Add("created__lte", parameterToString(*r.createdLte, ""))
	}
	if r.lastUpdated != nil {
		localVarQueryParams.Add("last_updated", parameterToString(*r.lastUpdated, ""))
	}
	if r.lastUpdatedGte != nil {
		localVarQueryParams.Add("last_updated__gte", parameterToString(*r.lastUpdatedGte, ""))
	}
	if r.lastUpdatedLte != nil {
		localVarQueryParams.Add("last_updated__lte", parameterToString(*r.lastUpdatedLte, ""))
	}
	if r.q != nil {
		localVarQueryParams.Add("q", parameterToString(*r.q, ""))
	}
	if r.parentId != nil {
		localVarQueryParams.Add("parent_id", parameterToString(*r.parentId, ""))
	}
	if r.parent != nil {
		localVarQueryParams.Add("parent", parameterToString(*r.parent, ""))
	}
	if r.idN != nil {
		localVarQueryParams.Add("id__n", parameterToString(*r.idN, ""))
	}
	if r.idLte != nil {
		localVarQueryParams.Add("id__lte", parameterToString(*r.idLte, ""))
	}
	if r.idLt != nil {
		localVarQueryParams.Add("id__lt", parameterToString(*r.idLt, ""))
	}
	if r.idGte != nil {
		localVarQueryParams.Add("id__gte", parameterToString(*r.idGte, ""))
	}
	if r.idGt != nil {
		localVarQueryParams.Add("id__gt", parameterToString(*r.idGt, ""))
	}
	if r.nameN != nil {
		localVarQueryParams.Add("name__n", parameterToString(*r.nameN, ""))
	}
	if r.nameIc != nil {
		localVarQueryParams.Add("name__ic", parameterToString(*r.nameIc, ""))
	}
	if r.nameNic != nil {
		localVarQueryParams.Add("name__nic", parameterToString(*r.nameNic, ""))
	}
	if r.nameIew != nil {
		localVarQueryParams.Add("name__iew", parameterToString(*r.nameIew, ""))
	}
	if r.nameNiew != nil {
		localVarQueryParams.Add("name__niew", parameterToString(*r.nameNiew, ""))
	}
	if r.nameIsw != nil {
		localVarQueryParams.Add("name__isw", parameterToString(*r.nameIsw, ""))
	}
	if r.nameNisw != nil {
		localVarQueryParams.Add("name__nisw", parameterToString(*r.nameNisw, ""))
	}
	if r.nameIe != nil {
		localVarQueryParams.Add("name__ie", parameterToString(*r.nameIe, ""))
	}
	if r.nameNie != nil {
		localVarQueryParams.Add("name__nie", parameterToString(*r.nameNie, ""))
	}
	if r.nameEmpty != nil {
		localVarQueryParams.Add("name__empty", parameterToString(*r.nameEmpty, ""))
	}
	if r.slugN != nil {
		localVarQueryParams.Add("slug__n", parameterToString(*r.slugN, ""))
	}
	if r.slugIc != nil {
		localVarQueryParams.Add("slug__ic", parameterToString(*r.slugIc, ""))
	}
	if r.slugNic != nil {
		localVarQueryParams.Add("slug__nic", parameterToString(*r.slugNic, ""))
	}
	if r.slugIew != nil {
		localVarQueryParams.Add("slug__iew", parameterToString(*r.slugIew, ""))
	}
	if r.slugNiew != nil {
		localVarQueryParams.Add("slug__niew", parameterToString(*r.slugNiew, ""))
	}
	if r.slugIsw != nil {
		localVarQueryParams.Add("slug__isw", parameterToString(*r.slugIsw, ""))
	}
	if r.slugNisw != nil {
		localVarQueryParams.Add("slug__nisw", parameterToString(*r.slugNisw, ""))
	}
	if r.slugIe != nil {
		localVarQueryParams.Add("slug__ie", parameterToString(*r.slugIe, ""))
	}
	if r.slugNie != nil {
		localVarQueryParams.Add("slug__nie", parameterToString(*r.slugNie, ""))
	}
	if r.slugEmpty != nil {
		localVarQueryParams.Add("slug__empty", parameterToString(*r.slugEmpty, ""))
	}
	if r.descriptionN != nil {
		localVarQueryParams.Add("description__n", parameterToString(*r.descriptionN, ""))
	}
	if r.descriptionIc != nil {
		localVarQueryParams.Add("description__ic", parameterToString(*r.descriptionIc, ""))
	}
	if r.descriptionNic != nil {
		localVarQueryParams.Add("description__nic", parameterToString(*r.descriptionNic, ""))
	}
	if r.descriptionIew != nil {
		localVarQueryParams.Add("description__iew", parameterToString(*r.descriptionIew, ""))
	}
	if r.descriptionNiew != nil {
		localVarQueryParams.Add("description__niew", parameterToString(*r.descriptionNiew, ""))
	}
	if r.descriptionIsw != nil {
		localVarQueryParams.Add("description__isw", parameterToString(*r.descriptionIsw, ""))
	}
	if r.descriptionNisw != nil {
		localVarQueryParams.Add("description__nisw", parameterToString(*r.descriptionNisw, ""))
	}
	if r.descriptionIe != nil {
		localVarQueryParams.Add("description__ie", parameterToString(*r.descriptionIe, ""))
	}
	if r.descriptionNie != nil {
		localVarQueryParams.Add("description__nie", parameterToString(*r.descriptionNie, ""))
	}
	if r.descriptionEmpty != nil {
		localVarQueryParams.Add("description__empty", parameterToString(*r.descriptionEmpty, ""))
	}
	if r.parentIdN != nil {
		localVarQueryParams.Add("parent_id__n", parameterToString(*r.parentIdN, ""))
	}
	if r.parentN != nil {
		localVarQueryParams.Add("parent__n", parameterToString(*r.parentN, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimSiteGroupsPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
	data *WritableSiteGroup
}

func (r ApiDcimSiteGroupsPartialUpdateRequest) Data(data WritableSiteGroup) ApiDcimSiteGroupsPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimSiteGroupsPartialUpdateRequest) Execute() (*SiteGroup, *http.Response, error) {
	return r.ApiService.DcimSiteGroupsPartialUpdateExecute(r)
}

/*
DcimSiteGroupsPartialUpdate Method for DcimSiteGroupsPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this site group.
 @return ApiDcimSiteGroupsPartialUpdateRequest
*/
func (a *DcimApiService) DcimSiteGroupsPartialUpdate(ctx context.Context, id int32) ApiDcimSiteGroupsPartialUpdateRequest {
	return ApiDcimSiteGroupsPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return SiteGroup
func (a *DcimApiService) DcimSiteGroupsPartialUpdateExecute(r ApiDcimSiteGroupsPartialUpdateRequest) (*SiteGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SiteGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimSiteGroupsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/site-groups/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimSiteGroupsReadRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
}

func (r ApiDcimSiteGroupsReadRequest) Execute() (*SiteGroup, *http.Response, error) {
	return r.ApiService.DcimSiteGroupsReadExecute(r)
}

/*
DcimSiteGroupsRead Method for DcimSiteGroupsRead

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this site group.
 @return ApiDcimSiteGroupsReadRequest
*/
func (a *DcimApiService) DcimSiteGroupsRead(ctx context.Context, id int32) ApiDcimSiteGroupsReadRequest {
	return ApiDcimSiteGroupsReadRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return SiteGroup
func (a *DcimApiService) DcimSiteGroupsReadExecute(r ApiDcimSiteGroupsReadRequest) (*SiteGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SiteGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimSiteGroupsRead")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/site-groups/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimSiteGroupsUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
	data *WritableSiteGroup
}

func (r ApiDcimSiteGroupsUpdateRequest) Data(data WritableSiteGroup) ApiDcimSiteGroupsUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimSiteGroupsUpdateRequest) Execute() (*SiteGroup, *http.Response, error) {
	return r.ApiService.DcimSiteGroupsUpdateExecute(r)
}

/*
DcimSiteGroupsUpdate Method for DcimSiteGroupsUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this site group.
 @return ApiDcimSiteGroupsUpdateRequest
*/
func (a *DcimApiService) DcimSiteGroupsUpdate(ctx context.Context, id int32) ApiDcimSiteGroupsUpdateRequest {
	return ApiDcimSiteGroupsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return SiteGroup
func (a *DcimApiService) DcimSiteGroupsUpdateExecute(r ApiDcimSiteGroupsUpdateRequest) (*SiteGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SiteGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimSiteGroupsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/site-groups/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimSitesBulkDeleteRequest struct {
	ctx context.Context
	ApiService *DcimApiService
}

func (r ApiDcimSitesBulkDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimSitesBulkDeleteExecute(r)
}

/*
DcimSitesBulkDelete Method for DcimSitesBulkDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimSitesBulkDeleteRequest
*/
func (a *DcimApiService) DcimSitesBulkDelete(ctx context.Context) ApiDcimSitesBulkDeleteRequest {
	return ApiDcimSitesBulkDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DcimApiService) DcimSitesBulkDeleteExecute(r ApiDcimSitesBulkDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimSitesBulkDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/sites/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimSitesBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	data *WritableSite
}

func (r ApiDcimSitesBulkPartialUpdateRequest) Data(data WritableSite) ApiDcimSitesBulkPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimSitesBulkPartialUpdateRequest) Execute() (*Site, *http.Response, error) {
	return r.ApiService.DcimSitesBulkPartialUpdateExecute(r)
}

/*
DcimSitesBulkPartialUpdate Method for DcimSitesBulkPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimSitesBulkPartialUpdateRequest
*/
func (a *DcimApiService) DcimSitesBulkPartialUpdate(ctx context.Context) ApiDcimSitesBulkPartialUpdateRequest {
	return ApiDcimSitesBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Site
func (a *DcimApiService) DcimSitesBulkPartialUpdateExecute(r ApiDcimSitesBulkPartialUpdateRequest) (*Site, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Site
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimSitesBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/sites/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimSitesBulkUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	data *WritableSite
}

func (r ApiDcimSitesBulkUpdateRequest) Data(data WritableSite) ApiDcimSitesBulkUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimSitesBulkUpdateRequest) Execute() (*Site, *http.Response, error) {
	return r.ApiService.DcimSitesBulkUpdateExecute(r)
}

/*
DcimSitesBulkUpdate Method for DcimSitesBulkUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimSitesBulkUpdateRequest
*/
func (a *DcimApiService) DcimSitesBulkUpdate(ctx context.Context) ApiDcimSitesBulkUpdateRequest {
	return ApiDcimSitesBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Site
func (a *DcimApiService) DcimSitesBulkUpdateExecute(r ApiDcimSitesBulkUpdateRequest) (*Site, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Site
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimSitesBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/sites/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimSitesCreateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	data *WritableSite
}

func (r ApiDcimSitesCreateRequest) Data(data WritableSite) ApiDcimSitesCreateRequest {
	r.data = &data
	return r
}

func (r ApiDcimSitesCreateRequest) Execute() (*Site, *http.Response, error) {
	return r.ApiService.DcimSitesCreateExecute(r)
}

/*
DcimSitesCreate Method for DcimSitesCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimSitesCreateRequest
*/
func (a *DcimApiService) DcimSitesCreate(ctx context.Context) ApiDcimSitesCreateRequest {
	return ApiDcimSitesCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Site
func (a *DcimApiService) DcimSitesCreateExecute(r ApiDcimSitesCreateRequest) (*Site, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Site
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimSitesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/sites/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimSitesDeleteRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
}

func (r ApiDcimSitesDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimSitesDeleteExecute(r)
}

/*
DcimSitesDelete Method for DcimSitesDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this site.
 @return ApiDcimSitesDeleteRequest
*/
func (a *DcimApiService) DcimSitesDelete(ctx context.Context, id int32) ApiDcimSitesDeleteRequest {
	return ApiDcimSitesDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DcimApiService) DcimSitesDeleteExecute(r ApiDcimSitesDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimSitesDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/sites/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimSitesListRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id *string
	name *string
	slug *string
	facility *string
	asn *string
	latitude *string
	longitude *string
	contactName *string
	contactPhone *string
	contactEmail *string
	created *string
	createdGte *string
	createdLte *string
	lastUpdated *string
	lastUpdatedGte *string
	lastUpdatedLte *string
	tenantGroupId *string
	tenantGroup *string
	tenantId *string
	tenant *string
	q *string
	status *string
	regionId *string
	region *string
	groupId *string
	group *string
	tag *string
	idN *string
	idLte *string
	idLt *string
	idGte *string
	idGt *string
	nameN *string
	nameIc *string
	nameNic *string
	nameIew *string
	nameNiew *string
	nameIsw *string
	nameNisw *string
	nameIe *string
	nameNie *string
	nameEmpty *string
	slugN *string
	slugIc *string
	slugNic *string
	slugIew *string
	slugNiew *string
	slugIsw *string
	slugNisw *string
	slugIe *string
	slugNie *string
	slugEmpty *string
	facilityN *string
	facilityIc *string
	facilityNic *string
	facilityIew *string
	facilityNiew *string
	facilityIsw *string
	facilityNisw *string
	facilityIe *string
	facilityNie *string
	facilityEmpty *string
	asnN *string
	asnLte *string
	asnLt *string
	asnGte *string
	asnGt *string
	latitudeN *string
	latitudeLte *string
	latitudeLt *string
	latitudeGte *string
	latitudeGt *string
	longitudeN *string
	longitudeLte *string
	longitudeLt *string
	longitudeGte *string
	longitudeGt *string
	contactNameN *string
	contactNameIc *string
	contactNameNic *string
	contactNameIew *string
	contactNameNiew *string
	contactNameIsw *string
	contactNameNisw *string
	contactNameIe *string
	contactNameNie *string
	contactNameEmpty *string
	contactPhoneN *string
	contactPhoneIc *string
	contactPhoneNic *string
	contactPhoneIew *string
	contactPhoneNiew *string
	contactPhoneIsw *string
	contactPhoneNisw *string
	contactPhoneIe *string
	contactPhoneNie *string
	contactPhoneEmpty *string
	contactEmailN *string
	contactEmailIc *string
	contactEmailNic *string
	contactEmailIew *string
	contactEmailNiew *string
	contactEmailIsw *string
	contactEmailNisw *string
	contactEmailIe *string
	contactEmailNie *string
	contactEmailEmpty *string
	tenantGroupIdN *string
	tenantGroupN *string
	tenantIdN *string
	tenantN *string
	statusN *string
	regionIdN *string
	regionN *string
	groupIdN *string
	groupN *string
	tagN *string
	limit *int32
	offset *int32
}

func (r ApiDcimSitesListRequest) Id(id string) ApiDcimSitesListRequest {
	r.id = &id
	return r
}

func (r ApiDcimSitesListRequest) Name(name string) ApiDcimSitesListRequest {
	r.name = &name
	return r
}

func (r ApiDcimSitesListRequest) Slug(slug string) ApiDcimSitesListRequest {
	r.slug = &slug
	return r
}

func (r ApiDcimSitesListRequest) Facility(facility string) ApiDcimSitesListRequest {
	r.facility = &facility
	return r
}

func (r ApiDcimSitesListRequest) Asn(asn string) ApiDcimSitesListRequest {
	r.asn = &asn
	return r
}

func (r ApiDcimSitesListRequest) Latitude(latitude string) ApiDcimSitesListRequest {
	r.latitude = &latitude
	return r
}

func (r ApiDcimSitesListRequest) Longitude(longitude string) ApiDcimSitesListRequest {
	r.longitude = &longitude
	return r
}

func (r ApiDcimSitesListRequest) ContactName(contactName string) ApiDcimSitesListRequest {
	r.contactName = &contactName
	return r
}

func (r ApiDcimSitesListRequest) ContactPhone(contactPhone string) ApiDcimSitesListRequest {
	r.contactPhone = &contactPhone
	return r
}

func (r ApiDcimSitesListRequest) ContactEmail(contactEmail string) ApiDcimSitesListRequest {
	r.contactEmail = &contactEmail
	return r
}

func (r ApiDcimSitesListRequest) Created(created string) ApiDcimSitesListRequest {
	r.created = &created
	return r
}

func (r ApiDcimSitesListRequest) CreatedGte(createdGte string) ApiDcimSitesListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiDcimSitesListRequest) CreatedLte(createdLte string) ApiDcimSitesListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiDcimSitesListRequest) LastUpdated(lastUpdated string) ApiDcimSitesListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiDcimSitesListRequest) LastUpdatedGte(lastUpdatedGte string) ApiDcimSitesListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiDcimSitesListRequest) LastUpdatedLte(lastUpdatedLte string) ApiDcimSitesListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiDcimSitesListRequest) TenantGroupId(tenantGroupId string) ApiDcimSitesListRequest {
	r.tenantGroupId = &tenantGroupId
	return r
}

func (r ApiDcimSitesListRequest) TenantGroup(tenantGroup string) ApiDcimSitesListRequest {
	r.tenantGroup = &tenantGroup
	return r
}

func (r ApiDcimSitesListRequest) TenantId(tenantId string) ApiDcimSitesListRequest {
	r.tenantId = &tenantId
	return r
}

func (r ApiDcimSitesListRequest) Tenant(tenant string) ApiDcimSitesListRequest {
	r.tenant = &tenant
	return r
}

func (r ApiDcimSitesListRequest) Q(q string) ApiDcimSitesListRequest {
	r.q = &q
	return r
}

func (r ApiDcimSitesListRequest) Status(status string) ApiDcimSitesListRequest {
	r.status = &status
	return r
}

func (r ApiDcimSitesListRequest) RegionId(regionId string) ApiDcimSitesListRequest {
	r.regionId = &regionId
	return r
}

func (r ApiDcimSitesListRequest) Region(region string) ApiDcimSitesListRequest {
	r.region = &region
	return r
}

func (r ApiDcimSitesListRequest) GroupId(groupId string) ApiDcimSitesListRequest {
	r.groupId = &groupId
	return r
}

func (r ApiDcimSitesListRequest) Group(group string) ApiDcimSitesListRequest {
	r.group = &group
	return r
}

func (r ApiDcimSitesListRequest) Tag(tag string) ApiDcimSitesListRequest {
	r.tag = &tag
	return r
}

func (r ApiDcimSitesListRequest) IdN(idN string) ApiDcimSitesListRequest {
	r.idN = &idN
	return r
}

func (r ApiDcimSitesListRequest) IdLte(idLte string) ApiDcimSitesListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiDcimSitesListRequest) IdLt(idLt string) ApiDcimSitesListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiDcimSitesListRequest) IdGte(idGte string) ApiDcimSitesListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiDcimSitesListRequest) IdGt(idGt string) ApiDcimSitesListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiDcimSitesListRequest) NameN(nameN string) ApiDcimSitesListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiDcimSitesListRequest) NameIc(nameIc string) ApiDcimSitesListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiDcimSitesListRequest) NameNic(nameNic string) ApiDcimSitesListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiDcimSitesListRequest) NameIew(nameIew string) ApiDcimSitesListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiDcimSitesListRequest) NameNiew(nameNiew string) ApiDcimSitesListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiDcimSitesListRequest) NameIsw(nameIsw string) ApiDcimSitesListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiDcimSitesListRequest) NameNisw(nameNisw string) ApiDcimSitesListRequest {
	r.nameNisw = &nameNisw
	return r
}

func (r ApiDcimSitesListRequest) NameIe(nameIe string) ApiDcimSitesListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiDcimSitesListRequest) NameNie(nameNie string) ApiDcimSitesListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiDcimSitesListRequest) NameEmpty(nameEmpty string) ApiDcimSitesListRequest {
	r.nameEmpty = &nameEmpty
	return r
}

func (r ApiDcimSitesListRequest) SlugN(slugN string) ApiDcimSitesListRequest {
	r.slugN = &slugN
	return r
}

func (r ApiDcimSitesListRequest) SlugIc(slugIc string) ApiDcimSitesListRequest {
	r.slugIc = &slugIc
	return r
}

func (r ApiDcimSitesListRequest) SlugNic(slugNic string) ApiDcimSitesListRequest {
	r.slugNic = &slugNic
	return r
}

func (r ApiDcimSitesListRequest) SlugIew(slugIew string) ApiDcimSitesListRequest {
	r.slugIew = &slugIew
	return r
}

func (r ApiDcimSitesListRequest) SlugNiew(slugNiew string) ApiDcimSitesListRequest {
	r.slugNiew = &slugNiew
	return r
}

func (r ApiDcimSitesListRequest) SlugIsw(slugIsw string) ApiDcimSitesListRequest {
	r.slugIsw = &slugIsw
	return r
}

func (r ApiDcimSitesListRequest) SlugNisw(slugNisw string) ApiDcimSitesListRequest {
	r.slugNisw = &slugNisw
	return r
}

func (r ApiDcimSitesListRequest) SlugIe(slugIe string) ApiDcimSitesListRequest {
	r.slugIe = &slugIe
	return r
}

func (r ApiDcimSitesListRequest) SlugNie(slugNie string) ApiDcimSitesListRequest {
	r.slugNie = &slugNie
	return r
}

func (r ApiDcimSitesListRequest) SlugEmpty(slugEmpty string) ApiDcimSitesListRequest {
	r.slugEmpty = &slugEmpty
	return r
}

func (r ApiDcimSitesListRequest) FacilityN(facilityN string) ApiDcimSitesListRequest {
	r.facilityN = &facilityN
	return r
}

func (r ApiDcimSitesListRequest) FacilityIc(facilityIc string) ApiDcimSitesListRequest {
	r.facilityIc = &facilityIc
	return r
}

func (r ApiDcimSitesListRequest) FacilityNic(facilityNic string) ApiDcimSitesListRequest {
	r.facilityNic = &facilityNic
	return r
}

func (r ApiDcimSitesListRequest) FacilityIew(facilityIew string) ApiDcimSitesListRequest {
	r.facilityIew = &facilityIew
	return r
}

func (r ApiDcimSitesListRequest) FacilityNiew(facilityNiew string) ApiDcimSitesListRequest {
	r.facilityNiew = &facilityNiew
	return r
}

func (r ApiDcimSitesListRequest) FacilityIsw(facilityIsw string) ApiDcimSitesListRequest {
	r.facilityIsw = &facilityIsw
	return r
}

func (r ApiDcimSitesListRequest) FacilityNisw(facilityNisw string) ApiDcimSitesListRequest {
	r.facilityNisw = &facilityNisw
	return r
}

func (r ApiDcimSitesListRequest) FacilityIe(facilityIe string) ApiDcimSitesListRequest {
	r.facilityIe = &facilityIe
	return r
}

func (r ApiDcimSitesListRequest) FacilityNie(facilityNie string) ApiDcimSitesListRequest {
	r.facilityNie = &facilityNie
	return r
}

func (r ApiDcimSitesListRequest) FacilityEmpty(facilityEmpty string) ApiDcimSitesListRequest {
	r.facilityEmpty = &facilityEmpty
	return r
}

func (r ApiDcimSitesListRequest) AsnN(asnN string) ApiDcimSitesListRequest {
	r.asnN = &asnN
	return r
}

func (r ApiDcimSitesListRequest) AsnLte(asnLte string) ApiDcimSitesListRequest {
	r.asnLte = &asnLte
	return r
}

func (r ApiDcimSitesListRequest) AsnLt(asnLt string) ApiDcimSitesListRequest {
	r.asnLt = &asnLt
	return r
}

func (r ApiDcimSitesListRequest) AsnGte(asnGte string) ApiDcimSitesListRequest {
	r.asnGte = &asnGte
	return r
}

func (r ApiDcimSitesListRequest) AsnGt(asnGt string) ApiDcimSitesListRequest {
	r.asnGt = &asnGt
	return r
}

func (r ApiDcimSitesListRequest) LatitudeN(latitudeN string) ApiDcimSitesListRequest {
	r.latitudeN = &latitudeN
	return r
}

func (r ApiDcimSitesListRequest) LatitudeLte(latitudeLte string) ApiDcimSitesListRequest {
	r.latitudeLte = &latitudeLte
	return r
}

func (r ApiDcimSitesListRequest) LatitudeLt(latitudeLt string) ApiDcimSitesListRequest {
	r.latitudeLt = &latitudeLt
	return r
}

func (r ApiDcimSitesListRequest) LatitudeGte(latitudeGte string) ApiDcimSitesListRequest {
	r.latitudeGte = &latitudeGte
	return r
}

func (r ApiDcimSitesListRequest) LatitudeGt(latitudeGt string) ApiDcimSitesListRequest {
	r.latitudeGt = &latitudeGt
	return r
}

func (r ApiDcimSitesListRequest) LongitudeN(longitudeN string) ApiDcimSitesListRequest {
	r.longitudeN = &longitudeN
	return r
}

func (r ApiDcimSitesListRequest) LongitudeLte(longitudeLte string) ApiDcimSitesListRequest {
	r.longitudeLte = &longitudeLte
	return r
}

func (r ApiDcimSitesListRequest) LongitudeLt(longitudeLt string) ApiDcimSitesListRequest {
	r.longitudeLt = &longitudeLt
	return r
}

func (r ApiDcimSitesListRequest) LongitudeGte(longitudeGte string) ApiDcimSitesListRequest {
	r.longitudeGte = &longitudeGte
	return r
}

func (r ApiDcimSitesListRequest) LongitudeGt(longitudeGt string) ApiDcimSitesListRequest {
	r.longitudeGt = &longitudeGt
	return r
}

func (r ApiDcimSitesListRequest) ContactNameN(contactNameN string) ApiDcimSitesListRequest {
	r.contactNameN = &contactNameN
	return r
}

func (r ApiDcimSitesListRequest) ContactNameIc(contactNameIc string) ApiDcimSitesListRequest {
	r.contactNameIc = &contactNameIc
	return r
}

func (r ApiDcimSitesListRequest) ContactNameNic(contactNameNic string) ApiDcimSitesListRequest {
	r.contactNameNic = &contactNameNic
	return r
}

func (r ApiDcimSitesListRequest) ContactNameIew(contactNameIew string) ApiDcimSitesListRequest {
	r.contactNameIew = &contactNameIew
	return r
}

func (r ApiDcimSitesListRequest) ContactNameNiew(contactNameNiew string) ApiDcimSitesListRequest {
	r.contactNameNiew = &contactNameNiew
	return r
}

func (r ApiDcimSitesListRequest) ContactNameIsw(contactNameIsw string) ApiDcimSitesListRequest {
	r.contactNameIsw = &contactNameIsw
	return r
}

func (r ApiDcimSitesListRequest) ContactNameNisw(contactNameNisw string) ApiDcimSitesListRequest {
	r.contactNameNisw = &contactNameNisw
	return r
}

func (r ApiDcimSitesListRequest) ContactNameIe(contactNameIe string) ApiDcimSitesListRequest {
	r.contactNameIe = &contactNameIe
	return r
}

func (r ApiDcimSitesListRequest) ContactNameNie(contactNameNie string) ApiDcimSitesListRequest {
	r.contactNameNie = &contactNameNie
	return r
}

func (r ApiDcimSitesListRequest) ContactNameEmpty(contactNameEmpty string) ApiDcimSitesListRequest {
	r.contactNameEmpty = &contactNameEmpty
	return r
}

func (r ApiDcimSitesListRequest) ContactPhoneN(contactPhoneN string) ApiDcimSitesListRequest {
	r.contactPhoneN = &contactPhoneN
	return r
}

func (r ApiDcimSitesListRequest) ContactPhoneIc(contactPhoneIc string) ApiDcimSitesListRequest {
	r.contactPhoneIc = &contactPhoneIc
	return r
}

func (r ApiDcimSitesListRequest) ContactPhoneNic(contactPhoneNic string) ApiDcimSitesListRequest {
	r.contactPhoneNic = &contactPhoneNic
	return r
}

func (r ApiDcimSitesListRequest) ContactPhoneIew(contactPhoneIew string) ApiDcimSitesListRequest {
	r.contactPhoneIew = &contactPhoneIew
	return r
}

func (r ApiDcimSitesListRequest) ContactPhoneNiew(contactPhoneNiew string) ApiDcimSitesListRequest {
	r.contactPhoneNiew = &contactPhoneNiew
	return r
}

func (r ApiDcimSitesListRequest) ContactPhoneIsw(contactPhoneIsw string) ApiDcimSitesListRequest {
	r.contactPhoneIsw = &contactPhoneIsw
	return r
}

func (r ApiDcimSitesListRequest) ContactPhoneNisw(contactPhoneNisw string) ApiDcimSitesListRequest {
	r.contactPhoneNisw = &contactPhoneNisw
	return r
}

func (r ApiDcimSitesListRequest) ContactPhoneIe(contactPhoneIe string) ApiDcimSitesListRequest {
	r.contactPhoneIe = &contactPhoneIe
	return r
}

func (r ApiDcimSitesListRequest) ContactPhoneNie(contactPhoneNie string) ApiDcimSitesListRequest {
	r.contactPhoneNie = &contactPhoneNie
	return r
}

func (r ApiDcimSitesListRequest) ContactPhoneEmpty(contactPhoneEmpty string) ApiDcimSitesListRequest {
	r.contactPhoneEmpty = &contactPhoneEmpty
	return r
}

func (r ApiDcimSitesListRequest) ContactEmailN(contactEmailN string) ApiDcimSitesListRequest {
	r.contactEmailN = &contactEmailN
	return r
}

func (r ApiDcimSitesListRequest) ContactEmailIc(contactEmailIc string) ApiDcimSitesListRequest {
	r.contactEmailIc = &contactEmailIc
	return r
}

func (r ApiDcimSitesListRequest) ContactEmailNic(contactEmailNic string) ApiDcimSitesListRequest {
	r.contactEmailNic = &contactEmailNic
	return r
}

func (r ApiDcimSitesListRequest) ContactEmailIew(contactEmailIew string) ApiDcimSitesListRequest {
	r.contactEmailIew = &contactEmailIew
	return r
}

func (r ApiDcimSitesListRequest) ContactEmailNiew(contactEmailNiew string) ApiDcimSitesListRequest {
	r.contactEmailNiew = &contactEmailNiew
	return r
}

func (r ApiDcimSitesListRequest) ContactEmailIsw(contactEmailIsw string) ApiDcimSitesListRequest {
	r.contactEmailIsw = &contactEmailIsw
	return r
}

func (r ApiDcimSitesListRequest) ContactEmailNisw(contactEmailNisw string) ApiDcimSitesListRequest {
	r.contactEmailNisw = &contactEmailNisw
	return r
}

func (r ApiDcimSitesListRequest) ContactEmailIe(contactEmailIe string) ApiDcimSitesListRequest {
	r.contactEmailIe = &contactEmailIe
	return r
}

func (r ApiDcimSitesListRequest) ContactEmailNie(contactEmailNie string) ApiDcimSitesListRequest {
	r.contactEmailNie = &contactEmailNie
	return r
}

func (r ApiDcimSitesListRequest) ContactEmailEmpty(contactEmailEmpty string) ApiDcimSitesListRequest {
	r.contactEmailEmpty = &contactEmailEmpty
	return r
}

func (r ApiDcimSitesListRequest) TenantGroupIdN(tenantGroupIdN string) ApiDcimSitesListRequest {
	r.tenantGroupIdN = &tenantGroupIdN
	return r
}

func (r ApiDcimSitesListRequest) TenantGroupN(tenantGroupN string) ApiDcimSitesListRequest {
	r.tenantGroupN = &tenantGroupN
	return r
}

func (r ApiDcimSitesListRequest) TenantIdN(tenantIdN string) ApiDcimSitesListRequest {
	r.tenantIdN = &tenantIdN
	return r
}

func (r ApiDcimSitesListRequest) TenantN(tenantN string) ApiDcimSitesListRequest {
	r.tenantN = &tenantN
	return r
}

func (r ApiDcimSitesListRequest) StatusN(statusN string) ApiDcimSitesListRequest {
	r.statusN = &statusN
	return r
}

func (r ApiDcimSitesListRequest) RegionIdN(regionIdN string) ApiDcimSitesListRequest {
	r.regionIdN = &regionIdN
	return r
}

func (r ApiDcimSitesListRequest) RegionN(regionN string) ApiDcimSitesListRequest {
	r.regionN = &regionN
	return r
}

func (r ApiDcimSitesListRequest) GroupIdN(groupIdN string) ApiDcimSitesListRequest {
	r.groupIdN = &groupIdN
	return r
}

func (r ApiDcimSitesListRequest) GroupN(groupN string) ApiDcimSitesListRequest {
	r.groupN = &groupN
	return r
}

func (r ApiDcimSitesListRequest) TagN(tagN string) ApiDcimSitesListRequest {
	r.tagN = &tagN
	return r
}

// Number of results to return per page.
func (r ApiDcimSitesListRequest) Limit(limit int32) ApiDcimSitesListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiDcimSitesListRequest) Offset(offset int32) ApiDcimSitesListRequest {
	r.offset = &offset
	return r
}

func (r ApiDcimSitesListRequest) Execute() (*DcimSitesList200Response, *http.Response, error) {
	return r.ApiService.DcimSitesListExecute(r)
}

/*
DcimSitesList Method for DcimSitesList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimSitesListRequest
*/
func (a *DcimApiService) DcimSitesList(ctx context.Context) ApiDcimSitesListRequest {
	return ApiDcimSitesListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DcimSitesList200Response
func (a *DcimApiService) DcimSitesListExecute(r ApiDcimSitesListRequest) (*DcimSitesList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DcimSitesList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimSitesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/sites/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.slug != nil {
		localVarQueryParams.Add("slug", parameterToString(*r.slug, ""))
	}
	if r.facility != nil {
		localVarQueryParams.Add("facility", parameterToString(*r.facility, ""))
	}
	if r.asn != nil {
		localVarQueryParams.Add("asn", parameterToString(*r.asn, ""))
	}
	if r.latitude != nil {
		localVarQueryParams.Add("latitude", parameterToString(*r.latitude, ""))
	}
	if r.longitude != nil {
		localVarQueryParams.Add("longitude", parameterToString(*r.longitude, ""))
	}
	if r.contactName != nil {
		localVarQueryParams.Add("contact_name", parameterToString(*r.contactName, ""))
	}
	if r.contactPhone != nil {
		localVarQueryParams.Add("contact_phone", parameterToString(*r.contactPhone, ""))
	}
	if r.contactEmail != nil {
		localVarQueryParams.Add("contact_email", parameterToString(*r.contactEmail, ""))
	}
	if r.created != nil {
		localVarQueryParams.Add("created", parameterToString(*r.created, ""))
	}
	if r.createdGte != nil {
		localVarQueryParams.Add("created__gte", parameterToString(*r.createdGte, ""))
	}
	if r.createdLte != nil {
		localVarQueryParams.Add("created__lte", parameterToString(*r.createdLte, ""))
	}
	if r.lastUpdated != nil {
		localVarQueryParams.Add("last_updated", parameterToString(*r.lastUpdated, ""))
	}
	if r.lastUpdatedGte != nil {
		localVarQueryParams.Add("last_updated__gte", parameterToString(*r.lastUpdatedGte, ""))
	}
	if r.lastUpdatedLte != nil {
		localVarQueryParams.Add("last_updated__lte", parameterToString(*r.lastUpdatedLte, ""))
	}
	if r.tenantGroupId != nil {
		localVarQueryParams.Add("tenant_group_id", parameterToString(*r.tenantGroupId, ""))
	}
	if r.tenantGroup != nil {
		localVarQueryParams.Add("tenant_group", parameterToString(*r.tenantGroup, ""))
	}
	if r.tenantId != nil {
		localVarQueryParams.Add("tenant_id", parameterToString(*r.tenantId, ""))
	}
	if r.tenant != nil {
		localVarQueryParams.Add("tenant", parameterToString(*r.tenant, ""))
	}
	if r.q != nil {
		localVarQueryParams.Add("q", parameterToString(*r.q, ""))
	}
	if r.status != nil {
		localVarQueryParams.Add("status", parameterToString(*r.status, ""))
	}
	if r.regionId != nil {
		localVarQueryParams.Add("region_id", parameterToString(*r.regionId, ""))
	}
	if r.region != nil {
		localVarQueryParams.Add("region", parameterToString(*r.region, ""))
	}
	if r.groupId != nil {
		localVarQueryParams.Add("group_id", parameterToString(*r.groupId, ""))
	}
	if r.group != nil {
		localVarQueryParams.Add("group", parameterToString(*r.group, ""))
	}
	if r.tag != nil {
		localVarQueryParams.Add("tag", parameterToString(*r.tag, ""))
	}
	if r.idN != nil {
		localVarQueryParams.Add("id__n", parameterToString(*r.idN, ""))
	}
	if r.idLte != nil {
		localVarQueryParams.Add("id__lte", parameterToString(*r.idLte, ""))
	}
	if r.idLt != nil {
		localVarQueryParams.Add("id__lt", parameterToString(*r.idLt, ""))
	}
	if r.idGte != nil {
		localVarQueryParams.Add("id__gte", parameterToString(*r.idGte, ""))
	}
	if r.idGt != nil {
		localVarQueryParams.Add("id__gt", parameterToString(*r.idGt, ""))
	}
	if r.nameN != nil {
		localVarQueryParams.Add("name__n", parameterToString(*r.nameN, ""))
	}
	if r.nameIc != nil {
		localVarQueryParams.Add("name__ic", parameterToString(*r.nameIc, ""))
	}
	if r.nameNic != nil {
		localVarQueryParams.Add("name__nic", parameterToString(*r.nameNic, ""))
	}
	if r.nameIew != nil {
		localVarQueryParams.Add("name__iew", parameterToString(*r.nameIew, ""))
	}
	if r.nameNiew != nil {
		localVarQueryParams.Add("name__niew", parameterToString(*r.nameNiew, ""))
	}
	if r.nameIsw != nil {
		localVarQueryParams.Add("name__isw", parameterToString(*r.nameIsw, ""))
	}
	if r.nameNisw != nil {
		localVarQueryParams.Add("name__nisw", parameterToString(*r.nameNisw, ""))
	}
	if r.nameIe != nil {
		localVarQueryParams.Add("name__ie", parameterToString(*r.nameIe, ""))
	}
	if r.nameNie != nil {
		localVarQueryParams.Add("name__nie", parameterToString(*r.nameNie, ""))
	}
	if r.nameEmpty != nil {
		localVarQueryParams.Add("name__empty", parameterToString(*r.nameEmpty, ""))
	}
	if r.slugN != nil {
		localVarQueryParams.Add("slug__n", parameterToString(*r.slugN, ""))
	}
	if r.slugIc != nil {
		localVarQueryParams.Add("slug__ic", parameterToString(*r.slugIc, ""))
	}
	if r.slugNic != nil {
		localVarQueryParams.Add("slug__nic", parameterToString(*r.slugNic, ""))
	}
	if r.slugIew != nil {
		localVarQueryParams.Add("slug__iew", parameterToString(*r.slugIew, ""))
	}
	if r.slugNiew != nil {
		localVarQueryParams.Add("slug__niew", parameterToString(*r.slugNiew, ""))
	}
	if r.slugIsw != nil {
		localVarQueryParams.Add("slug__isw", parameterToString(*r.slugIsw, ""))
	}
	if r.slugNisw != nil {
		localVarQueryParams.Add("slug__nisw", parameterToString(*r.slugNisw, ""))
	}
	if r.slugIe != nil {
		localVarQueryParams.Add("slug__ie", parameterToString(*r.slugIe, ""))
	}
	if r.slugNie != nil {
		localVarQueryParams.Add("slug__nie", parameterToString(*r.slugNie, ""))
	}
	if r.slugEmpty != nil {
		localVarQueryParams.Add("slug__empty", parameterToString(*r.slugEmpty, ""))
	}
	if r.facilityN != nil {
		localVarQueryParams.Add("facility__n", parameterToString(*r.facilityN, ""))
	}
	if r.facilityIc != nil {
		localVarQueryParams.Add("facility__ic", parameterToString(*r.facilityIc, ""))
	}
	if r.facilityNic != nil {
		localVarQueryParams.Add("facility__nic", parameterToString(*r.facilityNic, ""))
	}
	if r.facilityIew != nil {
		localVarQueryParams.Add("facility__iew", parameterToString(*r.facilityIew, ""))
	}
	if r.facilityNiew != nil {
		localVarQueryParams.Add("facility__niew", parameterToString(*r.facilityNiew, ""))
	}
	if r.facilityIsw != nil {
		localVarQueryParams.Add("facility__isw", parameterToString(*r.facilityIsw, ""))
	}
	if r.facilityNisw != nil {
		localVarQueryParams.Add("facility__nisw", parameterToString(*r.facilityNisw, ""))
	}
	if r.facilityIe != nil {
		localVarQueryParams.Add("facility__ie", parameterToString(*r.facilityIe, ""))
	}
	if r.facilityNie != nil {
		localVarQueryParams.Add("facility__nie", parameterToString(*r.facilityNie, ""))
	}
	if r.facilityEmpty != nil {
		localVarQueryParams.Add("facility__empty", parameterToString(*r.facilityEmpty, ""))
	}
	if r.asnN != nil {
		localVarQueryParams.Add("asn__n", parameterToString(*r.asnN, ""))
	}
	if r.asnLte != nil {
		localVarQueryParams.Add("asn__lte", parameterToString(*r.asnLte, ""))
	}
	if r.asnLt != nil {
		localVarQueryParams.Add("asn__lt", parameterToString(*r.asnLt, ""))
	}
	if r.asnGte != nil {
		localVarQueryParams.Add("asn__gte", parameterToString(*r.asnGte, ""))
	}
	if r.asnGt != nil {
		localVarQueryParams.Add("asn__gt", parameterToString(*r.asnGt, ""))
	}
	if r.latitudeN != nil {
		localVarQueryParams.Add("latitude__n", parameterToString(*r.latitudeN, ""))
	}
	if r.latitudeLte != nil {
		localVarQueryParams.Add("latitude__lte", parameterToString(*r.latitudeLte, ""))
	}
	if r.latitudeLt != nil {
		localVarQueryParams.Add("latitude__lt", parameterToString(*r.latitudeLt, ""))
	}
	if r.latitudeGte != nil {
		localVarQueryParams.Add("latitude__gte", parameterToString(*r.latitudeGte, ""))
	}
	if r.latitudeGt != nil {
		localVarQueryParams.Add("latitude__gt", parameterToString(*r.latitudeGt, ""))
	}
	if r.longitudeN != nil {
		localVarQueryParams.Add("longitude__n", parameterToString(*r.longitudeN, ""))
	}
	if r.longitudeLte != nil {
		localVarQueryParams.Add("longitude__lte", parameterToString(*r.longitudeLte, ""))
	}
	if r.longitudeLt != nil {
		localVarQueryParams.Add("longitude__lt", parameterToString(*r.longitudeLt, ""))
	}
	if r.longitudeGte != nil {
		localVarQueryParams.Add("longitude__gte", parameterToString(*r.longitudeGte, ""))
	}
	if r.longitudeGt != nil {
		localVarQueryParams.Add("longitude__gt", parameterToString(*r.longitudeGt, ""))
	}
	if r.contactNameN != nil {
		localVarQueryParams.Add("contact_name__n", parameterToString(*r.contactNameN, ""))
	}
	if r.contactNameIc != nil {
		localVarQueryParams.Add("contact_name__ic", parameterToString(*r.contactNameIc, ""))
	}
	if r.contactNameNic != nil {
		localVarQueryParams.Add("contact_name__nic", parameterToString(*r.contactNameNic, ""))
	}
	if r.contactNameIew != nil {
		localVarQueryParams.Add("contact_name__iew", parameterToString(*r.contactNameIew, ""))
	}
	if r.contactNameNiew != nil {
		localVarQueryParams.Add("contact_name__niew", parameterToString(*r.contactNameNiew, ""))
	}
	if r.contactNameIsw != nil {
		localVarQueryParams.Add("contact_name__isw", parameterToString(*r.contactNameIsw, ""))
	}
	if r.contactNameNisw != nil {
		localVarQueryParams.Add("contact_name__nisw", parameterToString(*r.contactNameNisw, ""))
	}
	if r.contactNameIe != nil {
		localVarQueryParams.Add("contact_name__ie", parameterToString(*r.contactNameIe, ""))
	}
	if r.contactNameNie != nil {
		localVarQueryParams.Add("contact_name__nie", parameterToString(*r.contactNameNie, ""))
	}
	if r.contactNameEmpty != nil {
		localVarQueryParams.Add("contact_name__empty", parameterToString(*r.contactNameEmpty, ""))
	}
	if r.contactPhoneN != nil {
		localVarQueryParams.Add("contact_phone__n", parameterToString(*r.contactPhoneN, ""))
	}
	if r.contactPhoneIc != nil {
		localVarQueryParams.Add("contact_phone__ic", parameterToString(*r.contactPhoneIc, ""))
	}
	if r.contactPhoneNic != nil {
		localVarQueryParams.Add("contact_phone__nic", parameterToString(*r.contactPhoneNic, ""))
	}
	if r.contactPhoneIew != nil {
		localVarQueryParams.Add("contact_phone__iew", parameterToString(*r.contactPhoneIew, ""))
	}
	if r.contactPhoneNiew != nil {
		localVarQueryParams.Add("contact_phone__niew", parameterToString(*r.contactPhoneNiew, ""))
	}
	if r.contactPhoneIsw != nil {
		localVarQueryParams.Add("contact_phone__isw", parameterToString(*r.contactPhoneIsw, ""))
	}
	if r.contactPhoneNisw != nil {
		localVarQueryParams.Add("contact_phone__nisw", parameterToString(*r.contactPhoneNisw, ""))
	}
	if r.contactPhoneIe != nil {
		localVarQueryParams.Add("contact_phone__ie", parameterToString(*r.contactPhoneIe, ""))
	}
	if r.contactPhoneNie != nil {
		localVarQueryParams.Add("contact_phone__nie", parameterToString(*r.contactPhoneNie, ""))
	}
	if r.contactPhoneEmpty != nil {
		localVarQueryParams.Add("contact_phone__empty", parameterToString(*r.contactPhoneEmpty, ""))
	}
	if r.contactEmailN != nil {
		localVarQueryParams.Add("contact_email__n", parameterToString(*r.contactEmailN, ""))
	}
	if r.contactEmailIc != nil {
		localVarQueryParams.Add("contact_email__ic", parameterToString(*r.contactEmailIc, ""))
	}
	if r.contactEmailNic != nil {
		localVarQueryParams.Add("contact_email__nic", parameterToString(*r.contactEmailNic, ""))
	}
	if r.contactEmailIew != nil {
		localVarQueryParams.Add("contact_email__iew", parameterToString(*r.contactEmailIew, ""))
	}
	if r.contactEmailNiew != nil {
		localVarQueryParams.Add("contact_email__niew", parameterToString(*r.contactEmailNiew, ""))
	}
	if r.contactEmailIsw != nil {
		localVarQueryParams.Add("contact_email__isw", parameterToString(*r.contactEmailIsw, ""))
	}
	if r.contactEmailNisw != nil {
		localVarQueryParams.Add("contact_email__nisw", parameterToString(*r.contactEmailNisw, ""))
	}
	if r.contactEmailIe != nil {
		localVarQueryParams.Add("contact_email__ie", parameterToString(*r.contactEmailIe, ""))
	}
	if r.contactEmailNie != nil {
		localVarQueryParams.Add("contact_email__nie", parameterToString(*r.contactEmailNie, ""))
	}
	if r.contactEmailEmpty != nil {
		localVarQueryParams.Add("contact_email__empty", parameterToString(*r.contactEmailEmpty, ""))
	}
	if r.tenantGroupIdN != nil {
		localVarQueryParams.Add("tenant_group_id__n", parameterToString(*r.tenantGroupIdN, ""))
	}
	if r.tenantGroupN != nil {
		localVarQueryParams.Add("tenant_group__n", parameterToString(*r.tenantGroupN, ""))
	}
	if r.tenantIdN != nil {
		localVarQueryParams.Add("tenant_id__n", parameterToString(*r.tenantIdN, ""))
	}
	if r.tenantN != nil {
		localVarQueryParams.Add("tenant__n", parameterToString(*r.tenantN, ""))
	}
	if r.statusN != nil {
		localVarQueryParams.Add("status__n", parameterToString(*r.statusN, ""))
	}
	if r.regionIdN != nil {
		localVarQueryParams.Add("region_id__n", parameterToString(*r.regionIdN, ""))
	}
	if r.regionN != nil {
		localVarQueryParams.Add("region__n", parameterToString(*r.regionN, ""))
	}
	if r.groupIdN != nil {
		localVarQueryParams.Add("group_id__n", parameterToString(*r.groupIdN, ""))
	}
	if r.groupN != nil {
		localVarQueryParams.Add("group__n", parameterToString(*r.groupN, ""))
	}
	if r.tagN != nil {
		localVarQueryParams.Add("tag__n", parameterToString(*r.tagN, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimSitesPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
	data *WritableSite
}

func (r ApiDcimSitesPartialUpdateRequest) Data(data WritableSite) ApiDcimSitesPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimSitesPartialUpdateRequest) Execute() (*Site, *http.Response, error) {
	return r.ApiService.DcimSitesPartialUpdateExecute(r)
}

/*
DcimSitesPartialUpdate Method for DcimSitesPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this site.
 @return ApiDcimSitesPartialUpdateRequest
*/
func (a *DcimApiService) DcimSitesPartialUpdate(ctx context.Context, id int32) ApiDcimSitesPartialUpdateRequest {
	return ApiDcimSitesPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Site
func (a *DcimApiService) DcimSitesPartialUpdateExecute(r ApiDcimSitesPartialUpdateRequest) (*Site, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Site
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimSitesPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/sites/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimSitesReadRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
}

func (r ApiDcimSitesReadRequest) Execute() (*Site, *http.Response, error) {
	return r.ApiService.DcimSitesReadExecute(r)
}

/*
DcimSitesRead Method for DcimSitesRead

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this site.
 @return ApiDcimSitesReadRequest
*/
func (a *DcimApiService) DcimSitesRead(ctx context.Context, id int32) ApiDcimSitesReadRequest {
	return ApiDcimSitesReadRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Site
func (a *DcimApiService) DcimSitesReadExecute(r ApiDcimSitesReadRequest) (*Site, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Site
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimSitesRead")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/sites/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimSitesUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
	data *WritableSite
}

func (r ApiDcimSitesUpdateRequest) Data(data WritableSite) ApiDcimSitesUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimSitesUpdateRequest) Execute() (*Site, *http.Response, error) {
	return r.ApiService.DcimSitesUpdateExecute(r)
}

/*
DcimSitesUpdate Method for DcimSitesUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this site.
 @return ApiDcimSitesUpdateRequest
*/
func (a *DcimApiService) DcimSitesUpdate(ctx context.Context, id int32) ApiDcimSitesUpdateRequest {
	return ApiDcimSitesUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Site
func (a *DcimApiService) DcimSitesUpdateExecute(r ApiDcimSitesUpdateRequest) (*Site, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Site
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimSitesUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/sites/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimVirtualChassisBulkDeleteRequest struct {
	ctx context.Context
	ApiService *DcimApiService
}

func (r ApiDcimVirtualChassisBulkDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimVirtualChassisBulkDeleteExecute(r)
}

/*
DcimVirtualChassisBulkDelete Method for DcimVirtualChassisBulkDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimVirtualChassisBulkDeleteRequest
*/
func (a *DcimApiService) DcimVirtualChassisBulkDelete(ctx context.Context) ApiDcimVirtualChassisBulkDeleteRequest {
	return ApiDcimVirtualChassisBulkDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DcimApiService) DcimVirtualChassisBulkDeleteExecute(r ApiDcimVirtualChassisBulkDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimVirtualChassisBulkDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/virtual-chassis/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimVirtualChassisBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	data *WritableVirtualChassis
}

func (r ApiDcimVirtualChassisBulkPartialUpdateRequest) Data(data WritableVirtualChassis) ApiDcimVirtualChassisBulkPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimVirtualChassisBulkPartialUpdateRequest) Execute() (*VirtualChassis, *http.Response, error) {
	return r.ApiService.DcimVirtualChassisBulkPartialUpdateExecute(r)
}

/*
DcimVirtualChassisBulkPartialUpdate Method for DcimVirtualChassisBulkPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimVirtualChassisBulkPartialUpdateRequest
*/
func (a *DcimApiService) DcimVirtualChassisBulkPartialUpdate(ctx context.Context) ApiDcimVirtualChassisBulkPartialUpdateRequest {
	return ApiDcimVirtualChassisBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return VirtualChassis
func (a *DcimApiService) DcimVirtualChassisBulkPartialUpdateExecute(r ApiDcimVirtualChassisBulkPartialUpdateRequest) (*VirtualChassis, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VirtualChassis
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimVirtualChassisBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/virtual-chassis/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimVirtualChassisBulkUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	data *WritableVirtualChassis
}

func (r ApiDcimVirtualChassisBulkUpdateRequest) Data(data WritableVirtualChassis) ApiDcimVirtualChassisBulkUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimVirtualChassisBulkUpdateRequest) Execute() (*VirtualChassis, *http.Response, error) {
	return r.ApiService.DcimVirtualChassisBulkUpdateExecute(r)
}

/*
DcimVirtualChassisBulkUpdate Method for DcimVirtualChassisBulkUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimVirtualChassisBulkUpdateRequest
*/
func (a *DcimApiService) DcimVirtualChassisBulkUpdate(ctx context.Context) ApiDcimVirtualChassisBulkUpdateRequest {
	return ApiDcimVirtualChassisBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return VirtualChassis
func (a *DcimApiService) DcimVirtualChassisBulkUpdateExecute(r ApiDcimVirtualChassisBulkUpdateRequest) (*VirtualChassis, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VirtualChassis
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimVirtualChassisBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/virtual-chassis/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimVirtualChassisCreateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	data *WritableVirtualChassis
}

func (r ApiDcimVirtualChassisCreateRequest) Data(data WritableVirtualChassis) ApiDcimVirtualChassisCreateRequest {
	r.data = &data
	return r
}

func (r ApiDcimVirtualChassisCreateRequest) Execute() (*VirtualChassis, *http.Response, error) {
	return r.ApiService.DcimVirtualChassisCreateExecute(r)
}

/*
DcimVirtualChassisCreate Method for DcimVirtualChassisCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimVirtualChassisCreateRequest
*/
func (a *DcimApiService) DcimVirtualChassisCreate(ctx context.Context) ApiDcimVirtualChassisCreateRequest {
	return ApiDcimVirtualChassisCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return VirtualChassis
func (a *DcimApiService) DcimVirtualChassisCreateExecute(r ApiDcimVirtualChassisCreateRequest) (*VirtualChassis, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VirtualChassis
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimVirtualChassisCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/virtual-chassis/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimVirtualChassisDeleteRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
}

func (r ApiDcimVirtualChassisDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimVirtualChassisDeleteExecute(r)
}

/*
DcimVirtualChassisDelete Method for DcimVirtualChassisDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this virtual chassis.
 @return ApiDcimVirtualChassisDeleteRequest
*/
func (a *DcimApiService) DcimVirtualChassisDelete(ctx context.Context, id int32) ApiDcimVirtualChassisDeleteRequest {
	return ApiDcimVirtualChassisDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DcimApiService) DcimVirtualChassisDeleteExecute(r ApiDcimVirtualChassisDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimVirtualChassisDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/virtual-chassis/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimVirtualChassisListRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id *string
	domain *string
	name *string
	created *string
	createdGte *string
	createdLte *string
	lastUpdated *string
	lastUpdatedGte *string
	lastUpdatedLte *string
	q *string
	masterId *string
	master *string
	regionId *string
	region *string
	siteGroupId *string
	siteGroup *string
	siteId *string
	site *string
	tenantId *string
	tenant *string
	tag *string
	idN *string
	idLte *string
	idLt *string
	idGte *string
	idGt *string
	domainN *string
	domainIc *string
	domainNic *string
	domainIew *string
	domainNiew *string
	domainIsw *string
	domainNisw *string
	domainIe *string
	domainNie *string
	domainEmpty *string
	nameN *string
	nameIc *string
	nameNic *string
	nameIew *string
	nameNiew *string
	nameIsw *string
	nameNisw *string
	nameIe *string
	nameNie *string
	nameEmpty *string
	masterIdN *string
	masterN *string
	regionIdN *string
	regionN *string
	siteGroupIdN *string
	siteGroupN *string
	siteIdN *string
	siteN *string
	tenantIdN *string
	tenantN *string
	tagN *string
	limit *int32
	offset *int32
}

func (r ApiDcimVirtualChassisListRequest) Id(id string) ApiDcimVirtualChassisListRequest {
	r.id = &id
	return r
}

func (r ApiDcimVirtualChassisListRequest) Domain(domain string) ApiDcimVirtualChassisListRequest {
	r.domain = &domain
	return r
}

func (r ApiDcimVirtualChassisListRequest) Name(name string) ApiDcimVirtualChassisListRequest {
	r.name = &name
	return r
}

func (r ApiDcimVirtualChassisListRequest) Created(created string) ApiDcimVirtualChassisListRequest {
	r.created = &created
	return r
}

func (r ApiDcimVirtualChassisListRequest) CreatedGte(createdGte string) ApiDcimVirtualChassisListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiDcimVirtualChassisListRequest) CreatedLte(createdLte string) ApiDcimVirtualChassisListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiDcimVirtualChassisListRequest) LastUpdated(lastUpdated string) ApiDcimVirtualChassisListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiDcimVirtualChassisListRequest) LastUpdatedGte(lastUpdatedGte string) ApiDcimVirtualChassisListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiDcimVirtualChassisListRequest) LastUpdatedLte(lastUpdatedLte string) ApiDcimVirtualChassisListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiDcimVirtualChassisListRequest) Q(q string) ApiDcimVirtualChassisListRequest {
	r.q = &q
	return r
}

func (r ApiDcimVirtualChassisListRequest) MasterId(masterId string) ApiDcimVirtualChassisListRequest {
	r.masterId = &masterId
	return r
}

func (r ApiDcimVirtualChassisListRequest) Master(master string) ApiDcimVirtualChassisListRequest {
	r.master = &master
	return r
}

func (r ApiDcimVirtualChassisListRequest) RegionId(regionId string) ApiDcimVirtualChassisListRequest {
	r.regionId = &regionId
	return r
}

func (r ApiDcimVirtualChassisListRequest) Region(region string) ApiDcimVirtualChassisListRequest {
	r.region = &region
	return r
}

func (r ApiDcimVirtualChassisListRequest) SiteGroupId(siteGroupId string) ApiDcimVirtualChassisListRequest {
	r.siteGroupId = &siteGroupId
	return r
}

func (r ApiDcimVirtualChassisListRequest) SiteGroup(siteGroup string) ApiDcimVirtualChassisListRequest {
	r.siteGroup = &siteGroup
	return r
}

func (r ApiDcimVirtualChassisListRequest) SiteId(siteId string) ApiDcimVirtualChassisListRequest {
	r.siteId = &siteId
	return r
}

func (r ApiDcimVirtualChassisListRequest) Site(site string) ApiDcimVirtualChassisListRequest {
	r.site = &site
	return r
}

func (r ApiDcimVirtualChassisListRequest) TenantId(tenantId string) ApiDcimVirtualChassisListRequest {
	r.tenantId = &tenantId
	return r
}

func (r ApiDcimVirtualChassisListRequest) Tenant(tenant string) ApiDcimVirtualChassisListRequest {
	r.tenant = &tenant
	return r
}

func (r ApiDcimVirtualChassisListRequest) Tag(tag string) ApiDcimVirtualChassisListRequest {
	r.tag = &tag
	return r
}

func (r ApiDcimVirtualChassisListRequest) IdN(idN string) ApiDcimVirtualChassisListRequest {
	r.idN = &idN
	return r
}

func (r ApiDcimVirtualChassisListRequest) IdLte(idLte string) ApiDcimVirtualChassisListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiDcimVirtualChassisListRequest) IdLt(idLt string) ApiDcimVirtualChassisListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiDcimVirtualChassisListRequest) IdGte(idGte string) ApiDcimVirtualChassisListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiDcimVirtualChassisListRequest) IdGt(idGt string) ApiDcimVirtualChassisListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiDcimVirtualChassisListRequest) DomainN(domainN string) ApiDcimVirtualChassisListRequest {
	r.domainN = &domainN
	return r
}

func (r ApiDcimVirtualChassisListRequest) DomainIc(domainIc string) ApiDcimVirtualChassisListRequest {
	r.domainIc = &domainIc
	return r
}

func (r ApiDcimVirtualChassisListRequest) DomainNic(domainNic string) ApiDcimVirtualChassisListRequest {
	r.domainNic = &domainNic
	return r
}

func (r ApiDcimVirtualChassisListRequest) DomainIew(domainIew string) ApiDcimVirtualChassisListRequest {
	r.domainIew = &domainIew
	return r
}

func (r ApiDcimVirtualChassisListRequest) DomainNiew(domainNiew string) ApiDcimVirtualChassisListRequest {
	r.domainNiew = &domainNiew
	return r
}

func (r ApiDcimVirtualChassisListRequest) DomainIsw(domainIsw string) ApiDcimVirtualChassisListRequest {
	r.domainIsw = &domainIsw
	return r
}

func (r ApiDcimVirtualChassisListRequest) DomainNisw(domainNisw string) ApiDcimVirtualChassisListRequest {
	r.domainNisw = &domainNisw
	return r
}

func (r ApiDcimVirtualChassisListRequest) DomainIe(domainIe string) ApiDcimVirtualChassisListRequest {
	r.domainIe = &domainIe
	return r
}

func (r ApiDcimVirtualChassisListRequest) DomainNie(domainNie string) ApiDcimVirtualChassisListRequest {
	r.domainNie = &domainNie
	return r
}

func (r ApiDcimVirtualChassisListRequest) DomainEmpty(domainEmpty string) ApiDcimVirtualChassisListRequest {
	r.domainEmpty = &domainEmpty
	return r
}

func (r ApiDcimVirtualChassisListRequest) NameN(nameN string) ApiDcimVirtualChassisListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiDcimVirtualChassisListRequest) NameIc(nameIc string) ApiDcimVirtualChassisListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiDcimVirtualChassisListRequest) NameNic(nameNic string) ApiDcimVirtualChassisListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiDcimVirtualChassisListRequest) NameIew(nameIew string) ApiDcimVirtualChassisListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiDcimVirtualChassisListRequest) NameNiew(nameNiew string) ApiDcimVirtualChassisListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiDcimVirtualChassisListRequest) NameIsw(nameIsw string) ApiDcimVirtualChassisListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiDcimVirtualChassisListRequest) NameNisw(nameNisw string) ApiDcimVirtualChassisListRequest {
	r.nameNisw = &nameNisw
	return r
}

func (r ApiDcimVirtualChassisListRequest) NameIe(nameIe string) ApiDcimVirtualChassisListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiDcimVirtualChassisListRequest) NameNie(nameNie string) ApiDcimVirtualChassisListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiDcimVirtualChassisListRequest) NameEmpty(nameEmpty string) ApiDcimVirtualChassisListRequest {
	r.nameEmpty = &nameEmpty
	return r
}

func (r ApiDcimVirtualChassisListRequest) MasterIdN(masterIdN string) ApiDcimVirtualChassisListRequest {
	r.masterIdN = &masterIdN
	return r
}

func (r ApiDcimVirtualChassisListRequest) MasterN(masterN string) ApiDcimVirtualChassisListRequest {
	r.masterN = &masterN
	return r
}

func (r ApiDcimVirtualChassisListRequest) RegionIdN(regionIdN string) ApiDcimVirtualChassisListRequest {
	r.regionIdN = &regionIdN
	return r
}

func (r ApiDcimVirtualChassisListRequest) RegionN(regionN string) ApiDcimVirtualChassisListRequest {
	r.regionN = &regionN
	return r
}

func (r ApiDcimVirtualChassisListRequest) SiteGroupIdN(siteGroupIdN string) ApiDcimVirtualChassisListRequest {
	r.siteGroupIdN = &siteGroupIdN
	return r
}

func (r ApiDcimVirtualChassisListRequest) SiteGroupN(siteGroupN string) ApiDcimVirtualChassisListRequest {
	r.siteGroupN = &siteGroupN
	return r
}

func (r ApiDcimVirtualChassisListRequest) SiteIdN(siteIdN string) ApiDcimVirtualChassisListRequest {
	r.siteIdN = &siteIdN
	return r
}

func (r ApiDcimVirtualChassisListRequest) SiteN(siteN string) ApiDcimVirtualChassisListRequest {
	r.siteN = &siteN
	return r
}

func (r ApiDcimVirtualChassisListRequest) TenantIdN(tenantIdN string) ApiDcimVirtualChassisListRequest {
	r.tenantIdN = &tenantIdN
	return r
}

func (r ApiDcimVirtualChassisListRequest) TenantN(tenantN string) ApiDcimVirtualChassisListRequest {
	r.tenantN = &tenantN
	return r
}

func (r ApiDcimVirtualChassisListRequest) TagN(tagN string) ApiDcimVirtualChassisListRequest {
	r.tagN = &tagN
	return r
}

// Number of results to return per page.
func (r ApiDcimVirtualChassisListRequest) Limit(limit int32) ApiDcimVirtualChassisListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiDcimVirtualChassisListRequest) Offset(offset int32) ApiDcimVirtualChassisListRequest {
	r.offset = &offset
	return r
}

func (r ApiDcimVirtualChassisListRequest) Execute() (*DcimVirtualChassisList200Response, *http.Response, error) {
	return r.ApiService.DcimVirtualChassisListExecute(r)
}

/*
DcimVirtualChassisList Method for DcimVirtualChassisList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimVirtualChassisListRequest
*/
func (a *DcimApiService) DcimVirtualChassisList(ctx context.Context) ApiDcimVirtualChassisListRequest {
	return ApiDcimVirtualChassisListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DcimVirtualChassisList200Response
func (a *DcimApiService) DcimVirtualChassisListExecute(r ApiDcimVirtualChassisListRequest) (*DcimVirtualChassisList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DcimVirtualChassisList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimVirtualChassisList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/virtual-chassis/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.domain != nil {
		localVarQueryParams.Add("domain", parameterToString(*r.domain, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.created != nil {
		localVarQueryParams.Add("created", parameterToString(*r.created, ""))
	}
	if r.createdGte != nil {
		localVarQueryParams.Add("created__gte", parameterToString(*r.createdGte, ""))
	}
	if r.createdLte != nil {
		localVarQueryParams.Add("created__lte", parameterToString(*r.createdLte, ""))
	}
	if r.lastUpdated != nil {
		localVarQueryParams.Add("last_updated", parameterToString(*r.lastUpdated, ""))
	}
	if r.lastUpdatedGte != nil {
		localVarQueryParams.Add("last_updated__gte", parameterToString(*r.lastUpdatedGte, ""))
	}
	if r.lastUpdatedLte != nil {
		localVarQueryParams.Add("last_updated__lte", parameterToString(*r.lastUpdatedLte, ""))
	}
	if r.q != nil {
		localVarQueryParams.Add("q", parameterToString(*r.q, ""))
	}
	if r.masterId != nil {
		localVarQueryParams.Add("master_id", parameterToString(*r.masterId, ""))
	}
	if r.master != nil {
		localVarQueryParams.Add("master", parameterToString(*r.master, ""))
	}
	if r.regionId != nil {
		localVarQueryParams.Add("region_id", parameterToString(*r.regionId, ""))
	}
	if r.region != nil {
		localVarQueryParams.Add("region", parameterToString(*r.region, ""))
	}
	if r.siteGroupId != nil {
		localVarQueryParams.Add("site_group_id", parameterToString(*r.siteGroupId, ""))
	}
	if r.siteGroup != nil {
		localVarQueryParams.Add("site_group", parameterToString(*r.siteGroup, ""))
	}
	if r.siteId != nil {
		localVarQueryParams.Add("site_id", parameterToString(*r.siteId, ""))
	}
	if r.site != nil {
		localVarQueryParams.Add("site", parameterToString(*r.site, ""))
	}
	if r.tenantId != nil {
		localVarQueryParams.Add("tenant_id", parameterToString(*r.tenantId, ""))
	}
	if r.tenant != nil {
		localVarQueryParams.Add("tenant", parameterToString(*r.tenant, ""))
	}
	if r.tag != nil {
		localVarQueryParams.Add("tag", parameterToString(*r.tag, ""))
	}
	if r.idN != nil {
		localVarQueryParams.Add("id__n", parameterToString(*r.idN, ""))
	}
	if r.idLte != nil {
		localVarQueryParams.Add("id__lte", parameterToString(*r.idLte, ""))
	}
	if r.idLt != nil {
		localVarQueryParams.Add("id__lt", parameterToString(*r.idLt, ""))
	}
	if r.idGte != nil {
		localVarQueryParams.Add("id__gte", parameterToString(*r.idGte, ""))
	}
	if r.idGt != nil {
		localVarQueryParams.Add("id__gt", parameterToString(*r.idGt, ""))
	}
	if r.domainN != nil {
		localVarQueryParams.Add("domain__n", parameterToString(*r.domainN, ""))
	}
	if r.domainIc != nil {
		localVarQueryParams.Add("domain__ic", parameterToString(*r.domainIc, ""))
	}
	if r.domainNic != nil {
		localVarQueryParams.Add("domain__nic", parameterToString(*r.domainNic, ""))
	}
	if r.domainIew != nil {
		localVarQueryParams.Add("domain__iew", parameterToString(*r.domainIew, ""))
	}
	if r.domainNiew != nil {
		localVarQueryParams.Add("domain__niew", parameterToString(*r.domainNiew, ""))
	}
	if r.domainIsw != nil {
		localVarQueryParams.Add("domain__isw", parameterToString(*r.domainIsw, ""))
	}
	if r.domainNisw != nil {
		localVarQueryParams.Add("domain__nisw", parameterToString(*r.domainNisw, ""))
	}
	if r.domainIe != nil {
		localVarQueryParams.Add("domain__ie", parameterToString(*r.domainIe, ""))
	}
	if r.domainNie != nil {
		localVarQueryParams.Add("domain__nie", parameterToString(*r.domainNie, ""))
	}
	if r.domainEmpty != nil {
		localVarQueryParams.Add("domain__empty", parameterToString(*r.domainEmpty, ""))
	}
	if r.nameN != nil {
		localVarQueryParams.Add("name__n", parameterToString(*r.nameN, ""))
	}
	if r.nameIc != nil {
		localVarQueryParams.Add("name__ic", parameterToString(*r.nameIc, ""))
	}
	if r.nameNic != nil {
		localVarQueryParams.Add("name__nic", parameterToString(*r.nameNic, ""))
	}
	if r.nameIew != nil {
		localVarQueryParams.Add("name__iew", parameterToString(*r.nameIew, ""))
	}
	if r.nameNiew != nil {
		localVarQueryParams.Add("name__niew", parameterToString(*r.nameNiew, ""))
	}
	if r.nameIsw != nil {
		localVarQueryParams.Add("name__isw", parameterToString(*r.nameIsw, ""))
	}
	if r.nameNisw != nil {
		localVarQueryParams.Add("name__nisw", parameterToString(*r.nameNisw, ""))
	}
	if r.nameIe != nil {
		localVarQueryParams.Add("name__ie", parameterToString(*r.nameIe, ""))
	}
	if r.nameNie != nil {
		localVarQueryParams.Add("name__nie", parameterToString(*r.nameNie, ""))
	}
	if r.nameEmpty != nil {
		localVarQueryParams.Add("name__empty", parameterToString(*r.nameEmpty, ""))
	}
	if r.masterIdN != nil {
		localVarQueryParams.Add("master_id__n", parameterToString(*r.masterIdN, ""))
	}
	if r.masterN != nil {
		localVarQueryParams.Add("master__n", parameterToString(*r.masterN, ""))
	}
	if r.regionIdN != nil {
		localVarQueryParams.Add("region_id__n", parameterToString(*r.regionIdN, ""))
	}
	if r.regionN != nil {
		localVarQueryParams.Add("region__n", parameterToString(*r.regionN, ""))
	}
	if r.siteGroupIdN != nil {
		localVarQueryParams.Add("site_group_id__n", parameterToString(*r.siteGroupIdN, ""))
	}
	if r.siteGroupN != nil {
		localVarQueryParams.Add("site_group__n", parameterToString(*r.siteGroupN, ""))
	}
	if r.siteIdN != nil {
		localVarQueryParams.Add("site_id__n", parameterToString(*r.siteIdN, ""))
	}
	if r.siteN != nil {
		localVarQueryParams.Add("site__n", parameterToString(*r.siteN, ""))
	}
	if r.tenantIdN != nil {
		localVarQueryParams.Add("tenant_id__n", parameterToString(*r.tenantIdN, ""))
	}
	if r.tenantN != nil {
		localVarQueryParams.Add("tenant__n", parameterToString(*r.tenantN, ""))
	}
	if r.tagN != nil {
		localVarQueryParams.Add("tag__n", parameterToString(*r.tagN, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimVirtualChassisPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
	data *WritableVirtualChassis
}

func (r ApiDcimVirtualChassisPartialUpdateRequest) Data(data WritableVirtualChassis) ApiDcimVirtualChassisPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimVirtualChassisPartialUpdateRequest) Execute() (*VirtualChassis, *http.Response, error) {
	return r.ApiService.DcimVirtualChassisPartialUpdateExecute(r)
}

/*
DcimVirtualChassisPartialUpdate Method for DcimVirtualChassisPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this virtual chassis.
 @return ApiDcimVirtualChassisPartialUpdateRequest
*/
func (a *DcimApiService) DcimVirtualChassisPartialUpdate(ctx context.Context, id int32) ApiDcimVirtualChassisPartialUpdateRequest {
	return ApiDcimVirtualChassisPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return VirtualChassis
func (a *DcimApiService) DcimVirtualChassisPartialUpdateExecute(r ApiDcimVirtualChassisPartialUpdateRequest) (*VirtualChassis, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VirtualChassis
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimVirtualChassisPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/virtual-chassis/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimVirtualChassisReadRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
}

func (r ApiDcimVirtualChassisReadRequest) Execute() (*VirtualChassis, *http.Response, error) {
	return r.ApiService.DcimVirtualChassisReadExecute(r)
}

/*
DcimVirtualChassisRead Method for DcimVirtualChassisRead

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this virtual chassis.
 @return ApiDcimVirtualChassisReadRequest
*/
func (a *DcimApiService) DcimVirtualChassisRead(ctx context.Context, id int32) ApiDcimVirtualChassisReadRequest {
	return ApiDcimVirtualChassisReadRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return VirtualChassis
func (a *DcimApiService) DcimVirtualChassisReadExecute(r ApiDcimVirtualChassisReadRequest) (*VirtualChassis, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VirtualChassis
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimVirtualChassisRead")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/virtual-chassis/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimVirtualChassisUpdateRequest struct {
	ctx context.Context
	ApiService *DcimApiService
	id int32
	data *WritableVirtualChassis
}

func (r ApiDcimVirtualChassisUpdateRequest) Data(data WritableVirtualChassis) ApiDcimVirtualChassisUpdateRequest {
	r.data = &data
	return r
}

func (r ApiDcimVirtualChassisUpdateRequest) Execute() (*VirtualChassis, *http.Response, error) {
	return r.ApiService.DcimVirtualChassisUpdateExecute(r)
}

/*
DcimVirtualChassisUpdate Method for DcimVirtualChassisUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this virtual chassis.
 @return ApiDcimVirtualChassisUpdateRequest
*/
func (a *DcimApiService) DcimVirtualChassisUpdate(ctx context.Context, id int32) ApiDcimVirtualChassisUpdateRequest {
	return ApiDcimVirtualChassisUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return VirtualChassis
func (a *DcimApiService) DcimVirtualChassisUpdateExecute(r ApiDcimVirtualChassisUpdateRequest) (*VirtualChassis, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VirtualChassis
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimApiService.DcimVirtualChassisUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/virtual-chassis/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
