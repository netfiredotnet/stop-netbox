/*
NetBox API

API to access NetBox

API version: 2.11
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package netbox

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// IpamApiService IpamApi service
type IpamApiService service

type ApiIpamAggregatesBulkDeleteRequest struct {
	ctx context.Context
	ApiService *IpamApiService
}

func (r ApiIpamAggregatesBulkDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamAggregatesBulkDeleteExecute(r)
}

/*
IpamAggregatesBulkDelete Method for IpamAggregatesBulkDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamAggregatesBulkDeleteRequest
*/
func (a *IpamApiService) IpamAggregatesBulkDelete(ctx context.Context) ApiIpamAggregatesBulkDeleteRequest {
	return ApiIpamAggregatesBulkDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *IpamApiService) IpamAggregatesBulkDeleteExecute(r ApiIpamAggregatesBulkDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamAggregatesBulkDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/aggregates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamAggregatesBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	data *WritableAggregate
}

func (r ApiIpamAggregatesBulkPartialUpdateRequest) Data(data WritableAggregate) ApiIpamAggregatesBulkPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiIpamAggregatesBulkPartialUpdateRequest) Execute() (*Aggregate, *http.Response, error) {
	return r.ApiService.IpamAggregatesBulkPartialUpdateExecute(r)
}

/*
IpamAggregatesBulkPartialUpdate Method for IpamAggregatesBulkPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamAggregatesBulkPartialUpdateRequest
*/
func (a *IpamApiService) IpamAggregatesBulkPartialUpdate(ctx context.Context) ApiIpamAggregatesBulkPartialUpdateRequest {
	return ApiIpamAggregatesBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Aggregate
func (a *IpamApiService) IpamAggregatesBulkPartialUpdateExecute(r ApiIpamAggregatesBulkPartialUpdateRequest) (*Aggregate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Aggregate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamAggregatesBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/aggregates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamAggregatesBulkUpdateRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	data *WritableAggregate
}

func (r ApiIpamAggregatesBulkUpdateRequest) Data(data WritableAggregate) ApiIpamAggregatesBulkUpdateRequest {
	r.data = &data
	return r
}

func (r ApiIpamAggregatesBulkUpdateRequest) Execute() (*Aggregate, *http.Response, error) {
	return r.ApiService.IpamAggregatesBulkUpdateExecute(r)
}

/*
IpamAggregatesBulkUpdate Method for IpamAggregatesBulkUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamAggregatesBulkUpdateRequest
*/
func (a *IpamApiService) IpamAggregatesBulkUpdate(ctx context.Context) ApiIpamAggregatesBulkUpdateRequest {
	return ApiIpamAggregatesBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Aggregate
func (a *IpamApiService) IpamAggregatesBulkUpdateExecute(r ApiIpamAggregatesBulkUpdateRequest) (*Aggregate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Aggregate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamAggregatesBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/aggregates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamAggregatesCreateRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	data *WritableAggregate
}

func (r ApiIpamAggregatesCreateRequest) Data(data WritableAggregate) ApiIpamAggregatesCreateRequest {
	r.data = &data
	return r
}

func (r ApiIpamAggregatesCreateRequest) Execute() (*Aggregate, *http.Response, error) {
	return r.ApiService.IpamAggregatesCreateExecute(r)
}

/*
IpamAggregatesCreate Method for IpamAggregatesCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamAggregatesCreateRequest
*/
func (a *IpamApiService) IpamAggregatesCreate(ctx context.Context) ApiIpamAggregatesCreateRequest {
	return ApiIpamAggregatesCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Aggregate
func (a *IpamApiService) IpamAggregatesCreateExecute(r ApiIpamAggregatesCreateRequest) (*Aggregate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Aggregate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamAggregatesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/aggregates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamAggregatesDeleteRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	id int32
}

func (r ApiIpamAggregatesDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamAggregatesDeleteExecute(r)
}

/*
IpamAggregatesDelete Method for IpamAggregatesDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this aggregate.
 @return ApiIpamAggregatesDeleteRequest
*/
func (a *IpamApiService) IpamAggregatesDelete(ctx context.Context, id int32) ApiIpamAggregatesDeleteRequest {
	return ApiIpamAggregatesDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *IpamApiService) IpamAggregatesDeleteExecute(r ApiIpamAggregatesDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamAggregatesDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/aggregates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamAggregatesListRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	id *string
	dateAdded *string
	created *string
	createdGte *string
	createdLte *string
	lastUpdated *string
	lastUpdatedGte *string
	lastUpdatedLte *string
	tenantGroupId *string
	tenantGroup *string
	tenantId *string
	tenant *string
	q *string
	family *float32
	prefix *string
	rirId *string
	rir *string
	tag *string
	idN *string
	idLte *string
	idLt *string
	idGte *string
	idGt *string
	dateAddedN *string
	dateAddedLte *string
	dateAddedLt *string
	dateAddedGte *string
	dateAddedGt *string
	tenantGroupIdN *string
	tenantGroupN *string
	tenantIdN *string
	tenantN *string
	rirIdN *string
	rirN *string
	tagN *string
	limit *int32
	offset *int32
}

func (r ApiIpamAggregatesListRequest) Id(id string) ApiIpamAggregatesListRequest {
	r.id = &id
	return r
}

func (r ApiIpamAggregatesListRequest) DateAdded(dateAdded string) ApiIpamAggregatesListRequest {
	r.dateAdded = &dateAdded
	return r
}

func (r ApiIpamAggregatesListRequest) Created(created string) ApiIpamAggregatesListRequest {
	r.created = &created
	return r
}

func (r ApiIpamAggregatesListRequest) CreatedGte(createdGte string) ApiIpamAggregatesListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiIpamAggregatesListRequest) CreatedLte(createdLte string) ApiIpamAggregatesListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiIpamAggregatesListRequest) LastUpdated(lastUpdated string) ApiIpamAggregatesListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiIpamAggregatesListRequest) LastUpdatedGte(lastUpdatedGte string) ApiIpamAggregatesListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiIpamAggregatesListRequest) LastUpdatedLte(lastUpdatedLte string) ApiIpamAggregatesListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiIpamAggregatesListRequest) TenantGroupId(tenantGroupId string) ApiIpamAggregatesListRequest {
	r.tenantGroupId = &tenantGroupId
	return r
}

func (r ApiIpamAggregatesListRequest) TenantGroup(tenantGroup string) ApiIpamAggregatesListRequest {
	r.tenantGroup = &tenantGroup
	return r
}

func (r ApiIpamAggregatesListRequest) TenantId(tenantId string) ApiIpamAggregatesListRequest {
	r.tenantId = &tenantId
	return r
}

func (r ApiIpamAggregatesListRequest) Tenant(tenant string) ApiIpamAggregatesListRequest {
	r.tenant = &tenant
	return r
}

func (r ApiIpamAggregatesListRequest) Q(q string) ApiIpamAggregatesListRequest {
	r.q = &q
	return r
}

func (r ApiIpamAggregatesListRequest) Family(family float32) ApiIpamAggregatesListRequest {
	r.family = &family
	return r
}

func (r ApiIpamAggregatesListRequest) Prefix(prefix string) ApiIpamAggregatesListRequest {
	r.prefix = &prefix
	return r
}

func (r ApiIpamAggregatesListRequest) RirId(rirId string) ApiIpamAggregatesListRequest {
	r.rirId = &rirId
	return r
}

func (r ApiIpamAggregatesListRequest) Rir(rir string) ApiIpamAggregatesListRequest {
	r.rir = &rir
	return r
}

func (r ApiIpamAggregatesListRequest) Tag(tag string) ApiIpamAggregatesListRequest {
	r.tag = &tag
	return r
}

func (r ApiIpamAggregatesListRequest) IdN(idN string) ApiIpamAggregatesListRequest {
	r.idN = &idN
	return r
}

func (r ApiIpamAggregatesListRequest) IdLte(idLte string) ApiIpamAggregatesListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiIpamAggregatesListRequest) IdLt(idLt string) ApiIpamAggregatesListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiIpamAggregatesListRequest) IdGte(idGte string) ApiIpamAggregatesListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiIpamAggregatesListRequest) IdGt(idGt string) ApiIpamAggregatesListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiIpamAggregatesListRequest) DateAddedN(dateAddedN string) ApiIpamAggregatesListRequest {
	r.dateAddedN = &dateAddedN
	return r
}

func (r ApiIpamAggregatesListRequest) DateAddedLte(dateAddedLte string) ApiIpamAggregatesListRequest {
	r.dateAddedLte = &dateAddedLte
	return r
}

func (r ApiIpamAggregatesListRequest) DateAddedLt(dateAddedLt string) ApiIpamAggregatesListRequest {
	r.dateAddedLt = &dateAddedLt
	return r
}

func (r ApiIpamAggregatesListRequest) DateAddedGte(dateAddedGte string) ApiIpamAggregatesListRequest {
	r.dateAddedGte = &dateAddedGte
	return r
}

func (r ApiIpamAggregatesListRequest) DateAddedGt(dateAddedGt string) ApiIpamAggregatesListRequest {
	r.dateAddedGt = &dateAddedGt
	return r
}

func (r ApiIpamAggregatesListRequest) TenantGroupIdN(tenantGroupIdN string) ApiIpamAggregatesListRequest {
	r.tenantGroupIdN = &tenantGroupIdN
	return r
}

func (r ApiIpamAggregatesListRequest) TenantGroupN(tenantGroupN string) ApiIpamAggregatesListRequest {
	r.tenantGroupN = &tenantGroupN
	return r
}

func (r ApiIpamAggregatesListRequest) TenantIdN(tenantIdN string) ApiIpamAggregatesListRequest {
	r.tenantIdN = &tenantIdN
	return r
}

func (r ApiIpamAggregatesListRequest) TenantN(tenantN string) ApiIpamAggregatesListRequest {
	r.tenantN = &tenantN
	return r
}

func (r ApiIpamAggregatesListRequest) RirIdN(rirIdN string) ApiIpamAggregatesListRequest {
	r.rirIdN = &rirIdN
	return r
}

func (r ApiIpamAggregatesListRequest) RirN(rirN string) ApiIpamAggregatesListRequest {
	r.rirN = &rirN
	return r
}

func (r ApiIpamAggregatesListRequest) TagN(tagN string) ApiIpamAggregatesListRequest {
	r.tagN = &tagN
	return r
}

// Number of results to return per page.
func (r ApiIpamAggregatesListRequest) Limit(limit int32) ApiIpamAggregatesListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiIpamAggregatesListRequest) Offset(offset int32) ApiIpamAggregatesListRequest {
	r.offset = &offset
	return r
}

func (r ApiIpamAggregatesListRequest) Execute() (*IpamAggregatesList200Response, *http.Response, error) {
	return r.ApiService.IpamAggregatesListExecute(r)
}

/*
IpamAggregatesList Method for IpamAggregatesList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamAggregatesListRequest
*/
func (a *IpamApiService) IpamAggregatesList(ctx context.Context) ApiIpamAggregatesListRequest {
	return ApiIpamAggregatesListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return IpamAggregatesList200Response
func (a *IpamApiService) IpamAggregatesListExecute(r ApiIpamAggregatesListRequest) (*IpamAggregatesList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IpamAggregatesList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamAggregatesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/aggregates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.dateAdded != nil {
		localVarQueryParams.Add("date_added", parameterToString(*r.dateAdded, ""))
	}
	if r.created != nil {
		localVarQueryParams.Add("created", parameterToString(*r.created, ""))
	}
	if r.createdGte != nil {
		localVarQueryParams.Add("created__gte", parameterToString(*r.createdGte, ""))
	}
	if r.createdLte != nil {
		localVarQueryParams.Add("created__lte", parameterToString(*r.createdLte, ""))
	}
	if r.lastUpdated != nil {
		localVarQueryParams.Add("last_updated", parameterToString(*r.lastUpdated, ""))
	}
	if r.lastUpdatedGte != nil {
		localVarQueryParams.Add("last_updated__gte", parameterToString(*r.lastUpdatedGte, ""))
	}
	if r.lastUpdatedLte != nil {
		localVarQueryParams.Add("last_updated__lte", parameterToString(*r.lastUpdatedLte, ""))
	}
	if r.tenantGroupId != nil {
		localVarQueryParams.Add("tenant_group_id", parameterToString(*r.tenantGroupId, ""))
	}
	if r.tenantGroup != nil {
		localVarQueryParams.Add("tenant_group", parameterToString(*r.tenantGroup, ""))
	}
	if r.tenantId != nil {
		localVarQueryParams.Add("tenant_id", parameterToString(*r.tenantId, ""))
	}
	if r.tenant != nil {
		localVarQueryParams.Add("tenant", parameterToString(*r.tenant, ""))
	}
	if r.q != nil {
		localVarQueryParams.Add("q", parameterToString(*r.q, ""))
	}
	if r.family != nil {
		localVarQueryParams.Add("family", parameterToString(*r.family, ""))
	}
	if r.prefix != nil {
		localVarQueryParams.Add("prefix", parameterToString(*r.prefix, ""))
	}
	if r.rirId != nil {
		localVarQueryParams.Add("rir_id", parameterToString(*r.rirId, ""))
	}
	if r.rir != nil {
		localVarQueryParams.Add("rir", parameterToString(*r.rir, ""))
	}
	if r.tag != nil {
		localVarQueryParams.Add("tag", parameterToString(*r.tag, ""))
	}
	if r.idN != nil {
		localVarQueryParams.Add("id__n", parameterToString(*r.idN, ""))
	}
	if r.idLte != nil {
		localVarQueryParams.Add("id__lte", parameterToString(*r.idLte, ""))
	}
	if r.idLt != nil {
		localVarQueryParams.Add("id__lt", parameterToString(*r.idLt, ""))
	}
	if r.idGte != nil {
		localVarQueryParams.Add("id__gte", parameterToString(*r.idGte, ""))
	}
	if r.idGt != nil {
		localVarQueryParams.Add("id__gt", parameterToString(*r.idGt, ""))
	}
	if r.dateAddedN != nil {
		localVarQueryParams.Add("date_added__n", parameterToString(*r.dateAddedN, ""))
	}
	if r.dateAddedLte != nil {
		localVarQueryParams.Add("date_added__lte", parameterToString(*r.dateAddedLte, ""))
	}
	if r.dateAddedLt != nil {
		localVarQueryParams.Add("date_added__lt", parameterToString(*r.dateAddedLt, ""))
	}
	if r.dateAddedGte != nil {
		localVarQueryParams.Add("date_added__gte", parameterToString(*r.dateAddedGte, ""))
	}
	if r.dateAddedGt != nil {
		localVarQueryParams.Add("date_added__gt", parameterToString(*r.dateAddedGt, ""))
	}
	if r.tenantGroupIdN != nil {
		localVarQueryParams.Add("tenant_group_id__n", parameterToString(*r.tenantGroupIdN, ""))
	}
	if r.tenantGroupN != nil {
		localVarQueryParams.Add("tenant_group__n", parameterToString(*r.tenantGroupN, ""))
	}
	if r.tenantIdN != nil {
		localVarQueryParams.Add("tenant_id__n", parameterToString(*r.tenantIdN, ""))
	}
	if r.tenantN != nil {
		localVarQueryParams.Add("tenant__n", parameterToString(*r.tenantN, ""))
	}
	if r.rirIdN != nil {
		localVarQueryParams.Add("rir_id__n", parameterToString(*r.rirIdN, ""))
	}
	if r.rirN != nil {
		localVarQueryParams.Add("rir__n", parameterToString(*r.rirN, ""))
	}
	if r.tagN != nil {
		localVarQueryParams.Add("tag__n", parameterToString(*r.tagN, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamAggregatesPartialUpdateRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	id int32
	data *WritableAggregate
}

func (r ApiIpamAggregatesPartialUpdateRequest) Data(data WritableAggregate) ApiIpamAggregatesPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiIpamAggregatesPartialUpdateRequest) Execute() (*Aggregate, *http.Response, error) {
	return r.ApiService.IpamAggregatesPartialUpdateExecute(r)
}

/*
IpamAggregatesPartialUpdate Method for IpamAggregatesPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this aggregate.
 @return ApiIpamAggregatesPartialUpdateRequest
*/
func (a *IpamApiService) IpamAggregatesPartialUpdate(ctx context.Context, id int32) ApiIpamAggregatesPartialUpdateRequest {
	return ApiIpamAggregatesPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Aggregate
func (a *IpamApiService) IpamAggregatesPartialUpdateExecute(r ApiIpamAggregatesPartialUpdateRequest) (*Aggregate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Aggregate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamAggregatesPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/aggregates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamAggregatesReadRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	id int32
}

func (r ApiIpamAggregatesReadRequest) Execute() (*Aggregate, *http.Response, error) {
	return r.ApiService.IpamAggregatesReadExecute(r)
}

/*
IpamAggregatesRead Method for IpamAggregatesRead

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this aggregate.
 @return ApiIpamAggregatesReadRequest
*/
func (a *IpamApiService) IpamAggregatesRead(ctx context.Context, id int32) ApiIpamAggregatesReadRequest {
	return ApiIpamAggregatesReadRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Aggregate
func (a *IpamApiService) IpamAggregatesReadExecute(r ApiIpamAggregatesReadRequest) (*Aggregate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Aggregate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamAggregatesRead")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/aggregates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamAggregatesUpdateRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	id int32
	data *WritableAggregate
}

func (r ApiIpamAggregatesUpdateRequest) Data(data WritableAggregate) ApiIpamAggregatesUpdateRequest {
	r.data = &data
	return r
}

func (r ApiIpamAggregatesUpdateRequest) Execute() (*Aggregate, *http.Response, error) {
	return r.ApiService.IpamAggregatesUpdateExecute(r)
}

/*
IpamAggregatesUpdate Method for IpamAggregatesUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this aggregate.
 @return ApiIpamAggregatesUpdateRequest
*/
func (a *IpamApiService) IpamAggregatesUpdate(ctx context.Context, id int32) ApiIpamAggregatesUpdateRequest {
	return ApiIpamAggregatesUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Aggregate
func (a *IpamApiService) IpamAggregatesUpdateExecute(r ApiIpamAggregatesUpdateRequest) (*Aggregate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Aggregate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamAggregatesUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/aggregates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamIpAddressesBulkDeleteRequest struct {
	ctx context.Context
	ApiService *IpamApiService
}

func (r ApiIpamIpAddressesBulkDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamIpAddressesBulkDeleteExecute(r)
}

/*
IpamIpAddressesBulkDelete Method for IpamIpAddressesBulkDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamIpAddressesBulkDeleteRequest
*/
func (a *IpamApiService) IpamIpAddressesBulkDelete(ctx context.Context) ApiIpamIpAddressesBulkDeleteRequest {
	return ApiIpamIpAddressesBulkDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *IpamApiService) IpamIpAddressesBulkDeleteExecute(r ApiIpamIpAddressesBulkDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamIpAddressesBulkDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/ip-addresses/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamIpAddressesBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	data *WritableIPAddress
}

func (r ApiIpamIpAddressesBulkPartialUpdateRequest) Data(data WritableIPAddress) ApiIpamIpAddressesBulkPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiIpamIpAddressesBulkPartialUpdateRequest) Execute() (*IPAddress, *http.Response, error) {
	return r.ApiService.IpamIpAddressesBulkPartialUpdateExecute(r)
}

/*
IpamIpAddressesBulkPartialUpdate Method for IpamIpAddressesBulkPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamIpAddressesBulkPartialUpdateRequest
*/
func (a *IpamApiService) IpamIpAddressesBulkPartialUpdate(ctx context.Context) ApiIpamIpAddressesBulkPartialUpdateRequest {
	return ApiIpamIpAddressesBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return IPAddress
func (a *IpamApiService) IpamIpAddressesBulkPartialUpdateExecute(r ApiIpamIpAddressesBulkPartialUpdateRequest) (*IPAddress, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IPAddress
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamIpAddressesBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/ip-addresses/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamIpAddressesBulkUpdateRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	data *WritableIPAddress
}

func (r ApiIpamIpAddressesBulkUpdateRequest) Data(data WritableIPAddress) ApiIpamIpAddressesBulkUpdateRequest {
	r.data = &data
	return r
}

func (r ApiIpamIpAddressesBulkUpdateRequest) Execute() (*IPAddress, *http.Response, error) {
	return r.ApiService.IpamIpAddressesBulkUpdateExecute(r)
}

/*
IpamIpAddressesBulkUpdate Method for IpamIpAddressesBulkUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamIpAddressesBulkUpdateRequest
*/
func (a *IpamApiService) IpamIpAddressesBulkUpdate(ctx context.Context) ApiIpamIpAddressesBulkUpdateRequest {
	return ApiIpamIpAddressesBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return IPAddress
func (a *IpamApiService) IpamIpAddressesBulkUpdateExecute(r ApiIpamIpAddressesBulkUpdateRequest) (*IPAddress, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IPAddress
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamIpAddressesBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/ip-addresses/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamIpAddressesCreateRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	data *WritableIPAddress
}

func (r ApiIpamIpAddressesCreateRequest) Data(data WritableIPAddress) ApiIpamIpAddressesCreateRequest {
	r.data = &data
	return r
}

func (r ApiIpamIpAddressesCreateRequest) Execute() (*IPAddress, *http.Response, error) {
	return r.ApiService.IpamIpAddressesCreateExecute(r)
}

/*
IpamIpAddressesCreate Method for IpamIpAddressesCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamIpAddressesCreateRequest
*/
func (a *IpamApiService) IpamIpAddressesCreate(ctx context.Context) ApiIpamIpAddressesCreateRequest {
	return ApiIpamIpAddressesCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return IPAddress
func (a *IpamApiService) IpamIpAddressesCreateExecute(r ApiIpamIpAddressesCreateRequest) (*IPAddress, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IPAddress
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamIpAddressesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/ip-addresses/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamIpAddressesDeleteRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	id int32
}

func (r ApiIpamIpAddressesDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamIpAddressesDeleteExecute(r)
}

/*
IpamIpAddressesDelete Method for IpamIpAddressesDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this IP address.
 @return ApiIpamIpAddressesDeleteRequest
*/
func (a *IpamApiService) IpamIpAddressesDelete(ctx context.Context, id int32) ApiIpamIpAddressesDeleteRequest {
	return ApiIpamIpAddressesDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *IpamApiService) IpamIpAddressesDeleteExecute(r ApiIpamIpAddressesDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamIpAddressesDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/ip-addresses/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamIpAddressesListRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	id *string
	dnsName *string
	description *string
	created *string
	createdGte *string
	createdLte *string
	lastUpdated *string
	lastUpdatedGte *string
	lastUpdatedLte *string
	tenantGroupId *string
	tenantGroup *string
	tenantId *string
	tenant *string
	q *string
	family *float32
	parent *string
	address *string
	maskLength *float32
	vrfId *string
	vrf *string
	presentInVrfId *string
	presentInVrf *string
	device *string
	deviceId *string
	virtualMachine *string
	virtualMachineId *string
	interface_ *string
	interfaceId *string
	vminterface *string
	vminterfaceId *string
	assignedToInterface *string
	status *string
	role *string
	tag *string
	idN *string
	idLte *string
	idLt *string
	idGte *string
	idGt *string
	dnsNameN *string
	dnsNameIc *string
	dnsNameNic *string
	dnsNameIew *string
	dnsNameNiew *string
	dnsNameIsw *string
	dnsNameNisw *string
	dnsNameIe *string
	dnsNameNie *string
	dnsNameEmpty *string
	descriptionN *string
	descriptionIc *string
	descriptionNic *string
	descriptionIew *string
	descriptionNiew *string
	descriptionIsw *string
	descriptionNisw *string
	descriptionIe *string
	descriptionNie *string
	descriptionEmpty *string
	tenantGroupIdN *string
	tenantGroupN *string
	tenantIdN *string
	tenantN *string
	vrfIdN *string
	vrfN *string
	interfaceN *string
	interfaceIdN *string
	vminterfaceN *string
	vminterfaceIdN *string
	statusN *string
	roleN *string
	tagN *string
	limit *int32
	offset *int32
}

func (r ApiIpamIpAddressesListRequest) Id(id string) ApiIpamIpAddressesListRequest {
	r.id = &id
	return r
}

func (r ApiIpamIpAddressesListRequest) DnsName(dnsName string) ApiIpamIpAddressesListRequest {
	r.dnsName = &dnsName
	return r
}

func (r ApiIpamIpAddressesListRequest) Description(description string) ApiIpamIpAddressesListRequest {
	r.description = &description
	return r
}

func (r ApiIpamIpAddressesListRequest) Created(created string) ApiIpamIpAddressesListRequest {
	r.created = &created
	return r
}

func (r ApiIpamIpAddressesListRequest) CreatedGte(createdGte string) ApiIpamIpAddressesListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiIpamIpAddressesListRequest) CreatedLte(createdLte string) ApiIpamIpAddressesListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiIpamIpAddressesListRequest) LastUpdated(lastUpdated string) ApiIpamIpAddressesListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiIpamIpAddressesListRequest) LastUpdatedGte(lastUpdatedGte string) ApiIpamIpAddressesListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiIpamIpAddressesListRequest) LastUpdatedLte(lastUpdatedLte string) ApiIpamIpAddressesListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiIpamIpAddressesListRequest) TenantGroupId(tenantGroupId string) ApiIpamIpAddressesListRequest {
	r.tenantGroupId = &tenantGroupId
	return r
}

func (r ApiIpamIpAddressesListRequest) TenantGroup(tenantGroup string) ApiIpamIpAddressesListRequest {
	r.tenantGroup = &tenantGroup
	return r
}

func (r ApiIpamIpAddressesListRequest) TenantId(tenantId string) ApiIpamIpAddressesListRequest {
	r.tenantId = &tenantId
	return r
}

func (r ApiIpamIpAddressesListRequest) Tenant(tenant string) ApiIpamIpAddressesListRequest {
	r.tenant = &tenant
	return r
}

func (r ApiIpamIpAddressesListRequest) Q(q string) ApiIpamIpAddressesListRequest {
	r.q = &q
	return r
}

func (r ApiIpamIpAddressesListRequest) Family(family float32) ApiIpamIpAddressesListRequest {
	r.family = &family
	return r
}

func (r ApiIpamIpAddressesListRequest) Parent(parent string) ApiIpamIpAddressesListRequest {
	r.parent = &parent
	return r
}

func (r ApiIpamIpAddressesListRequest) Address(address string) ApiIpamIpAddressesListRequest {
	r.address = &address
	return r
}

func (r ApiIpamIpAddressesListRequest) MaskLength(maskLength float32) ApiIpamIpAddressesListRequest {
	r.maskLength = &maskLength
	return r
}

func (r ApiIpamIpAddressesListRequest) VrfId(vrfId string) ApiIpamIpAddressesListRequest {
	r.vrfId = &vrfId
	return r
}

func (r ApiIpamIpAddressesListRequest) Vrf(vrf string) ApiIpamIpAddressesListRequest {
	r.vrf = &vrf
	return r
}

func (r ApiIpamIpAddressesListRequest) PresentInVrfId(presentInVrfId string) ApiIpamIpAddressesListRequest {
	r.presentInVrfId = &presentInVrfId
	return r
}

func (r ApiIpamIpAddressesListRequest) PresentInVrf(presentInVrf string) ApiIpamIpAddressesListRequest {
	r.presentInVrf = &presentInVrf
	return r
}

func (r ApiIpamIpAddressesListRequest) Device(device string) ApiIpamIpAddressesListRequest {
	r.device = &device
	return r
}

func (r ApiIpamIpAddressesListRequest) DeviceId(deviceId string) ApiIpamIpAddressesListRequest {
	r.deviceId = &deviceId
	return r
}

func (r ApiIpamIpAddressesListRequest) VirtualMachine(virtualMachine string) ApiIpamIpAddressesListRequest {
	r.virtualMachine = &virtualMachine
	return r
}

func (r ApiIpamIpAddressesListRequest) VirtualMachineId(virtualMachineId string) ApiIpamIpAddressesListRequest {
	r.virtualMachineId = &virtualMachineId
	return r
}

func (r ApiIpamIpAddressesListRequest) Interface_(interface_ string) ApiIpamIpAddressesListRequest {
	r.interface_ = &interface_
	return r
}

func (r ApiIpamIpAddressesListRequest) InterfaceId(interfaceId string) ApiIpamIpAddressesListRequest {
	r.interfaceId = &interfaceId
	return r
}

func (r ApiIpamIpAddressesListRequest) Vminterface(vminterface string) ApiIpamIpAddressesListRequest {
	r.vminterface = &vminterface
	return r
}

func (r ApiIpamIpAddressesListRequest) VminterfaceId(vminterfaceId string) ApiIpamIpAddressesListRequest {
	r.vminterfaceId = &vminterfaceId
	return r
}

func (r ApiIpamIpAddressesListRequest) AssignedToInterface(assignedToInterface string) ApiIpamIpAddressesListRequest {
	r.assignedToInterface = &assignedToInterface
	return r
}

func (r ApiIpamIpAddressesListRequest) Status(status string) ApiIpamIpAddressesListRequest {
	r.status = &status
	return r
}

func (r ApiIpamIpAddressesListRequest) Role(role string) ApiIpamIpAddressesListRequest {
	r.role = &role
	return r
}

func (r ApiIpamIpAddressesListRequest) Tag(tag string) ApiIpamIpAddressesListRequest {
	r.tag = &tag
	return r
}

func (r ApiIpamIpAddressesListRequest) IdN(idN string) ApiIpamIpAddressesListRequest {
	r.idN = &idN
	return r
}

func (r ApiIpamIpAddressesListRequest) IdLte(idLte string) ApiIpamIpAddressesListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiIpamIpAddressesListRequest) IdLt(idLt string) ApiIpamIpAddressesListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiIpamIpAddressesListRequest) IdGte(idGte string) ApiIpamIpAddressesListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiIpamIpAddressesListRequest) IdGt(idGt string) ApiIpamIpAddressesListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiIpamIpAddressesListRequest) DnsNameN(dnsNameN string) ApiIpamIpAddressesListRequest {
	r.dnsNameN = &dnsNameN
	return r
}

func (r ApiIpamIpAddressesListRequest) DnsNameIc(dnsNameIc string) ApiIpamIpAddressesListRequest {
	r.dnsNameIc = &dnsNameIc
	return r
}

func (r ApiIpamIpAddressesListRequest) DnsNameNic(dnsNameNic string) ApiIpamIpAddressesListRequest {
	r.dnsNameNic = &dnsNameNic
	return r
}

func (r ApiIpamIpAddressesListRequest) DnsNameIew(dnsNameIew string) ApiIpamIpAddressesListRequest {
	r.dnsNameIew = &dnsNameIew
	return r
}

func (r ApiIpamIpAddressesListRequest) DnsNameNiew(dnsNameNiew string) ApiIpamIpAddressesListRequest {
	r.dnsNameNiew = &dnsNameNiew
	return r
}

func (r ApiIpamIpAddressesListRequest) DnsNameIsw(dnsNameIsw string) ApiIpamIpAddressesListRequest {
	r.dnsNameIsw = &dnsNameIsw
	return r
}

func (r ApiIpamIpAddressesListRequest) DnsNameNisw(dnsNameNisw string) ApiIpamIpAddressesListRequest {
	r.dnsNameNisw = &dnsNameNisw
	return r
}

func (r ApiIpamIpAddressesListRequest) DnsNameIe(dnsNameIe string) ApiIpamIpAddressesListRequest {
	r.dnsNameIe = &dnsNameIe
	return r
}

func (r ApiIpamIpAddressesListRequest) DnsNameNie(dnsNameNie string) ApiIpamIpAddressesListRequest {
	r.dnsNameNie = &dnsNameNie
	return r
}

func (r ApiIpamIpAddressesListRequest) DnsNameEmpty(dnsNameEmpty string) ApiIpamIpAddressesListRequest {
	r.dnsNameEmpty = &dnsNameEmpty
	return r
}

func (r ApiIpamIpAddressesListRequest) DescriptionN(descriptionN string) ApiIpamIpAddressesListRequest {
	r.descriptionN = &descriptionN
	return r
}

func (r ApiIpamIpAddressesListRequest) DescriptionIc(descriptionIc string) ApiIpamIpAddressesListRequest {
	r.descriptionIc = &descriptionIc
	return r
}

func (r ApiIpamIpAddressesListRequest) DescriptionNic(descriptionNic string) ApiIpamIpAddressesListRequest {
	r.descriptionNic = &descriptionNic
	return r
}

func (r ApiIpamIpAddressesListRequest) DescriptionIew(descriptionIew string) ApiIpamIpAddressesListRequest {
	r.descriptionIew = &descriptionIew
	return r
}

func (r ApiIpamIpAddressesListRequest) DescriptionNiew(descriptionNiew string) ApiIpamIpAddressesListRequest {
	r.descriptionNiew = &descriptionNiew
	return r
}

func (r ApiIpamIpAddressesListRequest) DescriptionIsw(descriptionIsw string) ApiIpamIpAddressesListRequest {
	r.descriptionIsw = &descriptionIsw
	return r
}

func (r ApiIpamIpAddressesListRequest) DescriptionNisw(descriptionNisw string) ApiIpamIpAddressesListRequest {
	r.descriptionNisw = &descriptionNisw
	return r
}

func (r ApiIpamIpAddressesListRequest) DescriptionIe(descriptionIe string) ApiIpamIpAddressesListRequest {
	r.descriptionIe = &descriptionIe
	return r
}

func (r ApiIpamIpAddressesListRequest) DescriptionNie(descriptionNie string) ApiIpamIpAddressesListRequest {
	r.descriptionNie = &descriptionNie
	return r
}

func (r ApiIpamIpAddressesListRequest) DescriptionEmpty(descriptionEmpty string) ApiIpamIpAddressesListRequest {
	r.descriptionEmpty = &descriptionEmpty
	return r
}

func (r ApiIpamIpAddressesListRequest) TenantGroupIdN(tenantGroupIdN string) ApiIpamIpAddressesListRequest {
	r.tenantGroupIdN = &tenantGroupIdN
	return r
}

func (r ApiIpamIpAddressesListRequest) TenantGroupN(tenantGroupN string) ApiIpamIpAddressesListRequest {
	r.tenantGroupN = &tenantGroupN
	return r
}

func (r ApiIpamIpAddressesListRequest) TenantIdN(tenantIdN string) ApiIpamIpAddressesListRequest {
	r.tenantIdN = &tenantIdN
	return r
}

func (r ApiIpamIpAddressesListRequest) TenantN(tenantN string) ApiIpamIpAddressesListRequest {
	r.tenantN = &tenantN
	return r
}

func (r ApiIpamIpAddressesListRequest) VrfIdN(vrfIdN string) ApiIpamIpAddressesListRequest {
	r.vrfIdN = &vrfIdN
	return r
}

func (r ApiIpamIpAddressesListRequest) VrfN(vrfN string) ApiIpamIpAddressesListRequest {
	r.vrfN = &vrfN
	return r
}

func (r ApiIpamIpAddressesListRequest) InterfaceN(interfaceN string) ApiIpamIpAddressesListRequest {
	r.interfaceN = &interfaceN
	return r
}

func (r ApiIpamIpAddressesListRequest) InterfaceIdN(interfaceIdN string) ApiIpamIpAddressesListRequest {
	r.interfaceIdN = &interfaceIdN
	return r
}

func (r ApiIpamIpAddressesListRequest) VminterfaceN(vminterfaceN string) ApiIpamIpAddressesListRequest {
	r.vminterfaceN = &vminterfaceN
	return r
}

func (r ApiIpamIpAddressesListRequest) VminterfaceIdN(vminterfaceIdN string) ApiIpamIpAddressesListRequest {
	r.vminterfaceIdN = &vminterfaceIdN
	return r
}

func (r ApiIpamIpAddressesListRequest) StatusN(statusN string) ApiIpamIpAddressesListRequest {
	r.statusN = &statusN
	return r
}

func (r ApiIpamIpAddressesListRequest) RoleN(roleN string) ApiIpamIpAddressesListRequest {
	r.roleN = &roleN
	return r
}

func (r ApiIpamIpAddressesListRequest) TagN(tagN string) ApiIpamIpAddressesListRequest {
	r.tagN = &tagN
	return r
}

// Number of results to return per page.
func (r ApiIpamIpAddressesListRequest) Limit(limit int32) ApiIpamIpAddressesListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiIpamIpAddressesListRequest) Offset(offset int32) ApiIpamIpAddressesListRequest {
	r.offset = &offset
	return r
}

func (r ApiIpamIpAddressesListRequest) Execute() (*IpamIpAddressesList200Response, *http.Response, error) {
	return r.ApiService.IpamIpAddressesListExecute(r)
}

/*
IpamIpAddressesList Method for IpamIpAddressesList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamIpAddressesListRequest
*/
func (a *IpamApiService) IpamIpAddressesList(ctx context.Context) ApiIpamIpAddressesListRequest {
	return ApiIpamIpAddressesListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return IpamIpAddressesList200Response
func (a *IpamApiService) IpamIpAddressesListExecute(r ApiIpamIpAddressesListRequest) (*IpamIpAddressesList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IpamIpAddressesList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamIpAddressesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/ip-addresses/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.dnsName != nil {
		localVarQueryParams.Add("dns_name", parameterToString(*r.dnsName, ""))
	}
	if r.description != nil {
		localVarQueryParams.Add("description", parameterToString(*r.description, ""))
	}
	if r.created != nil {
		localVarQueryParams.Add("created", parameterToString(*r.created, ""))
	}
	if r.createdGte != nil {
		localVarQueryParams.Add("created__gte", parameterToString(*r.createdGte, ""))
	}
	if r.createdLte != nil {
		localVarQueryParams.Add("created__lte", parameterToString(*r.createdLte, ""))
	}
	if r.lastUpdated != nil {
		localVarQueryParams.Add("last_updated", parameterToString(*r.lastUpdated, ""))
	}
	if r.lastUpdatedGte != nil {
		localVarQueryParams.Add("last_updated__gte", parameterToString(*r.lastUpdatedGte, ""))
	}
	if r.lastUpdatedLte != nil {
		localVarQueryParams.Add("last_updated__lte", parameterToString(*r.lastUpdatedLte, ""))
	}
	if r.tenantGroupId != nil {
		localVarQueryParams.Add("tenant_group_id", parameterToString(*r.tenantGroupId, ""))
	}
	if r.tenantGroup != nil {
		localVarQueryParams.Add("tenant_group", parameterToString(*r.tenantGroup, ""))
	}
	if r.tenantId != nil {
		localVarQueryParams.Add("tenant_id", parameterToString(*r.tenantId, ""))
	}
	if r.tenant != nil {
		localVarQueryParams.Add("tenant", parameterToString(*r.tenant, ""))
	}
	if r.q != nil {
		localVarQueryParams.Add("q", parameterToString(*r.q, ""))
	}
	if r.family != nil {
		localVarQueryParams.Add("family", parameterToString(*r.family, ""))
	}
	if r.parent != nil {
		localVarQueryParams.Add("parent", parameterToString(*r.parent, ""))
	}
	if r.address != nil {
		localVarQueryParams.Add("address", parameterToString(*r.address, ""))
	}
	if r.maskLength != nil {
		localVarQueryParams.Add("mask_length", parameterToString(*r.maskLength, ""))
	}
	if r.vrfId != nil {
		localVarQueryParams.Add("vrf_id", parameterToString(*r.vrfId, ""))
	}
	if r.vrf != nil {
		localVarQueryParams.Add("vrf", parameterToString(*r.vrf, ""))
	}
	if r.presentInVrfId != nil {
		localVarQueryParams.Add("present_in_vrf_id", parameterToString(*r.presentInVrfId, ""))
	}
	if r.presentInVrf != nil {
		localVarQueryParams.Add("present_in_vrf", parameterToString(*r.presentInVrf, ""))
	}
	if r.device != nil {
		localVarQueryParams.Add("device", parameterToString(*r.device, ""))
	}
	if r.deviceId != nil {
		localVarQueryParams.Add("device_id", parameterToString(*r.deviceId, ""))
	}
	if r.virtualMachine != nil {
		localVarQueryParams.Add("virtual_machine", parameterToString(*r.virtualMachine, ""))
	}
	if r.virtualMachineId != nil {
		localVarQueryParams.Add("virtual_machine_id", parameterToString(*r.virtualMachineId, ""))
	}
	if r.interface_ != nil {
		localVarQueryParams.Add("interface", parameterToString(*r.interface_, ""))
	}
	if r.interfaceId != nil {
		localVarQueryParams.Add("interface_id", parameterToString(*r.interfaceId, ""))
	}
	if r.vminterface != nil {
		localVarQueryParams.Add("vminterface", parameterToString(*r.vminterface, ""))
	}
	if r.vminterfaceId != nil {
		localVarQueryParams.Add("vminterface_id", parameterToString(*r.vminterfaceId, ""))
	}
	if r.assignedToInterface != nil {
		localVarQueryParams.Add("assigned_to_interface", parameterToString(*r.assignedToInterface, ""))
	}
	if r.status != nil {
		localVarQueryParams.Add("status", parameterToString(*r.status, ""))
	}
	if r.role != nil {
		localVarQueryParams.Add("role", parameterToString(*r.role, ""))
	}
	if r.tag != nil {
		localVarQueryParams.Add("tag", parameterToString(*r.tag, ""))
	}
	if r.idN != nil {
		localVarQueryParams.Add("id__n", parameterToString(*r.idN, ""))
	}
	if r.idLte != nil {
		localVarQueryParams.Add("id__lte", parameterToString(*r.idLte, ""))
	}
	if r.idLt != nil {
		localVarQueryParams.Add("id__lt", parameterToString(*r.idLt, ""))
	}
	if r.idGte != nil {
		localVarQueryParams.Add("id__gte", parameterToString(*r.idGte, ""))
	}
	if r.idGt != nil {
		localVarQueryParams.Add("id__gt", parameterToString(*r.idGt, ""))
	}
	if r.dnsNameN != nil {
		localVarQueryParams.Add("dns_name__n", parameterToString(*r.dnsNameN, ""))
	}
	if r.dnsNameIc != nil {
		localVarQueryParams.Add("dns_name__ic", parameterToString(*r.dnsNameIc, ""))
	}
	if r.dnsNameNic != nil {
		localVarQueryParams.Add("dns_name__nic", parameterToString(*r.dnsNameNic, ""))
	}
	if r.dnsNameIew != nil {
		localVarQueryParams.Add("dns_name__iew", parameterToString(*r.dnsNameIew, ""))
	}
	if r.dnsNameNiew != nil {
		localVarQueryParams.Add("dns_name__niew", parameterToString(*r.dnsNameNiew, ""))
	}
	if r.dnsNameIsw != nil {
		localVarQueryParams.Add("dns_name__isw", parameterToString(*r.dnsNameIsw, ""))
	}
	if r.dnsNameNisw != nil {
		localVarQueryParams.Add("dns_name__nisw", parameterToString(*r.dnsNameNisw, ""))
	}
	if r.dnsNameIe != nil {
		localVarQueryParams.Add("dns_name__ie", parameterToString(*r.dnsNameIe, ""))
	}
	if r.dnsNameNie != nil {
		localVarQueryParams.Add("dns_name__nie", parameterToString(*r.dnsNameNie, ""))
	}
	if r.dnsNameEmpty != nil {
		localVarQueryParams.Add("dns_name__empty", parameterToString(*r.dnsNameEmpty, ""))
	}
	if r.descriptionN != nil {
		localVarQueryParams.Add("description__n", parameterToString(*r.descriptionN, ""))
	}
	if r.descriptionIc != nil {
		localVarQueryParams.Add("description__ic", parameterToString(*r.descriptionIc, ""))
	}
	if r.descriptionNic != nil {
		localVarQueryParams.Add("description__nic", parameterToString(*r.descriptionNic, ""))
	}
	if r.descriptionIew != nil {
		localVarQueryParams.Add("description__iew", parameterToString(*r.descriptionIew, ""))
	}
	if r.descriptionNiew != nil {
		localVarQueryParams.Add("description__niew", parameterToString(*r.descriptionNiew, ""))
	}
	if r.descriptionIsw != nil {
		localVarQueryParams.Add("description__isw", parameterToString(*r.descriptionIsw, ""))
	}
	if r.descriptionNisw != nil {
		localVarQueryParams.Add("description__nisw", parameterToString(*r.descriptionNisw, ""))
	}
	if r.descriptionIe != nil {
		localVarQueryParams.Add("description__ie", parameterToString(*r.descriptionIe, ""))
	}
	if r.descriptionNie != nil {
		localVarQueryParams.Add("description__nie", parameterToString(*r.descriptionNie, ""))
	}
	if r.descriptionEmpty != nil {
		localVarQueryParams.Add("description__empty", parameterToString(*r.descriptionEmpty, ""))
	}
	if r.tenantGroupIdN != nil {
		localVarQueryParams.Add("tenant_group_id__n", parameterToString(*r.tenantGroupIdN, ""))
	}
	if r.tenantGroupN != nil {
		localVarQueryParams.Add("tenant_group__n", parameterToString(*r.tenantGroupN, ""))
	}
	if r.tenantIdN != nil {
		localVarQueryParams.Add("tenant_id__n", parameterToString(*r.tenantIdN, ""))
	}
	if r.tenantN != nil {
		localVarQueryParams.Add("tenant__n", parameterToString(*r.tenantN, ""))
	}
	if r.vrfIdN != nil {
		localVarQueryParams.Add("vrf_id__n", parameterToString(*r.vrfIdN, ""))
	}
	if r.vrfN != nil {
		localVarQueryParams.Add("vrf__n", parameterToString(*r.vrfN, ""))
	}
	if r.interfaceN != nil {
		localVarQueryParams.Add("interface__n", parameterToString(*r.interfaceN, ""))
	}
	if r.interfaceIdN != nil {
		localVarQueryParams.Add("interface_id__n", parameterToString(*r.interfaceIdN, ""))
	}
	if r.vminterfaceN != nil {
		localVarQueryParams.Add("vminterface__n", parameterToString(*r.vminterfaceN, ""))
	}
	if r.vminterfaceIdN != nil {
		localVarQueryParams.Add("vminterface_id__n", parameterToString(*r.vminterfaceIdN, ""))
	}
	if r.statusN != nil {
		localVarQueryParams.Add("status__n", parameterToString(*r.statusN, ""))
	}
	if r.roleN != nil {
		localVarQueryParams.Add("role__n", parameterToString(*r.roleN, ""))
	}
	if r.tagN != nil {
		localVarQueryParams.Add("tag__n", parameterToString(*r.tagN, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamIpAddressesPartialUpdateRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	id int32
	data *WritableIPAddress
}

func (r ApiIpamIpAddressesPartialUpdateRequest) Data(data WritableIPAddress) ApiIpamIpAddressesPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiIpamIpAddressesPartialUpdateRequest) Execute() (*IPAddress, *http.Response, error) {
	return r.ApiService.IpamIpAddressesPartialUpdateExecute(r)
}

/*
IpamIpAddressesPartialUpdate Method for IpamIpAddressesPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this IP address.
 @return ApiIpamIpAddressesPartialUpdateRequest
*/
func (a *IpamApiService) IpamIpAddressesPartialUpdate(ctx context.Context, id int32) ApiIpamIpAddressesPartialUpdateRequest {
	return ApiIpamIpAddressesPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return IPAddress
func (a *IpamApiService) IpamIpAddressesPartialUpdateExecute(r ApiIpamIpAddressesPartialUpdateRequest) (*IPAddress, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IPAddress
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamIpAddressesPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/ip-addresses/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamIpAddressesReadRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	id int32
}

func (r ApiIpamIpAddressesReadRequest) Execute() (*IPAddress, *http.Response, error) {
	return r.ApiService.IpamIpAddressesReadExecute(r)
}

/*
IpamIpAddressesRead Method for IpamIpAddressesRead

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this IP address.
 @return ApiIpamIpAddressesReadRequest
*/
func (a *IpamApiService) IpamIpAddressesRead(ctx context.Context, id int32) ApiIpamIpAddressesReadRequest {
	return ApiIpamIpAddressesReadRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return IPAddress
func (a *IpamApiService) IpamIpAddressesReadExecute(r ApiIpamIpAddressesReadRequest) (*IPAddress, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IPAddress
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamIpAddressesRead")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/ip-addresses/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamIpAddressesUpdateRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	id int32
	data *WritableIPAddress
}

func (r ApiIpamIpAddressesUpdateRequest) Data(data WritableIPAddress) ApiIpamIpAddressesUpdateRequest {
	r.data = &data
	return r
}

func (r ApiIpamIpAddressesUpdateRequest) Execute() (*IPAddress, *http.Response, error) {
	return r.ApiService.IpamIpAddressesUpdateExecute(r)
}

/*
IpamIpAddressesUpdate Method for IpamIpAddressesUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this IP address.
 @return ApiIpamIpAddressesUpdateRequest
*/
func (a *IpamApiService) IpamIpAddressesUpdate(ctx context.Context, id int32) ApiIpamIpAddressesUpdateRequest {
	return ApiIpamIpAddressesUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return IPAddress
func (a *IpamApiService) IpamIpAddressesUpdateExecute(r ApiIpamIpAddressesUpdateRequest) (*IPAddress, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IPAddress
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamIpAddressesUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/ip-addresses/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamPrefixesAvailableIpsCreateRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	id int32
	data *[]AvailableIP
}

func (r ApiIpamPrefixesAvailableIpsCreateRequest) Data(data []AvailableIP) ApiIpamPrefixesAvailableIpsCreateRequest {
	r.data = &data
	return r
}

func (r ApiIpamPrefixesAvailableIpsCreateRequest) Execute() ([]AvailableIP, *http.Response, error) {
	return r.ApiService.IpamPrefixesAvailableIpsCreateExecute(r)
}

/*
IpamPrefixesAvailableIpsCreate Method for IpamPrefixesAvailableIpsCreate

A convenience method for returning available IP addresses within a prefix. By default, the number of IPs
returned will be equivalent to PAGINATE_COUNT. An arbitrary limit (up to MAX_PAGE_SIZE, if set) may be passed,
however results will not be paginated.

The advisory lock decorator uses a PostgreSQL advisory lock to prevent this API from being
invoked in parallel, which results in a race condition where multiple insertions can occur.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this prefix.
 @return ApiIpamPrefixesAvailableIpsCreateRequest
*/
func (a *IpamApiService) IpamPrefixesAvailableIpsCreate(ctx context.Context, id int32) ApiIpamPrefixesAvailableIpsCreateRequest {
	return ApiIpamPrefixesAvailableIpsCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return []AvailableIP
func (a *IpamApiService) IpamPrefixesAvailableIpsCreateExecute(r ApiIpamPrefixesAvailableIpsCreateRequest) ([]AvailableIP, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []AvailableIP
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamPrefixesAvailableIpsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/prefixes/{id}/available-ips/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamPrefixesAvailableIpsReadRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	id int32
}

func (r ApiIpamPrefixesAvailableIpsReadRequest) Execute() ([]AvailableIP, *http.Response, error) {
	return r.ApiService.IpamPrefixesAvailableIpsReadExecute(r)
}

/*
IpamPrefixesAvailableIpsRead Method for IpamPrefixesAvailableIpsRead

A convenience method for returning available IP addresses within a prefix. By default, the number of IPs
returned will be equivalent to PAGINATE_COUNT. An arbitrary limit (up to MAX_PAGE_SIZE, if set) may be passed,
however results will not be paginated.

The advisory lock decorator uses a PostgreSQL advisory lock to prevent this API from being
invoked in parallel, which results in a race condition where multiple insertions can occur.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this prefix.
 @return ApiIpamPrefixesAvailableIpsReadRequest
*/
func (a *IpamApiService) IpamPrefixesAvailableIpsRead(ctx context.Context, id int32) ApiIpamPrefixesAvailableIpsReadRequest {
	return ApiIpamPrefixesAvailableIpsReadRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return []AvailableIP
func (a *IpamApiService) IpamPrefixesAvailableIpsReadExecute(r ApiIpamPrefixesAvailableIpsReadRequest) ([]AvailableIP, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []AvailableIP
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamPrefixesAvailableIpsRead")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/prefixes/{id}/available-ips/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamPrefixesAvailablePrefixesCreateRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	id int32
	data *PrefixLength
}

func (r ApiIpamPrefixesAvailablePrefixesCreateRequest) Data(data PrefixLength) ApiIpamPrefixesAvailablePrefixesCreateRequest {
	r.data = &data
	return r
}

func (r ApiIpamPrefixesAvailablePrefixesCreateRequest) Execute() (*Prefix, *http.Response, error) {
	return r.ApiService.IpamPrefixesAvailablePrefixesCreateExecute(r)
}

/*
IpamPrefixesAvailablePrefixesCreate A convenience method for returning available child prefixes within a parent.

The advisory lock decorator uses a PostgreSQL advisory lock to prevent this API from being
invoked in parallel, which results in a race condition where multiple insertions can occur.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this prefix.
 @return ApiIpamPrefixesAvailablePrefixesCreateRequest
*/
func (a *IpamApiService) IpamPrefixesAvailablePrefixesCreate(ctx context.Context, id int32) ApiIpamPrefixesAvailablePrefixesCreateRequest {
	return ApiIpamPrefixesAvailablePrefixesCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Prefix
func (a *IpamApiService) IpamPrefixesAvailablePrefixesCreateExecute(r ApiIpamPrefixesAvailablePrefixesCreateRequest) (*Prefix, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Prefix
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamPrefixesAvailablePrefixesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/prefixes/{id}/available-prefixes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamPrefixesAvailablePrefixesReadRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	id int32
}

func (r ApiIpamPrefixesAvailablePrefixesReadRequest) Execute() ([]AvailablePrefix, *http.Response, error) {
	return r.ApiService.IpamPrefixesAvailablePrefixesReadExecute(r)
}

/*
IpamPrefixesAvailablePrefixesRead A convenience method for returning available child prefixes within a parent.

The advisory lock decorator uses a PostgreSQL advisory lock to prevent this API from being
invoked in parallel, which results in a race condition where multiple insertions can occur.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this prefix.
 @return ApiIpamPrefixesAvailablePrefixesReadRequest
*/
func (a *IpamApiService) IpamPrefixesAvailablePrefixesRead(ctx context.Context, id int32) ApiIpamPrefixesAvailablePrefixesReadRequest {
	return ApiIpamPrefixesAvailablePrefixesReadRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return []AvailablePrefix
func (a *IpamApiService) IpamPrefixesAvailablePrefixesReadExecute(r ApiIpamPrefixesAvailablePrefixesReadRequest) ([]AvailablePrefix, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []AvailablePrefix
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamPrefixesAvailablePrefixesRead")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/prefixes/{id}/available-prefixes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamPrefixesBulkDeleteRequest struct {
	ctx context.Context
	ApiService *IpamApiService
}

func (r ApiIpamPrefixesBulkDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamPrefixesBulkDeleteExecute(r)
}

/*
IpamPrefixesBulkDelete Method for IpamPrefixesBulkDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamPrefixesBulkDeleteRequest
*/
func (a *IpamApiService) IpamPrefixesBulkDelete(ctx context.Context) ApiIpamPrefixesBulkDeleteRequest {
	return ApiIpamPrefixesBulkDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *IpamApiService) IpamPrefixesBulkDeleteExecute(r ApiIpamPrefixesBulkDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamPrefixesBulkDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/prefixes/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamPrefixesBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	data *WritablePrefix
}

func (r ApiIpamPrefixesBulkPartialUpdateRequest) Data(data WritablePrefix) ApiIpamPrefixesBulkPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiIpamPrefixesBulkPartialUpdateRequest) Execute() (*Prefix, *http.Response, error) {
	return r.ApiService.IpamPrefixesBulkPartialUpdateExecute(r)
}

/*
IpamPrefixesBulkPartialUpdate Method for IpamPrefixesBulkPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamPrefixesBulkPartialUpdateRequest
*/
func (a *IpamApiService) IpamPrefixesBulkPartialUpdate(ctx context.Context) ApiIpamPrefixesBulkPartialUpdateRequest {
	return ApiIpamPrefixesBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Prefix
func (a *IpamApiService) IpamPrefixesBulkPartialUpdateExecute(r ApiIpamPrefixesBulkPartialUpdateRequest) (*Prefix, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Prefix
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamPrefixesBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/prefixes/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamPrefixesBulkUpdateRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	data *WritablePrefix
}

func (r ApiIpamPrefixesBulkUpdateRequest) Data(data WritablePrefix) ApiIpamPrefixesBulkUpdateRequest {
	r.data = &data
	return r
}

func (r ApiIpamPrefixesBulkUpdateRequest) Execute() (*Prefix, *http.Response, error) {
	return r.ApiService.IpamPrefixesBulkUpdateExecute(r)
}

/*
IpamPrefixesBulkUpdate Method for IpamPrefixesBulkUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamPrefixesBulkUpdateRequest
*/
func (a *IpamApiService) IpamPrefixesBulkUpdate(ctx context.Context) ApiIpamPrefixesBulkUpdateRequest {
	return ApiIpamPrefixesBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Prefix
func (a *IpamApiService) IpamPrefixesBulkUpdateExecute(r ApiIpamPrefixesBulkUpdateRequest) (*Prefix, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Prefix
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamPrefixesBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/prefixes/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamPrefixesCreateRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	data *WritablePrefix
}

func (r ApiIpamPrefixesCreateRequest) Data(data WritablePrefix) ApiIpamPrefixesCreateRequest {
	r.data = &data
	return r
}

func (r ApiIpamPrefixesCreateRequest) Execute() (*Prefix, *http.Response, error) {
	return r.ApiService.IpamPrefixesCreateExecute(r)
}

/*
IpamPrefixesCreate Method for IpamPrefixesCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamPrefixesCreateRequest
*/
func (a *IpamApiService) IpamPrefixesCreate(ctx context.Context) ApiIpamPrefixesCreateRequest {
	return ApiIpamPrefixesCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Prefix
func (a *IpamApiService) IpamPrefixesCreateExecute(r ApiIpamPrefixesCreateRequest) (*Prefix, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Prefix
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamPrefixesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/prefixes/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamPrefixesDeleteRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	id int32
}

func (r ApiIpamPrefixesDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamPrefixesDeleteExecute(r)
}

/*
IpamPrefixesDelete Method for IpamPrefixesDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this prefix.
 @return ApiIpamPrefixesDeleteRequest
*/
func (a *IpamApiService) IpamPrefixesDelete(ctx context.Context, id int32) ApiIpamPrefixesDeleteRequest {
	return ApiIpamPrefixesDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *IpamApiService) IpamPrefixesDeleteExecute(r ApiIpamPrefixesDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamPrefixesDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/prefixes/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamPrefixesListRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	id *[]string
	isPool *string
	created *string
	createdGte *string
	createdLte *string
	lastUpdated *string
	lastUpdatedGte *string
	lastUpdatedLte *string
	tenantGroupId *string
	tenantGroup *string
	tenantId *string
	tenant *string
	q *string
	family *float32
	prefix *string
	within *string
	withinInclude *string
	contains *string
	depth *string
	children *string
	maskLength *float32
	maskLengthGte *float32
	maskLengthLte *float32
	vrfId *string
	vrf *string
	presentInVrfId *string
	presentInVrf *string
	regionId *string
	region *string
	siteGroupId *string
	siteGroup *string
	siteId *string
	site *string
	vlanId *string
	vlanVid *float32
	roleId *string
	role *string
	status *string
	tag *string
	idN *string
	idLte *string
	idLt *string
	idGte *string
	idGt *string
	tenantGroupIdN *string
	tenantGroupN *string
	tenantIdN *string
	tenantN *string
	depthN *string
	depthLte *string
	depthLt *string
	depthGte *string
	depthGt *string
	childrenN *string
	childrenLte *string
	childrenLt *string
	childrenGte *string
	childrenGt *string
	vrfIdN *string
	vrfN *string
	regionIdN *string
	regionN *string
	siteGroupIdN *string
	siteGroupN *string
	siteIdN *string
	siteN *string
	vlanIdN *string
	roleIdN *string
	roleN *string
	statusN *string
	tagN *string
	limit *int32
	offset *int32
}

func (r ApiIpamPrefixesListRequest) Id(id []string) ApiIpamPrefixesListRequest {
	r.id = &id
	return r
}

func (r ApiIpamPrefixesListRequest) IsPool(isPool string) ApiIpamPrefixesListRequest {
	r.isPool = &isPool
	return r
}

func (r ApiIpamPrefixesListRequest) Created(created string) ApiIpamPrefixesListRequest {
	r.created = &created
	return r
}

func (r ApiIpamPrefixesListRequest) CreatedGte(createdGte string) ApiIpamPrefixesListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiIpamPrefixesListRequest) CreatedLte(createdLte string) ApiIpamPrefixesListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiIpamPrefixesListRequest) LastUpdated(lastUpdated string) ApiIpamPrefixesListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiIpamPrefixesListRequest) LastUpdatedGte(lastUpdatedGte string) ApiIpamPrefixesListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiIpamPrefixesListRequest) LastUpdatedLte(lastUpdatedLte string) ApiIpamPrefixesListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiIpamPrefixesListRequest) TenantGroupId(tenantGroupId string) ApiIpamPrefixesListRequest {
	r.tenantGroupId = &tenantGroupId
	return r
}

func (r ApiIpamPrefixesListRequest) TenantGroup(tenantGroup string) ApiIpamPrefixesListRequest {
	r.tenantGroup = &tenantGroup
	return r
}

func (r ApiIpamPrefixesListRequest) TenantId(tenantId string) ApiIpamPrefixesListRequest {
	r.tenantId = &tenantId
	return r
}

func (r ApiIpamPrefixesListRequest) Tenant(tenant string) ApiIpamPrefixesListRequest {
	r.tenant = &tenant
	return r
}

func (r ApiIpamPrefixesListRequest) Q(q string) ApiIpamPrefixesListRequest {
	r.q = &q
	return r
}

func (r ApiIpamPrefixesListRequest) Family(family float32) ApiIpamPrefixesListRequest {
	r.family = &family
	return r
}

func (r ApiIpamPrefixesListRequest) Prefix(prefix string) ApiIpamPrefixesListRequest {
	r.prefix = &prefix
	return r
}

func (r ApiIpamPrefixesListRequest) Within(within string) ApiIpamPrefixesListRequest {
	r.within = &within
	return r
}

func (r ApiIpamPrefixesListRequest) WithinInclude(withinInclude string) ApiIpamPrefixesListRequest {
	r.withinInclude = &withinInclude
	return r
}

func (r ApiIpamPrefixesListRequest) Contains(contains string) ApiIpamPrefixesListRequest {
	r.contains = &contains
	return r
}

func (r ApiIpamPrefixesListRequest) Depth(depth string) ApiIpamPrefixesListRequest {
	r.depth = &depth
	return r
}

func (r ApiIpamPrefixesListRequest) Children(children string) ApiIpamPrefixesListRequest {
	r.children = &children
	return r
}

func (r ApiIpamPrefixesListRequest) MaskLength(maskLength float32) ApiIpamPrefixesListRequest {
	r.maskLength = &maskLength
	return r
}

func (r ApiIpamPrefixesListRequest) MaskLengthGte(maskLengthGte float32) ApiIpamPrefixesListRequest {
	r.maskLengthGte = &maskLengthGte
	return r
}

func (r ApiIpamPrefixesListRequest) MaskLengthLte(maskLengthLte float32) ApiIpamPrefixesListRequest {
	r.maskLengthLte = &maskLengthLte
	return r
}

func (r ApiIpamPrefixesListRequest) VrfId(vrfId string) ApiIpamPrefixesListRequest {
	r.vrfId = &vrfId
	return r
}

func (r ApiIpamPrefixesListRequest) Vrf(vrf string) ApiIpamPrefixesListRequest {
	r.vrf = &vrf
	return r
}

func (r ApiIpamPrefixesListRequest) PresentInVrfId(presentInVrfId string) ApiIpamPrefixesListRequest {
	r.presentInVrfId = &presentInVrfId
	return r
}

func (r ApiIpamPrefixesListRequest) PresentInVrf(presentInVrf string) ApiIpamPrefixesListRequest {
	r.presentInVrf = &presentInVrf
	return r
}

func (r ApiIpamPrefixesListRequest) RegionId(regionId string) ApiIpamPrefixesListRequest {
	r.regionId = &regionId
	return r
}

func (r ApiIpamPrefixesListRequest) Region(region string) ApiIpamPrefixesListRequest {
	r.region = &region
	return r
}

func (r ApiIpamPrefixesListRequest) SiteGroupId(siteGroupId string) ApiIpamPrefixesListRequest {
	r.siteGroupId = &siteGroupId
	return r
}

func (r ApiIpamPrefixesListRequest) SiteGroup(siteGroup string) ApiIpamPrefixesListRequest {
	r.siteGroup = &siteGroup
	return r
}

func (r ApiIpamPrefixesListRequest) SiteId(siteId string) ApiIpamPrefixesListRequest {
	r.siteId = &siteId
	return r
}

func (r ApiIpamPrefixesListRequest) Site(site string) ApiIpamPrefixesListRequest {
	r.site = &site
	return r
}

func (r ApiIpamPrefixesListRequest) VlanId(vlanId string) ApiIpamPrefixesListRequest {
	r.vlanId = &vlanId
	return r
}

func (r ApiIpamPrefixesListRequest) VlanVid(vlanVid float32) ApiIpamPrefixesListRequest {
	r.vlanVid = &vlanVid
	return r
}

func (r ApiIpamPrefixesListRequest) RoleId(roleId string) ApiIpamPrefixesListRequest {
	r.roleId = &roleId
	return r
}

func (r ApiIpamPrefixesListRequest) Role(role string) ApiIpamPrefixesListRequest {
	r.role = &role
	return r
}

func (r ApiIpamPrefixesListRequest) Status(status string) ApiIpamPrefixesListRequest {
	r.status = &status
	return r
}

func (r ApiIpamPrefixesListRequest) Tag(tag string) ApiIpamPrefixesListRequest {
	r.tag = &tag
	return r
}

func (r ApiIpamPrefixesListRequest) IdN(idN string) ApiIpamPrefixesListRequest {
	r.idN = &idN
	return r
}

func (r ApiIpamPrefixesListRequest) IdLte(idLte string) ApiIpamPrefixesListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiIpamPrefixesListRequest) IdLt(idLt string) ApiIpamPrefixesListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiIpamPrefixesListRequest) IdGte(idGte string) ApiIpamPrefixesListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiIpamPrefixesListRequest) IdGt(idGt string) ApiIpamPrefixesListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiIpamPrefixesListRequest) TenantGroupIdN(tenantGroupIdN string) ApiIpamPrefixesListRequest {
	r.tenantGroupIdN = &tenantGroupIdN
	return r
}

func (r ApiIpamPrefixesListRequest) TenantGroupN(tenantGroupN string) ApiIpamPrefixesListRequest {
	r.tenantGroupN = &tenantGroupN
	return r
}

func (r ApiIpamPrefixesListRequest) TenantIdN(tenantIdN string) ApiIpamPrefixesListRequest {
	r.tenantIdN = &tenantIdN
	return r
}

func (r ApiIpamPrefixesListRequest) TenantN(tenantN string) ApiIpamPrefixesListRequest {
	r.tenantN = &tenantN
	return r
}

func (r ApiIpamPrefixesListRequest) DepthN(depthN string) ApiIpamPrefixesListRequest {
	r.depthN = &depthN
	return r
}

func (r ApiIpamPrefixesListRequest) DepthLte(depthLte string) ApiIpamPrefixesListRequest {
	r.depthLte = &depthLte
	return r
}

func (r ApiIpamPrefixesListRequest) DepthLt(depthLt string) ApiIpamPrefixesListRequest {
	r.depthLt = &depthLt
	return r
}

func (r ApiIpamPrefixesListRequest) DepthGte(depthGte string) ApiIpamPrefixesListRequest {
	r.depthGte = &depthGte
	return r
}

func (r ApiIpamPrefixesListRequest) DepthGt(depthGt string) ApiIpamPrefixesListRequest {
	r.depthGt = &depthGt
	return r
}

func (r ApiIpamPrefixesListRequest) ChildrenN(childrenN string) ApiIpamPrefixesListRequest {
	r.childrenN = &childrenN
	return r
}

func (r ApiIpamPrefixesListRequest) ChildrenLte(childrenLte string) ApiIpamPrefixesListRequest {
	r.childrenLte = &childrenLte
	return r
}

func (r ApiIpamPrefixesListRequest) ChildrenLt(childrenLt string) ApiIpamPrefixesListRequest {
	r.childrenLt = &childrenLt
	return r
}

func (r ApiIpamPrefixesListRequest) ChildrenGte(childrenGte string) ApiIpamPrefixesListRequest {
	r.childrenGte = &childrenGte
	return r
}

func (r ApiIpamPrefixesListRequest) ChildrenGt(childrenGt string) ApiIpamPrefixesListRequest {
	r.childrenGt = &childrenGt
	return r
}

func (r ApiIpamPrefixesListRequest) VrfIdN(vrfIdN string) ApiIpamPrefixesListRequest {
	r.vrfIdN = &vrfIdN
	return r
}

func (r ApiIpamPrefixesListRequest) VrfN(vrfN string) ApiIpamPrefixesListRequest {
	r.vrfN = &vrfN
	return r
}

func (r ApiIpamPrefixesListRequest) RegionIdN(regionIdN string) ApiIpamPrefixesListRequest {
	r.regionIdN = &regionIdN
	return r
}

func (r ApiIpamPrefixesListRequest) RegionN(regionN string) ApiIpamPrefixesListRequest {
	r.regionN = &regionN
	return r
}

func (r ApiIpamPrefixesListRequest) SiteGroupIdN(siteGroupIdN string) ApiIpamPrefixesListRequest {
	r.siteGroupIdN = &siteGroupIdN
	return r
}

func (r ApiIpamPrefixesListRequest) SiteGroupN(siteGroupN string) ApiIpamPrefixesListRequest {
	r.siteGroupN = &siteGroupN
	return r
}

func (r ApiIpamPrefixesListRequest) SiteIdN(siteIdN string) ApiIpamPrefixesListRequest {
	r.siteIdN = &siteIdN
	return r
}

func (r ApiIpamPrefixesListRequest) SiteN(siteN string) ApiIpamPrefixesListRequest {
	r.siteN = &siteN
	return r
}

func (r ApiIpamPrefixesListRequest) VlanIdN(vlanIdN string) ApiIpamPrefixesListRequest {
	r.vlanIdN = &vlanIdN
	return r
}

func (r ApiIpamPrefixesListRequest) RoleIdN(roleIdN string) ApiIpamPrefixesListRequest {
	r.roleIdN = &roleIdN
	return r
}

func (r ApiIpamPrefixesListRequest) RoleN(roleN string) ApiIpamPrefixesListRequest {
	r.roleN = &roleN
	return r
}

func (r ApiIpamPrefixesListRequest) StatusN(statusN string) ApiIpamPrefixesListRequest {
	r.statusN = &statusN
	return r
}

func (r ApiIpamPrefixesListRequest) TagN(tagN string) ApiIpamPrefixesListRequest {
	r.tagN = &tagN
	return r
}

// Number of results to return per page.
func (r ApiIpamPrefixesListRequest) Limit(limit int32) ApiIpamPrefixesListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiIpamPrefixesListRequest) Offset(offset int32) ApiIpamPrefixesListRequest {
	r.offset = &offset
	return r
}

func (r ApiIpamPrefixesListRequest) Execute() (*IpamPrefixesList200Response, *http.Response, error) {
	return r.ApiService.IpamPrefixesListExecute(r)
}

/*
IpamPrefixesList Method for IpamPrefixesList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamPrefixesListRequest
*/
func (a *IpamApiService) IpamPrefixesList(ctx context.Context) ApiIpamPrefixesListRequest {
	return ApiIpamPrefixesListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return IpamPrefixesList200Response
func (a *IpamApiService) IpamPrefixesListExecute(r ApiIpamPrefixesListRequest) (*IpamPrefixesList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IpamPrefixesList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamPrefixesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/prefixes/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id", parameterToString(t, "multi"))
		}
	}
	if r.isPool != nil {
		localVarQueryParams.Add("is_pool", parameterToString(*r.isPool, ""))
	}
	if r.created != nil {
		localVarQueryParams.Add("created", parameterToString(*r.created, ""))
	}
	if r.createdGte != nil {
		localVarQueryParams.Add("created__gte", parameterToString(*r.createdGte, ""))
	}
	if r.createdLte != nil {
		localVarQueryParams.Add("created__lte", parameterToString(*r.createdLte, ""))
	}
	if r.lastUpdated != nil {
		localVarQueryParams.Add("last_updated", parameterToString(*r.lastUpdated, ""))
	}
	if r.lastUpdatedGte != nil {
		localVarQueryParams.Add("last_updated__gte", parameterToString(*r.lastUpdatedGte, ""))
	}
	if r.lastUpdatedLte != nil {
		localVarQueryParams.Add("last_updated__lte", parameterToString(*r.lastUpdatedLte, ""))
	}
	if r.tenantGroupId != nil {
		localVarQueryParams.Add("tenant_group_id", parameterToString(*r.tenantGroupId, ""))
	}
	if r.tenantGroup != nil {
		localVarQueryParams.Add("tenant_group", parameterToString(*r.tenantGroup, ""))
	}
	if r.tenantId != nil {
		localVarQueryParams.Add("tenant_id", parameterToString(*r.tenantId, ""))
	}
	if r.tenant != nil {
		localVarQueryParams.Add("tenant", parameterToString(*r.tenant, ""))
	}
	if r.q != nil {
		localVarQueryParams.Add("q", parameterToString(*r.q, ""))
	}
	if r.family != nil {
		localVarQueryParams.Add("family", parameterToString(*r.family, ""))
	}
	if r.prefix != nil {
		localVarQueryParams.Add("prefix", parameterToString(*r.prefix, ""))
	}
	if r.within != nil {
		localVarQueryParams.Add("within", parameterToString(*r.within, ""))
	}
	if r.withinInclude != nil {
		localVarQueryParams.Add("within_include", parameterToString(*r.withinInclude, ""))
	}
	if r.contains != nil {
		localVarQueryParams.Add("contains", parameterToString(*r.contains, ""))
	}
	if r.depth != nil {
		localVarQueryParams.Add("depth", parameterToString(*r.depth, ""))
	}
	if r.children != nil {
		localVarQueryParams.Add("children", parameterToString(*r.children, ""))
	}
	if r.maskLength != nil {
		localVarQueryParams.Add("mask_length", parameterToString(*r.maskLength, ""))
	}
	if r.maskLengthGte != nil {
		localVarQueryParams.Add("mask_length__gte", parameterToString(*r.maskLengthGte, ""))
	}
	if r.maskLengthLte != nil {
		localVarQueryParams.Add("mask_length__lte", parameterToString(*r.maskLengthLte, ""))
	}
	if r.vrfId != nil {
		localVarQueryParams.Add("vrf_id", parameterToString(*r.vrfId, ""))
	}
	if r.vrf != nil {
		localVarQueryParams.Add("vrf", parameterToString(*r.vrf, ""))
	}
	if r.presentInVrfId != nil {
		localVarQueryParams.Add("present_in_vrf_id", parameterToString(*r.presentInVrfId, ""))
	}
	if r.presentInVrf != nil {
		localVarQueryParams.Add("present_in_vrf", parameterToString(*r.presentInVrf, ""))
	}
	if r.regionId != nil {
		localVarQueryParams.Add("region_id", parameterToString(*r.regionId, ""))
	}
	if r.region != nil {
		localVarQueryParams.Add("region", parameterToString(*r.region, ""))
	}
	if r.siteGroupId != nil {
		localVarQueryParams.Add("site_group_id", parameterToString(*r.siteGroupId, ""))
	}
	if r.siteGroup != nil {
		localVarQueryParams.Add("site_group", parameterToString(*r.siteGroup, ""))
	}
	if r.siteId != nil {
		localVarQueryParams.Add("site_id", parameterToString(*r.siteId, ""))
	}
	if r.site != nil {
		localVarQueryParams.Add("site", parameterToString(*r.site, ""))
	}
	if r.vlanId != nil {
		localVarQueryParams.Add("vlan_id", parameterToString(*r.vlanId, ""))
	}
	if r.vlanVid != nil {
		localVarQueryParams.Add("vlan_vid", parameterToString(*r.vlanVid, ""))
	}
	if r.roleId != nil {
		localVarQueryParams.Add("role_id", parameterToString(*r.roleId, ""))
	}
	if r.role != nil {
		localVarQueryParams.Add("role", parameterToString(*r.role, ""))
	}
	if r.status != nil {
		localVarQueryParams.Add("status", parameterToString(*r.status, ""))
	}
	if r.tag != nil {
		localVarQueryParams.Add("tag", parameterToString(*r.tag, ""))
	}
	if r.idN != nil {
		localVarQueryParams.Add("id__n", parameterToString(*r.idN, ""))
	}
	if r.idLte != nil {
		localVarQueryParams.Add("id__lte", parameterToString(*r.idLte, ""))
	}
	if r.idLt != nil {
		localVarQueryParams.Add("id__lt", parameterToString(*r.idLt, ""))
	}
	if r.idGte != nil {
		localVarQueryParams.Add("id__gte", parameterToString(*r.idGte, ""))
	}
	if r.idGt != nil {
		localVarQueryParams.Add("id__gt", parameterToString(*r.idGt, ""))
	}
	if r.tenantGroupIdN != nil {
		localVarQueryParams.Add("tenant_group_id__n", parameterToString(*r.tenantGroupIdN, ""))
	}
	if r.tenantGroupN != nil {
		localVarQueryParams.Add("tenant_group__n", parameterToString(*r.tenantGroupN, ""))
	}
	if r.tenantIdN != nil {
		localVarQueryParams.Add("tenant_id__n", parameterToString(*r.tenantIdN, ""))
	}
	if r.tenantN != nil {
		localVarQueryParams.Add("tenant__n", parameterToString(*r.tenantN, ""))
	}
	if r.depthN != nil {
		localVarQueryParams.Add("depth__n", parameterToString(*r.depthN, ""))
	}
	if r.depthLte != nil {
		localVarQueryParams.Add("depth__lte", parameterToString(*r.depthLte, ""))
	}
	if r.depthLt != nil {
		localVarQueryParams.Add("depth__lt", parameterToString(*r.depthLt, ""))
	}
	if r.depthGte != nil {
		localVarQueryParams.Add("depth__gte", parameterToString(*r.depthGte, ""))
	}
	if r.depthGt != nil {
		localVarQueryParams.Add("depth__gt", parameterToString(*r.depthGt, ""))
	}
	if r.childrenN != nil {
		localVarQueryParams.Add("children__n", parameterToString(*r.childrenN, ""))
	}
	if r.childrenLte != nil {
		localVarQueryParams.Add("children__lte", parameterToString(*r.childrenLte, ""))
	}
	if r.childrenLt != nil {
		localVarQueryParams.Add("children__lt", parameterToString(*r.childrenLt, ""))
	}
	if r.childrenGte != nil {
		localVarQueryParams.Add("children__gte", parameterToString(*r.childrenGte, ""))
	}
	if r.childrenGt != nil {
		localVarQueryParams.Add("children__gt", parameterToString(*r.childrenGt, ""))
	}
	if r.vrfIdN != nil {
		localVarQueryParams.Add("vrf_id__n", parameterToString(*r.vrfIdN, ""))
	}
	if r.vrfN != nil {
		localVarQueryParams.Add("vrf__n", parameterToString(*r.vrfN, ""))
	}
	if r.regionIdN != nil {
		localVarQueryParams.Add("region_id__n", parameterToString(*r.regionIdN, ""))
	}
	if r.regionN != nil {
		localVarQueryParams.Add("region__n", parameterToString(*r.regionN, ""))
	}
	if r.siteGroupIdN != nil {
		localVarQueryParams.Add("site_group_id__n", parameterToString(*r.siteGroupIdN, ""))
	}
	if r.siteGroupN != nil {
		localVarQueryParams.Add("site_group__n", parameterToString(*r.siteGroupN, ""))
	}
	if r.siteIdN != nil {
		localVarQueryParams.Add("site_id__n", parameterToString(*r.siteIdN, ""))
	}
	if r.siteN != nil {
		localVarQueryParams.Add("site__n", parameterToString(*r.siteN, ""))
	}
	if r.vlanIdN != nil {
		localVarQueryParams.Add("vlan_id__n", parameterToString(*r.vlanIdN, ""))
	}
	if r.roleIdN != nil {
		localVarQueryParams.Add("role_id__n", parameterToString(*r.roleIdN, ""))
	}
	if r.roleN != nil {
		localVarQueryParams.Add("role__n", parameterToString(*r.roleN, ""))
	}
	if r.statusN != nil {
		localVarQueryParams.Add("status__n", parameterToString(*r.statusN, ""))
	}
	if r.tagN != nil {
		localVarQueryParams.Add("tag__n", parameterToString(*r.tagN, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamPrefixesPartialUpdateRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	id int32
	data *WritablePrefix
}

func (r ApiIpamPrefixesPartialUpdateRequest) Data(data WritablePrefix) ApiIpamPrefixesPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiIpamPrefixesPartialUpdateRequest) Execute() (*Prefix, *http.Response, error) {
	return r.ApiService.IpamPrefixesPartialUpdateExecute(r)
}

/*
IpamPrefixesPartialUpdate Method for IpamPrefixesPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this prefix.
 @return ApiIpamPrefixesPartialUpdateRequest
*/
func (a *IpamApiService) IpamPrefixesPartialUpdate(ctx context.Context, id int32) ApiIpamPrefixesPartialUpdateRequest {
	return ApiIpamPrefixesPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Prefix
func (a *IpamApiService) IpamPrefixesPartialUpdateExecute(r ApiIpamPrefixesPartialUpdateRequest) (*Prefix, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Prefix
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamPrefixesPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/prefixes/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamPrefixesReadRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	id int32
}

func (r ApiIpamPrefixesReadRequest) Execute() (*Prefix, *http.Response, error) {
	return r.ApiService.IpamPrefixesReadExecute(r)
}

/*
IpamPrefixesRead Method for IpamPrefixesRead

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this prefix.
 @return ApiIpamPrefixesReadRequest
*/
func (a *IpamApiService) IpamPrefixesRead(ctx context.Context, id int32) ApiIpamPrefixesReadRequest {
	return ApiIpamPrefixesReadRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Prefix
func (a *IpamApiService) IpamPrefixesReadExecute(r ApiIpamPrefixesReadRequest) (*Prefix, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Prefix
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamPrefixesRead")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/prefixes/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamPrefixesUpdateRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	id int32
	data *WritablePrefix
}

func (r ApiIpamPrefixesUpdateRequest) Data(data WritablePrefix) ApiIpamPrefixesUpdateRequest {
	r.data = &data
	return r
}

func (r ApiIpamPrefixesUpdateRequest) Execute() (*Prefix, *http.Response, error) {
	return r.ApiService.IpamPrefixesUpdateExecute(r)
}

/*
IpamPrefixesUpdate Method for IpamPrefixesUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this prefix.
 @return ApiIpamPrefixesUpdateRequest
*/
func (a *IpamApiService) IpamPrefixesUpdate(ctx context.Context, id int32) ApiIpamPrefixesUpdateRequest {
	return ApiIpamPrefixesUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Prefix
func (a *IpamApiService) IpamPrefixesUpdateExecute(r ApiIpamPrefixesUpdateRequest) (*Prefix, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Prefix
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamPrefixesUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/prefixes/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamRirsBulkDeleteRequest struct {
	ctx context.Context
	ApiService *IpamApiService
}

func (r ApiIpamRirsBulkDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamRirsBulkDeleteExecute(r)
}

/*
IpamRirsBulkDelete Method for IpamRirsBulkDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamRirsBulkDeleteRequest
*/
func (a *IpamApiService) IpamRirsBulkDelete(ctx context.Context) ApiIpamRirsBulkDeleteRequest {
	return ApiIpamRirsBulkDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *IpamApiService) IpamRirsBulkDeleteExecute(r ApiIpamRirsBulkDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamRirsBulkDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/rirs/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamRirsBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	data *RIR
}

func (r ApiIpamRirsBulkPartialUpdateRequest) Data(data RIR) ApiIpamRirsBulkPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiIpamRirsBulkPartialUpdateRequest) Execute() (*RIR, *http.Response, error) {
	return r.ApiService.IpamRirsBulkPartialUpdateExecute(r)
}

/*
IpamRirsBulkPartialUpdate Method for IpamRirsBulkPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamRirsBulkPartialUpdateRequest
*/
func (a *IpamApiService) IpamRirsBulkPartialUpdate(ctx context.Context) ApiIpamRirsBulkPartialUpdateRequest {
	return ApiIpamRirsBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RIR
func (a *IpamApiService) IpamRirsBulkPartialUpdateExecute(r ApiIpamRirsBulkPartialUpdateRequest) (*RIR, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RIR
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamRirsBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/rirs/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamRirsBulkUpdateRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	data *RIR
}

func (r ApiIpamRirsBulkUpdateRequest) Data(data RIR) ApiIpamRirsBulkUpdateRequest {
	r.data = &data
	return r
}

func (r ApiIpamRirsBulkUpdateRequest) Execute() (*RIR, *http.Response, error) {
	return r.ApiService.IpamRirsBulkUpdateExecute(r)
}

/*
IpamRirsBulkUpdate Method for IpamRirsBulkUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamRirsBulkUpdateRequest
*/
func (a *IpamApiService) IpamRirsBulkUpdate(ctx context.Context) ApiIpamRirsBulkUpdateRequest {
	return ApiIpamRirsBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RIR
func (a *IpamApiService) IpamRirsBulkUpdateExecute(r ApiIpamRirsBulkUpdateRequest) (*RIR, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RIR
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamRirsBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/rirs/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamRirsCreateRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	data *RIR
}

func (r ApiIpamRirsCreateRequest) Data(data RIR) ApiIpamRirsCreateRequest {
	r.data = &data
	return r
}

func (r ApiIpamRirsCreateRequest) Execute() (*RIR, *http.Response, error) {
	return r.ApiService.IpamRirsCreateExecute(r)
}

/*
IpamRirsCreate Method for IpamRirsCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamRirsCreateRequest
*/
func (a *IpamApiService) IpamRirsCreate(ctx context.Context) ApiIpamRirsCreateRequest {
	return ApiIpamRirsCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RIR
func (a *IpamApiService) IpamRirsCreateExecute(r ApiIpamRirsCreateRequest) (*RIR, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RIR
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamRirsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/rirs/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamRirsDeleteRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	id int32
}

func (r ApiIpamRirsDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamRirsDeleteExecute(r)
}

/*
IpamRirsDelete Method for IpamRirsDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this RIR.
 @return ApiIpamRirsDeleteRequest
*/
func (a *IpamApiService) IpamRirsDelete(ctx context.Context, id int32) ApiIpamRirsDeleteRequest {
	return ApiIpamRirsDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *IpamApiService) IpamRirsDeleteExecute(r ApiIpamRirsDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamRirsDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/rirs/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamRirsListRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	id *string
	name *string
	slug *string
	isPrivate *string
	description *string
	created *string
	createdGte *string
	createdLte *string
	lastUpdated *string
	lastUpdatedGte *string
	lastUpdatedLte *string
	q *string
	idN *string
	idLte *string
	idLt *string
	idGte *string
	idGt *string
	nameN *string
	nameIc *string
	nameNic *string
	nameIew *string
	nameNiew *string
	nameIsw *string
	nameNisw *string
	nameIe *string
	nameNie *string
	nameEmpty *string
	slugN *string
	slugIc *string
	slugNic *string
	slugIew *string
	slugNiew *string
	slugIsw *string
	slugNisw *string
	slugIe *string
	slugNie *string
	slugEmpty *string
	descriptionN *string
	descriptionIc *string
	descriptionNic *string
	descriptionIew *string
	descriptionNiew *string
	descriptionIsw *string
	descriptionNisw *string
	descriptionIe *string
	descriptionNie *string
	descriptionEmpty *string
	limit *int32
	offset *int32
}

func (r ApiIpamRirsListRequest) Id(id string) ApiIpamRirsListRequest {
	r.id = &id
	return r
}

func (r ApiIpamRirsListRequest) Name(name string) ApiIpamRirsListRequest {
	r.name = &name
	return r
}

func (r ApiIpamRirsListRequest) Slug(slug string) ApiIpamRirsListRequest {
	r.slug = &slug
	return r
}

func (r ApiIpamRirsListRequest) IsPrivate(isPrivate string) ApiIpamRirsListRequest {
	r.isPrivate = &isPrivate
	return r
}

func (r ApiIpamRirsListRequest) Description(description string) ApiIpamRirsListRequest {
	r.description = &description
	return r
}

func (r ApiIpamRirsListRequest) Created(created string) ApiIpamRirsListRequest {
	r.created = &created
	return r
}

func (r ApiIpamRirsListRequest) CreatedGte(createdGte string) ApiIpamRirsListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiIpamRirsListRequest) CreatedLte(createdLte string) ApiIpamRirsListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiIpamRirsListRequest) LastUpdated(lastUpdated string) ApiIpamRirsListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiIpamRirsListRequest) LastUpdatedGte(lastUpdatedGte string) ApiIpamRirsListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiIpamRirsListRequest) LastUpdatedLte(lastUpdatedLte string) ApiIpamRirsListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiIpamRirsListRequest) Q(q string) ApiIpamRirsListRequest {
	r.q = &q
	return r
}

func (r ApiIpamRirsListRequest) IdN(idN string) ApiIpamRirsListRequest {
	r.idN = &idN
	return r
}

func (r ApiIpamRirsListRequest) IdLte(idLte string) ApiIpamRirsListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiIpamRirsListRequest) IdLt(idLt string) ApiIpamRirsListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiIpamRirsListRequest) IdGte(idGte string) ApiIpamRirsListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiIpamRirsListRequest) IdGt(idGt string) ApiIpamRirsListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiIpamRirsListRequest) NameN(nameN string) ApiIpamRirsListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiIpamRirsListRequest) NameIc(nameIc string) ApiIpamRirsListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiIpamRirsListRequest) NameNic(nameNic string) ApiIpamRirsListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiIpamRirsListRequest) NameIew(nameIew string) ApiIpamRirsListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiIpamRirsListRequest) NameNiew(nameNiew string) ApiIpamRirsListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiIpamRirsListRequest) NameIsw(nameIsw string) ApiIpamRirsListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiIpamRirsListRequest) NameNisw(nameNisw string) ApiIpamRirsListRequest {
	r.nameNisw = &nameNisw
	return r
}

func (r ApiIpamRirsListRequest) NameIe(nameIe string) ApiIpamRirsListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiIpamRirsListRequest) NameNie(nameNie string) ApiIpamRirsListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiIpamRirsListRequest) NameEmpty(nameEmpty string) ApiIpamRirsListRequest {
	r.nameEmpty = &nameEmpty
	return r
}

func (r ApiIpamRirsListRequest) SlugN(slugN string) ApiIpamRirsListRequest {
	r.slugN = &slugN
	return r
}

func (r ApiIpamRirsListRequest) SlugIc(slugIc string) ApiIpamRirsListRequest {
	r.slugIc = &slugIc
	return r
}

func (r ApiIpamRirsListRequest) SlugNic(slugNic string) ApiIpamRirsListRequest {
	r.slugNic = &slugNic
	return r
}

func (r ApiIpamRirsListRequest) SlugIew(slugIew string) ApiIpamRirsListRequest {
	r.slugIew = &slugIew
	return r
}

func (r ApiIpamRirsListRequest) SlugNiew(slugNiew string) ApiIpamRirsListRequest {
	r.slugNiew = &slugNiew
	return r
}

func (r ApiIpamRirsListRequest) SlugIsw(slugIsw string) ApiIpamRirsListRequest {
	r.slugIsw = &slugIsw
	return r
}

func (r ApiIpamRirsListRequest) SlugNisw(slugNisw string) ApiIpamRirsListRequest {
	r.slugNisw = &slugNisw
	return r
}

func (r ApiIpamRirsListRequest) SlugIe(slugIe string) ApiIpamRirsListRequest {
	r.slugIe = &slugIe
	return r
}

func (r ApiIpamRirsListRequest) SlugNie(slugNie string) ApiIpamRirsListRequest {
	r.slugNie = &slugNie
	return r
}

func (r ApiIpamRirsListRequest) SlugEmpty(slugEmpty string) ApiIpamRirsListRequest {
	r.slugEmpty = &slugEmpty
	return r
}

func (r ApiIpamRirsListRequest) DescriptionN(descriptionN string) ApiIpamRirsListRequest {
	r.descriptionN = &descriptionN
	return r
}

func (r ApiIpamRirsListRequest) DescriptionIc(descriptionIc string) ApiIpamRirsListRequest {
	r.descriptionIc = &descriptionIc
	return r
}

func (r ApiIpamRirsListRequest) DescriptionNic(descriptionNic string) ApiIpamRirsListRequest {
	r.descriptionNic = &descriptionNic
	return r
}

func (r ApiIpamRirsListRequest) DescriptionIew(descriptionIew string) ApiIpamRirsListRequest {
	r.descriptionIew = &descriptionIew
	return r
}

func (r ApiIpamRirsListRequest) DescriptionNiew(descriptionNiew string) ApiIpamRirsListRequest {
	r.descriptionNiew = &descriptionNiew
	return r
}

func (r ApiIpamRirsListRequest) DescriptionIsw(descriptionIsw string) ApiIpamRirsListRequest {
	r.descriptionIsw = &descriptionIsw
	return r
}

func (r ApiIpamRirsListRequest) DescriptionNisw(descriptionNisw string) ApiIpamRirsListRequest {
	r.descriptionNisw = &descriptionNisw
	return r
}

func (r ApiIpamRirsListRequest) DescriptionIe(descriptionIe string) ApiIpamRirsListRequest {
	r.descriptionIe = &descriptionIe
	return r
}

func (r ApiIpamRirsListRequest) DescriptionNie(descriptionNie string) ApiIpamRirsListRequest {
	r.descriptionNie = &descriptionNie
	return r
}

func (r ApiIpamRirsListRequest) DescriptionEmpty(descriptionEmpty string) ApiIpamRirsListRequest {
	r.descriptionEmpty = &descriptionEmpty
	return r
}

// Number of results to return per page.
func (r ApiIpamRirsListRequest) Limit(limit int32) ApiIpamRirsListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiIpamRirsListRequest) Offset(offset int32) ApiIpamRirsListRequest {
	r.offset = &offset
	return r
}

func (r ApiIpamRirsListRequest) Execute() (*IpamRirsList200Response, *http.Response, error) {
	return r.ApiService.IpamRirsListExecute(r)
}

/*
IpamRirsList Method for IpamRirsList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamRirsListRequest
*/
func (a *IpamApiService) IpamRirsList(ctx context.Context) ApiIpamRirsListRequest {
	return ApiIpamRirsListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return IpamRirsList200Response
func (a *IpamApiService) IpamRirsListExecute(r ApiIpamRirsListRequest) (*IpamRirsList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IpamRirsList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamRirsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/rirs/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.slug != nil {
		localVarQueryParams.Add("slug", parameterToString(*r.slug, ""))
	}
	if r.isPrivate != nil {
		localVarQueryParams.Add("is_private", parameterToString(*r.isPrivate, ""))
	}
	if r.description != nil {
		localVarQueryParams.Add("description", parameterToString(*r.description, ""))
	}
	if r.created != nil {
		localVarQueryParams.Add("created", parameterToString(*r.created, ""))
	}
	if r.createdGte != nil {
		localVarQueryParams.Add("created__gte", parameterToString(*r.createdGte, ""))
	}
	if r.createdLte != nil {
		localVarQueryParams.Add("created__lte", parameterToString(*r.createdLte, ""))
	}
	if r.lastUpdated != nil {
		localVarQueryParams.Add("last_updated", parameterToString(*r.lastUpdated, ""))
	}
	if r.lastUpdatedGte != nil {
		localVarQueryParams.Add("last_updated__gte", parameterToString(*r.lastUpdatedGte, ""))
	}
	if r.lastUpdatedLte != nil {
		localVarQueryParams.Add("last_updated__lte", parameterToString(*r.lastUpdatedLte, ""))
	}
	if r.q != nil {
		localVarQueryParams.Add("q", parameterToString(*r.q, ""))
	}
	if r.idN != nil {
		localVarQueryParams.Add("id__n", parameterToString(*r.idN, ""))
	}
	if r.idLte != nil {
		localVarQueryParams.Add("id__lte", parameterToString(*r.idLte, ""))
	}
	if r.idLt != nil {
		localVarQueryParams.Add("id__lt", parameterToString(*r.idLt, ""))
	}
	if r.idGte != nil {
		localVarQueryParams.Add("id__gte", parameterToString(*r.idGte, ""))
	}
	if r.idGt != nil {
		localVarQueryParams.Add("id__gt", parameterToString(*r.idGt, ""))
	}
	if r.nameN != nil {
		localVarQueryParams.Add("name__n", parameterToString(*r.nameN, ""))
	}
	if r.nameIc != nil {
		localVarQueryParams.Add("name__ic", parameterToString(*r.nameIc, ""))
	}
	if r.nameNic != nil {
		localVarQueryParams.Add("name__nic", parameterToString(*r.nameNic, ""))
	}
	if r.nameIew != nil {
		localVarQueryParams.Add("name__iew", parameterToString(*r.nameIew, ""))
	}
	if r.nameNiew != nil {
		localVarQueryParams.Add("name__niew", parameterToString(*r.nameNiew, ""))
	}
	if r.nameIsw != nil {
		localVarQueryParams.Add("name__isw", parameterToString(*r.nameIsw, ""))
	}
	if r.nameNisw != nil {
		localVarQueryParams.Add("name__nisw", parameterToString(*r.nameNisw, ""))
	}
	if r.nameIe != nil {
		localVarQueryParams.Add("name__ie", parameterToString(*r.nameIe, ""))
	}
	if r.nameNie != nil {
		localVarQueryParams.Add("name__nie", parameterToString(*r.nameNie, ""))
	}
	if r.nameEmpty != nil {
		localVarQueryParams.Add("name__empty", parameterToString(*r.nameEmpty, ""))
	}
	if r.slugN != nil {
		localVarQueryParams.Add("slug__n", parameterToString(*r.slugN, ""))
	}
	if r.slugIc != nil {
		localVarQueryParams.Add("slug__ic", parameterToString(*r.slugIc, ""))
	}
	if r.slugNic != nil {
		localVarQueryParams.Add("slug__nic", parameterToString(*r.slugNic, ""))
	}
	if r.slugIew != nil {
		localVarQueryParams.Add("slug__iew", parameterToString(*r.slugIew, ""))
	}
	if r.slugNiew != nil {
		localVarQueryParams.Add("slug__niew", parameterToString(*r.slugNiew, ""))
	}
	if r.slugIsw != nil {
		localVarQueryParams.Add("slug__isw", parameterToString(*r.slugIsw, ""))
	}
	if r.slugNisw != nil {
		localVarQueryParams.Add("slug__nisw", parameterToString(*r.slugNisw, ""))
	}
	if r.slugIe != nil {
		localVarQueryParams.Add("slug__ie", parameterToString(*r.slugIe, ""))
	}
	if r.slugNie != nil {
		localVarQueryParams.Add("slug__nie", parameterToString(*r.slugNie, ""))
	}
	if r.slugEmpty != nil {
		localVarQueryParams.Add("slug__empty", parameterToString(*r.slugEmpty, ""))
	}
	if r.descriptionN != nil {
		localVarQueryParams.Add("description__n", parameterToString(*r.descriptionN, ""))
	}
	if r.descriptionIc != nil {
		localVarQueryParams.Add("description__ic", parameterToString(*r.descriptionIc, ""))
	}
	if r.descriptionNic != nil {
		localVarQueryParams.Add("description__nic", parameterToString(*r.descriptionNic, ""))
	}
	if r.descriptionIew != nil {
		localVarQueryParams.Add("description__iew", parameterToString(*r.descriptionIew, ""))
	}
	if r.descriptionNiew != nil {
		localVarQueryParams.Add("description__niew", parameterToString(*r.descriptionNiew, ""))
	}
	if r.descriptionIsw != nil {
		localVarQueryParams.Add("description__isw", parameterToString(*r.descriptionIsw, ""))
	}
	if r.descriptionNisw != nil {
		localVarQueryParams.Add("description__nisw", parameterToString(*r.descriptionNisw, ""))
	}
	if r.descriptionIe != nil {
		localVarQueryParams.Add("description__ie", parameterToString(*r.descriptionIe, ""))
	}
	if r.descriptionNie != nil {
		localVarQueryParams.Add("description__nie", parameterToString(*r.descriptionNie, ""))
	}
	if r.descriptionEmpty != nil {
		localVarQueryParams.Add("description__empty", parameterToString(*r.descriptionEmpty, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamRirsPartialUpdateRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	id int32
	data *RIR
}

func (r ApiIpamRirsPartialUpdateRequest) Data(data RIR) ApiIpamRirsPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiIpamRirsPartialUpdateRequest) Execute() (*RIR, *http.Response, error) {
	return r.ApiService.IpamRirsPartialUpdateExecute(r)
}

/*
IpamRirsPartialUpdate Method for IpamRirsPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this RIR.
 @return ApiIpamRirsPartialUpdateRequest
*/
func (a *IpamApiService) IpamRirsPartialUpdate(ctx context.Context, id int32) ApiIpamRirsPartialUpdateRequest {
	return ApiIpamRirsPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return RIR
func (a *IpamApiService) IpamRirsPartialUpdateExecute(r ApiIpamRirsPartialUpdateRequest) (*RIR, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RIR
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamRirsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/rirs/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamRirsReadRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	id int32
}

func (r ApiIpamRirsReadRequest) Execute() (*RIR, *http.Response, error) {
	return r.ApiService.IpamRirsReadExecute(r)
}

/*
IpamRirsRead Method for IpamRirsRead

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this RIR.
 @return ApiIpamRirsReadRequest
*/
func (a *IpamApiService) IpamRirsRead(ctx context.Context, id int32) ApiIpamRirsReadRequest {
	return ApiIpamRirsReadRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return RIR
func (a *IpamApiService) IpamRirsReadExecute(r ApiIpamRirsReadRequest) (*RIR, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RIR
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamRirsRead")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/rirs/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamRirsUpdateRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	id int32
	data *RIR
}

func (r ApiIpamRirsUpdateRequest) Data(data RIR) ApiIpamRirsUpdateRequest {
	r.data = &data
	return r
}

func (r ApiIpamRirsUpdateRequest) Execute() (*RIR, *http.Response, error) {
	return r.ApiService.IpamRirsUpdateExecute(r)
}

/*
IpamRirsUpdate Method for IpamRirsUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this RIR.
 @return ApiIpamRirsUpdateRequest
*/
func (a *IpamApiService) IpamRirsUpdate(ctx context.Context, id int32) ApiIpamRirsUpdateRequest {
	return ApiIpamRirsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return RIR
func (a *IpamApiService) IpamRirsUpdateExecute(r ApiIpamRirsUpdateRequest) (*RIR, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RIR
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamRirsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/rirs/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamRolesBulkDeleteRequest struct {
	ctx context.Context
	ApiService *IpamApiService
}

func (r ApiIpamRolesBulkDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamRolesBulkDeleteExecute(r)
}

/*
IpamRolesBulkDelete Method for IpamRolesBulkDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamRolesBulkDeleteRequest
*/
func (a *IpamApiService) IpamRolesBulkDelete(ctx context.Context) ApiIpamRolesBulkDeleteRequest {
	return ApiIpamRolesBulkDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *IpamApiService) IpamRolesBulkDeleteExecute(r ApiIpamRolesBulkDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamRolesBulkDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/roles/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamRolesBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	data *Role
}

func (r ApiIpamRolesBulkPartialUpdateRequest) Data(data Role) ApiIpamRolesBulkPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiIpamRolesBulkPartialUpdateRequest) Execute() (*Role, *http.Response, error) {
	return r.ApiService.IpamRolesBulkPartialUpdateExecute(r)
}

/*
IpamRolesBulkPartialUpdate Method for IpamRolesBulkPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamRolesBulkPartialUpdateRequest
*/
func (a *IpamApiService) IpamRolesBulkPartialUpdate(ctx context.Context) ApiIpamRolesBulkPartialUpdateRequest {
	return ApiIpamRolesBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Role
func (a *IpamApiService) IpamRolesBulkPartialUpdateExecute(r ApiIpamRolesBulkPartialUpdateRequest) (*Role, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Role
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamRolesBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/roles/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamRolesBulkUpdateRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	data *Role
}

func (r ApiIpamRolesBulkUpdateRequest) Data(data Role) ApiIpamRolesBulkUpdateRequest {
	r.data = &data
	return r
}

func (r ApiIpamRolesBulkUpdateRequest) Execute() (*Role, *http.Response, error) {
	return r.ApiService.IpamRolesBulkUpdateExecute(r)
}

/*
IpamRolesBulkUpdate Method for IpamRolesBulkUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamRolesBulkUpdateRequest
*/
func (a *IpamApiService) IpamRolesBulkUpdate(ctx context.Context) ApiIpamRolesBulkUpdateRequest {
	return ApiIpamRolesBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Role
func (a *IpamApiService) IpamRolesBulkUpdateExecute(r ApiIpamRolesBulkUpdateRequest) (*Role, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Role
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamRolesBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/roles/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamRolesCreateRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	data *Role
}

func (r ApiIpamRolesCreateRequest) Data(data Role) ApiIpamRolesCreateRequest {
	r.data = &data
	return r
}

func (r ApiIpamRolesCreateRequest) Execute() (*Role, *http.Response, error) {
	return r.ApiService.IpamRolesCreateExecute(r)
}

/*
IpamRolesCreate Method for IpamRolesCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamRolesCreateRequest
*/
func (a *IpamApiService) IpamRolesCreate(ctx context.Context) ApiIpamRolesCreateRequest {
	return ApiIpamRolesCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Role
func (a *IpamApiService) IpamRolesCreateExecute(r ApiIpamRolesCreateRequest) (*Role, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Role
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamRolesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/roles/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamRolesDeleteRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	id int32
}

func (r ApiIpamRolesDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamRolesDeleteExecute(r)
}

/*
IpamRolesDelete Method for IpamRolesDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this role.
 @return ApiIpamRolesDeleteRequest
*/
func (a *IpamApiService) IpamRolesDelete(ctx context.Context, id int32) ApiIpamRolesDeleteRequest {
	return ApiIpamRolesDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *IpamApiService) IpamRolesDeleteExecute(r ApiIpamRolesDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamRolesDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/roles/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamRolesListRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	id *string
	name *string
	slug *string
	created *string
	createdGte *string
	createdLte *string
	lastUpdated *string
	lastUpdatedGte *string
	lastUpdatedLte *string
	q *string
	idN *string
	idLte *string
	idLt *string
	idGte *string
	idGt *string
	nameN *string
	nameIc *string
	nameNic *string
	nameIew *string
	nameNiew *string
	nameIsw *string
	nameNisw *string
	nameIe *string
	nameNie *string
	nameEmpty *string
	slugN *string
	slugIc *string
	slugNic *string
	slugIew *string
	slugNiew *string
	slugIsw *string
	slugNisw *string
	slugIe *string
	slugNie *string
	slugEmpty *string
	limit *int32
	offset *int32
}

func (r ApiIpamRolesListRequest) Id(id string) ApiIpamRolesListRequest {
	r.id = &id
	return r
}

func (r ApiIpamRolesListRequest) Name(name string) ApiIpamRolesListRequest {
	r.name = &name
	return r
}

func (r ApiIpamRolesListRequest) Slug(slug string) ApiIpamRolesListRequest {
	r.slug = &slug
	return r
}

func (r ApiIpamRolesListRequest) Created(created string) ApiIpamRolesListRequest {
	r.created = &created
	return r
}

func (r ApiIpamRolesListRequest) CreatedGte(createdGte string) ApiIpamRolesListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiIpamRolesListRequest) CreatedLte(createdLte string) ApiIpamRolesListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiIpamRolesListRequest) LastUpdated(lastUpdated string) ApiIpamRolesListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiIpamRolesListRequest) LastUpdatedGte(lastUpdatedGte string) ApiIpamRolesListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiIpamRolesListRequest) LastUpdatedLte(lastUpdatedLte string) ApiIpamRolesListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiIpamRolesListRequest) Q(q string) ApiIpamRolesListRequest {
	r.q = &q
	return r
}

func (r ApiIpamRolesListRequest) IdN(idN string) ApiIpamRolesListRequest {
	r.idN = &idN
	return r
}

func (r ApiIpamRolesListRequest) IdLte(idLte string) ApiIpamRolesListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiIpamRolesListRequest) IdLt(idLt string) ApiIpamRolesListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiIpamRolesListRequest) IdGte(idGte string) ApiIpamRolesListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiIpamRolesListRequest) IdGt(idGt string) ApiIpamRolesListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiIpamRolesListRequest) NameN(nameN string) ApiIpamRolesListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiIpamRolesListRequest) NameIc(nameIc string) ApiIpamRolesListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiIpamRolesListRequest) NameNic(nameNic string) ApiIpamRolesListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiIpamRolesListRequest) NameIew(nameIew string) ApiIpamRolesListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiIpamRolesListRequest) NameNiew(nameNiew string) ApiIpamRolesListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiIpamRolesListRequest) NameIsw(nameIsw string) ApiIpamRolesListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiIpamRolesListRequest) NameNisw(nameNisw string) ApiIpamRolesListRequest {
	r.nameNisw = &nameNisw
	return r
}

func (r ApiIpamRolesListRequest) NameIe(nameIe string) ApiIpamRolesListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiIpamRolesListRequest) NameNie(nameNie string) ApiIpamRolesListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiIpamRolesListRequest) NameEmpty(nameEmpty string) ApiIpamRolesListRequest {
	r.nameEmpty = &nameEmpty
	return r
}

func (r ApiIpamRolesListRequest) SlugN(slugN string) ApiIpamRolesListRequest {
	r.slugN = &slugN
	return r
}

func (r ApiIpamRolesListRequest) SlugIc(slugIc string) ApiIpamRolesListRequest {
	r.slugIc = &slugIc
	return r
}

func (r ApiIpamRolesListRequest) SlugNic(slugNic string) ApiIpamRolesListRequest {
	r.slugNic = &slugNic
	return r
}

func (r ApiIpamRolesListRequest) SlugIew(slugIew string) ApiIpamRolesListRequest {
	r.slugIew = &slugIew
	return r
}

func (r ApiIpamRolesListRequest) SlugNiew(slugNiew string) ApiIpamRolesListRequest {
	r.slugNiew = &slugNiew
	return r
}

func (r ApiIpamRolesListRequest) SlugIsw(slugIsw string) ApiIpamRolesListRequest {
	r.slugIsw = &slugIsw
	return r
}

func (r ApiIpamRolesListRequest) SlugNisw(slugNisw string) ApiIpamRolesListRequest {
	r.slugNisw = &slugNisw
	return r
}

func (r ApiIpamRolesListRequest) SlugIe(slugIe string) ApiIpamRolesListRequest {
	r.slugIe = &slugIe
	return r
}

func (r ApiIpamRolesListRequest) SlugNie(slugNie string) ApiIpamRolesListRequest {
	r.slugNie = &slugNie
	return r
}

func (r ApiIpamRolesListRequest) SlugEmpty(slugEmpty string) ApiIpamRolesListRequest {
	r.slugEmpty = &slugEmpty
	return r
}

// Number of results to return per page.
func (r ApiIpamRolesListRequest) Limit(limit int32) ApiIpamRolesListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiIpamRolesListRequest) Offset(offset int32) ApiIpamRolesListRequest {
	r.offset = &offset
	return r
}

func (r ApiIpamRolesListRequest) Execute() (*IpamRolesList200Response, *http.Response, error) {
	return r.ApiService.IpamRolesListExecute(r)
}

/*
IpamRolesList Method for IpamRolesList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamRolesListRequest
*/
func (a *IpamApiService) IpamRolesList(ctx context.Context) ApiIpamRolesListRequest {
	return ApiIpamRolesListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return IpamRolesList200Response
func (a *IpamApiService) IpamRolesListExecute(r ApiIpamRolesListRequest) (*IpamRolesList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IpamRolesList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamRolesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/roles/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.slug != nil {
		localVarQueryParams.Add("slug", parameterToString(*r.slug, ""))
	}
	if r.created != nil {
		localVarQueryParams.Add("created", parameterToString(*r.created, ""))
	}
	if r.createdGte != nil {
		localVarQueryParams.Add("created__gte", parameterToString(*r.createdGte, ""))
	}
	if r.createdLte != nil {
		localVarQueryParams.Add("created__lte", parameterToString(*r.createdLte, ""))
	}
	if r.lastUpdated != nil {
		localVarQueryParams.Add("last_updated", parameterToString(*r.lastUpdated, ""))
	}
	if r.lastUpdatedGte != nil {
		localVarQueryParams.Add("last_updated__gte", parameterToString(*r.lastUpdatedGte, ""))
	}
	if r.lastUpdatedLte != nil {
		localVarQueryParams.Add("last_updated__lte", parameterToString(*r.lastUpdatedLte, ""))
	}
	if r.q != nil {
		localVarQueryParams.Add("q", parameterToString(*r.q, ""))
	}
	if r.idN != nil {
		localVarQueryParams.Add("id__n", parameterToString(*r.idN, ""))
	}
	if r.idLte != nil {
		localVarQueryParams.Add("id__lte", parameterToString(*r.idLte, ""))
	}
	if r.idLt != nil {
		localVarQueryParams.Add("id__lt", parameterToString(*r.idLt, ""))
	}
	if r.idGte != nil {
		localVarQueryParams.Add("id__gte", parameterToString(*r.idGte, ""))
	}
	if r.idGt != nil {
		localVarQueryParams.Add("id__gt", parameterToString(*r.idGt, ""))
	}
	if r.nameN != nil {
		localVarQueryParams.Add("name__n", parameterToString(*r.nameN, ""))
	}
	if r.nameIc != nil {
		localVarQueryParams.Add("name__ic", parameterToString(*r.nameIc, ""))
	}
	if r.nameNic != nil {
		localVarQueryParams.Add("name__nic", parameterToString(*r.nameNic, ""))
	}
	if r.nameIew != nil {
		localVarQueryParams.Add("name__iew", parameterToString(*r.nameIew, ""))
	}
	if r.nameNiew != nil {
		localVarQueryParams.Add("name__niew", parameterToString(*r.nameNiew, ""))
	}
	if r.nameIsw != nil {
		localVarQueryParams.Add("name__isw", parameterToString(*r.nameIsw, ""))
	}
	if r.nameNisw != nil {
		localVarQueryParams.Add("name__nisw", parameterToString(*r.nameNisw, ""))
	}
	if r.nameIe != nil {
		localVarQueryParams.Add("name__ie", parameterToString(*r.nameIe, ""))
	}
	if r.nameNie != nil {
		localVarQueryParams.Add("name__nie", parameterToString(*r.nameNie, ""))
	}
	if r.nameEmpty != nil {
		localVarQueryParams.Add("name__empty", parameterToString(*r.nameEmpty, ""))
	}
	if r.slugN != nil {
		localVarQueryParams.Add("slug__n", parameterToString(*r.slugN, ""))
	}
	if r.slugIc != nil {
		localVarQueryParams.Add("slug__ic", parameterToString(*r.slugIc, ""))
	}
	if r.slugNic != nil {
		localVarQueryParams.Add("slug__nic", parameterToString(*r.slugNic, ""))
	}
	if r.slugIew != nil {
		localVarQueryParams.Add("slug__iew", parameterToString(*r.slugIew, ""))
	}
	if r.slugNiew != nil {
		localVarQueryParams.Add("slug__niew", parameterToString(*r.slugNiew, ""))
	}
	if r.slugIsw != nil {
		localVarQueryParams.Add("slug__isw", parameterToString(*r.slugIsw, ""))
	}
	if r.slugNisw != nil {
		localVarQueryParams.Add("slug__nisw", parameterToString(*r.slugNisw, ""))
	}
	if r.slugIe != nil {
		localVarQueryParams.Add("slug__ie", parameterToString(*r.slugIe, ""))
	}
	if r.slugNie != nil {
		localVarQueryParams.Add("slug__nie", parameterToString(*r.slugNie, ""))
	}
	if r.slugEmpty != nil {
		localVarQueryParams.Add("slug__empty", parameterToString(*r.slugEmpty, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamRolesPartialUpdateRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	id int32
	data *Role
}

func (r ApiIpamRolesPartialUpdateRequest) Data(data Role) ApiIpamRolesPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiIpamRolesPartialUpdateRequest) Execute() (*Role, *http.Response, error) {
	return r.ApiService.IpamRolesPartialUpdateExecute(r)
}

/*
IpamRolesPartialUpdate Method for IpamRolesPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this role.
 @return ApiIpamRolesPartialUpdateRequest
*/
func (a *IpamApiService) IpamRolesPartialUpdate(ctx context.Context, id int32) ApiIpamRolesPartialUpdateRequest {
	return ApiIpamRolesPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Role
func (a *IpamApiService) IpamRolesPartialUpdateExecute(r ApiIpamRolesPartialUpdateRequest) (*Role, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Role
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamRolesPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/roles/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamRolesReadRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	id int32
}

func (r ApiIpamRolesReadRequest) Execute() (*Role, *http.Response, error) {
	return r.ApiService.IpamRolesReadExecute(r)
}

/*
IpamRolesRead Method for IpamRolesRead

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this role.
 @return ApiIpamRolesReadRequest
*/
func (a *IpamApiService) IpamRolesRead(ctx context.Context, id int32) ApiIpamRolesReadRequest {
	return ApiIpamRolesReadRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Role
func (a *IpamApiService) IpamRolesReadExecute(r ApiIpamRolesReadRequest) (*Role, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Role
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamRolesRead")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/roles/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamRolesUpdateRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	id int32
	data *Role
}

func (r ApiIpamRolesUpdateRequest) Data(data Role) ApiIpamRolesUpdateRequest {
	r.data = &data
	return r
}

func (r ApiIpamRolesUpdateRequest) Execute() (*Role, *http.Response, error) {
	return r.ApiService.IpamRolesUpdateExecute(r)
}

/*
IpamRolesUpdate Method for IpamRolesUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this role.
 @return ApiIpamRolesUpdateRequest
*/
func (a *IpamApiService) IpamRolesUpdate(ctx context.Context, id int32) ApiIpamRolesUpdateRequest {
	return ApiIpamRolesUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Role
func (a *IpamApiService) IpamRolesUpdateExecute(r ApiIpamRolesUpdateRequest) (*Role, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Role
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamRolesUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/roles/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamRouteTargetsBulkDeleteRequest struct {
	ctx context.Context
	ApiService *IpamApiService
}

func (r ApiIpamRouteTargetsBulkDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamRouteTargetsBulkDeleteExecute(r)
}

/*
IpamRouteTargetsBulkDelete Method for IpamRouteTargetsBulkDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamRouteTargetsBulkDeleteRequest
*/
func (a *IpamApiService) IpamRouteTargetsBulkDelete(ctx context.Context) ApiIpamRouteTargetsBulkDeleteRequest {
	return ApiIpamRouteTargetsBulkDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *IpamApiService) IpamRouteTargetsBulkDeleteExecute(r ApiIpamRouteTargetsBulkDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamRouteTargetsBulkDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/route-targets/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamRouteTargetsBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	data *WritableRouteTarget
}

func (r ApiIpamRouteTargetsBulkPartialUpdateRequest) Data(data WritableRouteTarget) ApiIpamRouteTargetsBulkPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiIpamRouteTargetsBulkPartialUpdateRequest) Execute() (*RouteTarget, *http.Response, error) {
	return r.ApiService.IpamRouteTargetsBulkPartialUpdateExecute(r)
}

/*
IpamRouteTargetsBulkPartialUpdate Method for IpamRouteTargetsBulkPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamRouteTargetsBulkPartialUpdateRequest
*/
func (a *IpamApiService) IpamRouteTargetsBulkPartialUpdate(ctx context.Context) ApiIpamRouteTargetsBulkPartialUpdateRequest {
	return ApiIpamRouteTargetsBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RouteTarget
func (a *IpamApiService) IpamRouteTargetsBulkPartialUpdateExecute(r ApiIpamRouteTargetsBulkPartialUpdateRequest) (*RouteTarget, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RouteTarget
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamRouteTargetsBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/route-targets/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamRouteTargetsBulkUpdateRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	data *WritableRouteTarget
}

func (r ApiIpamRouteTargetsBulkUpdateRequest) Data(data WritableRouteTarget) ApiIpamRouteTargetsBulkUpdateRequest {
	r.data = &data
	return r
}

func (r ApiIpamRouteTargetsBulkUpdateRequest) Execute() (*RouteTarget, *http.Response, error) {
	return r.ApiService.IpamRouteTargetsBulkUpdateExecute(r)
}

/*
IpamRouteTargetsBulkUpdate Method for IpamRouteTargetsBulkUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamRouteTargetsBulkUpdateRequest
*/
func (a *IpamApiService) IpamRouteTargetsBulkUpdate(ctx context.Context) ApiIpamRouteTargetsBulkUpdateRequest {
	return ApiIpamRouteTargetsBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RouteTarget
func (a *IpamApiService) IpamRouteTargetsBulkUpdateExecute(r ApiIpamRouteTargetsBulkUpdateRequest) (*RouteTarget, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RouteTarget
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamRouteTargetsBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/route-targets/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamRouteTargetsCreateRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	data *WritableRouteTarget
}

func (r ApiIpamRouteTargetsCreateRequest) Data(data WritableRouteTarget) ApiIpamRouteTargetsCreateRequest {
	r.data = &data
	return r
}

func (r ApiIpamRouteTargetsCreateRequest) Execute() (*RouteTarget, *http.Response, error) {
	return r.ApiService.IpamRouteTargetsCreateExecute(r)
}

/*
IpamRouteTargetsCreate Method for IpamRouteTargetsCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamRouteTargetsCreateRequest
*/
func (a *IpamApiService) IpamRouteTargetsCreate(ctx context.Context) ApiIpamRouteTargetsCreateRequest {
	return ApiIpamRouteTargetsCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RouteTarget
func (a *IpamApiService) IpamRouteTargetsCreateExecute(r ApiIpamRouteTargetsCreateRequest) (*RouteTarget, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RouteTarget
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamRouteTargetsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/route-targets/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamRouteTargetsDeleteRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	id int32
}

func (r ApiIpamRouteTargetsDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamRouteTargetsDeleteExecute(r)
}

/*
IpamRouteTargetsDelete Method for IpamRouteTargetsDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this route target.
 @return ApiIpamRouteTargetsDeleteRequest
*/
func (a *IpamApiService) IpamRouteTargetsDelete(ctx context.Context, id int32) ApiIpamRouteTargetsDeleteRequest {
	return ApiIpamRouteTargetsDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *IpamApiService) IpamRouteTargetsDeleteExecute(r ApiIpamRouteTargetsDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamRouteTargetsDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/route-targets/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamRouteTargetsListRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	id *string
	name *string
	created *string
	createdGte *string
	createdLte *string
	lastUpdated *string
	lastUpdatedGte *string
	lastUpdatedLte *string
	tenantGroupId *string
	tenantGroup *string
	tenantId *string
	tenant *string
	q *string
	importingVrfId *string
	importingVrf *string
	exportingVrfId *string
	exportingVrf *string
	tag *string
	idN *string
	idLte *string
	idLt *string
	idGte *string
	idGt *string
	nameN *string
	nameIc *string
	nameNic *string
	nameIew *string
	nameNiew *string
	nameIsw *string
	nameNisw *string
	nameIe *string
	nameNie *string
	nameEmpty *string
	tenantGroupIdN *string
	tenantGroupN *string
	tenantIdN *string
	tenantN *string
	importingVrfIdN *string
	importingVrfN *string
	exportingVrfIdN *string
	exportingVrfN *string
	tagN *string
	limit *int32
	offset *int32
}

func (r ApiIpamRouteTargetsListRequest) Id(id string) ApiIpamRouteTargetsListRequest {
	r.id = &id
	return r
}

func (r ApiIpamRouteTargetsListRequest) Name(name string) ApiIpamRouteTargetsListRequest {
	r.name = &name
	return r
}

func (r ApiIpamRouteTargetsListRequest) Created(created string) ApiIpamRouteTargetsListRequest {
	r.created = &created
	return r
}

func (r ApiIpamRouteTargetsListRequest) CreatedGte(createdGte string) ApiIpamRouteTargetsListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiIpamRouteTargetsListRequest) CreatedLte(createdLte string) ApiIpamRouteTargetsListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiIpamRouteTargetsListRequest) LastUpdated(lastUpdated string) ApiIpamRouteTargetsListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiIpamRouteTargetsListRequest) LastUpdatedGte(lastUpdatedGte string) ApiIpamRouteTargetsListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiIpamRouteTargetsListRequest) LastUpdatedLte(lastUpdatedLte string) ApiIpamRouteTargetsListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiIpamRouteTargetsListRequest) TenantGroupId(tenantGroupId string) ApiIpamRouteTargetsListRequest {
	r.tenantGroupId = &tenantGroupId
	return r
}

func (r ApiIpamRouteTargetsListRequest) TenantGroup(tenantGroup string) ApiIpamRouteTargetsListRequest {
	r.tenantGroup = &tenantGroup
	return r
}

func (r ApiIpamRouteTargetsListRequest) TenantId(tenantId string) ApiIpamRouteTargetsListRequest {
	r.tenantId = &tenantId
	return r
}

func (r ApiIpamRouteTargetsListRequest) Tenant(tenant string) ApiIpamRouteTargetsListRequest {
	r.tenant = &tenant
	return r
}

func (r ApiIpamRouteTargetsListRequest) Q(q string) ApiIpamRouteTargetsListRequest {
	r.q = &q
	return r
}

func (r ApiIpamRouteTargetsListRequest) ImportingVrfId(importingVrfId string) ApiIpamRouteTargetsListRequest {
	r.importingVrfId = &importingVrfId
	return r
}

func (r ApiIpamRouteTargetsListRequest) ImportingVrf(importingVrf string) ApiIpamRouteTargetsListRequest {
	r.importingVrf = &importingVrf
	return r
}

func (r ApiIpamRouteTargetsListRequest) ExportingVrfId(exportingVrfId string) ApiIpamRouteTargetsListRequest {
	r.exportingVrfId = &exportingVrfId
	return r
}

func (r ApiIpamRouteTargetsListRequest) ExportingVrf(exportingVrf string) ApiIpamRouteTargetsListRequest {
	r.exportingVrf = &exportingVrf
	return r
}

func (r ApiIpamRouteTargetsListRequest) Tag(tag string) ApiIpamRouteTargetsListRequest {
	r.tag = &tag
	return r
}

func (r ApiIpamRouteTargetsListRequest) IdN(idN string) ApiIpamRouteTargetsListRequest {
	r.idN = &idN
	return r
}

func (r ApiIpamRouteTargetsListRequest) IdLte(idLte string) ApiIpamRouteTargetsListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiIpamRouteTargetsListRequest) IdLt(idLt string) ApiIpamRouteTargetsListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiIpamRouteTargetsListRequest) IdGte(idGte string) ApiIpamRouteTargetsListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiIpamRouteTargetsListRequest) IdGt(idGt string) ApiIpamRouteTargetsListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiIpamRouteTargetsListRequest) NameN(nameN string) ApiIpamRouteTargetsListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiIpamRouteTargetsListRequest) NameIc(nameIc string) ApiIpamRouteTargetsListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiIpamRouteTargetsListRequest) NameNic(nameNic string) ApiIpamRouteTargetsListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiIpamRouteTargetsListRequest) NameIew(nameIew string) ApiIpamRouteTargetsListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiIpamRouteTargetsListRequest) NameNiew(nameNiew string) ApiIpamRouteTargetsListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiIpamRouteTargetsListRequest) NameIsw(nameIsw string) ApiIpamRouteTargetsListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiIpamRouteTargetsListRequest) NameNisw(nameNisw string) ApiIpamRouteTargetsListRequest {
	r.nameNisw = &nameNisw
	return r
}

func (r ApiIpamRouteTargetsListRequest) NameIe(nameIe string) ApiIpamRouteTargetsListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiIpamRouteTargetsListRequest) NameNie(nameNie string) ApiIpamRouteTargetsListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiIpamRouteTargetsListRequest) NameEmpty(nameEmpty string) ApiIpamRouteTargetsListRequest {
	r.nameEmpty = &nameEmpty
	return r
}

func (r ApiIpamRouteTargetsListRequest) TenantGroupIdN(tenantGroupIdN string) ApiIpamRouteTargetsListRequest {
	r.tenantGroupIdN = &tenantGroupIdN
	return r
}

func (r ApiIpamRouteTargetsListRequest) TenantGroupN(tenantGroupN string) ApiIpamRouteTargetsListRequest {
	r.tenantGroupN = &tenantGroupN
	return r
}

func (r ApiIpamRouteTargetsListRequest) TenantIdN(tenantIdN string) ApiIpamRouteTargetsListRequest {
	r.tenantIdN = &tenantIdN
	return r
}

func (r ApiIpamRouteTargetsListRequest) TenantN(tenantN string) ApiIpamRouteTargetsListRequest {
	r.tenantN = &tenantN
	return r
}

func (r ApiIpamRouteTargetsListRequest) ImportingVrfIdN(importingVrfIdN string) ApiIpamRouteTargetsListRequest {
	r.importingVrfIdN = &importingVrfIdN
	return r
}

func (r ApiIpamRouteTargetsListRequest) ImportingVrfN(importingVrfN string) ApiIpamRouteTargetsListRequest {
	r.importingVrfN = &importingVrfN
	return r
}

func (r ApiIpamRouteTargetsListRequest) ExportingVrfIdN(exportingVrfIdN string) ApiIpamRouteTargetsListRequest {
	r.exportingVrfIdN = &exportingVrfIdN
	return r
}

func (r ApiIpamRouteTargetsListRequest) ExportingVrfN(exportingVrfN string) ApiIpamRouteTargetsListRequest {
	r.exportingVrfN = &exportingVrfN
	return r
}

func (r ApiIpamRouteTargetsListRequest) TagN(tagN string) ApiIpamRouteTargetsListRequest {
	r.tagN = &tagN
	return r
}

// Number of results to return per page.
func (r ApiIpamRouteTargetsListRequest) Limit(limit int32) ApiIpamRouteTargetsListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiIpamRouteTargetsListRequest) Offset(offset int32) ApiIpamRouteTargetsListRequest {
	r.offset = &offset
	return r
}

func (r ApiIpamRouteTargetsListRequest) Execute() (*IpamRouteTargetsList200Response, *http.Response, error) {
	return r.ApiService.IpamRouteTargetsListExecute(r)
}

/*
IpamRouteTargetsList Method for IpamRouteTargetsList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamRouteTargetsListRequest
*/
func (a *IpamApiService) IpamRouteTargetsList(ctx context.Context) ApiIpamRouteTargetsListRequest {
	return ApiIpamRouteTargetsListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return IpamRouteTargetsList200Response
func (a *IpamApiService) IpamRouteTargetsListExecute(r ApiIpamRouteTargetsListRequest) (*IpamRouteTargetsList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IpamRouteTargetsList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamRouteTargetsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/route-targets/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.created != nil {
		localVarQueryParams.Add("created", parameterToString(*r.created, ""))
	}
	if r.createdGte != nil {
		localVarQueryParams.Add("created__gte", parameterToString(*r.createdGte, ""))
	}
	if r.createdLte != nil {
		localVarQueryParams.Add("created__lte", parameterToString(*r.createdLte, ""))
	}
	if r.lastUpdated != nil {
		localVarQueryParams.Add("last_updated", parameterToString(*r.lastUpdated, ""))
	}
	if r.lastUpdatedGte != nil {
		localVarQueryParams.Add("last_updated__gte", parameterToString(*r.lastUpdatedGte, ""))
	}
	if r.lastUpdatedLte != nil {
		localVarQueryParams.Add("last_updated__lte", parameterToString(*r.lastUpdatedLte, ""))
	}
	if r.tenantGroupId != nil {
		localVarQueryParams.Add("tenant_group_id", parameterToString(*r.tenantGroupId, ""))
	}
	if r.tenantGroup != nil {
		localVarQueryParams.Add("tenant_group", parameterToString(*r.tenantGroup, ""))
	}
	if r.tenantId != nil {
		localVarQueryParams.Add("tenant_id", parameterToString(*r.tenantId, ""))
	}
	if r.tenant != nil {
		localVarQueryParams.Add("tenant", parameterToString(*r.tenant, ""))
	}
	if r.q != nil {
		localVarQueryParams.Add("q", parameterToString(*r.q, ""))
	}
	if r.importingVrfId != nil {
		localVarQueryParams.Add("importing_vrf_id", parameterToString(*r.importingVrfId, ""))
	}
	if r.importingVrf != nil {
		localVarQueryParams.Add("importing_vrf", parameterToString(*r.importingVrf, ""))
	}
	if r.exportingVrfId != nil {
		localVarQueryParams.Add("exporting_vrf_id", parameterToString(*r.exportingVrfId, ""))
	}
	if r.exportingVrf != nil {
		localVarQueryParams.Add("exporting_vrf", parameterToString(*r.exportingVrf, ""))
	}
	if r.tag != nil {
		localVarQueryParams.Add("tag", parameterToString(*r.tag, ""))
	}
	if r.idN != nil {
		localVarQueryParams.Add("id__n", parameterToString(*r.idN, ""))
	}
	if r.idLte != nil {
		localVarQueryParams.Add("id__lte", parameterToString(*r.idLte, ""))
	}
	if r.idLt != nil {
		localVarQueryParams.Add("id__lt", parameterToString(*r.idLt, ""))
	}
	if r.idGte != nil {
		localVarQueryParams.Add("id__gte", parameterToString(*r.idGte, ""))
	}
	if r.idGt != nil {
		localVarQueryParams.Add("id__gt", parameterToString(*r.idGt, ""))
	}
	if r.nameN != nil {
		localVarQueryParams.Add("name__n", parameterToString(*r.nameN, ""))
	}
	if r.nameIc != nil {
		localVarQueryParams.Add("name__ic", parameterToString(*r.nameIc, ""))
	}
	if r.nameNic != nil {
		localVarQueryParams.Add("name__nic", parameterToString(*r.nameNic, ""))
	}
	if r.nameIew != nil {
		localVarQueryParams.Add("name__iew", parameterToString(*r.nameIew, ""))
	}
	if r.nameNiew != nil {
		localVarQueryParams.Add("name__niew", parameterToString(*r.nameNiew, ""))
	}
	if r.nameIsw != nil {
		localVarQueryParams.Add("name__isw", parameterToString(*r.nameIsw, ""))
	}
	if r.nameNisw != nil {
		localVarQueryParams.Add("name__nisw", parameterToString(*r.nameNisw, ""))
	}
	if r.nameIe != nil {
		localVarQueryParams.Add("name__ie", parameterToString(*r.nameIe, ""))
	}
	if r.nameNie != nil {
		localVarQueryParams.Add("name__nie", parameterToString(*r.nameNie, ""))
	}
	if r.nameEmpty != nil {
		localVarQueryParams.Add("name__empty", parameterToString(*r.nameEmpty, ""))
	}
	if r.tenantGroupIdN != nil {
		localVarQueryParams.Add("tenant_group_id__n", parameterToString(*r.tenantGroupIdN, ""))
	}
	if r.tenantGroupN != nil {
		localVarQueryParams.Add("tenant_group__n", parameterToString(*r.tenantGroupN, ""))
	}
	if r.tenantIdN != nil {
		localVarQueryParams.Add("tenant_id__n", parameterToString(*r.tenantIdN, ""))
	}
	if r.tenantN != nil {
		localVarQueryParams.Add("tenant__n", parameterToString(*r.tenantN, ""))
	}
	if r.importingVrfIdN != nil {
		localVarQueryParams.Add("importing_vrf_id__n", parameterToString(*r.importingVrfIdN, ""))
	}
	if r.importingVrfN != nil {
		localVarQueryParams.Add("importing_vrf__n", parameterToString(*r.importingVrfN, ""))
	}
	if r.exportingVrfIdN != nil {
		localVarQueryParams.Add("exporting_vrf_id__n", parameterToString(*r.exportingVrfIdN, ""))
	}
	if r.exportingVrfN != nil {
		localVarQueryParams.Add("exporting_vrf__n", parameterToString(*r.exportingVrfN, ""))
	}
	if r.tagN != nil {
		localVarQueryParams.Add("tag__n", parameterToString(*r.tagN, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamRouteTargetsPartialUpdateRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	id int32
	data *WritableRouteTarget
}

func (r ApiIpamRouteTargetsPartialUpdateRequest) Data(data WritableRouteTarget) ApiIpamRouteTargetsPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiIpamRouteTargetsPartialUpdateRequest) Execute() (*RouteTarget, *http.Response, error) {
	return r.ApiService.IpamRouteTargetsPartialUpdateExecute(r)
}

/*
IpamRouteTargetsPartialUpdate Method for IpamRouteTargetsPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this route target.
 @return ApiIpamRouteTargetsPartialUpdateRequest
*/
func (a *IpamApiService) IpamRouteTargetsPartialUpdate(ctx context.Context, id int32) ApiIpamRouteTargetsPartialUpdateRequest {
	return ApiIpamRouteTargetsPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return RouteTarget
func (a *IpamApiService) IpamRouteTargetsPartialUpdateExecute(r ApiIpamRouteTargetsPartialUpdateRequest) (*RouteTarget, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RouteTarget
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamRouteTargetsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/route-targets/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamRouteTargetsReadRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	id int32
}

func (r ApiIpamRouteTargetsReadRequest) Execute() (*RouteTarget, *http.Response, error) {
	return r.ApiService.IpamRouteTargetsReadExecute(r)
}

/*
IpamRouteTargetsRead Method for IpamRouteTargetsRead

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this route target.
 @return ApiIpamRouteTargetsReadRequest
*/
func (a *IpamApiService) IpamRouteTargetsRead(ctx context.Context, id int32) ApiIpamRouteTargetsReadRequest {
	return ApiIpamRouteTargetsReadRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return RouteTarget
func (a *IpamApiService) IpamRouteTargetsReadExecute(r ApiIpamRouteTargetsReadRequest) (*RouteTarget, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RouteTarget
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamRouteTargetsRead")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/route-targets/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamRouteTargetsUpdateRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	id int32
	data *WritableRouteTarget
}

func (r ApiIpamRouteTargetsUpdateRequest) Data(data WritableRouteTarget) ApiIpamRouteTargetsUpdateRequest {
	r.data = &data
	return r
}

func (r ApiIpamRouteTargetsUpdateRequest) Execute() (*RouteTarget, *http.Response, error) {
	return r.ApiService.IpamRouteTargetsUpdateExecute(r)
}

/*
IpamRouteTargetsUpdate Method for IpamRouteTargetsUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this route target.
 @return ApiIpamRouteTargetsUpdateRequest
*/
func (a *IpamApiService) IpamRouteTargetsUpdate(ctx context.Context, id int32) ApiIpamRouteTargetsUpdateRequest {
	return ApiIpamRouteTargetsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return RouteTarget
func (a *IpamApiService) IpamRouteTargetsUpdateExecute(r ApiIpamRouteTargetsUpdateRequest) (*RouteTarget, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RouteTarget
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamRouteTargetsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/route-targets/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamServicesBulkDeleteRequest struct {
	ctx context.Context
	ApiService *IpamApiService
}

func (r ApiIpamServicesBulkDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamServicesBulkDeleteExecute(r)
}

/*
IpamServicesBulkDelete Method for IpamServicesBulkDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamServicesBulkDeleteRequest
*/
func (a *IpamApiService) IpamServicesBulkDelete(ctx context.Context) ApiIpamServicesBulkDeleteRequest {
	return ApiIpamServicesBulkDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *IpamApiService) IpamServicesBulkDeleteExecute(r ApiIpamServicesBulkDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamServicesBulkDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/services/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamServicesBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	data *WritableService
}

func (r ApiIpamServicesBulkPartialUpdateRequest) Data(data WritableService) ApiIpamServicesBulkPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiIpamServicesBulkPartialUpdateRequest) Execute() (*Service, *http.Response, error) {
	return r.ApiService.IpamServicesBulkPartialUpdateExecute(r)
}

/*
IpamServicesBulkPartialUpdate Method for IpamServicesBulkPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamServicesBulkPartialUpdateRequest
*/
func (a *IpamApiService) IpamServicesBulkPartialUpdate(ctx context.Context) ApiIpamServicesBulkPartialUpdateRequest {
	return ApiIpamServicesBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Service
func (a *IpamApiService) IpamServicesBulkPartialUpdateExecute(r ApiIpamServicesBulkPartialUpdateRequest) (*Service, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Service
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamServicesBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/services/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamServicesBulkUpdateRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	data *WritableService
}

func (r ApiIpamServicesBulkUpdateRequest) Data(data WritableService) ApiIpamServicesBulkUpdateRequest {
	r.data = &data
	return r
}

func (r ApiIpamServicesBulkUpdateRequest) Execute() (*Service, *http.Response, error) {
	return r.ApiService.IpamServicesBulkUpdateExecute(r)
}

/*
IpamServicesBulkUpdate Method for IpamServicesBulkUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamServicesBulkUpdateRequest
*/
func (a *IpamApiService) IpamServicesBulkUpdate(ctx context.Context) ApiIpamServicesBulkUpdateRequest {
	return ApiIpamServicesBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Service
func (a *IpamApiService) IpamServicesBulkUpdateExecute(r ApiIpamServicesBulkUpdateRequest) (*Service, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Service
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamServicesBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/services/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamServicesCreateRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	data *WritableService
}

func (r ApiIpamServicesCreateRequest) Data(data WritableService) ApiIpamServicesCreateRequest {
	r.data = &data
	return r
}

func (r ApiIpamServicesCreateRequest) Execute() (*Service, *http.Response, error) {
	return r.ApiService.IpamServicesCreateExecute(r)
}

/*
IpamServicesCreate Method for IpamServicesCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamServicesCreateRequest
*/
func (a *IpamApiService) IpamServicesCreate(ctx context.Context) ApiIpamServicesCreateRequest {
	return ApiIpamServicesCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Service
func (a *IpamApiService) IpamServicesCreateExecute(r ApiIpamServicesCreateRequest) (*Service, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Service
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamServicesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/services/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamServicesDeleteRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	id int32
}

func (r ApiIpamServicesDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamServicesDeleteExecute(r)
}

/*
IpamServicesDelete Method for IpamServicesDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this service.
 @return ApiIpamServicesDeleteRequest
*/
func (a *IpamApiService) IpamServicesDelete(ctx context.Context, id int32) ApiIpamServicesDeleteRequest {
	return ApiIpamServicesDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *IpamApiService) IpamServicesDeleteExecute(r ApiIpamServicesDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamServicesDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/services/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamServicesListRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	id *string
	name *string
	protocol *string
	created *string
	createdGte *string
	createdLte *string
	lastUpdated *string
	lastUpdatedGte *string
	lastUpdatedLte *string
	q *string
	deviceId *string
	device *string
	virtualMachineId *string
	virtualMachine *string
	port *float32
	tag *string
	idN *string
	idLte *string
	idLt *string
	idGte *string
	idGt *string
	nameN *string
	nameIc *string
	nameNic *string
	nameIew *string
	nameNiew *string
	nameIsw *string
	nameNisw *string
	nameIe *string
	nameNie *string
	nameEmpty *string
	protocolN *string
	deviceIdN *string
	deviceN *string
	virtualMachineIdN *string
	virtualMachineN *string
	tagN *string
	limit *int32
	offset *int32
}

func (r ApiIpamServicesListRequest) Id(id string) ApiIpamServicesListRequest {
	r.id = &id
	return r
}

func (r ApiIpamServicesListRequest) Name(name string) ApiIpamServicesListRequest {
	r.name = &name
	return r
}

func (r ApiIpamServicesListRequest) Protocol(protocol string) ApiIpamServicesListRequest {
	r.protocol = &protocol
	return r
}

func (r ApiIpamServicesListRequest) Created(created string) ApiIpamServicesListRequest {
	r.created = &created
	return r
}

func (r ApiIpamServicesListRequest) CreatedGte(createdGte string) ApiIpamServicesListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiIpamServicesListRequest) CreatedLte(createdLte string) ApiIpamServicesListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiIpamServicesListRequest) LastUpdated(lastUpdated string) ApiIpamServicesListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiIpamServicesListRequest) LastUpdatedGte(lastUpdatedGte string) ApiIpamServicesListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiIpamServicesListRequest) LastUpdatedLte(lastUpdatedLte string) ApiIpamServicesListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiIpamServicesListRequest) Q(q string) ApiIpamServicesListRequest {
	r.q = &q
	return r
}

func (r ApiIpamServicesListRequest) DeviceId(deviceId string) ApiIpamServicesListRequest {
	r.deviceId = &deviceId
	return r
}

func (r ApiIpamServicesListRequest) Device(device string) ApiIpamServicesListRequest {
	r.device = &device
	return r
}

func (r ApiIpamServicesListRequest) VirtualMachineId(virtualMachineId string) ApiIpamServicesListRequest {
	r.virtualMachineId = &virtualMachineId
	return r
}

func (r ApiIpamServicesListRequest) VirtualMachine(virtualMachine string) ApiIpamServicesListRequest {
	r.virtualMachine = &virtualMachine
	return r
}

func (r ApiIpamServicesListRequest) Port(port float32) ApiIpamServicesListRequest {
	r.port = &port
	return r
}

func (r ApiIpamServicesListRequest) Tag(tag string) ApiIpamServicesListRequest {
	r.tag = &tag
	return r
}

func (r ApiIpamServicesListRequest) IdN(idN string) ApiIpamServicesListRequest {
	r.idN = &idN
	return r
}

func (r ApiIpamServicesListRequest) IdLte(idLte string) ApiIpamServicesListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiIpamServicesListRequest) IdLt(idLt string) ApiIpamServicesListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiIpamServicesListRequest) IdGte(idGte string) ApiIpamServicesListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiIpamServicesListRequest) IdGt(idGt string) ApiIpamServicesListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiIpamServicesListRequest) NameN(nameN string) ApiIpamServicesListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiIpamServicesListRequest) NameIc(nameIc string) ApiIpamServicesListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiIpamServicesListRequest) NameNic(nameNic string) ApiIpamServicesListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiIpamServicesListRequest) NameIew(nameIew string) ApiIpamServicesListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiIpamServicesListRequest) NameNiew(nameNiew string) ApiIpamServicesListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiIpamServicesListRequest) NameIsw(nameIsw string) ApiIpamServicesListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiIpamServicesListRequest) NameNisw(nameNisw string) ApiIpamServicesListRequest {
	r.nameNisw = &nameNisw
	return r
}

func (r ApiIpamServicesListRequest) NameIe(nameIe string) ApiIpamServicesListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiIpamServicesListRequest) NameNie(nameNie string) ApiIpamServicesListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiIpamServicesListRequest) NameEmpty(nameEmpty string) ApiIpamServicesListRequest {
	r.nameEmpty = &nameEmpty
	return r
}

func (r ApiIpamServicesListRequest) ProtocolN(protocolN string) ApiIpamServicesListRequest {
	r.protocolN = &protocolN
	return r
}

func (r ApiIpamServicesListRequest) DeviceIdN(deviceIdN string) ApiIpamServicesListRequest {
	r.deviceIdN = &deviceIdN
	return r
}

func (r ApiIpamServicesListRequest) DeviceN(deviceN string) ApiIpamServicesListRequest {
	r.deviceN = &deviceN
	return r
}

func (r ApiIpamServicesListRequest) VirtualMachineIdN(virtualMachineIdN string) ApiIpamServicesListRequest {
	r.virtualMachineIdN = &virtualMachineIdN
	return r
}

func (r ApiIpamServicesListRequest) VirtualMachineN(virtualMachineN string) ApiIpamServicesListRequest {
	r.virtualMachineN = &virtualMachineN
	return r
}

func (r ApiIpamServicesListRequest) TagN(tagN string) ApiIpamServicesListRequest {
	r.tagN = &tagN
	return r
}

// Number of results to return per page.
func (r ApiIpamServicesListRequest) Limit(limit int32) ApiIpamServicesListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiIpamServicesListRequest) Offset(offset int32) ApiIpamServicesListRequest {
	r.offset = &offset
	return r
}

func (r ApiIpamServicesListRequest) Execute() (*IpamServicesList200Response, *http.Response, error) {
	return r.ApiService.IpamServicesListExecute(r)
}

/*
IpamServicesList Method for IpamServicesList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamServicesListRequest
*/
func (a *IpamApiService) IpamServicesList(ctx context.Context) ApiIpamServicesListRequest {
	return ApiIpamServicesListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return IpamServicesList200Response
func (a *IpamApiService) IpamServicesListExecute(r ApiIpamServicesListRequest) (*IpamServicesList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IpamServicesList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamServicesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/services/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.protocol != nil {
		localVarQueryParams.Add("protocol", parameterToString(*r.protocol, ""))
	}
	if r.created != nil {
		localVarQueryParams.Add("created", parameterToString(*r.created, ""))
	}
	if r.createdGte != nil {
		localVarQueryParams.Add("created__gte", parameterToString(*r.createdGte, ""))
	}
	if r.createdLte != nil {
		localVarQueryParams.Add("created__lte", parameterToString(*r.createdLte, ""))
	}
	if r.lastUpdated != nil {
		localVarQueryParams.Add("last_updated", parameterToString(*r.lastUpdated, ""))
	}
	if r.lastUpdatedGte != nil {
		localVarQueryParams.Add("last_updated__gte", parameterToString(*r.lastUpdatedGte, ""))
	}
	if r.lastUpdatedLte != nil {
		localVarQueryParams.Add("last_updated__lte", parameterToString(*r.lastUpdatedLte, ""))
	}
	if r.q != nil {
		localVarQueryParams.Add("q", parameterToString(*r.q, ""))
	}
	if r.deviceId != nil {
		localVarQueryParams.Add("device_id", parameterToString(*r.deviceId, ""))
	}
	if r.device != nil {
		localVarQueryParams.Add("device", parameterToString(*r.device, ""))
	}
	if r.virtualMachineId != nil {
		localVarQueryParams.Add("virtual_machine_id", parameterToString(*r.virtualMachineId, ""))
	}
	if r.virtualMachine != nil {
		localVarQueryParams.Add("virtual_machine", parameterToString(*r.virtualMachine, ""))
	}
	if r.port != nil {
		localVarQueryParams.Add("port", parameterToString(*r.port, ""))
	}
	if r.tag != nil {
		localVarQueryParams.Add("tag", parameterToString(*r.tag, ""))
	}
	if r.idN != nil {
		localVarQueryParams.Add("id__n", parameterToString(*r.idN, ""))
	}
	if r.idLte != nil {
		localVarQueryParams.Add("id__lte", parameterToString(*r.idLte, ""))
	}
	if r.idLt != nil {
		localVarQueryParams.Add("id__lt", parameterToString(*r.idLt, ""))
	}
	if r.idGte != nil {
		localVarQueryParams.Add("id__gte", parameterToString(*r.idGte, ""))
	}
	if r.idGt != nil {
		localVarQueryParams.Add("id__gt", parameterToString(*r.idGt, ""))
	}
	if r.nameN != nil {
		localVarQueryParams.Add("name__n", parameterToString(*r.nameN, ""))
	}
	if r.nameIc != nil {
		localVarQueryParams.Add("name__ic", parameterToString(*r.nameIc, ""))
	}
	if r.nameNic != nil {
		localVarQueryParams.Add("name__nic", parameterToString(*r.nameNic, ""))
	}
	if r.nameIew != nil {
		localVarQueryParams.Add("name__iew", parameterToString(*r.nameIew, ""))
	}
	if r.nameNiew != nil {
		localVarQueryParams.Add("name__niew", parameterToString(*r.nameNiew, ""))
	}
	if r.nameIsw != nil {
		localVarQueryParams.Add("name__isw", parameterToString(*r.nameIsw, ""))
	}
	if r.nameNisw != nil {
		localVarQueryParams.Add("name__nisw", parameterToString(*r.nameNisw, ""))
	}
	if r.nameIe != nil {
		localVarQueryParams.Add("name__ie", parameterToString(*r.nameIe, ""))
	}
	if r.nameNie != nil {
		localVarQueryParams.Add("name__nie", parameterToString(*r.nameNie, ""))
	}
	if r.nameEmpty != nil {
		localVarQueryParams.Add("name__empty", parameterToString(*r.nameEmpty, ""))
	}
	if r.protocolN != nil {
		localVarQueryParams.Add("protocol__n", parameterToString(*r.protocolN, ""))
	}
	if r.deviceIdN != nil {
		localVarQueryParams.Add("device_id__n", parameterToString(*r.deviceIdN, ""))
	}
	if r.deviceN != nil {
		localVarQueryParams.Add("device__n", parameterToString(*r.deviceN, ""))
	}
	if r.virtualMachineIdN != nil {
		localVarQueryParams.Add("virtual_machine_id__n", parameterToString(*r.virtualMachineIdN, ""))
	}
	if r.virtualMachineN != nil {
		localVarQueryParams.Add("virtual_machine__n", parameterToString(*r.virtualMachineN, ""))
	}
	if r.tagN != nil {
		localVarQueryParams.Add("tag__n", parameterToString(*r.tagN, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamServicesPartialUpdateRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	id int32
	data *WritableService
}

func (r ApiIpamServicesPartialUpdateRequest) Data(data WritableService) ApiIpamServicesPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiIpamServicesPartialUpdateRequest) Execute() (*Service, *http.Response, error) {
	return r.ApiService.IpamServicesPartialUpdateExecute(r)
}

/*
IpamServicesPartialUpdate Method for IpamServicesPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this service.
 @return ApiIpamServicesPartialUpdateRequest
*/
func (a *IpamApiService) IpamServicesPartialUpdate(ctx context.Context, id int32) ApiIpamServicesPartialUpdateRequest {
	return ApiIpamServicesPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Service
func (a *IpamApiService) IpamServicesPartialUpdateExecute(r ApiIpamServicesPartialUpdateRequest) (*Service, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Service
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamServicesPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/services/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamServicesReadRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	id int32
}

func (r ApiIpamServicesReadRequest) Execute() (*Service, *http.Response, error) {
	return r.ApiService.IpamServicesReadExecute(r)
}

/*
IpamServicesRead Method for IpamServicesRead

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this service.
 @return ApiIpamServicesReadRequest
*/
func (a *IpamApiService) IpamServicesRead(ctx context.Context, id int32) ApiIpamServicesReadRequest {
	return ApiIpamServicesReadRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Service
func (a *IpamApiService) IpamServicesReadExecute(r ApiIpamServicesReadRequest) (*Service, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Service
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamServicesRead")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/services/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamServicesUpdateRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	id int32
	data *WritableService
}

func (r ApiIpamServicesUpdateRequest) Data(data WritableService) ApiIpamServicesUpdateRequest {
	r.data = &data
	return r
}

func (r ApiIpamServicesUpdateRequest) Execute() (*Service, *http.Response, error) {
	return r.ApiService.IpamServicesUpdateExecute(r)
}

/*
IpamServicesUpdate Method for IpamServicesUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this service.
 @return ApiIpamServicesUpdateRequest
*/
func (a *IpamApiService) IpamServicesUpdate(ctx context.Context, id int32) ApiIpamServicesUpdateRequest {
	return ApiIpamServicesUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Service
func (a *IpamApiService) IpamServicesUpdateExecute(r ApiIpamServicesUpdateRequest) (*Service, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Service
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamServicesUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/services/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVlanGroupsBulkDeleteRequest struct {
	ctx context.Context
	ApiService *IpamApiService
}

func (r ApiIpamVlanGroupsBulkDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamVlanGroupsBulkDeleteExecute(r)
}

/*
IpamVlanGroupsBulkDelete Method for IpamVlanGroupsBulkDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamVlanGroupsBulkDeleteRequest
*/
func (a *IpamApiService) IpamVlanGroupsBulkDelete(ctx context.Context) ApiIpamVlanGroupsBulkDeleteRequest {
	return ApiIpamVlanGroupsBulkDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *IpamApiService) IpamVlanGroupsBulkDeleteExecute(r ApiIpamVlanGroupsBulkDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamVlanGroupsBulkDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/vlan-groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamVlanGroupsBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	data *VLANGroup
}

func (r ApiIpamVlanGroupsBulkPartialUpdateRequest) Data(data VLANGroup) ApiIpamVlanGroupsBulkPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiIpamVlanGroupsBulkPartialUpdateRequest) Execute() (*VLANGroup, *http.Response, error) {
	return r.ApiService.IpamVlanGroupsBulkPartialUpdateExecute(r)
}

/*
IpamVlanGroupsBulkPartialUpdate Method for IpamVlanGroupsBulkPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamVlanGroupsBulkPartialUpdateRequest
*/
func (a *IpamApiService) IpamVlanGroupsBulkPartialUpdate(ctx context.Context) ApiIpamVlanGroupsBulkPartialUpdateRequest {
	return ApiIpamVlanGroupsBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return VLANGroup
func (a *IpamApiService) IpamVlanGroupsBulkPartialUpdateExecute(r ApiIpamVlanGroupsBulkPartialUpdateRequest) (*VLANGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VLANGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamVlanGroupsBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/vlan-groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVlanGroupsBulkUpdateRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	data *VLANGroup
}

func (r ApiIpamVlanGroupsBulkUpdateRequest) Data(data VLANGroup) ApiIpamVlanGroupsBulkUpdateRequest {
	r.data = &data
	return r
}

func (r ApiIpamVlanGroupsBulkUpdateRequest) Execute() (*VLANGroup, *http.Response, error) {
	return r.ApiService.IpamVlanGroupsBulkUpdateExecute(r)
}

/*
IpamVlanGroupsBulkUpdate Method for IpamVlanGroupsBulkUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamVlanGroupsBulkUpdateRequest
*/
func (a *IpamApiService) IpamVlanGroupsBulkUpdate(ctx context.Context) ApiIpamVlanGroupsBulkUpdateRequest {
	return ApiIpamVlanGroupsBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return VLANGroup
func (a *IpamApiService) IpamVlanGroupsBulkUpdateExecute(r ApiIpamVlanGroupsBulkUpdateRequest) (*VLANGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VLANGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamVlanGroupsBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/vlan-groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVlanGroupsCreateRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	data *VLANGroup
}

func (r ApiIpamVlanGroupsCreateRequest) Data(data VLANGroup) ApiIpamVlanGroupsCreateRequest {
	r.data = &data
	return r
}

func (r ApiIpamVlanGroupsCreateRequest) Execute() (*VLANGroup, *http.Response, error) {
	return r.ApiService.IpamVlanGroupsCreateExecute(r)
}

/*
IpamVlanGroupsCreate Method for IpamVlanGroupsCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamVlanGroupsCreateRequest
*/
func (a *IpamApiService) IpamVlanGroupsCreate(ctx context.Context) ApiIpamVlanGroupsCreateRequest {
	return ApiIpamVlanGroupsCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return VLANGroup
func (a *IpamApiService) IpamVlanGroupsCreateExecute(r ApiIpamVlanGroupsCreateRequest) (*VLANGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VLANGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamVlanGroupsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/vlan-groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVlanGroupsDeleteRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	id int32
}

func (r ApiIpamVlanGroupsDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamVlanGroupsDeleteExecute(r)
}

/*
IpamVlanGroupsDelete Method for IpamVlanGroupsDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this VLAN group.
 @return ApiIpamVlanGroupsDeleteRequest
*/
func (a *IpamApiService) IpamVlanGroupsDelete(ctx context.Context, id int32) ApiIpamVlanGroupsDeleteRequest {
	return ApiIpamVlanGroupsDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *IpamApiService) IpamVlanGroupsDeleteExecute(r ApiIpamVlanGroupsDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamVlanGroupsDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/vlan-groups/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamVlanGroupsListRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	id *string
	name *string
	slug *string
	description *string
	scopeId *string
	created *string
	createdGte *string
	createdLte *string
	lastUpdated *string
	lastUpdatedGte *string
	lastUpdatedLte *string
	q *string
	scopeType *string
	region *float32
	sitegroup *float32
	site *float32
	location *float32
	rack *float32
	clustergroup *float32
	cluster *float32
	idN *string
	idLte *string
	idLt *string
	idGte *string
	idGt *string
	nameN *string
	nameIc *string
	nameNic *string
	nameIew *string
	nameNiew *string
	nameIsw *string
	nameNisw *string
	nameIe *string
	nameNie *string
	nameEmpty *string
	slugN *string
	slugIc *string
	slugNic *string
	slugIew *string
	slugNiew *string
	slugIsw *string
	slugNisw *string
	slugIe *string
	slugNie *string
	slugEmpty *string
	descriptionN *string
	descriptionIc *string
	descriptionNic *string
	descriptionIew *string
	descriptionNiew *string
	descriptionIsw *string
	descriptionNisw *string
	descriptionIe *string
	descriptionNie *string
	descriptionEmpty *string
	scopeIdN *string
	scopeIdLte *string
	scopeIdLt *string
	scopeIdGte *string
	scopeIdGt *string
	scopeTypeN *string
	limit *int32
	offset *int32
}

func (r ApiIpamVlanGroupsListRequest) Id(id string) ApiIpamVlanGroupsListRequest {
	r.id = &id
	return r
}

func (r ApiIpamVlanGroupsListRequest) Name(name string) ApiIpamVlanGroupsListRequest {
	r.name = &name
	return r
}

func (r ApiIpamVlanGroupsListRequest) Slug(slug string) ApiIpamVlanGroupsListRequest {
	r.slug = &slug
	return r
}

func (r ApiIpamVlanGroupsListRequest) Description(description string) ApiIpamVlanGroupsListRequest {
	r.description = &description
	return r
}

func (r ApiIpamVlanGroupsListRequest) ScopeId(scopeId string) ApiIpamVlanGroupsListRequest {
	r.scopeId = &scopeId
	return r
}

func (r ApiIpamVlanGroupsListRequest) Created(created string) ApiIpamVlanGroupsListRequest {
	r.created = &created
	return r
}

func (r ApiIpamVlanGroupsListRequest) CreatedGte(createdGte string) ApiIpamVlanGroupsListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiIpamVlanGroupsListRequest) CreatedLte(createdLte string) ApiIpamVlanGroupsListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiIpamVlanGroupsListRequest) LastUpdated(lastUpdated string) ApiIpamVlanGroupsListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiIpamVlanGroupsListRequest) LastUpdatedGte(lastUpdatedGte string) ApiIpamVlanGroupsListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiIpamVlanGroupsListRequest) LastUpdatedLte(lastUpdatedLte string) ApiIpamVlanGroupsListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiIpamVlanGroupsListRequest) Q(q string) ApiIpamVlanGroupsListRequest {
	r.q = &q
	return r
}

func (r ApiIpamVlanGroupsListRequest) ScopeType(scopeType string) ApiIpamVlanGroupsListRequest {
	r.scopeType = &scopeType
	return r
}

func (r ApiIpamVlanGroupsListRequest) Region(region float32) ApiIpamVlanGroupsListRequest {
	r.region = &region
	return r
}

func (r ApiIpamVlanGroupsListRequest) Sitegroup(sitegroup float32) ApiIpamVlanGroupsListRequest {
	r.sitegroup = &sitegroup
	return r
}

func (r ApiIpamVlanGroupsListRequest) Site(site float32) ApiIpamVlanGroupsListRequest {
	r.site = &site
	return r
}

func (r ApiIpamVlanGroupsListRequest) Location(location float32) ApiIpamVlanGroupsListRequest {
	r.location = &location
	return r
}

func (r ApiIpamVlanGroupsListRequest) Rack(rack float32) ApiIpamVlanGroupsListRequest {
	r.rack = &rack
	return r
}

func (r ApiIpamVlanGroupsListRequest) Clustergroup(clustergroup float32) ApiIpamVlanGroupsListRequest {
	r.clustergroup = &clustergroup
	return r
}

func (r ApiIpamVlanGroupsListRequest) Cluster(cluster float32) ApiIpamVlanGroupsListRequest {
	r.cluster = &cluster
	return r
}

func (r ApiIpamVlanGroupsListRequest) IdN(idN string) ApiIpamVlanGroupsListRequest {
	r.idN = &idN
	return r
}

func (r ApiIpamVlanGroupsListRequest) IdLte(idLte string) ApiIpamVlanGroupsListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiIpamVlanGroupsListRequest) IdLt(idLt string) ApiIpamVlanGroupsListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiIpamVlanGroupsListRequest) IdGte(idGte string) ApiIpamVlanGroupsListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiIpamVlanGroupsListRequest) IdGt(idGt string) ApiIpamVlanGroupsListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiIpamVlanGroupsListRequest) NameN(nameN string) ApiIpamVlanGroupsListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiIpamVlanGroupsListRequest) NameIc(nameIc string) ApiIpamVlanGroupsListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiIpamVlanGroupsListRequest) NameNic(nameNic string) ApiIpamVlanGroupsListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiIpamVlanGroupsListRequest) NameIew(nameIew string) ApiIpamVlanGroupsListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiIpamVlanGroupsListRequest) NameNiew(nameNiew string) ApiIpamVlanGroupsListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiIpamVlanGroupsListRequest) NameIsw(nameIsw string) ApiIpamVlanGroupsListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiIpamVlanGroupsListRequest) NameNisw(nameNisw string) ApiIpamVlanGroupsListRequest {
	r.nameNisw = &nameNisw
	return r
}

func (r ApiIpamVlanGroupsListRequest) NameIe(nameIe string) ApiIpamVlanGroupsListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiIpamVlanGroupsListRequest) NameNie(nameNie string) ApiIpamVlanGroupsListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiIpamVlanGroupsListRequest) NameEmpty(nameEmpty string) ApiIpamVlanGroupsListRequest {
	r.nameEmpty = &nameEmpty
	return r
}

func (r ApiIpamVlanGroupsListRequest) SlugN(slugN string) ApiIpamVlanGroupsListRequest {
	r.slugN = &slugN
	return r
}

func (r ApiIpamVlanGroupsListRequest) SlugIc(slugIc string) ApiIpamVlanGroupsListRequest {
	r.slugIc = &slugIc
	return r
}

func (r ApiIpamVlanGroupsListRequest) SlugNic(slugNic string) ApiIpamVlanGroupsListRequest {
	r.slugNic = &slugNic
	return r
}

func (r ApiIpamVlanGroupsListRequest) SlugIew(slugIew string) ApiIpamVlanGroupsListRequest {
	r.slugIew = &slugIew
	return r
}

func (r ApiIpamVlanGroupsListRequest) SlugNiew(slugNiew string) ApiIpamVlanGroupsListRequest {
	r.slugNiew = &slugNiew
	return r
}

func (r ApiIpamVlanGroupsListRequest) SlugIsw(slugIsw string) ApiIpamVlanGroupsListRequest {
	r.slugIsw = &slugIsw
	return r
}

func (r ApiIpamVlanGroupsListRequest) SlugNisw(slugNisw string) ApiIpamVlanGroupsListRequest {
	r.slugNisw = &slugNisw
	return r
}

func (r ApiIpamVlanGroupsListRequest) SlugIe(slugIe string) ApiIpamVlanGroupsListRequest {
	r.slugIe = &slugIe
	return r
}

func (r ApiIpamVlanGroupsListRequest) SlugNie(slugNie string) ApiIpamVlanGroupsListRequest {
	r.slugNie = &slugNie
	return r
}

func (r ApiIpamVlanGroupsListRequest) SlugEmpty(slugEmpty string) ApiIpamVlanGroupsListRequest {
	r.slugEmpty = &slugEmpty
	return r
}

func (r ApiIpamVlanGroupsListRequest) DescriptionN(descriptionN string) ApiIpamVlanGroupsListRequest {
	r.descriptionN = &descriptionN
	return r
}

func (r ApiIpamVlanGroupsListRequest) DescriptionIc(descriptionIc string) ApiIpamVlanGroupsListRequest {
	r.descriptionIc = &descriptionIc
	return r
}

func (r ApiIpamVlanGroupsListRequest) DescriptionNic(descriptionNic string) ApiIpamVlanGroupsListRequest {
	r.descriptionNic = &descriptionNic
	return r
}

func (r ApiIpamVlanGroupsListRequest) DescriptionIew(descriptionIew string) ApiIpamVlanGroupsListRequest {
	r.descriptionIew = &descriptionIew
	return r
}

func (r ApiIpamVlanGroupsListRequest) DescriptionNiew(descriptionNiew string) ApiIpamVlanGroupsListRequest {
	r.descriptionNiew = &descriptionNiew
	return r
}

func (r ApiIpamVlanGroupsListRequest) DescriptionIsw(descriptionIsw string) ApiIpamVlanGroupsListRequest {
	r.descriptionIsw = &descriptionIsw
	return r
}

func (r ApiIpamVlanGroupsListRequest) DescriptionNisw(descriptionNisw string) ApiIpamVlanGroupsListRequest {
	r.descriptionNisw = &descriptionNisw
	return r
}

func (r ApiIpamVlanGroupsListRequest) DescriptionIe(descriptionIe string) ApiIpamVlanGroupsListRequest {
	r.descriptionIe = &descriptionIe
	return r
}

func (r ApiIpamVlanGroupsListRequest) DescriptionNie(descriptionNie string) ApiIpamVlanGroupsListRequest {
	r.descriptionNie = &descriptionNie
	return r
}

func (r ApiIpamVlanGroupsListRequest) DescriptionEmpty(descriptionEmpty string) ApiIpamVlanGroupsListRequest {
	r.descriptionEmpty = &descriptionEmpty
	return r
}

func (r ApiIpamVlanGroupsListRequest) ScopeIdN(scopeIdN string) ApiIpamVlanGroupsListRequest {
	r.scopeIdN = &scopeIdN
	return r
}

func (r ApiIpamVlanGroupsListRequest) ScopeIdLte(scopeIdLte string) ApiIpamVlanGroupsListRequest {
	r.scopeIdLte = &scopeIdLte
	return r
}

func (r ApiIpamVlanGroupsListRequest) ScopeIdLt(scopeIdLt string) ApiIpamVlanGroupsListRequest {
	r.scopeIdLt = &scopeIdLt
	return r
}

func (r ApiIpamVlanGroupsListRequest) ScopeIdGte(scopeIdGte string) ApiIpamVlanGroupsListRequest {
	r.scopeIdGte = &scopeIdGte
	return r
}

func (r ApiIpamVlanGroupsListRequest) ScopeIdGt(scopeIdGt string) ApiIpamVlanGroupsListRequest {
	r.scopeIdGt = &scopeIdGt
	return r
}

func (r ApiIpamVlanGroupsListRequest) ScopeTypeN(scopeTypeN string) ApiIpamVlanGroupsListRequest {
	r.scopeTypeN = &scopeTypeN
	return r
}

// Number of results to return per page.
func (r ApiIpamVlanGroupsListRequest) Limit(limit int32) ApiIpamVlanGroupsListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiIpamVlanGroupsListRequest) Offset(offset int32) ApiIpamVlanGroupsListRequest {
	r.offset = &offset
	return r
}

func (r ApiIpamVlanGroupsListRequest) Execute() (*IpamVlanGroupsList200Response, *http.Response, error) {
	return r.ApiService.IpamVlanGroupsListExecute(r)
}

/*
IpamVlanGroupsList Method for IpamVlanGroupsList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamVlanGroupsListRequest
*/
func (a *IpamApiService) IpamVlanGroupsList(ctx context.Context) ApiIpamVlanGroupsListRequest {
	return ApiIpamVlanGroupsListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return IpamVlanGroupsList200Response
func (a *IpamApiService) IpamVlanGroupsListExecute(r ApiIpamVlanGroupsListRequest) (*IpamVlanGroupsList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IpamVlanGroupsList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamVlanGroupsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/vlan-groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.slug != nil {
		localVarQueryParams.Add("slug", parameterToString(*r.slug, ""))
	}
	if r.description != nil {
		localVarQueryParams.Add("description", parameterToString(*r.description, ""))
	}
	if r.scopeId != nil {
		localVarQueryParams.Add("scope_id", parameterToString(*r.scopeId, ""))
	}
	if r.created != nil {
		localVarQueryParams.Add("created", parameterToString(*r.created, ""))
	}
	if r.createdGte != nil {
		localVarQueryParams.Add("created__gte", parameterToString(*r.createdGte, ""))
	}
	if r.createdLte != nil {
		localVarQueryParams.Add("created__lte", parameterToString(*r.createdLte, ""))
	}
	if r.lastUpdated != nil {
		localVarQueryParams.Add("last_updated", parameterToString(*r.lastUpdated, ""))
	}
	if r.lastUpdatedGte != nil {
		localVarQueryParams.Add("last_updated__gte", parameterToString(*r.lastUpdatedGte, ""))
	}
	if r.lastUpdatedLte != nil {
		localVarQueryParams.Add("last_updated__lte", parameterToString(*r.lastUpdatedLte, ""))
	}
	if r.q != nil {
		localVarQueryParams.Add("q", parameterToString(*r.q, ""))
	}
	if r.scopeType != nil {
		localVarQueryParams.Add("scope_type", parameterToString(*r.scopeType, ""))
	}
	if r.region != nil {
		localVarQueryParams.Add("region", parameterToString(*r.region, ""))
	}
	if r.sitegroup != nil {
		localVarQueryParams.Add("sitegroup", parameterToString(*r.sitegroup, ""))
	}
	if r.site != nil {
		localVarQueryParams.Add("site", parameterToString(*r.site, ""))
	}
	if r.location != nil {
		localVarQueryParams.Add("location", parameterToString(*r.location, ""))
	}
	if r.rack != nil {
		localVarQueryParams.Add("rack", parameterToString(*r.rack, ""))
	}
	if r.clustergroup != nil {
		localVarQueryParams.Add("clustergroup", parameterToString(*r.clustergroup, ""))
	}
	if r.cluster != nil {
		localVarQueryParams.Add("cluster", parameterToString(*r.cluster, ""))
	}
	if r.idN != nil {
		localVarQueryParams.Add("id__n", parameterToString(*r.idN, ""))
	}
	if r.idLte != nil {
		localVarQueryParams.Add("id__lte", parameterToString(*r.idLte, ""))
	}
	if r.idLt != nil {
		localVarQueryParams.Add("id__lt", parameterToString(*r.idLt, ""))
	}
	if r.idGte != nil {
		localVarQueryParams.Add("id__gte", parameterToString(*r.idGte, ""))
	}
	if r.idGt != nil {
		localVarQueryParams.Add("id__gt", parameterToString(*r.idGt, ""))
	}
	if r.nameN != nil {
		localVarQueryParams.Add("name__n", parameterToString(*r.nameN, ""))
	}
	if r.nameIc != nil {
		localVarQueryParams.Add("name__ic", parameterToString(*r.nameIc, ""))
	}
	if r.nameNic != nil {
		localVarQueryParams.Add("name__nic", parameterToString(*r.nameNic, ""))
	}
	if r.nameIew != nil {
		localVarQueryParams.Add("name__iew", parameterToString(*r.nameIew, ""))
	}
	if r.nameNiew != nil {
		localVarQueryParams.Add("name__niew", parameterToString(*r.nameNiew, ""))
	}
	if r.nameIsw != nil {
		localVarQueryParams.Add("name__isw", parameterToString(*r.nameIsw, ""))
	}
	if r.nameNisw != nil {
		localVarQueryParams.Add("name__nisw", parameterToString(*r.nameNisw, ""))
	}
	if r.nameIe != nil {
		localVarQueryParams.Add("name__ie", parameterToString(*r.nameIe, ""))
	}
	if r.nameNie != nil {
		localVarQueryParams.Add("name__nie", parameterToString(*r.nameNie, ""))
	}
	if r.nameEmpty != nil {
		localVarQueryParams.Add("name__empty", parameterToString(*r.nameEmpty, ""))
	}
	if r.slugN != nil {
		localVarQueryParams.Add("slug__n", parameterToString(*r.slugN, ""))
	}
	if r.slugIc != nil {
		localVarQueryParams.Add("slug__ic", parameterToString(*r.slugIc, ""))
	}
	if r.slugNic != nil {
		localVarQueryParams.Add("slug__nic", parameterToString(*r.slugNic, ""))
	}
	if r.slugIew != nil {
		localVarQueryParams.Add("slug__iew", parameterToString(*r.slugIew, ""))
	}
	if r.slugNiew != nil {
		localVarQueryParams.Add("slug__niew", parameterToString(*r.slugNiew, ""))
	}
	if r.slugIsw != nil {
		localVarQueryParams.Add("slug__isw", parameterToString(*r.slugIsw, ""))
	}
	if r.slugNisw != nil {
		localVarQueryParams.Add("slug__nisw", parameterToString(*r.slugNisw, ""))
	}
	if r.slugIe != nil {
		localVarQueryParams.Add("slug__ie", parameterToString(*r.slugIe, ""))
	}
	if r.slugNie != nil {
		localVarQueryParams.Add("slug__nie", parameterToString(*r.slugNie, ""))
	}
	if r.slugEmpty != nil {
		localVarQueryParams.Add("slug__empty", parameterToString(*r.slugEmpty, ""))
	}
	if r.descriptionN != nil {
		localVarQueryParams.Add("description__n", parameterToString(*r.descriptionN, ""))
	}
	if r.descriptionIc != nil {
		localVarQueryParams.Add("description__ic", parameterToString(*r.descriptionIc, ""))
	}
	if r.descriptionNic != nil {
		localVarQueryParams.Add("description__nic", parameterToString(*r.descriptionNic, ""))
	}
	if r.descriptionIew != nil {
		localVarQueryParams.Add("description__iew", parameterToString(*r.descriptionIew, ""))
	}
	if r.descriptionNiew != nil {
		localVarQueryParams.Add("description__niew", parameterToString(*r.descriptionNiew, ""))
	}
	if r.descriptionIsw != nil {
		localVarQueryParams.Add("description__isw", parameterToString(*r.descriptionIsw, ""))
	}
	if r.descriptionNisw != nil {
		localVarQueryParams.Add("description__nisw", parameterToString(*r.descriptionNisw, ""))
	}
	if r.descriptionIe != nil {
		localVarQueryParams.Add("description__ie", parameterToString(*r.descriptionIe, ""))
	}
	if r.descriptionNie != nil {
		localVarQueryParams.Add("description__nie", parameterToString(*r.descriptionNie, ""))
	}
	if r.descriptionEmpty != nil {
		localVarQueryParams.Add("description__empty", parameterToString(*r.descriptionEmpty, ""))
	}
	if r.scopeIdN != nil {
		localVarQueryParams.Add("scope_id__n", parameterToString(*r.scopeIdN, ""))
	}
	if r.scopeIdLte != nil {
		localVarQueryParams.Add("scope_id__lte", parameterToString(*r.scopeIdLte, ""))
	}
	if r.scopeIdLt != nil {
		localVarQueryParams.Add("scope_id__lt", parameterToString(*r.scopeIdLt, ""))
	}
	if r.scopeIdGte != nil {
		localVarQueryParams.Add("scope_id__gte", parameterToString(*r.scopeIdGte, ""))
	}
	if r.scopeIdGt != nil {
		localVarQueryParams.Add("scope_id__gt", parameterToString(*r.scopeIdGt, ""))
	}
	if r.scopeTypeN != nil {
		localVarQueryParams.Add("scope_type__n", parameterToString(*r.scopeTypeN, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVlanGroupsPartialUpdateRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	id int32
	data *VLANGroup
}

func (r ApiIpamVlanGroupsPartialUpdateRequest) Data(data VLANGroup) ApiIpamVlanGroupsPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiIpamVlanGroupsPartialUpdateRequest) Execute() (*VLANGroup, *http.Response, error) {
	return r.ApiService.IpamVlanGroupsPartialUpdateExecute(r)
}

/*
IpamVlanGroupsPartialUpdate Method for IpamVlanGroupsPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this VLAN group.
 @return ApiIpamVlanGroupsPartialUpdateRequest
*/
func (a *IpamApiService) IpamVlanGroupsPartialUpdate(ctx context.Context, id int32) ApiIpamVlanGroupsPartialUpdateRequest {
	return ApiIpamVlanGroupsPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return VLANGroup
func (a *IpamApiService) IpamVlanGroupsPartialUpdateExecute(r ApiIpamVlanGroupsPartialUpdateRequest) (*VLANGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VLANGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamVlanGroupsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/vlan-groups/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVlanGroupsReadRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	id int32
}

func (r ApiIpamVlanGroupsReadRequest) Execute() (*VLANGroup, *http.Response, error) {
	return r.ApiService.IpamVlanGroupsReadExecute(r)
}

/*
IpamVlanGroupsRead Method for IpamVlanGroupsRead

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this VLAN group.
 @return ApiIpamVlanGroupsReadRequest
*/
func (a *IpamApiService) IpamVlanGroupsRead(ctx context.Context, id int32) ApiIpamVlanGroupsReadRequest {
	return ApiIpamVlanGroupsReadRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return VLANGroup
func (a *IpamApiService) IpamVlanGroupsReadExecute(r ApiIpamVlanGroupsReadRequest) (*VLANGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VLANGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamVlanGroupsRead")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/vlan-groups/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVlanGroupsUpdateRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	id int32
	data *VLANGroup
}

func (r ApiIpamVlanGroupsUpdateRequest) Data(data VLANGroup) ApiIpamVlanGroupsUpdateRequest {
	r.data = &data
	return r
}

func (r ApiIpamVlanGroupsUpdateRequest) Execute() (*VLANGroup, *http.Response, error) {
	return r.ApiService.IpamVlanGroupsUpdateExecute(r)
}

/*
IpamVlanGroupsUpdate Method for IpamVlanGroupsUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this VLAN group.
 @return ApiIpamVlanGroupsUpdateRequest
*/
func (a *IpamApiService) IpamVlanGroupsUpdate(ctx context.Context, id int32) ApiIpamVlanGroupsUpdateRequest {
	return ApiIpamVlanGroupsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return VLANGroup
func (a *IpamApiService) IpamVlanGroupsUpdateExecute(r ApiIpamVlanGroupsUpdateRequest) (*VLANGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VLANGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamVlanGroupsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/vlan-groups/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVlansBulkDeleteRequest struct {
	ctx context.Context
	ApiService *IpamApiService
}

func (r ApiIpamVlansBulkDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamVlansBulkDeleteExecute(r)
}

/*
IpamVlansBulkDelete Method for IpamVlansBulkDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamVlansBulkDeleteRequest
*/
func (a *IpamApiService) IpamVlansBulkDelete(ctx context.Context) ApiIpamVlansBulkDeleteRequest {
	return ApiIpamVlansBulkDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *IpamApiService) IpamVlansBulkDeleteExecute(r ApiIpamVlansBulkDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamVlansBulkDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/vlans/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamVlansBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	data *WritableVLAN
}

func (r ApiIpamVlansBulkPartialUpdateRequest) Data(data WritableVLAN) ApiIpamVlansBulkPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiIpamVlansBulkPartialUpdateRequest) Execute() (*VLAN, *http.Response, error) {
	return r.ApiService.IpamVlansBulkPartialUpdateExecute(r)
}

/*
IpamVlansBulkPartialUpdate Method for IpamVlansBulkPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamVlansBulkPartialUpdateRequest
*/
func (a *IpamApiService) IpamVlansBulkPartialUpdate(ctx context.Context) ApiIpamVlansBulkPartialUpdateRequest {
	return ApiIpamVlansBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return VLAN
func (a *IpamApiService) IpamVlansBulkPartialUpdateExecute(r ApiIpamVlansBulkPartialUpdateRequest) (*VLAN, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VLAN
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamVlansBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/vlans/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVlansBulkUpdateRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	data *WritableVLAN
}

func (r ApiIpamVlansBulkUpdateRequest) Data(data WritableVLAN) ApiIpamVlansBulkUpdateRequest {
	r.data = &data
	return r
}

func (r ApiIpamVlansBulkUpdateRequest) Execute() (*VLAN, *http.Response, error) {
	return r.ApiService.IpamVlansBulkUpdateExecute(r)
}

/*
IpamVlansBulkUpdate Method for IpamVlansBulkUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamVlansBulkUpdateRequest
*/
func (a *IpamApiService) IpamVlansBulkUpdate(ctx context.Context) ApiIpamVlansBulkUpdateRequest {
	return ApiIpamVlansBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return VLAN
func (a *IpamApiService) IpamVlansBulkUpdateExecute(r ApiIpamVlansBulkUpdateRequest) (*VLAN, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VLAN
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamVlansBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/vlans/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVlansCreateRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	data *WritableVLAN
}

func (r ApiIpamVlansCreateRequest) Data(data WritableVLAN) ApiIpamVlansCreateRequest {
	r.data = &data
	return r
}

func (r ApiIpamVlansCreateRequest) Execute() (*VLAN, *http.Response, error) {
	return r.ApiService.IpamVlansCreateExecute(r)
}

/*
IpamVlansCreate Method for IpamVlansCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamVlansCreateRequest
*/
func (a *IpamApiService) IpamVlansCreate(ctx context.Context) ApiIpamVlansCreateRequest {
	return ApiIpamVlansCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return VLAN
func (a *IpamApiService) IpamVlansCreateExecute(r ApiIpamVlansCreateRequest) (*VLAN, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VLAN
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamVlansCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/vlans/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVlansDeleteRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	id int32
}

func (r ApiIpamVlansDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamVlansDeleteExecute(r)
}

/*
IpamVlansDelete Method for IpamVlansDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this VLAN.
 @return ApiIpamVlansDeleteRequest
*/
func (a *IpamApiService) IpamVlansDelete(ctx context.Context, id int32) ApiIpamVlansDeleteRequest {
	return ApiIpamVlansDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *IpamApiService) IpamVlansDeleteExecute(r ApiIpamVlansDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamVlansDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/vlans/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamVlansListRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	id *string
	vid *string
	name *string
	created *string
	createdGte *string
	createdLte *string
	lastUpdated *string
	lastUpdatedGte *string
	lastUpdatedLte *string
	tenantGroupId *string
	tenantGroup *string
	tenantId *string
	tenant *string
	q *string
	regionId *string
	region *string
	siteGroupId *string
	siteGroup *string
	siteId *string
	site *string
	groupId *string
	group *string
	roleId *string
	role *string
	status *string
	availableOnDevice *string
	availableOnVirtualmachine *string
	tag *string
	idN *string
	idLte *string
	idLt *string
	idGte *string
	idGt *string
	vidN *string
	vidLte *string
	vidLt *string
	vidGte *string
	vidGt *string
	nameN *string
	nameIc *string
	nameNic *string
	nameIew *string
	nameNiew *string
	nameIsw *string
	nameNisw *string
	nameIe *string
	nameNie *string
	nameEmpty *string
	tenantGroupIdN *string
	tenantGroupN *string
	tenantIdN *string
	tenantN *string
	regionIdN *string
	regionN *string
	siteGroupIdN *string
	siteGroupN *string
	siteIdN *string
	siteN *string
	groupIdN *string
	groupN *string
	roleIdN *string
	roleN *string
	statusN *string
	tagN *string
	limit *int32
	offset *int32
}

func (r ApiIpamVlansListRequest) Id(id string) ApiIpamVlansListRequest {
	r.id = &id
	return r
}

func (r ApiIpamVlansListRequest) Vid(vid string) ApiIpamVlansListRequest {
	r.vid = &vid
	return r
}

func (r ApiIpamVlansListRequest) Name(name string) ApiIpamVlansListRequest {
	r.name = &name
	return r
}

func (r ApiIpamVlansListRequest) Created(created string) ApiIpamVlansListRequest {
	r.created = &created
	return r
}

func (r ApiIpamVlansListRequest) CreatedGte(createdGte string) ApiIpamVlansListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiIpamVlansListRequest) CreatedLte(createdLte string) ApiIpamVlansListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiIpamVlansListRequest) LastUpdated(lastUpdated string) ApiIpamVlansListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiIpamVlansListRequest) LastUpdatedGte(lastUpdatedGte string) ApiIpamVlansListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiIpamVlansListRequest) LastUpdatedLte(lastUpdatedLte string) ApiIpamVlansListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiIpamVlansListRequest) TenantGroupId(tenantGroupId string) ApiIpamVlansListRequest {
	r.tenantGroupId = &tenantGroupId
	return r
}

func (r ApiIpamVlansListRequest) TenantGroup(tenantGroup string) ApiIpamVlansListRequest {
	r.tenantGroup = &tenantGroup
	return r
}

func (r ApiIpamVlansListRequest) TenantId(tenantId string) ApiIpamVlansListRequest {
	r.tenantId = &tenantId
	return r
}

func (r ApiIpamVlansListRequest) Tenant(tenant string) ApiIpamVlansListRequest {
	r.tenant = &tenant
	return r
}

func (r ApiIpamVlansListRequest) Q(q string) ApiIpamVlansListRequest {
	r.q = &q
	return r
}

func (r ApiIpamVlansListRequest) RegionId(regionId string) ApiIpamVlansListRequest {
	r.regionId = &regionId
	return r
}

func (r ApiIpamVlansListRequest) Region(region string) ApiIpamVlansListRequest {
	r.region = &region
	return r
}

func (r ApiIpamVlansListRequest) SiteGroupId(siteGroupId string) ApiIpamVlansListRequest {
	r.siteGroupId = &siteGroupId
	return r
}

func (r ApiIpamVlansListRequest) SiteGroup(siteGroup string) ApiIpamVlansListRequest {
	r.siteGroup = &siteGroup
	return r
}

func (r ApiIpamVlansListRequest) SiteId(siteId string) ApiIpamVlansListRequest {
	r.siteId = &siteId
	return r
}

func (r ApiIpamVlansListRequest) Site(site string) ApiIpamVlansListRequest {
	r.site = &site
	return r
}

func (r ApiIpamVlansListRequest) GroupId(groupId string) ApiIpamVlansListRequest {
	r.groupId = &groupId
	return r
}

func (r ApiIpamVlansListRequest) Group(group string) ApiIpamVlansListRequest {
	r.group = &group
	return r
}

func (r ApiIpamVlansListRequest) RoleId(roleId string) ApiIpamVlansListRequest {
	r.roleId = &roleId
	return r
}

func (r ApiIpamVlansListRequest) Role(role string) ApiIpamVlansListRequest {
	r.role = &role
	return r
}

func (r ApiIpamVlansListRequest) Status(status string) ApiIpamVlansListRequest {
	r.status = &status
	return r
}

func (r ApiIpamVlansListRequest) AvailableOnDevice(availableOnDevice string) ApiIpamVlansListRequest {
	r.availableOnDevice = &availableOnDevice
	return r
}

func (r ApiIpamVlansListRequest) AvailableOnVirtualmachine(availableOnVirtualmachine string) ApiIpamVlansListRequest {
	r.availableOnVirtualmachine = &availableOnVirtualmachine
	return r
}

func (r ApiIpamVlansListRequest) Tag(tag string) ApiIpamVlansListRequest {
	r.tag = &tag
	return r
}

func (r ApiIpamVlansListRequest) IdN(idN string) ApiIpamVlansListRequest {
	r.idN = &idN
	return r
}

func (r ApiIpamVlansListRequest) IdLte(idLte string) ApiIpamVlansListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiIpamVlansListRequest) IdLt(idLt string) ApiIpamVlansListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiIpamVlansListRequest) IdGte(idGte string) ApiIpamVlansListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiIpamVlansListRequest) IdGt(idGt string) ApiIpamVlansListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiIpamVlansListRequest) VidN(vidN string) ApiIpamVlansListRequest {
	r.vidN = &vidN
	return r
}

func (r ApiIpamVlansListRequest) VidLte(vidLte string) ApiIpamVlansListRequest {
	r.vidLte = &vidLte
	return r
}

func (r ApiIpamVlansListRequest) VidLt(vidLt string) ApiIpamVlansListRequest {
	r.vidLt = &vidLt
	return r
}

func (r ApiIpamVlansListRequest) VidGte(vidGte string) ApiIpamVlansListRequest {
	r.vidGte = &vidGte
	return r
}

func (r ApiIpamVlansListRequest) VidGt(vidGt string) ApiIpamVlansListRequest {
	r.vidGt = &vidGt
	return r
}

func (r ApiIpamVlansListRequest) NameN(nameN string) ApiIpamVlansListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiIpamVlansListRequest) NameIc(nameIc string) ApiIpamVlansListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiIpamVlansListRequest) NameNic(nameNic string) ApiIpamVlansListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiIpamVlansListRequest) NameIew(nameIew string) ApiIpamVlansListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiIpamVlansListRequest) NameNiew(nameNiew string) ApiIpamVlansListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiIpamVlansListRequest) NameIsw(nameIsw string) ApiIpamVlansListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiIpamVlansListRequest) NameNisw(nameNisw string) ApiIpamVlansListRequest {
	r.nameNisw = &nameNisw
	return r
}

func (r ApiIpamVlansListRequest) NameIe(nameIe string) ApiIpamVlansListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiIpamVlansListRequest) NameNie(nameNie string) ApiIpamVlansListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiIpamVlansListRequest) NameEmpty(nameEmpty string) ApiIpamVlansListRequest {
	r.nameEmpty = &nameEmpty
	return r
}

func (r ApiIpamVlansListRequest) TenantGroupIdN(tenantGroupIdN string) ApiIpamVlansListRequest {
	r.tenantGroupIdN = &tenantGroupIdN
	return r
}

func (r ApiIpamVlansListRequest) TenantGroupN(tenantGroupN string) ApiIpamVlansListRequest {
	r.tenantGroupN = &tenantGroupN
	return r
}

func (r ApiIpamVlansListRequest) TenantIdN(tenantIdN string) ApiIpamVlansListRequest {
	r.tenantIdN = &tenantIdN
	return r
}

func (r ApiIpamVlansListRequest) TenantN(tenantN string) ApiIpamVlansListRequest {
	r.tenantN = &tenantN
	return r
}

func (r ApiIpamVlansListRequest) RegionIdN(regionIdN string) ApiIpamVlansListRequest {
	r.regionIdN = &regionIdN
	return r
}

func (r ApiIpamVlansListRequest) RegionN(regionN string) ApiIpamVlansListRequest {
	r.regionN = &regionN
	return r
}

func (r ApiIpamVlansListRequest) SiteGroupIdN(siteGroupIdN string) ApiIpamVlansListRequest {
	r.siteGroupIdN = &siteGroupIdN
	return r
}

func (r ApiIpamVlansListRequest) SiteGroupN(siteGroupN string) ApiIpamVlansListRequest {
	r.siteGroupN = &siteGroupN
	return r
}

func (r ApiIpamVlansListRequest) SiteIdN(siteIdN string) ApiIpamVlansListRequest {
	r.siteIdN = &siteIdN
	return r
}

func (r ApiIpamVlansListRequest) SiteN(siteN string) ApiIpamVlansListRequest {
	r.siteN = &siteN
	return r
}

func (r ApiIpamVlansListRequest) GroupIdN(groupIdN string) ApiIpamVlansListRequest {
	r.groupIdN = &groupIdN
	return r
}

func (r ApiIpamVlansListRequest) GroupN(groupN string) ApiIpamVlansListRequest {
	r.groupN = &groupN
	return r
}

func (r ApiIpamVlansListRequest) RoleIdN(roleIdN string) ApiIpamVlansListRequest {
	r.roleIdN = &roleIdN
	return r
}

func (r ApiIpamVlansListRequest) RoleN(roleN string) ApiIpamVlansListRequest {
	r.roleN = &roleN
	return r
}

func (r ApiIpamVlansListRequest) StatusN(statusN string) ApiIpamVlansListRequest {
	r.statusN = &statusN
	return r
}

func (r ApiIpamVlansListRequest) TagN(tagN string) ApiIpamVlansListRequest {
	r.tagN = &tagN
	return r
}

// Number of results to return per page.
func (r ApiIpamVlansListRequest) Limit(limit int32) ApiIpamVlansListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiIpamVlansListRequest) Offset(offset int32) ApiIpamVlansListRequest {
	r.offset = &offset
	return r
}

func (r ApiIpamVlansListRequest) Execute() (*IpamVlansList200Response, *http.Response, error) {
	return r.ApiService.IpamVlansListExecute(r)
}

/*
IpamVlansList Method for IpamVlansList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamVlansListRequest
*/
func (a *IpamApiService) IpamVlansList(ctx context.Context) ApiIpamVlansListRequest {
	return ApiIpamVlansListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return IpamVlansList200Response
func (a *IpamApiService) IpamVlansListExecute(r ApiIpamVlansListRequest) (*IpamVlansList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IpamVlansList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamVlansList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/vlans/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.vid != nil {
		localVarQueryParams.Add("vid", parameterToString(*r.vid, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.created != nil {
		localVarQueryParams.Add("created", parameterToString(*r.created, ""))
	}
	if r.createdGte != nil {
		localVarQueryParams.Add("created__gte", parameterToString(*r.createdGte, ""))
	}
	if r.createdLte != nil {
		localVarQueryParams.Add("created__lte", parameterToString(*r.createdLte, ""))
	}
	if r.lastUpdated != nil {
		localVarQueryParams.Add("last_updated", parameterToString(*r.lastUpdated, ""))
	}
	if r.lastUpdatedGte != nil {
		localVarQueryParams.Add("last_updated__gte", parameterToString(*r.lastUpdatedGte, ""))
	}
	if r.lastUpdatedLte != nil {
		localVarQueryParams.Add("last_updated__lte", parameterToString(*r.lastUpdatedLte, ""))
	}
	if r.tenantGroupId != nil {
		localVarQueryParams.Add("tenant_group_id", parameterToString(*r.tenantGroupId, ""))
	}
	if r.tenantGroup != nil {
		localVarQueryParams.Add("tenant_group", parameterToString(*r.tenantGroup, ""))
	}
	if r.tenantId != nil {
		localVarQueryParams.Add("tenant_id", parameterToString(*r.tenantId, ""))
	}
	if r.tenant != nil {
		localVarQueryParams.Add("tenant", parameterToString(*r.tenant, ""))
	}
	if r.q != nil {
		localVarQueryParams.Add("q", parameterToString(*r.q, ""))
	}
	if r.regionId != nil {
		localVarQueryParams.Add("region_id", parameterToString(*r.regionId, ""))
	}
	if r.region != nil {
		localVarQueryParams.Add("region", parameterToString(*r.region, ""))
	}
	if r.siteGroupId != nil {
		localVarQueryParams.Add("site_group_id", parameterToString(*r.siteGroupId, ""))
	}
	if r.siteGroup != nil {
		localVarQueryParams.Add("site_group", parameterToString(*r.siteGroup, ""))
	}
	if r.siteId != nil {
		localVarQueryParams.Add("site_id", parameterToString(*r.siteId, ""))
	}
	if r.site != nil {
		localVarQueryParams.Add("site", parameterToString(*r.site, ""))
	}
	if r.groupId != nil {
		localVarQueryParams.Add("group_id", parameterToString(*r.groupId, ""))
	}
	if r.group != nil {
		localVarQueryParams.Add("group", parameterToString(*r.group, ""))
	}
	if r.roleId != nil {
		localVarQueryParams.Add("role_id", parameterToString(*r.roleId, ""))
	}
	if r.role != nil {
		localVarQueryParams.Add("role", parameterToString(*r.role, ""))
	}
	if r.status != nil {
		localVarQueryParams.Add("status", parameterToString(*r.status, ""))
	}
	if r.availableOnDevice != nil {
		localVarQueryParams.Add("available_on_device", parameterToString(*r.availableOnDevice, ""))
	}
	if r.availableOnVirtualmachine != nil {
		localVarQueryParams.Add("available_on_virtualmachine", parameterToString(*r.availableOnVirtualmachine, ""))
	}
	if r.tag != nil {
		localVarQueryParams.Add("tag", parameterToString(*r.tag, ""))
	}
	if r.idN != nil {
		localVarQueryParams.Add("id__n", parameterToString(*r.idN, ""))
	}
	if r.idLte != nil {
		localVarQueryParams.Add("id__lte", parameterToString(*r.idLte, ""))
	}
	if r.idLt != nil {
		localVarQueryParams.Add("id__lt", parameterToString(*r.idLt, ""))
	}
	if r.idGte != nil {
		localVarQueryParams.Add("id__gte", parameterToString(*r.idGte, ""))
	}
	if r.idGt != nil {
		localVarQueryParams.Add("id__gt", parameterToString(*r.idGt, ""))
	}
	if r.vidN != nil {
		localVarQueryParams.Add("vid__n", parameterToString(*r.vidN, ""))
	}
	if r.vidLte != nil {
		localVarQueryParams.Add("vid__lte", parameterToString(*r.vidLte, ""))
	}
	if r.vidLt != nil {
		localVarQueryParams.Add("vid__lt", parameterToString(*r.vidLt, ""))
	}
	if r.vidGte != nil {
		localVarQueryParams.Add("vid__gte", parameterToString(*r.vidGte, ""))
	}
	if r.vidGt != nil {
		localVarQueryParams.Add("vid__gt", parameterToString(*r.vidGt, ""))
	}
	if r.nameN != nil {
		localVarQueryParams.Add("name__n", parameterToString(*r.nameN, ""))
	}
	if r.nameIc != nil {
		localVarQueryParams.Add("name__ic", parameterToString(*r.nameIc, ""))
	}
	if r.nameNic != nil {
		localVarQueryParams.Add("name__nic", parameterToString(*r.nameNic, ""))
	}
	if r.nameIew != nil {
		localVarQueryParams.Add("name__iew", parameterToString(*r.nameIew, ""))
	}
	if r.nameNiew != nil {
		localVarQueryParams.Add("name__niew", parameterToString(*r.nameNiew, ""))
	}
	if r.nameIsw != nil {
		localVarQueryParams.Add("name__isw", parameterToString(*r.nameIsw, ""))
	}
	if r.nameNisw != nil {
		localVarQueryParams.Add("name__nisw", parameterToString(*r.nameNisw, ""))
	}
	if r.nameIe != nil {
		localVarQueryParams.Add("name__ie", parameterToString(*r.nameIe, ""))
	}
	if r.nameNie != nil {
		localVarQueryParams.Add("name__nie", parameterToString(*r.nameNie, ""))
	}
	if r.nameEmpty != nil {
		localVarQueryParams.Add("name__empty", parameterToString(*r.nameEmpty, ""))
	}
	if r.tenantGroupIdN != nil {
		localVarQueryParams.Add("tenant_group_id__n", parameterToString(*r.tenantGroupIdN, ""))
	}
	if r.tenantGroupN != nil {
		localVarQueryParams.Add("tenant_group__n", parameterToString(*r.tenantGroupN, ""))
	}
	if r.tenantIdN != nil {
		localVarQueryParams.Add("tenant_id__n", parameterToString(*r.tenantIdN, ""))
	}
	if r.tenantN != nil {
		localVarQueryParams.Add("tenant__n", parameterToString(*r.tenantN, ""))
	}
	if r.regionIdN != nil {
		localVarQueryParams.Add("region_id__n", parameterToString(*r.regionIdN, ""))
	}
	if r.regionN != nil {
		localVarQueryParams.Add("region__n", parameterToString(*r.regionN, ""))
	}
	if r.siteGroupIdN != nil {
		localVarQueryParams.Add("site_group_id__n", parameterToString(*r.siteGroupIdN, ""))
	}
	if r.siteGroupN != nil {
		localVarQueryParams.Add("site_group__n", parameterToString(*r.siteGroupN, ""))
	}
	if r.siteIdN != nil {
		localVarQueryParams.Add("site_id__n", parameterToString(*r.siteIdN, ""))
	}
	if r.siteN != nil {
		localVarQueryParams.Add("site__n", parameterToString(*r.siteN, ""))
	}
	if r.groupIdN != nil {
		localVarQueryParams.Add("group_id__n", parameterToString(*r.groupIdN, ""))
	}
	if r.groupN != nil {
		localVarQueryParams.Add("group__n", parameterToString(*r.groupN, ""))
	}
	if r.roleIdN != nil {
		localVarQueryParams.Add("role_id__n", parameterToString(*r.roleIdN, ""))
	}
	if r.roleN != nil {
		localVarQueryParams.Add("role__n", parameterToString(*r.roleN, ""))
	}
	if r.statusN != nil {
		localVarQueryParams.Add("status__n", parameterToString(*r.statusN, ""))
	}
	if r.tagN != nil {
		localVarQueryParams.Add("tag__n", parameterToString(*r.tagN, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVlansPartialUpdateRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	id int32
	data *WritableVLAN
}

func (r ApiIpamVlansPartialUpdateRequest) Data(data WritableVLAN) ApiIpamVlansPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiIpamVlansPartialUpdateRequest) Execute() (*VLAN, *http.Response, error) {
	return r.ApiService.IpamVlansPartialUpdateExecute(r)
}

/*
IpamVlansPartialUpdate Method for IpamVlansPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this VLAN.
 @return ApiIpamVlansPartialUpdateRequest
*/
func (a *IpamApiService) IpamVlansPartialUpdate(ctx context.Context, id int32) ApiIpamVlansPartialUpdateRequest {
	return ApiIpamVlansPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return VLAN
func (a *IpamApiService) IpamVlansPartialUpdateExecute(r ApiIpamVlansPartialUpdateRequest) (*VLAN, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VLAN
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamVlansPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/vlans/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVlansReadRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	id int32
}

func (r ApiIpamVlansReadRequest) Execute() (*VLAN, *http.Response, error) {
	return r.ApiService.IpamVlansReadExecute(r)
}

/*
IpamVlansRead Method for IpamVlansRead

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this VLAN.
 @return ApiIpamVlansReadRequest
*/
func (a *IpamApiService) IpamVlansRead(ctx context.Context, id int32) ApiIpamVlansReadRequest {
	return ApiIpamVlansReadRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return VLAN
func (a *IpamApiService) IpamVlansReadExecute(r ApiIpamVlansReadRequest) (*VLAN, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VLAN
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamVlansRead")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/vlans/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVlansUpdateRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	id int32
	data *WritableVLAN
}

func (r ApiIpamVlansUpdateRequest) Data(data WritableVLAN) ApiIpamVlansUpdateRequest {
	r.data = &data
	return r
}

func (r ApiIpamVlansUpdateRequest) Execute() (*VLAN, *http.Response, error) {
	return r.ApiService.IpamVlansUpdateExecute(r)
}

/*
IpamVlansUpdate Method for IpamVlansUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this VLAN.
 @return ApiIpamVlansUpdateRequest
*/
func (a *IpamApiService) IpamVlansUpdate(ctx context.Context, id int32) ApiIpamVlansUpdateRequest {
	return ApiIpamVlansUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return VLAN
func (a *IpamApiService) IpamVlansUpdateExecute(r ApiIpamVlansUpdateRequest) (*VLAN, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VLAN
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamVlansUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/vlans/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVrfsBulkDeleteRequest struct {
	ctx context.Context
	ApiService *IpamApiService
}

func (r ApiIpamVrfsBulkDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamVrfsBulkDeleteExecute(r)
}

/*
IpamVrfsBulkDelete Method for IpamVrfsBulkDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamVrfsBulkDeleteRequest
*/
func (a *IpamApiService) IpamVrfsBulkDelete(ctx context.Context) ApiIpamVrfsBulkDeleteRequest {
	return ApiIpamVrfsBulkDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *IpamApiService) IpamVrfsBulkDeleteExecute(r ApiIpamVrfsBulkDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamVrfsBulkDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/vrfs/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamVrfsBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	data *WritableVRF
}

func (r ApiIpamVrfsBulkPartialUpdateRequest) Data(data WritableVRF) ApiIpamVrfsBulkPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiIpamVrfsBulkPartialUpdateRequest) Execute() (*VRF, *http.Response, error) {
	return r.ApiService.IpamVrfsBulkPartialUpdateExecute(r)
}

/*
IpamVrfsBulkPartialUpdate Method for IpamVrfsBulkPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamVrfsBulkPartialUpdateRequest
*/
func (a *IpamApiService) IpamVrfsBulkPartialUpdate(ctx context.Context) ApiIpamVrfsBulkPartialUpdateRequest {
	return ApiIpamVrfsBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return VRF
func (a *IpamApiService) IpamVrfsBulkPartialUpdateExecute(r ApiIpamVrfsBulkPartialUpdateRequest) (*VRF, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VRF
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamVrfsBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/vrfs/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVrfsBulkUpdateRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	data *WritableVRF
}

func (r ApiIpamVrfsBulkUpdateRequest) Data(data WritableVRF) ApiIpamVrfsBulkUpdateRequest {
	r.data = &data
	return r
}

func (r ApiIpamVrfsBulkUpdateRequest) Execute() (*VRF, *http.Response, error) {
	return r.ApiService.IpamVrfsBulkUpdateExecute(r)
}

/*
IpamVrfsBulkUpdate Method for IpamVrfsBulkUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamVrfsBulkUpdateRequest
*/
func (a *IpamApiService) IpamVrfsBulkUpdate(ctx context.Context) ApiIpamVrfsBulkUpdateRequest {
	return ApiIpamVrfsBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return VRF
func (a *IpamApiService) IpamVrfsBulkUpdateExecute(r ApiIpamVrfsBulkUpdateRequest) (*VRF, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VRF
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamVrfsBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/vrfs/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVrfsCreateRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	data *WritableVRF
}

func (r ApiIpamVrfsCreateRequest) Data(data WritableVRF) ApiIpamVrfsCreateRequest {
	r.data = &data
	return r
}

func (r ApiIpamVrfsCreateRequest) Execute() (*VRF, *http.Response, error) {
	return r.ApiService.IpamVrfsCreateExecute(r)
}

/*
IpamVrfsCreate Method for IpamVrfsCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamVrfsCreateRequest
*/
func (a *IpamApiService) IpamVrfsCreate(ctx context.Context) ApiIpamVrfsCreateRequest {
	return ApiIpamVrfsCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return VRF
func (a *IpamApiService) IpamVrfsCreateExecute(r ApiIpamVrfsCreateRequest) (*VRF, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VRF
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamVrfsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/vrfs/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVrfsDeleteRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	id int32
}

func (r ApiIpamVrfsDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamVrfsDeleteExecute(r)
}

/*
IpamVrfsDelete Method for IpamVrfsDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this VRF.
 @return ApiIpamVrfsDeleteRequest
*/
func (a *IpamApiService) IpamVrfsDelete(ctx context.Context, id int32) ApiIpamVrfsDeleteRequest {
	return ApiIpamVrfsDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *IpamApiService) IpamVrfsDeleteExecute(r ApiIpamVrfsDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamVrfsDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/vrfs/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamVrfsListRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	id *string
	name *string
	rd *string
	enforceUnique *string
	created *string
	createdGte *string
	createdLte *string
	lastUpdated *string
	lastUpdatedGte *string
	lastUpdatedLte *string
	tenantGroupId *string
	tenantGroup *string
	tenantId *string
	tenant *string
	q *string
	importTargetId *string
	importTarget *string
	exportTargetId *string
	exportTarget *string
	tag *string
	idN *string
	idLte *string
	idLt *string
	idGte *string
	idGt *string
	nameN *string
	nameIc *string
	nameNic *string
	nameIew *string
	nameNiew *string
	nameIsw *string
	nameNisw *string
	nameIe *string
	nameNie *string
	nameEmpty *string
	rdN *string
	rdIc *string
	rdNic *string
	rdIew *string
	rdNiew *string
	rdIsw *string
	rdNisw *string
	rdIe *string
	rdNie *string
	rdEmpty *string
	tenantGroupIdN *string
	tenantGroupN *string
	tenantIdN *string
	tenantN *string
	importTargetIdN *string
	importTargetN *string
	exportTargetIdN *string
	exportTargetN *string
	tagN *string
	limit *int32
	offset *int32
}

func (r ApiIpamVrfsListRequest) Id(id string) ApiIpamVrfsListRequest {
	r.id = &id
	return r
}

func (r ApiIpamVrfsListRequest) Name(name string) ApiIpamVrfsListRequest {
	r.name = &name
	return r
}

func (r ApiIpamVrfsListRequest) Rd(rd string) ApiIpamVrfsListRequest {
	r.rd = &rd
	return r
}

func (r ApiIpamVrfsListRequest) EnforceUnique(enforceUnique string) ApiIpamVrfsListRequest {
	r.enforceUnique = &enforceUnique
	return r
}

func (r ApiIpamVrfsListRequest) Created(created string) ApiIpamVrfsListRequest {
	r.created = &created
	return r
}

func (r ApiIpamVrfsListRequest) CreatedGte(createdGte string) ApiIpamVrfsListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiIpamVrfsListRequest) CreatedLte(createdLte string) ApiIpamVrfsListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiIpamVrfsListRequest) LastUpdated(lastUpdated string) ApiIpamVrfsListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiIpamVrfsListRequest) LastUpdatedGte(lastUpdatedGte string) ApiIpamVrfsListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiIpamVrfsListRequest) LastUpdatedLte(lastUpdatedLte string) ApiIpamVrfsListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiIpamVrfsListRequest) TenantGroupId(tenantGroupId string) ApiIpamVrfsListRequest {
	r.tenantGroupId = &tenantGroupId
	return r
}

func (r ApiIpamVrfsListRequest) TenantGroup(tenantGroup string) ApiIpamVrfsListRequest {
	r.tenantGroup = &tenantGroup
	return r
}

func (r ApiIpamVrfsListRequest) TenantId(tenantId string) ApiIpamVrfsListRequest {
	r.tenantId = &tenantId
	return r
}

func (r ApiIpamVrfsListRequest) Tenant(tenant string) ApiIpamVrfsListRequest {
	r.tenant = &tenant
	return r
}

func (r ApiIpamVrfsListRequest) Q(q string) ApiIpamVrfsListRequest {
	r.q = &q
	return r
}

func (r ApiIpamVrfsListRequest) ImportTargetId(importTargetId string) ApiIpamVrfsListRequest {
	r.importTargetId = &importTargetId
	return r
}

func (r ApiIpamVrfsListRequest) ImportTarget(importTarget string) ApiIpamVrfsListRequest {
	r.importTarget = &importTarget
	return r
}

func (r ApiIpamVrfsListRequest) ExportTargetId(exportTargetId string) ApiIpamVrfsListRequest {
	r.exportTargetId = &exportTargetId
	return r
}

func (r ApiIpamVrfsListRequest) ExportTarget(exportTarget string) ApiIpamVrfsListRequest {
	r.exportTarget = &exportTarget
	return r
}

func (r ApiIpamVrfsListRequest) Tag(tag string) ApiIpamVrfsListRequest {
	r.tag = &tag
	return r
}

func (r ApiIpamVrfsListRequest) IdN(idN string) ApiIpamVrfsListRequest {
	r.idN = &idN
	return r
}

func (r ApiIpamVrfsListRequest) IdLte(idLte string) ApiIpamVrfsListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiIpamVrfsListRequest) IdLt(idLt string) ApiIpamVrfsListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiIpamVrfsListRequest) IdGte(idGte string) ApiIpamVrfsListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiIpamVrfsListRequest) IdGt(idGt string) ApiIpamVrfsListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiIpamVrfsListRequest) NameN(nameN string) ApiIpamVrfsListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiIpamVrfsListRequest) NameIc(nameIc string) ApiIpamVrfsListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiIpamVrfsListRequest) NameNic(nameNic string) ApiIpamVrfsListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiIpamVrfsListRequest) NameIew(nameIew string) ApiIpamVrfsListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiIpamVrfsListRequest) NameNiew(nameNiew string) ApiIpamVrfsListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiIpamVrfsListRequest) NameIsw(nameIsw string) ApiIpamVrfsListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiIpamVrfsListRequest) NameNisw(nameNisw string) ApiIpamVrfsListRequest {
	r.nameNisw = &nameNisw
	return r
}

func (r ApiIpamVrfsListRequest) NameIe(nameIe string) ApiIpamVrfsListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiIpamVrfsListRequest) NameNie(nameNie string) ApiIpamVrfsListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiIpamVrfsListRequest) NameEmpty(nameEmpty string) ApiIpamVrfsListRequest {
	r.nameEmpty = &nameEmpty
	return r
}

func (r ApiIpamVrfsListRequest) RdN(rdN string) ApiIpamVrfsListRequest {
	r.rdN = &rdN
	return r
}

func (r ApiIpamVrfsListRequest) RdIc(rdIc string) ApiIpamVrfsListRequest {
	r.rdIc = &rdIc
	return r
}

func (r ApiIpamVrfsListRequest) RdNic(rdNic string) ApiIpamVrfsListRequest {
	r.rdNic = &rdNic
	return r
}

func (r ApiIpamVrfsListRequest) RdIew(rdIew string) ApiIpamVrfsListRequest {
	r.rdIew = &rdIew
	return r
}

func (r ApiIpamVrfsListRequest) RdNiew(rdNiew string) ApiIpamVrfsListRequest {
	r.rdNiew = &rdNiew
	return r
}

func (r ApiIpamVrfsListRequest) RdIsw(rdIsw string) ApiIpamVrfsListRequest {
	r.rdIsw = &rdIsw
	return r
}

func (r ApiIpamVrfsListRequest) RdNisw(rdNisw string) ApiIpamVrfsListRequest {
	r.rdNisw = &rdNisw
	return r
}

func (r ApiIpamVrfsListRequest) RdIe(rdIe string) ApiIpamVrfsListRequest {
	r.rdIe = &rdIe
	return r
}

func (r ApiIpamVrfsListRequest) RdNie(rdNie string) ApiIpamVrfsListRequest {
	r.rdNie = &rdNie
	return r
}

func (r ApiIpamVrfsListRequest) RdEmpty(rdEmpty string) ApiIpamVrfsListRequest {
	r.rdEmpty = &rdEmpty
	return r
}

func (r ApiIpamVrfsListRequest) TenantGroupIdN(tenantGroupIdN string) ApiIpamVrfsListRequest {
	r.tenantGroupIdN = &tenantGroupIdN
	return r
}

func (r ApiIpamVrfsListRequest) TenantGroupN(tenantGroupN string) ApiIpamVrfsListRequest {
	r.tenantGroupN = &tenantGroupN
	return r
}

func (r ApiIpamVrfsListRequest) TenantIdN(tenantIdN string) ApiIpamVrfsListRequest {
	r.tenantIdN = &tenantIdN
	return r
}

func (r ApiIpamVrfsListRequest) TenantN(tenantN string) ApiIpamVrfsListRequest {
	r.tenantN = &tenantN
	return r
}

func (r ApiIpamVrfsListRequest) ImportTargetIdN(importTargetIdN string) ApiIpamVrfsListRequest {
	r.importTargetIdN = &importTargetIdN
	return r
}

func (r ApiIpamVrfsListRequest) ImportTargetN(importTargetN string) ApiIpamVrfsListRequest {
	r.importTargetN = &importTargetN
	return r
}

func (r ApiIpamVrfsListRequest) ExportTargetIdN(exportTargetIdN string) ApiIpamVrfsListRequest {
	r.exportTargetIdN = &exportTargetIdN
	return r
}

func (r ApiIpamVrfsListRequest) ExportTargetN(exportTargetN string) ApiIpamVrfsListRequest {
	r.exportTargetN = &exportTargetN
	return r
}

func (r ApiIpamVrfsListRequest) TagN(tagN string) ApiIpamVrfsListRequest {
	r.tagN = &tagN
	return r
}

// Number of results to return per page.
func (r ApiIpamVrfsListRequest) Limit(limit int32) ApiIpamVrfsListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiIpamVrfsListRequest) Offset(offset int32) ApiIpamVrfsListRequest {
	r.offset = &offset
	return r
}

func (r ApiIpamVrfsListRequest) Execute() (*IpamVrfsList200Response, *http.Response, error) {
	return r.ApiService.IpamVrfsListExecute(r)
}

/*
IpamVrfsList Method for IpamVrfsList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamVrfsListRequest
*/
func (a *IpamApiService) IpamVrfsList(ctx context.Context) ApiIpamVrfsListRequest {
	return ApiIpamVrfsListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return IpamVrfsList200Response
func (a *IpamApiService) IpamVrfsListExecute(r ApiIpamVrfsListRequest) (*IpamVrfsList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IpamVrfsList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamVrfsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/vrfs/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.rd != nil {
		localVarQueryParams.Add("rd", parameterToString(*r.rd, ""))
	}
	if r.enforceUnique != nil {
		localVarQueryParams.Add("enforce_unique", parameterToString(*r.enforceUnique, ""))
	}
	if r.created != nil {
		localVarQueryParams.Add("created", parameterToString(*r.created, ""))
	}
	if r.createdGte != nil {
		localVarQueryParams.Add("created__gte", parameterToString(*r.createdGte, ""))
	}
	if r.createdLte != nil {
		localVarQueryParams.Add("created__lte", parameterToString(*r.createdLte, ""))
	}
	if r.lastUpdated != nil {
		localVarQueryParams.Add("last_updated", parameterToString(*r.lastUpdated, ""))
	}
	if r.lastUpdatedGte != nil {
		localVarQueryParams.Add("last_updated__gte", parameterToString(*r.lastUpdatedGte, ""))
	}
	if r.lastUpdatedLte != nil {
		localVarQueryParams.Add("last_updated__lte", parameterToString(*r.lastUpdatedLte, ""))
	}
	if r.tenantGroupId != nil {
		localVarQueryParams.Add("tenant_group_id", parameterToString(*r.tenantGroupId, ""))
	}
	if r.tenantGroup != nil {
		localVarQueryParams.Add("tenant_group", parameterToString(*r.tenantGroup, ""))
	}
	if r.tenantId != nil {
		localVarQueryParams.Add("tenant_id", parameterToString(*r.tenantId, ""))
	}
	if r.tenant != nil {
		localVarQueryParams.Add("tenant", parameterToString(*r.tenant, ""))
	}
	if r.q != nil {
		localVarQueryParams.Add("q", parameterToString(*r.q, ""))
	}
	if r.importTargetId != nil {
		localVarQueryParams.Add("import_target_id", parameterToString(*r.importTargetId, ""))
	}
	if r.importTarget != nil {
		localVarQueryParams.Add("import_target", parameterToString(*r.importTarget, ""))
	}
	if r.exportTargetId != nil {
		localVarQueryParams.Add("export_target_id", parameterToString(*r.exportTargetId, ""))
	}
	if r.exportTarget != nil {
		localVarQueryParams.Add("export_target", parameterToString(*r.exportTarget, ""))
	}
	if r.tag != nil {
		localVarQueryParams.Add("tag", parameterToString(*r.tag, ""))
	}
	if r.idN != nil {
		localVarQueryParams.Add("id__n", parameterToString(*r.idN, ""))
	}
	if r.idLte != nil {
		localVarQueryParams.Add("id__lte", parameterToString(*r.idLte, ""))
	}
	if r.idLt != nil {
		localVarQueryParams.Add("id__lt", parameterToString(*r.idLt, ""))
	}
	if r.idGte != nil {
		localVarQueryParams.Add("id__gte", parameterToString(*r.idGte, ""))
	}
	if r.idGt != nil {
		localVarQueryParams.Add("id__gt", parameterToString(*r.idGt, ""))
	}
	if r.nameN != nil {
		localVarQueryParams.Add("name__n", parameterToString(*r.nameN, ""))
	}
	if r.nameIc != nil {
		localVarQueryParams.Add("name__ic", parameterToString(*r.nameIc, ""))
	}
	if r.nameNic != nil {
		localVarQueryParams.Add("name__nic", parameterToString(*r.nameNic, ""))
	}
	if r.nameIew != nil {
		localVarQueryParams.Add("name__iew", parameterToString(*r.nameIew, ""))
	}
	if r.nameNiew != nil {
		localVarQueryParams.Add("name__niew", parameterToString(*r.nameNiew, ""))
	}
	if r.nameIsw != nil {
		localVarQueryParams.Add("name__isw", parameterToString(*r.nameIsw, ""))
	}
	if r.nameNisw != nil {
		localVarQueryParams.Add("name__nisw", parameterToString(*r.nameNisw, ""))
	}
	if r.nameIe != nil {
		localVarQueryParams.Add("name__ie", parameterToString(*r.nameIe, ""))
	}
	if r.nameNie != nil {
		localVarQueryParams.Add("name__nie", parameterToString(*r.nameNie, ""))
	}
	if r.nameEmpty != nil {
		localVarQueryParams.Add("name__empty", parameterToString(*r.nameEmpty, ""))
	}
	if r.rdN != nil {
		localVarQueryParams.Add("rd__n", parameterToString(*r.rdN, ""))
	}
	if r.rdIc != nil {
		localVarQueryParams.Add("rd__ic", parameterToString(*r.rdIc, ""))
	}
	if r.rdNic != nil {
		localVarQueryParams.Add("rd__nic", parameterToString(*r.rdNic, ""))
	}
	if r.rdIew != nil {
		localVarQueryParams.Add("rd__iew", parameterToString(*r.rdIew, ""))
	}
	if r.rdNiew != nil {
		localVarQueryParams.Add("rd__niew", parameterToString(*r.rdNiew, ""))
	}
	if r.rdIsw != nil {
		localVarQueryParams.Add("rd__isw", parameterToString(*r.rdIsw, ""))
	}
	if r.rdNisw != nil {
		localVarQueryParams.Add("rd__nisw", parameterToString(*r.rdNisw, ""))
	}
	if r.rdIe != nil {
		localVarQueryParams.Add("rd__ie", parameterToString(*r.rdIe, ""))
	}
	if r.rdNie != nil {
		localVarQueryParams.Add("rd__nie", parameterToString(*r.rdNie, ""))
	}
	if r.rdEmpty != nil {
		localVarQueryParams.Add("rd__empty", parameterToString(*r.rdEmpty, ""))
	}
	if r.tenantGroupIdN != nil {
		localVarQueryParams.Add("tenant_group_id__n", parameterToString(*r.tenantGroupIdN, ""))
	}
	if r.tenantGroupN != nil {
		localVarQueryParams.Add("tenant_group__n", parameterToString(*r.tenantGroupN, ""))
	}
	if r.tenantIdN != nil {
		localVarQueryParams.Add("tenant_id__n", parameterToString(*r.tenantIdN, ""))
	}
	if r.tenantN != nil {
		localVarQueryParams.Add("tenant__n", parameterToString(*r.tenantN, ""))
	}
	if r.importTargetIdN != nil {
		localVarQueryParams.Add("import_target_id__n", parameterToString(*r.importTargetIdN, ""))
	}
	if r.importTargetN != nil {
		localVarQueryParams.Add("import_target__n", parameterToString(*r.importTargetN, ""))
	}
	if r.exportTargetIdN != nil {
		localVarQueryParams.Add("export_target_id__n", parameterToString(*r.exportTargetIdN, ""))
	}
	if r.exportTargetN != nil {
		localVarQueryParams.Add("export_target__n", parameterToString(*r.exportTargetN, ""))
	}
	if r.tagN != nil {
		localVarQueryParams.Add("tag__n", parameterToString(*r.tagN, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVrfsPartialUpdateRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	id int32
	data *WritableVRF
}

func (r ApiIpamVrfsPartialUpdateRequest) Data(data WritableVRF) ApiIpamVrfsPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiIpamVrfsPartialUpdateRequest) Execute() (*VRF, *http.Response, error) {
	return r.ApiService.IpamVrfsPartialUpdateExecute(r)
}

/*
IpamVrfsPartialUpdate Method for IpamVrfsPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this VRF.
 @return ApiIpamVrfsPartialUpdateRequest
*/
func (a *IpamApiService) IpamVrfsPartialUpdate(ctx context.Context, id int32) ApiIpamVrfsPartialUpdateRequest {
	return ApiIpamVrfsPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return VRF
func (a *IpamApiService) IpamVrfsPartialUpdateExecute(r ApiIpamVrfsPartialUpdateRequest) (*VRF, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VRF
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamVrfsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/vrfs/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVrfsReadRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	id int32
}

func (r ApiIpamVrfsReadRequest) Execute() (*VRF, *http.Response, error) {
	return r.ApiService.IpamVrfsReadExecute(r)
}

/*
IpamVrfsRead Method for IpamVrfsRead

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this VRF.
 @return ApiIpamVrfsReadRequest
*/
func (a *IpamApiService) IpamVrfsRead(ctx context.Context, id int32) ApiIpamVrfsReadRequest {
	return ApiIpamVrfsReadRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return VRF
func (a *IpamApiService) IpamVrfsReadExecute(r ApiIpamVrfsReadRequest) (*VRF, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VRF
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamVrfsRead")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/vrfs/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVrfsUpdateRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	id int32
	data *WritableVRF
}

func (r ApiIpamVrfsUpdateRequest) Data(data WritableVRF) ApiIpamVrfsUpdateRequest {
	r.data = &data
	return r
}

func (r ApiIpamVrfsUpdateRequest) Execute() (*VRF, *http.Response, error) {
	return r.ApiService.IpamVrfsUpdateExecute(r)
}

/*
IpamVrfsUpdate Method for IpamVrfsUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this VRF.
 @return ApiIpamVrfsUpdateRequest
*/
func (a *IpamApiService) IpamVrfsUpdate(ctx context.Context, id int32) ApiIpamVrfsUpdateRequest {
	return ApiIpamVrfsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return VRF
func (a *IpamApiService) IpamVrfsUpdateExecute(r ApiIpamVrfsUpdateRequest) (*VRF, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VRF
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamVrfsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/vrfs/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
