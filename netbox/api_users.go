/*
NetBox API

API to access NetBox

API version: 2.11
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package netbox

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


// UsersApiService UsersApi service
type UsersApiService service

type ApiUsersConfigListRequest struct {
	ctx context.Context
	ApiService *UsersApiService
}

func (r ApiUsersConfigListRequest) Execute() (*http.Response, error) {
	return r.ApiService.UsersConfigListExecute(r)
}

/*
UsersConfigList Method for UsersConfigList

Return the UserConfig for the currently authenticated User.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUsersConfigListRequest
*/
func (a *UsersApiService) UsersConfigList(ctx context.Context) ApiUsersConfigListRequest {
	return ApiUsersConfigListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *UsersApiService) UsersConfigListExecute(r ApiUsersConfigListRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.UsersConfigList")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/config/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersGroupsBulkDeleteRequest struct {
	ctx context.Context
	ApiService *UsersApiService
}

func (r ApiUsersGroupsBulkDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.UsersGroupsBulkDeleteExecute(r)
}

/*
UsersGroupsBulkDelete Method for UsersGroupsBulkDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUsersGroupsBulkDeleteRequest
*/
func (a *UsersApiService) UsersGroupsBulkDelete(ctx context.Context) ApiUsersGroupsBulkDeleteRequest {
	return ApiUsersGroupsBulkDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *UsersApiService) UsersGroupsBulkDeleteExecute(r ApiUsersGroupsBulkDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.UsersGroupsBulkDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersGroupsBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *UsersApiService
	data *Group
}

func (r ApiUsersGroupsBulkPartialUpdateRequest) Data(data Group) ApiUsersGroupsBulkPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiUsersGroupsBulkPartialUpdateRequest) Execute() (*Group, *http.Response, error) {
	return r.ApiService.UsersGroupsBulkPartialUpdateExecute(r)
}

/*
UsersGroupsBulkPartialUpdate Method for UsersGroupsBulkPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUsersGroupsBulkPartialUpdateRequest
*/
func (a *UsersApiService) UsersGroupsBulkPartialUpdate(ctx context.Context) ApiUsersGroupsBulkPartialUpdateRequest {
	return ApiUsersGroupsBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Group
func (a *UsersApiService) UsersGroupsBulkPartialUpdateExecute(r ApiUsersGroupsBulkPartialUpdateRequest) (*Group, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Group
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.UsersGroupsBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersGroupsBulkUpdateRequest struct {
	ctx context.Context
	ApiService *UsersApiService
	data *Group
}

func (r ApiUsersGroupsBulkUpdateRequest) Data(data Group) ApiUsersGroupsBulkUpdateRequest {
	r.data = &data
	return r
}

func (r ApiUsersGroupsBulkUpdateRequest) Execute() (*Group, *http.Response, error) {
	return r.ApiService.UsersGroupsBulkUpdateExecute(r)
}

/*
UsersGroupsBulkUpdate Method for UsersGroupsBulkUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUsersGroupsBulkUpdateRequest
*/
func (a *UsersApiService) UsersGroupsBulkUpdate(ctx context.Context) ApiUsersGroupsBulkUpdateRequest {
	return ApiUsersGroupsBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Group
func (a *UsersApiService) UsersGroupsBulkUpdateExecute(r ApiUsersGroupsBulkUpdateRequest) (*Group, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Group
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.UsersGroupsBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersGroupsCreateRequest struct {
	ctx context.Context
	ApiService *UsersApiService
	data *Group
}

func (r ApiUsersGroupsCreateRequest) Data(data Group) ApiUsersGroupsCreateRequest {
	r.data = &data
	return r
}

func (r ApiUsersGroupsCreateRequest) Execute() (*Group, *http.Response, error) {
	return r.ApiService.UsersGroupsCreateExecute(r)
}

/*
UsersGroupsCreate Method for UsersGroupsCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUsersGroupsCreateRequest
*/
func (a *UsersApiService) UsersGroupsCreate(ctx context.Context) ApiUsersGroupsCreateRequest {
	return ApiUsersGroupsCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Group
func (a *UsersApiService) UsersGroupsCreateExecute(r ApiUsersGroupsCreateRequest) (*Group, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Group
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.UsersGroupsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersGroupsDeleteRequest struct {
	ctx context.Context
	ApiService *UsersApiService
	id int32
}

func (r ApiUsersGroupsDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.UsersGroupsDeleteExecute(r)
}

/*
UsersGroupsDelete Method for UsersGroupsDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this group.
 @return ApiUsersGroupsDeleteRequest
*/
func (a *UsersApiService) UsersGroupsDelete(ctx context.Context, id int32) ApiUsersGroupsDeleteRequest {
	return ApiUsersGroupsDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *UsersApiService) UsersGroupsDeleteExecute(r ApiUsersGroupsDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.UsersGroupsDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/groups/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersGroupsListRequest struct {
	ctx context.Context
	ApiService *UsersApiService
	id *string
	name *string
	q *string
	idN *string
	idLte *string
	idLt *string
	idGte *string
	idGt *string
	nameN *string
	nameIc *string
	nameNic *string
	nameIew *string
	nameNiew *string
	nameIsw *string
	nameNisw *string
	nameIe *string
	nameNie *string
	nameEmpty *string
	limit *int32
	offset *int32
}

func (r ApiUsersGroupsListRequest) Id(id string) ApiUsersGroupsListRequest {
	r.id = &id
	return r
}

func (r ApiUsersGroupsListRequest) Name(name string) ApiUsersGroupsListRequest {
	r.name = &name
	return r
}

func (r ApiUsersGroupsListRequest) Q(q string) ApiUsersGroupsListRequest {
	r.q = &q
	return r
}

func (r ApiUsersGroupsListRequest) IdN(idN string) ApiUsersGroupsListRequest {
	r.idN = &idN
	return r
}

func (r ApiUsersGroupsListRequest) IdLte(idLte string) ApiUsersGroupsListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiUsersGroupsListRequest) IdLt(idLt string) ApiUsersGroupsListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiUsersGroupsListRequest) IdGte(idGte string) ApiUsersGroupsListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiUsersGroupsListRequest) IdGt(idGt string) ApiUsersGroupsListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiUsersGroupsListRequest) NameN(nameN string) ApiUsersGroupsListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiUsersGroupsListRequest) NameIc(nameIc string) ApiUsersGroupsListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiUsersGroupsListRequest) NameNic(nameNic string) ApiUsersGroupsListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiUsersGroupsListRequest) NameIew(nameIew string) ApiUsersGroupsListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiUsersGroupsListRequest) NameNiew(nameNiew string) ApiUsersGroupsListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiUsersGroupsListRequest) NameIsw(nameIsw string) ApiUsersGroupsListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiUsersGroupsListRequest) NameNisw(nameNisw string) ApiUsersGroupsListRequest {
	r.nameNisw = &nameNisw
	return r
}

func (r ApiUsersGroupsListRequest) NameIe(nameIe string) ApiUsersGroupsListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiUsersGroupsListRequest) NameNie(nameNie string) ApiUsersGroupsListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiUsersGroupsListRequest) NameEmpty(nameEmpty string) ApiUsersGroupsListRequest {
	r.nameEmpty = &nameEmpty
	return r
}

// Number of results to return per page.
func (r ApiUsersGroupsListRequest) Limit(limit int32) ApiUsersGroupsListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiUsersGroupsListRequest) Offset(offset int32) ApiUsersGroupsListRequest {
	r.offset = &offset
	return r
}

func (r ApiUsersGroupsListRequest) Execute() (*UsersGroupsList200Response, *http.Response, error) {
	return r.ApiService.UsersGroupsListExecute(r)
}

/*
UsersGroupsList Method for UsersGroupsList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUsersGroupsListRequest
*/
func (a *UsersApiService) UsersGroupsList(ctx context.Context) ApiUsersGroupsListRequest {
	return ApiUsersGroupsListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UsersGroupsList200Response
func (a *UsersApiService) UsersGroupsListExecute(r ApiUsersGroupsListRequest) (*UsersGroupsList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UsersGroupsList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.UsersGroupsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.q != nil {
		localVarQueryParams.Add("q", parameterToString(*r.q, ""))
	}
	if r.idN != nil {
		localVarQueryParams.Add("id__n", parameterToString(*r.idN, ""))
	}
	if r.idLte != nil {
		localVarQueryParams.Add("id__lte", parameterToString(*r.idLte, ""))
	}
	if r.idLt != nil {
		localVarQueryParams.Add("id__lt", parameterToString(*r.idLt, ""))
	}
	if r.idGte != nil {
		localVarQueryParams.Add("id__gte", parameterToString(*r.idGte, ""))
	}
	if r.idGt != nil {
		localVarQueryParams.Add("id__gt", parameterToString(*r.idGt, ""))
	}
	if r.nameN != nil {
		localVarQueryParams.Add("name__n", parameterToString(*r.nameN, ""))
	}
	if r.nameIc != nil {
		localVarQueryParams.Add("name__ic", parameterToString(*r.nameIc, ""))
	}
	if r.nameNic != nil {
		localVarQueryParams.Add("name__nic", parameterToString(*r.nameNic, ""))
	}
	if r.nameIew != nil {
		localVarQueryParams.Add("name__iew", parameterToString(*r.nameIew, ""))
	}
	if r.nameNiew != nil {
		localVarQueryParams.Add("name__niew", parameterToString(*r.nameNiew, ""))
	}
	if r.nameIsw != nil {
		localVarQueryParams.Add("name__isw", parameterToString(*r.nameIsw, ""))
	}
	if r.nameNisw != nil {
		localVarQueryParams.Add("name__nisw", parameterToString(*r.nameNisw, ""))
	}
	if r.nameIe != nil {
		localVarQueryParams.Add("name__ie", parameterToString(*r.nameIe, ""))
	}
	if r.nameNie != nil {
		localVarQueryParams.Add("name__nie", parameterToString(*r.nameNie, ""))
	}
	if r.nameEmpty != nil {
		localVarQueryParams.Add("name__empty", parameterToString(*r.nameEmpty, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersGroupsPartialUpdateRequest struct {
	ctx context.Context
	ApiService *UsersApiService
	id int32
	data *Group
}

func (r ApiUsersGroupsPartialUpdateRequest) Data(data Group) ApiUsersGroupsPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiUsersGroupsPartialUpdateRequest) Execute() (*Group, *http.Response, error) {
	return r.ApiService.UsersGroupsPartialUpdateExecute(r)
}

/*
UsersGroupsPartialUpdate Method for UsersGroupsPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this group.
 @return ApiUsersGroupsPartialUpdateRequest
*/
func (a *UsersApiService) UsersGroupsPartialUpdate(ctx context.Context, id int32) ApiUsersGroupsPartialUpdateRequest {
	return ApiUsersGroupsPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Group
func (a *UsersApiService) UsersGroupsPartialUpdateExecute(r ApiUsersGroupsPartialUpdateRequest) (*Group, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Group
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.UsersGroupsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/groups/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersGroupsReadRequest struct {
	ctx context.Context
	ApiService *UsersApiService
	id int32
}

func (r ApiUsersGroupsReadRequest) Execute() (*Group, *http.Response, error) {
	return r.ApiService.UsersGroupsReadExecute(r)
}

/*
UsersGroupsRead Method for UsersGroupsRead

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this group.
 @return ApiUsersGroupsReadRequest
*/
func (a *UsersApiService) UsersGroupsRead(ctx context.Context, id int32) ApiUsersGroupsReadRequest {
	return ApiUsersGroupsReadRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Group
func (a *UsersApiService) UsersGroupsReadExecute(r ApiUsersGroupsReadRequest) (*Group, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Group
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.UsersGroupsRead")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/groups/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersGroupsUpdateRequest struct {
	ctx context.Context
	ApiService *UsersApiService
	id int32
	data *Group
}

func (r ApiUsersGroupsUpdateRequest) Data(data Group) ApiUsersGroupsUpdateRequest {
	r.data = &data
	return r
}

func (r ApiUsersGroupsUpdateRequest) Execute() (*Group, *http.Response, error) {
	return r.ApiService.UsersGroupsUpdateExecute(r)
}

/*
UsersGroupsUpdate Method for UsersGroupsUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this group.
 @return ApiUsersGroupsUpdateRequest
*/
func (a *UsersApiService) UsersGroupsUpdate(ctx context.Context, id int32) ApiUsersGroupsUpdateRequest {
	return ApiUsersGroupsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Group
func (a *UsersApiService) UsersGroupsUpdateExecute(r ApiUsersGroupsUpdateRequest) (*Group, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Group
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.UsersGroupsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/groups/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersPermissionsBulkDeleteRequest struct {
	ctx context.Context
	ApiService *UsersApiService
}

func (r ApiUsersPermissionsBulkDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.UsersPermissionsBulkDeleteExecute(r)
}

/*
UsersPermissionsBulkDelete Method for UsersPermissionsBulkDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUsersPermissionsBulkDeleteRequest
*/
func (a *UsersApiService) UsersPermissionsBulkDelete(ctx context.Context) ApiUsersPermissionsBulkDeleteRequest {
	return ApiUsersPermissionsBulkDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *UsersApiService) UsersPermissionsBulkDeleteExecute(r ApiUsersPermissionsBulkDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.UsersPermissionsBulkDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/permissions/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersPermissionsBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *UsersApiService
	data *WritableObjectPermission
}

func (r ApiUsersPermissionsBulkPartialUpdateRequest) Data(data WritableObjectPermission) ApiUsersPermissionsBulkPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiUsersPermissionsBulkPartialUpdateRequest) Execute() (*ObjectPermission, *http.Response, error) {
	return r.ApiService.UsersPermissionsBulkPartialUpdateExecute(r)
}

/*
UsersPermissionsBulkPartialUpdate Method for UsersPermissionsBulkPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUsersPermissionsBulkPartialUpdateRequest
*/
func (a *UsersApiService) UsersPermissionsBulkPartialUpdate(ctx context.Context) ApiUsersPermissionsBulkPartialUpdateRequest {
	return ApiUsersPermissionsBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ObjectPermission
func (a *UsersApiService) UsersPermissionsBulkPartialUpdateExecute(r ApiUsersPermissionsBulkPartialUpdateRequest) (*ObjectPermission, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ObjectPermission
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.UsersPermissionsBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/permissions/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersPermissionsBulkUpdateRequest struct {
	ctx context.Context
	ApiService *UsersApiService
	data *WritableObjectPermission
}

func (r ApiUsersPermissionsBulkUpdateRequest) Data(data WritableObjectPermission) ApiUsersPermissionsBulkUpdateRequest {
	r.data = &data
	return r
}

func (r ApiUsersPermissionsBulkUpdateRequest) Execute() (*ObjectPermission, *http.Response, error) {
	return r.ApiService.UsersPermissionsBulkUpdateExecute(r)
}

/*
UsersPermissionsBulkUpdate Method for UsersPermissionsBulkUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUsersPermissionsBulkUpdateRequest
*/
func (a *UsersApiService) UsersPermissionsBulkUpdate(ctx context.Context) ApiUsersPermissionsBulkUpdateRequest {
	return ApiUsersPermissionsBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ObjectPermission
func (a *UsersApiService) UsersPermissionsBulkUpdateExecute(r ApiUsersPermissionsBulkUpdateRequest) (*ObjectPermission, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ObjectPermission
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.UsersPermissionsBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/permissions/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersPermissionsCreateRequest struct {
	ctx context.Context
	ApiService *UsersApiService
	data *WritableObjectPermission
}

func (r ApiUsersPermissionsCreateRequest) Data(data WritableObjectPermission) ApiUsersPermissionsCreateRequest {
	r.data = &data
	return r
}

func (r ApiUsersPermissionsCreateRequest) Execute() (*ObjectPermission, *http.Response, error) {
	return r.ApiService.UsersPermissionsCreateExecute(r)
}

/*
UsersPermissionsCreate Method for UsersPermissionsCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUsersPermissionsCreateRequest
*/
func (a *UsersApiService) UsersPermissionsCreate(ctx context.Context) ApiUsersPermissionsCreateRequest {
	return ApiUsersPermissionsCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ObjectPermission
func (a *UsersApiService) UsersPermissionsCreateExecute(r ApiUsersPermissionsCreateRequest) (*ObjectPermission, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ObjectPermission
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.UsersPermissionsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/permissions/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersPermissionsDeleteRequest struct {
	ctx context.Context
	ApiService *UsersApiService
	id int32
}

func (r ApiUsersPermissionsDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.UsersPermissionsDeleteExecute(r)
}

/*
UsersPermissionsDelete Method for UsersPermissionsDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this permission.
 @return ApiUsersPermissionsDeleteRequest
*/
func (a *UsersApiService) UsersPermissionsDelete(ctx context.Context, id int32) ApiUsersPermissionsDeleteRequest {
	return ApiUsersPermissionsDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *UsersApiService) UsersPermissionsDeleteExecute(r ApiUsersPermissionsDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.UsersPermissionsDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/permissions/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersPermissionsListRequest struct {
	ctx context.Context
	ApiService *UsersApiService
	id *string
	name *string
	enabled *string
	objectTypes *string
	userId *string
	user *string
	groupId *string
	group *string
	idN *string
	idLte *string
	idLt *string
	idGte *string
	idGt *string
	nameN *string
	nameIc *string
	nameNic *string
	nameIew *string
	nameNiew *string
	nameIsw *string
	nameNisw *string
	nameIe *string
	nameNie *string
	nameEmpty *string
	objectTypesN *string
	userIdN *string
	userN *string
	groupIdN *string
	groupN *string
	limit *int32
	offset *int32
}

func (r ApiUsersPermissionsListRequest) Id(id string) ApiUsersPermissionsListRequest {
	r.id = &id
	return r
}

func (r ApiUsersPermissionsListRequest) Name(name string) ApiUsersPermissionsListRequest {
	r.name = &name
	return r
}

func (r ApiUsersPermissionsListRequest) Enabled(enabled string) ApiUsersPermissionsListRequest {
	r.enabled = &enabled
	return r
}

func (r ApiUsersPermissionsListRequest) ObjectTypes(objectTypes string) ApiUsersPermissionsListRequest {
	r.objectTypes = &objectTypes
	return r
}

func (r ApiUsersPermissionsListRequest) UserId(userId string) ApiUsersPermissionsListRequest {
	r.userId = &userId
	return r
}

func (r ApiUsersPermissionsListRequest) User(user string) ApiUsersPermissionsListRequest {
	r.user = &user
	return r
}

func (r ApiUsersPermissionsListRequest) GroupId(groupId string) ApiUsersPermissionsListRequest {
	r.groupId = &groupId
	return r
}

func (r ApiUsersPermissionsListRequest) Group(group string) ApiUsersPermissionsListRequest {
	r.group = &group
	return r
}

func (r ApiUsersPermissionsListRequest) IdN(idN string) ApiUsersPermissionsListRequest {
	r.idN = &idN
	return r
}

func (r ApiUsersPermissionsListRequest) IdLte(idLte string) ApiUsersPermissionsListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiUsersPermissionsListRequest) IdLt(idLt string) ApiUsersPermissionsListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiUsersPermissionsListRequest) IdGte(idGte string) ApiUsersPermissionsListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiUsersPermissionsListRequest) IdGt(idGt string) ApiUsersPermissionsListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiUsersPermissionsListRequest) NameN(nameN string) ApiUsersPermissionsListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiUsersPermissionsListRequest) NameIc(nameIc string) ApiUsersPermissionsListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiUsersPermissionsListRequest) NameNic(nameNic string) ApiUsersPermissionsListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiUsersPermissionsListRequest) NameIew(nameIew string) ApiUsersPermissionsListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiUsersPermissionsListRequest) NameNiew(nameNiew string) ApiUsersPermissionsListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiUsersPermissionsListRequest) NameIsw(nameIsw string) ApiUsersPermissionsListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiUsersPermissionsListRequest) NameNisw(nameNisw string) ApiUsersPermissionsListRequest {
	r.nameNisw = &nameNisw
	return r
}

func (r ApiUsersPermissionsListRequest) NameIe(nameIe string) ApiUsersPermissionsListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiUsersPermissionsListRequest) NameNie(nameNie string) ApiUsersPermissionsListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiUsersPermissionsListRequest) NameEmpty(nameEmpty string) ApiUsersPermissionsListRequest {
	r.nameEmpty = &nameEmpty
	return r
}

func (r ApiUsersPermissionsListRequest) ObjectTypesN(objectTypesN string) ApiUsersPermissionsListRequest {
	r.objectTypesN = &objectTypesN
	return r
}

func (r ApiUsersPermissionsListRequest) UserIdN(userIdN string) ApiUsersPermissionsListRequest {
	r.userIdN = &userIdN
	return r
}

func (r ApiUsersPermissionsListRequest) UserN(userN string) ApiUsersPermissionsListRequest {
	r.userN = &userN
	return r
}

func (r ApiUsersPermissionsListRequest) GroupIdN(groupIdN string) ApiUsersPermissionsListRequest {
	r.groupIdN = &groupIdN
	return r
}

func (r ApiUsersPermissionsListRequest) GroupN(groupN string) ApiUsersPermissionsListRequest {
	r.groupN = &groupN
	return r
}

// Number of results to return per page.
func (r ApiUsersPermissionsListRequest) Limit(limit int32) ApiUsersPermissionsListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiUsersPermissionsListRequest) Offset(offset int32) ApiUsersPermissionsListRequest {
	r.offset = &offset
	return r
}

func (r ApiUsersPermissionsListRequest) Execute() (*UsersPermissionsList200Response, *http.Response, error) {
	return r.ApiService.UsersPermissionsListExecute(r)
}

/*
UsersPermissionsList Method for UsersPermissionsList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUsersPermissionsListRequest
*/
func (a *UsersApiService) UsersPermissionsList(ctx context.Context) ApiUsersPermissionsListRequest {
	return ApiUsersPermissionsListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UsersPermissionsList200Response
func (a *UsersApiService) UsersPermissionsListExecute(r ApiUsersPermissionsListRequest) (*UsersPermissionsList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UsersPermissionsList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.UsersPermissionsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/permissions/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.enabled != nil {
		localVarQueryParams.Add("enabled", parameterToString(*r.enabled, ""))
	}
	if r.objectTypes != nil {
		localVarQueryParams.Add("object_types", parameterToString(*r.objectTypes, ""))
	}
	if r.userId != nil {
		localVarQueryParams.Add("user_id", parameterToString(*r.userId, ""))
	}
	if r.user != nil {
		localVarQueryParams.Add("user", parameterToString(*r.user, ""))
	}
	if r.groupId != nil {
		localVarQueryParams.Add("group_id", parameterToString(*r.groupId, ""))
	}
	if r.group != nil {
		localVarQueryParams.Add("group", parameterToString(*r.group, ""))
	}
	if r.idN != nil {
		localVarQueryParams.Add("id__n", parameterToString(*r.idN, ""))
	}
	if r.idLte != nil {
		localVarQueryParams.Add("id__lte", parameterToString(*r.idLte, ""))
	}
	if r.idLt != nil {
		localVarQueryParams.Add("id__lt", parameterToString(*r.idLt, ""))
	}
	if r.idGte != nil {
		localVarQueryParams.Add("id__gte", parameterToString(*r.idGte, ""))
	}
	if r.idGt != nil {
		localVarQueryParams.Add("id__gt", parameterToString(*r.idGt, ""))
	}
	if r.nameN != nil {
		localVarQueryParams.Add("name__n", parameterToString(*r.nameN, ""))
	}
	if r.nameIc != nil {
		localVarQueryParams.Add("name__ic", parameterToString(*r.nameIc, ""))
	}
	if r.nameNic != nil {
		localVarQueryParams.Add("name__nic", parameterToString(*r.nameNic, ""))
	}
	if r.nameIew != nil {
		localVarQueryParams.Add("name__iew", parameterToString(*r.nameIew, ""))
	}
	if r.nameNiew != nil {
		localVarQueryParams.Add("name__niew", parameterToString(*r.nameNiew, ""))
	}
	if r.nameIsw != nil {
		localVarQueryParams.Add("name__isw", parameterToString(*r.nameIsw, ""))
	}
	if r.nameNisw != nil {
		localVarQueryParams.Add("name__nisw", parameterToString(*r.nameNisw, ""))
	}
	if r.nameIe != nil {
		localVarQueryParams.Add("name__ie", parameterToString(*r.nameIe, ""))
	}
	if r.nameNie != nil {
		localVarQueryParams.Add("name__nie", parameterToString(*r.nameNie, ""))
	}
	if r.nameEmpty != nil {
		localVarQueryParams.Add("name__empty", parameterToString(*r.nameEmpty, ""))
	}
	if r.objectTypesN != nil {
		localVarQueryParams.Add("object_types__n", parameterToString(*r.objectTypesN, ""))
	}
	if r.userIdN != nil {
		localVarQueryParams.Add("user_id__n", parameterToString(*r.userIdN, ""))
	}
	if r.userN != nil {
		localVarQueryParams.Add("user__n", parameterToString(*r.userN, ""))
	}
	if r.groupIdN != nil {
		localVarQueryParams.Add("group_id__n", parameterToString(*r.groupIdN, ""))
	}
	if r.groupN != nil {
		localVarQueryParams.Add("group__n", parameterToString(*r.groupN, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersPermissionsPartialUpdateRequest struct {
	ctx context.Context
	ApiService *UsersApiService
	id int32
	data *WritableObjectPermission
}

func (r ApiUsersPermissionsPartialUpdateRequest) Data(data WritableObjectPermission) ApiUsersPermissionsPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiUsersPermissionsPartialUpdateRequest) Execute() (*ObjectPermission, *http.Response, error) {
	return r.ApiService.UsersPermissionsPartialUpdateExecute(r)
}

/*
UsersPermissionsPartialUpdate Method for UsersPermissionsPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this permission.
 @return ApiUsersPermissionsPartialUpdateRequest
*/
func (a *UsersApiService) UsersPermissionsPartialUpdate(ctx context.Context, id int32) ApiUsersPermissionsPartialUpdateRequest {
	return ApiUsersPermissionsPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ObjectPermission
func (a *UsersApiService) UsersPermissionsPartialUpdateExecute(r ApiUsersPermissionsPartialUpdateRequest) (*ObjectPermission, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ObjectPermission
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.UsersPermissionsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/permissions/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersPermissionsReadRequest struct {
	ctx context.Context
	ApiService *UsersApiService
	id int32
}

func (r ApiUsersPermissionsReadRequest) Execute() (*ObjectPermission, *http.Response, error) {
	return r.ApiService.UsersPermissionsReadExecute(r)
}

/*
UsersPermissionsRead Method for UsersPermissionsRead

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this permission.
 @return ApiUsersPermissionsReadRequest
*/
func (a *UsersApiService) UsersPermissionsRead(ctx context.Context, id int32) ApiUsersPermissionsReadRequest {
	return ApiUsersPermissionsReadRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ObjectPermission
func (a *UsersApiService) UsersPermissionsReadExecute(r ApiUsersPermissionsReadRequest) (*ObjectPermission, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ObjectPermission
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.UsersPermissionsRead")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/permissions/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersPermissionsUpdateRequest struct {
	ctx context.Context
	ApiService *UsersApiService
	id int32
	data *WritableObjectPermission
}

func (r ApiUsersPermissionsUpdateRequest) Data(data WritableObjectPermission) ApiUsersPermissionsUpdateRequest {
	r.data = &data
	return r
}

func (r ApiUsersPermissionsUpdateRequest) Execute() (*ObjectPermission, *http.Response, error) {
	return r.ApiService.UsersPermissionsUpdateExecute(r)
}

/*
UsersPermissionsUpdate Method for UsersPermissionsUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this permission.
 @return ApiUsersPermissionsUpdateRequest
*/
func (a *UsersApiService) UsersPermissionsUpdate(ctx context.Context, id int32) ApiUsersPermissionsUpdateRequest {
	return ApiUsersPermissionsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ObjectPermission
func (a *UsersApiService) UsersPermissionsUpdateExecute(r ApiUsersPermissionsUpdateRequest) (*ObjectPermission, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ObjectPermission
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.UsersPermissionsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/permissions/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUsersBulkDeleteRequest struct {
	ctx context.Context
	ApiService *UsersApiService
}

func (r ApiUsersUsersBulkDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.UsersUsersBulkDeleteExecute(r)
}

/*
UsersUsersBulkDelete Method for UsersUsersBulkDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUsersUsersBulkDeleteRequest
*/
func (a *UsersApiService) UsersUsersBulkDelete(ctx context.Context) ApiUsersUsersBulkDeleteRequest {
	return ApiUsersUsersBulkDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *UsersApiService) UsersUsersBulkDeleteExecute(r ApiUsersUsersBulkDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.UsersUsersBulkDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/users/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUsersBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *UsersApiService
	data *WritableUser
}

func (r ApiUsersUsersBulkPartialUpdateRequest) Data(data WritableUser) ApiUsersUsersBulkPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiUsersUsersBulkPartialUpdateRequest) Execute() (*User, *http.Response, error) {
	return r.ApiService.UsersUsersBulkPartialUpdateExecute(r)
}

/*
UsersUsersBulkPartialUpdate Method for UsersUsersBulkPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUsersUsersBulkPartialUpdateRequest
*/
func (a *UsersApiService) UsersUsersBulkPartialUpdate(ctx context.Context) ApiUsersUsersBulkPartialUpdateRequest {
	return ApiUsersUsersBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return User
func (a *UsersApiService) UsersUsersBulkPartialUpdateExecute(r ApiUsersUsersBulkPartialUpdateRequest) (*User, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *User
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.UsersUsersBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/users/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUsersBulkUpdateRequest struct {
	ctx context.Context
	ApiService *UsersApiService
	data *WritableUser
}

func (r ApiUsersUsersBulkUpdateRequest) Data(data WritableUser) ApiUsersUsersBulkUpdateRequest {
	r.data = &data
	return r
}

func (r ApiUsersUsersBulkUpdateRequest) Execute() (*User, *http.Response, error) {
	return r.ApiService.UsersUsersBulkUpdateExecute(r)
}

/*
UsersUsersBulkUpdate Method for UsersUsersBulkUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUsersUsersBulkUpdateRequest
*/
func (a *UsersApiService) UsersUsersBulkUpdate(ctx context.Context) ApiUsersUsersBulkUpdateRequest {
	return ApiUsersUsersBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return User
func (a *UsersApiService) UsersUsersBulkUpdateExecute(r ApiUsersUsersBulkUpdateRequest) (*User, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *User
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.UsersUsersBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/users/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUsersCreateRequest struct {
	ctx context.Context
	ApiService *UsersApiService
	data *WritableUser
}

func (r ApiUsersUsersCreateRequest) Data(data WritableUser) ApiUsersUsersCreateRequest {
	r.data = &data
	return r
}

func (r ApiUsersUsersCreateRequest) Execute() (*User, *http.Response, error) {
	return r.ApiService.UsersUsersCreateExecute(r)
}

/*
UsersUsersCreate Method for UsersUsersCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUsersUsersCreateRequest
*/
func (a *UsersApiService) UsersUsersCreate(ctx context.Context) ApiUsersUsersCreateRequest {
	return ApiUsersUsersCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return User
func (a *UsersApiService) UsersUsersCreateExecute(r ApiUsersUsersCreateRequest) (*User, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *User
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.UsersUsersCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/users/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUsersDeleteRequest struct {
	ctx context.Context
	ApiService *UsersApiService
	id int32
}

func (r ApiUsersUsersDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.UsersUsersDeleteExecute(r)
}

/*
UsersUsersDelete Method for UsersUsersDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this user.
 @return ApiUsersUsersDeleteRequest
*/
func (a *UsersApiService) UsersUsersDelete(ctx context.Context, id int32) ApiUsersUsersDeleteRequest {
	return ApiUsersUsersDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *UsersApiService) UsersUsersDeleteExecute(r ApiUsersUsersDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.UsersUsersDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/users/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUsersListRequest struct {
	ctx context.Context
	ApiService *UsersApiService
	id *string
	username *string
	firstName *string
	lastName *string
	email *string
	isStaff *string
	isActive *string
	q *string
	groupId *string
	group *string
	idN *string
	idLte *string
	idLt *string
	idGte *string
	idGt *string
	usernameN *string
	usernameIc *string
	usernameNic *string
	usernameIew *string
	usernameNiew *string
	usernameIsw *string
	usernameNisw *string
	usernameIe *string
	usernameNie *string
	usernameEmpty *string
	firstNameN *string
	firstNameIc *string
	firstNameNic *string
	firstNameIew *string
	firstNameNiew *string
	firstNameIsw *string
	firstNameNisw *string
	firstNameIe *string
	firstNameNie *string
	firstNameEmpty *string
	lastNameN *string
	lastNameIc *string
	lastNameNic *string
	lastNameIew *string
	lastNameNiew *string
	lastNameIsw *string
	lastNameNisw *string
	lastNameIe *string
	lastNameNie *string
	lastNameEmpty *string
	emailN *string
	emailIc *string
	emailNic *string
	emailIew *string
	emailNiew *string
	emailIsw *string
	emailNisw *string
	emailIe *string
	emailNie *string
	emailEmpty *string
	groupIdN *string
	groupN *string
	limit *int32
	offset *int32
}

func (r ApiUsersUsersListRequest) Id(id string) ApiUsersUsersListRequest {
	r.id = &id
	return r
}

func (r ApiUsersUsersListRequest) Username(username string) ApiUsersUsersListRequest {
	r.username = &username
	return r
}

func (r ApiUsersUsersListRequest) FirstName(firstName string) ApiUsersUsersListRequest {
	r.firstName = &firstName
	return r
}

func (r ApiUsersUsersListRequest) LastName(lastName string) ApiUsersUsersListRequest {
	r.lastName = &lastName
	return r
}

func (r ApiUsersUsersListRequest) Email(email string) ApiUsersUsersListRequest {
	r.email = &email
	return r
}

func (r ApiUsersUsersListRequest) IsStaff(isStaff string) ApiUsersUsersListRequest {
	r.isStaff = &isStaff
	return r
}

func (r ApiUsersUsersListRequest) IsActive(isActive string) ApiUsersUsersListRequest {
	r.isActive = &isActive
	return r
}

func (r ApiUsersUsersListRequest) Q(q string) ApiUsersUsersListRequest {
	r.q = &q
	return r
}

func (r ApiUsersUsersListRequest) GroupId(groupId string) ApiUsersUsersListRequest {
	r.groupId = &groupId
	return r
}

func (r ApiUsersUsersListRequest) Group(group string) ApiUsersUsersListRequest {
	r.group = &group
	return r
}

func (r ApiUsersUsersListRequest) IdN(idN string) ApiUsersUsersListRequest {
	r.idN = &idN
	return r
}

func (r ApiUsersUsersListRequest) IdLte(idLte string) ApiUsersUsersListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiUsersUsersListRequest) IdLt(idLt string) ApiUsersUsersListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiUsersUsersListRequest) IdGte(idGte string) ApiUsersUsersListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiUsersUsersListRequest) IdGt(idGt string) ApiUsersUsersListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiUsersUsersListRequest) UsernameN(usernameN string) ApiUsersUsersListRequest {
	r.usernameN = &usernameN
	return r
}

func (r ApiUsersUsersListRequest) UsernameIc(usernameIc string) ApiUsersUsersListRequest {
	r.usernameIc = &usernameIc
	return r
}

func (r ApiUsersUsersListRequest) UsernameNic(usernameNic string) ApiUsersUsersListRequest {
	r.usernameNic = &usernameNic
	return r
}

func (r ApiUsersUsersListRequest) UsernameIew(usernameIew string) ApiUsersUsersListRequest {
	r.usernameIew = &usernameIew
	return r
}

func (r ApiUsersUsersListRequest) UsernameNiew(usernameNiew string) ApiUsersUsersListRequest {
	r.usernameNiew = &usernameNiew
	return r
}

func (r ApiUsersUsersListRequest) UsernameIsw(usernameIsw string) ApiUsersUsersListRequest {
	r.usernameIsw = &usernameIsw
	return r
}

func (r ApiUsersUsersListRequest) UsernameNisw(usernameNisw string) ApiUsersUsersListRequest {
	r.usernameNisw = &usernameNisw
	return r
}

func (r ApiUsersUsersListRequest) UsernameIe(usernameIe string) ApiUsersUsersListRequest {
	r.usernameIe = &usernameIe
	return r
}

func (r ApiUsersUsersListRequest) UsernameNie(usernameNie string) ApiUsersUsersListRequest {
	r.usernameNie = &usernameNie
	return r
}

func (r ApiUsersUsersListRequest) UsernameEmpty(usernameEmpty string) ApiUsersUsersListRequest {
	r.usernameEmpty = &usernameEmpty
	return r
}

func (r ApiUsersUsersListRequest) FirstNameN(firstNameN string) ApiUsersUsersListRequest {
	r.firstNameN = &firstNameN
	return r
}

func (r ApiUsersUsersListRequest) FirstNameIc(firstNameIc string) ApiUsersUsersListRequest {
	r.firstNameIc = &firstNameIc
	return r
}

func (r ApiUsersUsersListRequest) FirstNameNic(firstNameNic string) ApiUsersUsersListRequest {
	r.firstNameNic = &firstNameNic
	return r
}

func (r ApiUsersUsersListRequest) FirstNameIew(firstNameIew string) ApiUsersUsersListRequest {
	r.firstNameIew = &firstNameIew
	return r
}

func (r ApiUsersUsersListRequest) FirstNameNiew(firstNameNiew string) ApiUsersUsersListRequest {
	r.firstNameNiew = &firstNameNiew
	return r
}

func (r ApiUsersUsersListRequest) FirstNameIsw(firstNameIsw string) ApiUsersUsersListRequest {
	r.firstNameIsw = &firstNameIsw
	return r
}

func (r ApiUsersUsersListRequest) FirstNameNisw(firstNameNisw string) ApiUsersUsersListRequest {
	r.firstNameNisw = &firstNameNisw
	return r
}

func (r ApiUsersUsersListRequest) FirstNameIe(firstNameIe string) ApiUsersUsersListRequest {
	r.firstNameIe = &firstNameIe
	return r
}

func (r ApiUsersUsersListRequest) FirstNameNie(firstNameNie string) ApiUsersUsersListRequest {
	r.firstNameNie = &firstNameNie
	return r
}

func (r ApiUsersUsersListRequest) FirstNameEmpty(firstNameEmpty string) ApiUsersUsersListRequest {
	r.firstNameEmpty = &firstNameEmpty
	return r
}

func (r ApiUsersUsersListRequest) LastNameN(lastNameN string) ApiUsersUsersListRequest {
	r.lastNameN = &lastNameN
	return r
}

func (r ApiUsersUsersListRequest) LastNameIc(lastNameIc string) ApiUsersUsersListRequest {
	r.lastNameIc = &lastNameIc
	return r
}

func (r ApiUsersUsersListRequest) LastNameNic(lastNameNic string) ApiUsersUsersListRequest {
	r.lastNameNic = &lastNameNic
	return r
}

func (r ApiUsersUsersListRequest) LastNameIew(lastNameIew string) ApiUsersUsersListRequest {
	r.lastNameIew = &lastNameIew
	return r
}

func (r ApiUsersUsersListRequest) LastNameNiew(lastNameNiew string) ApiUsersUsersListRequest {
	r.lastNameNiew = &lastNameNiew
	return r
}

func (r ApiUsersUsersListRequest) LastNameIsw(lastNameIsw string) ApiUsersUsersListRequest {
	r.lastNameIsw = &lastNameIsw
	return r
}

func (r ApiUsersUsersListRequest) LastNameNisw(lastNameNisw string) ApiUsersUsersListRequest {
	r.lastNameNisw = &lastNameNisw
	return r
}

func (r ApiUsersUsersListRequest) LastNameIe(lastNameIe string) ApiUsersUsersListRequest {
	r.lastNameIe = &lastNameIe
	return r
}

func (r ApiUsersUsersListRequest) LastNameNie(lastNameNie string) ApiUsersUsersListRequest {
	r.lastNameNie = &lastNameNie
	return r
}

func (r ApiUsersUsersListRequest) LastNameEmpty(lastNameEmpty string) ApiUsersUsersListRequest {
	r.lastNameEmpty = &lastNameEmpty
	return r
}

func (r ApiUsersUsersListRequest) EmailN(emailN string) ApiUsersUsersListRequest {
	r.emailN = &emailN
	return r
}

func (r ApiUsersUsersListRequest) EmailIc(emailIc string) ApiUsersUsersListRequest {
	r.emailIc = &emailIc
	return r
}

func (r ApiUsersUsersListRequest) EmailNic(emailNic string) ApiUsersUsersListRequest {
	r.emailNic = &emailNic
	return r
}

func (r ApiUsersUsersListRequest) EmailIew(emailIew string) ApiUsersUsersListRequest {
	r.emailIew = &emailIew
	return r
}

func (r ApiUsersUsersListRequest) EmailNiew(emailNiew string) ApiUsersUsersListRequest {
	r.emailNiew = &emailNiew
	return r
}

func (r ApiUsersUsersListRequest) EmailIsw(emailIsw string) ApiUsersUsersListRequest {
	r.emailIsw = &emailIsw
	return r
}

func (r ApiUsersUsersListRequest) EmailNisw(emailNisw string) ApiUsersUsersListRequest {
	r.emailNisw = &emailNisw
	return r
}

func (r ApiUsersUsersListRequest) EmailIe(emailIe string) ApiUsersUsersListRequest {
	r.emailIe = &emailIe
	return r
}

func (r ApiUsersUsersListRequest) EmailNie(emailNie string) ApiUsersUsersListRequest {
	r.emailNie = &emailNie
	return r
}

func (r ApiUsersUsersListRequest) EmailEmpty(emailEmpty string) ApiUsersUsersListRequest {
	r.emailEmpty = &emailEmpty
	return r
}

func (r ApiUsersUsersListRequest) GroupIdN(groupIdN string) ApiUsersUsersListRequest {
	r.groupIdN = &groupIdN
	return r
}

func (r ApiUsersUsersListRequest) GroupN(groupN string) ApiUsersUsersListRequest {
	r.groupN = &groupN
	return r
}

// Number of results to return per page.
func (r ApiUsersUsersListRequest) Limit(limit int32) ApiUsersUsersListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiUsersUsersListRequest) Offset(offset int32) ApiUsersUsersListRequest {
	r.offset = &offset
	return r
}

func (r ApiUsersUsersListRequest) Execute() (*UsersUsersList200Response, *http.Response, error) {
	return r.ApiService.UsersUsersListExecute(r)
}

/*
UsersUsersList Method for UsersUsersList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUsersUsersListRequest
*/
func (a *UsersApiService) UsersUsersList(ctx context.Context) ApiUsersUsersListRequest {
	return ApiUsersUsersListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UsersUsersList200Response
func (a *UsersApiService) UsersUsersListExecute(r ApiUsersUsersListRequest) (*UsersUsersList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UsersUsersList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.UsersUsersList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/users/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.username != nil {
		localVarQueryParams.Add("username", parameterToString(*r.username, ""))
	}
	if r.firstName != nil {
		localVarQueryParams.Add("first_name", parameterToString(*r.firstName, ""))
	}
	if r.lastName != nil {
		localVarQueryParams.Add("last_name", parameterToString(*r.lastName, ""))
	}
	if r.email != nil {
		localVarQueryParams.Add("email", parameterToString(*r.email, ""))
	}
	if r.isStaff != nil {
		localVarQueryParams.Add("is_staff", parameterToString(*r.isStaff, ""))
	}
	if r.isActive != nil {
		localVarQueryParams.Add("is_active", parameterToString(*r.isActive, ""))
	}
	if r.q != nil {
		localVarQueryParams.Add("q", parameterToString(*r.q, ""))
	}
	if r.groupId != nil {
		localVarQueryParams.Add("group_id", parameterToString(*r.groupId, ""))
	}
	if r.group != nil {
		localVarQueryParams.Add("group", parameterToString(*r.group, ""))
	}
	if r.idN != nil {
		localVarQueryParams.Add("id__n", parameterToString(*r.idN, ""))
	}
	if r.idLte != nil {
		localVarQueryParams.Add("id__lte", parameterToString(*r.idLte, ""))
	}
	if r.idLt != nil {
		localVarQueryParams.Add("id__lt", parameterToString(*r.idLt, ""))
	}
	if r.idGte != nil {
		localVarQueryParams.Add("id__gte", parameterToString(*r.idGte, ""))
	}
	if r.idGt != nil {
		localVarQueryParams.Add("id__gt", parameterToString(*r.idGt, ""))
	}
	if r.usernameN != nil {
		localVarQueryParams.Add("username__n", parameterToString(*r.usernameN, ""))
	}
	if r.usernameIc != nil {
		localVarQueryParams.Add("username__ic", parameterToString(*r.usernameIc, ""))
	}
	if r.usernameNic != nil {
		localVarQueryParams.Add("username__nic", parameterToString(*r.usernameNic, ""))
	}
	if r.usernameIew != nil {
		localVarQueryParams.Add("username__iew", parameterToString(*r.usernameIew, ""))
	}
	if r.usernameNiew != nil {
		localVarQueryParams.Add("username__niew", parameterToString(*r.usernameNiew, ""))
	}
	if r.usernameIsw != nil {
		localVarQueryParams.Add("username__isw", parameterToString(*r.usernameIsw, ""))
	}
	if r.usernameNisw != nil {
		localVarQueryParams.Add("username__nisw", parameterToString(*r.usernameNisw, ""))
	}
	if r.usernameIe != nil {
		localVarQueryParams.Add("username__ie", parameterToString(*r.usernameIe, ""))
	}
	if r.usernameNie != nil {
		localVarQueryParams.Add("username__nie", parameterToString(*r.usernameNie, ""))
	}
	if r.usernameEmpty != nil {
		localVarQueryParams.Add("username__empty", parameterToString(*r.usernameEmpty, ""))
	}
	if r.firstNameN != nil {
		localVarQueryParams.Add("first_name__n", parameterToString(*r.firstNameN, ""))
	}
	if r.firstNameIc != nil {
		localVarQueryParams.Add("first_name__ic", parameterToString(*r.firstNameIc, ""))
	}
	if r.firstNameNic != nil {
		localVarQueryParams.Add("first_name__nic", parameterToString(*r.firstNameNic, ""))
	}
	if r.firstNameIew != nil {
		localVarQueryParams.Add("first_name__iew", parameterToString(*r.firstNameIew, ""))
	}
	if r.firstNameNiew != nil {
		localVarQueryParams.Add("first_name__niew", parameterToString(*r.firstNameNiew, ""))
	}
	if r.firstNameIsw != nil {
		localVarQueryParams.Add("first_name__isw", parameterToString(*r.firstNameIsw, ""))
	}
	if r.firstNameNisw != nil {
		localVarQueryParams.Add("first_name__nisw", parameterToString(*r.firstNameNisw, ""))
	}
	if r.firstNameIe != nil {
		localVarQueryParams.Add("first_name__ie", parameterToString(*r.firstNameIe, ""))
	}
	if r.firstNameNie != nil {
		localVarQueryParams.Add("first_name__nie", parameterToString(*r.firstNameNie, ""))
	}
	if r.firstNameEmpty != nil {
		localVarQueryParams.Add("first_name__empty", parameterToString(*r.firstNameEmpty, ""))
	}
	if r.lastNameN != nil {
		localVarQueryParams.Add("last_name__n", parameterToString(*r.lastNameN, ""))
	}
	if r.lastNameIc != nil {
		localVarQueryParams.Add("last_name__ic", parameterToString(*r.lastNameIc, ""))
	}
	if r.lastNameNic != nil {
		localVarQueryParams.Add("last_name__nic", parameterToString(*r.lastNameNic, ""))
	}
	if r.lastNameIew != nil {
		localVarQueryParams.Add("last_name__iew", parameterToString(*r.lastNameIew, ""))
	}
	if r.lastNameNiew != nil {
		localVarQueryParams.Add("last_name__niew", parameterToString(*r.lastNameNiew, ""))
	}
	if r.lastNameIsw != nil {
		localVarQueryParams.Add("last_name__isw", parameterToString(*r.lastNameIsw, ""))
	}
	if r.lastNameNisw != nil {
		localVarQueryParams.Add("last_name__nisw", parameterToString(*r.lastNameNisw, ""))
	}
	if r.lastNameIe != nil {
		localVarQueryParams.Add("last_name__ie", parameterToString(*r.lastNameIe, ""))
	}
	if r.lastNameNie != nil {
		localVarQueryParams.Add("last_name__nie", parameterToString(*r.lastNameNie, ""))
	}
	if r.lastNameEmpty != nil {
		localVarQueryParams.Add("last_name__empty", parameterToString(*r.lastNameEmpty, ""))
	}
	if r.emailN != nil {
		localVarQueryParams.Add("email__n", parameterToString(*r.emailN, ""))
	}
	if r.emailIc != nil {
		localVarQueryParams.Add("email__ic", parameterToString(*r.emailIc, ""))
	}
	if r.emailNic != nil {
		localVarQueryParams.Add("email__nic", parameterToString(*r.emailNic, ""))
	}
	if r.emailIew != nil {
		localVarQueryParams.Add("email__iew", parameterToString(*r.emailIew, ""))
	}
	if r.emailNiew != nil {
		localVarQueryParams.Add("email__niew", parameterToString(*r.emailNiew, ""))
	}
	if r.emailIsw != nil {
		localVarQueryParams.Add("email__isw", parameterToString(*r.emailIsw, ""))
	}
	if r.emailNisw != nil {
		localVarQueryParams.Add("email__nisw", parameterToString(*r.emailNisw, ""))
	}
	if r.emailIe != nil {
		localVarQueryParams.Add("email__ie", parameterToString(*r.emailIe, ""))
	}
	if r.emailNie != nil {
		localVarQueryParams.Add("email__nie", parameterToString(*r.emailNie, ""))
	}
	if r.emailEmpty != nil {
		localVarQueryParams.Add("email__empty", parameterToString(*r.emailEmpty, ""))
	}
	if r.groupIdN != nil {
		localVarQueryParams.Add("group_id__n", parameterToString(*r.groupIdN, ""))
	}
	if r.groupN != nil {
		localVarQueryParams.Add("group__n", parameterToString(*r.groupN, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUsersPartialUpdateRequest struct {
	ctx context.Context
	ApiService *UsersApiService
	id int32
	data *WritableUser
}

func (r ApiUsersUsersPartialUpdateRequest) Data(data WritableUser) ApiUsersUsersPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiUsersUsersPartialUpdateRequest) Execute() (*User, *http.Response, error) {
	return r.ApiService.UsersUsersPartialUpdateExecute(r)
}

/*
UsersUsersPartialUpdate Method for UsersUsersPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this user.
 @return ApiUsersUsersPartialUpdateRequest
*/
func (a *UsersApiService) UsersUsersPartialUpdate(ctx context.Context, id int32) ApiUsersUsersPartialUpdateRequest {
	return ApiUsersUsersPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return User
func (a *UsersApiService) UsersUsersPartialUpdateExecute(r ApiUsersUsersPartialUpdateRequest) (*User, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *User
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.UsersUsersPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/users/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUsersReadRequest struct {
	ctx context.Context
	ApiService *UsersApiService
	id int32
}

func (r ApiUsersUsersReadRequest) Execute() (*User, *http.Response, error) {
	return r.ApiService.UsersUsersReadExecute(r)
}

/*
UsersUsersRead Method for UsersUsersRead

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this user.
 @return ApiUsersUsersReadRequest
*/
func (a *UsersApiService) UsersUsersRead(ctx context.Context, id int32) ApiUsersUsersReadRequest {
	return ApiUsersUsersReadRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return User
func (a *UsersApiService) UsersUsersReadExecute(r ApiUsersUsersReadRequest) (*User, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *User
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.UsersUsersRead")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/users/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUsersUpdateRequest struct {
	ctx context.Context
	ApiService *UsersApiService
	id int32
	data *WritableUser
}

func (r ApiUsersUsersUpdateRequest) Data(data WritableUser) ApiUsersUsersUpdateRequest {
	r.data = &data
	return r
}

func (r ApiUsersUsersUpdateRequest) Execute() (*User, *http.Response, error) {
	return r.ApiService.UsersUsersUpdateExecute(r)
}

/*
UsersUsersUpdate Method for UsersUsersUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this user.
 @return ApiUsersUsersUpdateRequest
*/
func (a *UsersApiService) UsersUsersUpdate(ctx context.Context, id int32) ApiUsersUsersUpdateRequest {
	return ApiUsersUsersUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return User
func (a *UsersApiService) UsersUsersUpdateExecute(r ApiUsersUsersUpdateRequest) (*User, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *User
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.UsersUsersUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/users/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
