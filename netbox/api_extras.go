/*
NetBox API

API to access NetBox

API version: 2.11
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package netbox

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


// ExtrasApiService ExtrasApi service
type ExtrasApiService service

type ApiExtrasConfigContextsBulkDeleteRequest struct {
	ctx context.Context
	ApiService *ExtrasApiService
}

func (r ApiExtrasConfigContextsBulkDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.ExtrasConfigContextsBulkDeleteExecute(r)
}

/*
ExtrasConfigContextsBulkDelete Method for ExtrasConfigContextsBulkDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiExtrasConfigContextsBulkDeleteRequest
*/
func (a *ExtrasApiService) ExtrasConfigContextsBulkDelete(ctx context.Context) ApiExtrasConfigContextsBulkDeleteRequest {
	return ApiExtrasConfigContextsBulkDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ExtrasApiService) ExtrasConfigContextsBulkDeleteExecute(r ApiExtrasConfigContextsBulkDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExtrasApiService.ExtrasConfigContextsBulkDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extras/config-contexts/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiExtrasConfigContextsBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *ExtrasApiService
	data *WritableConfigContext
}

func (r ApiExtrasConfigContextsBulkPartialUpdateRequest) Data(data WritableConfigContext) ApiExtrasConfigContextsBulkPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiExtrasConfigContextsBulkPartialUpdateRequest) Execute() (*ConfigContext, *http.Response, error) {
	return r.ApiService.ExtrasConfigContextsBulkPartialUpdateExecute(r)
}

/*
ExtrasConfigContextsBulkPartialUpdate Method for ExtrasConfigContextsBulkPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiExtrasConfigContextsBulkPartialUpdateRequest
*/
func (a *ExtrasApiService) ExtrasConfigContextsBulkPartialUpdate(ctx context.Context) ApiExtrasConfigContextsBulkPartialUpdateRequest {
	return ApiExtrasConfigContextsBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ConfigContext
func (a *ExtrasApiService) ExtrasConfigContextsBulkPartialUpdateExecute(r ApiExtrasConfigContextsBulkPartialUpdateRequest) (*ConfigContext, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConfigContext
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExtrasApiService.ExtrasConfigContextsBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extras/config-contexts/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiExtrasConfigContextsBulkUpdateRequest struct {
	ctx context.Context
	ApiService *ExtrasApiService
	data *WritableConfigContext
}

func (r ApiExtrasConfigContextsBulkUpdateRequest) Data(data WritableConfigContext) ApiExtrasConfigContextsBulkUpdateRequest {
	r.data = &data
	return r
}

func (r ApiExtrasConfigContextsBulkUpdateRequest) Execute() (*ConfigContext, *http.Response, error) {
	return r.ApiService.ExtrasConfigContextsBulkUpdateExecute(r)
}

/*
ExtrasConfigContextsBulkUpdate Method for ExtrasConfigContextsBulkUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiExtrasConfigContextsBulkUpdateRequest
*/
func (a *ExtrasApiService) ExtrasConfigContextsBulkUpdate(ctx context.Context) ApiExtrasConfigContextsBulkUpdateRequest {
	return ApiExtrasConfigContextsBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ConfigContext
func (a *ExtrasApiService) ExtrasConfigContextsBulkUpdateExecute(r ApiExtrasConfigContextsBulkUpdateRequest) (*ConfigContext, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConfigContext
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExtrasApiService.ExtrasConfigContextsBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extras/config-contexts/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiExtrasConfigContextsCreateRequest struct {
	ctx context.Context
	ApiService *ExtrasApiService
	data *WritableConfigContext
}

func (r ApiExtrasConfigContextsCreateRequest) Data(data WritableConfigContext) ApiExtrasConfigContextsCreateRequest {
	r.data = &data
	return r
}

func (r ApiExtrasConfigContextsCreateRequest) Execute() (*ConfigContext, *http.Response, error) {
	return r.ApiService.ExtrasConfigContextsCreateExecute(r)
}

/*
ExtrasConfigContextsCreate Method for ExtrasConfigContextsCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiExtrasConfigContextsCreateRequest
*/
func (a *ExtrasApiService) ExtrasConfigContextsCreate(ctx context.Context) ApiExtrasConfigContextsCreateRequest {
	return ApiExtrasConfigContextsCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ConfigContext
func (a *ExtrasApiService) ExtrasConfigContextsCreateExecute(r ApiExtrasConfigContextsCreateRequest) (*ConfigContext, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConfigContext
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExtrasApiService.ExtrasConfigContextsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extras/config-contexts/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiExtrasConfigContextsDeleteRequest struct {
	ctx context.Context
	ApiService *ExtrasApiService
	id int32
}

func (r ApiExtrasConfigContextsDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.ExtrasConfigContextsDeleteExecute(r)
}

/*
ExtrasConfigContextsDelete Method for ExtrasConfigContextsDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this config context.
 @return ApiExtrasConfigContextsDeleteRequest
*/
func (a *ExtrasApiService) ExtrasConfigContextsDelete(ctx context.Context, id int32) ApiExtrasConfigContextsDeleteRequest {
	return ApiExtrasConfigContextsDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *ExtrasApiService) ExtrasConfigContextsDeleteExecute(r ApiExtrasConfigContextsDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExtrasApiService.ExtrasConfigContextsDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extras/config-contexts/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiExtrasConfigContextsListRequest struct {
	ctx context.Context
	ApiService *ExtrasApiService
	id *string
	name *string
	isActive *string
	created *string
	createdGte *string
	createdLte *string
	lastUpdated *string
	lastUpdatedGte *string
	lastUpdatedLte *string
	q *string
	regionId *string
	region *string
	siteGroup *string
	siteGroupId *string
	siteId *string
	site *string
	deviceTypeId *string
	roleId *string
	role *string
	platformId *string
	platform *string
	clusterGroupId *string
	clusterGroup *string
	clusterId *string
	tenantGroupId *string
	tenantGroup *string
	tenantId *string
	tenant *string
	tag *string
	idN *string
	idLte *string
	idLt *string
	idGte *string
	idGt *string
	nameN *string
	nameIc *string
	nameNic *string
	nameIew *string
	nameNiew *string
	nameIsw *string
	nameNisw *string
	nameIe *string
	nameNie *string
	nameEmpty *string
	regionIdN *string
	regionN *string
	siteGroupN *string
	siteGroupIdN *string
	siteIdN *string
	siteN *string
	deviceTypeIdN *string
	roleIdN *string
	roleN *string
	platformIdN *string
	platformN *string
	clusterGroupIdN *string
	clusterGroupN *string
	clusterIdN *string
	tenantGroupIdN *string
	tenantGroupN *string
	tenantIdN *string
	tenantN *string
	tagN *string
	limit *int32
	offset *int32
}

func (r ApiExtrasConfigContextsListRequest) Id(id string) ApiExtrasConfigContextsListRequest {
	r.id = &id
	return r
}

func (r ApiExtrasConfigContextsListRequest) Name(name string) ApiExtrasConfigContextsListRequest {
	r.name = &name
	return r
}

func (r ApiExtrasConfigContextsListRequest) IsActive(isActive string) ApiExtrasConfigContextsListRequest {
	r.isActive = &isActive
	return r
}

func (r ApiExtrasConfigContextsListRequest) Created(created string) ApiExtrasConfigContextsListRequest {
	r.created = &created
	return r
}

func (r ApiExtrasConfigContextsListRequest) CreatedGte(createdGte string) ApiExtrasConfigContextsListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiExtrasConfigContextsListRequest) CreatedLte(createdLte string) ApiExtrasConfigContextsListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiExtrasConfigContextsListRequest) LastUpdated(lastUpdated string) ApiExtrasConfigContextsListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiExtrasConfigContextsListRequest) LastUpdatedGte(lastUpdatedGte string) ApiExtrasConfigContextsListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiExtrasConfigContextsListRequest) LastUpdatedLte(lastUpdatedLte string) ApiExtrasConfigContextsListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiExtrasConfigContextsListRequest) Q(q string) ApiExtrasConfigContextsListRequest {
	r.q = &q
	return r
}

func (r ApiExtrasConfigContextsListRequest) RegionId(regionId string) ApiExtrasConfigContextsListRequest {
	r.regionId = &regionId
	return r
}

func (r ApiExtrasConfigContextsListRequest) Region(region string) ApiExtrasConfigContextsListRequest {
	r.region = &region
	return r
}

func (r ApiExtrasConfigContextsListRequest) SiteGroup(siteGroup string) ApiExtrasConfigContextsListRequest {
	r.siteGroup = &siteGroup
	return r
}

func (r ApiExtrasConfigContextsListRequest) SiteGroupId(siteGroupId string) ApiExtrasConfigContextsListRequest {
	r.siteGroupId = &siteGroupId
	return r
}

func (r ApiExtrasConfigContextsListRequest) SiteId(siteId string) ApiExtrasConfigContextsListRequest {
	r.siteId = &siteId
	return r
}

func (r ApiExtrasConfigContextsListRequest) Site(site string) ApiExtrasConfigContextsListRequest {
	r.site = &site
	return r
}

func (r ApiExtrasConfigContextsListRequest) DeviceTypeId(deviceTypeId string) ApiExtrasConfigContextsListRequest {
	r.deviceTypeId = &deviceTypeId
	return r
}

func (r ApiExtrasConfigContextsListRequest) RoleId(roleId string) ApiExtrasConfigContextsListRequest {
	r.roleId = &roleId
	return r
}

func (r ApiExtrasConfigContextsListRequest) Role(role string) ApiExtrasConfigContextsListRequest {
	r.role = &role
	return r
}

func (r ApiExtrasConfigContextsListRequest) PlatformId(platformId string) ApiExtrasConfigContextsListRequest {
	r.platformId = &platformId
	return r
}

func (r ApiExtrasConfigContextsListRequest) Platform(platform string) ApiExtrasConfigContextsListRequest {
	r.platform = &platform
	return r
}

func (r ApiExtrasConfigContextsListRequest) ClusterGroupId(clusterGroupId string) ApiExtrasConfigContextsListRequest {
	r.clusterGroupId = &clusterGroupId
	return r
}

func (r ApiExtrasConfigContextsListRequest) ClusterGroup(clusterGroup string) ApiExtrasConfigContextsListRequest {
	r.clusterGroup = &clusterGroup
	return r
}

func (r ApiExtrasConfigContextsListRequest) ClusterId(clusterId string) ApiExtrasConfigContextsListRequest {
	r.clusterId = &clusterId
	return r
}

func (r ApiExtrasConfigContextsListRequest) TenantGroupId(tenantGroupId string) ApiExtrasConfigContextsListRequest {
	r.tenantGroupId = &tenantGroupId
	return r
}

func (r ApiExtrasConfigContextsListRequest) TenantGroup(tenantGroup string) ApiExtrasConfigContextsListRequest {
	r.tenantGroup = &tenantGroup
	return r
}

func (r ApiExtrasConfigContextsListRequest) TenantId(tenantId string) ApiExtrasConfigContextsListRequest {
	r.tenantId = &tenantId
	return r
}

func (r ApiExtrasConfigContextsListRequest) Tenant(tenant string) ApiExtrasConfigContextsListRequest {
	r.tenant = &tenant
	return r
}

func (r ApiExtrasConfigContextsListRequest) Tag(tag string) ApiExtrasConfigContextsListRequest {
	r.tag = &tag
	return r
}

func (r ApiExtrasConfigContextsListRequest) IdN(idN string) ApiExtrasConfigContextsListRequest {
	r.idN = &idN
	return r
}

func (r ApiExtrasConfigContextsListRequest) IdLte(idLte string) ApiExtrasConfigContextsListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiExtrasConfigContextsListRequest) IdLt(idLt string) ApiExtrasConfigContextsListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiExtrasConfigContextsListRequest) IdGte(idGte string) ApiExtrasConfigContextsListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiExtrasConfigContextsListRequest) IdGt(idGt string) ApiExtrasConfigContextsListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiExtrasConfigContextsListRequest) NameN(nameN string) ApiExtrasConfigContextsListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiExtrasConfigContextsListRequest) NameIc(nameIc string) ApiExtrasConfigContextsListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiExtrasConfigContextsListRequest) NameNic(nameNic string) ApiExtrasConfigContextsListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiExtrasConfigContextsListRequest) NameIew(nameIew string) ApiExtrasConfigContextsListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiExtrasConfigContextsListRequest) NameNiew(nameNiew string) ApiExtrasConfigContextsListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiExtrasConfigContextsListRequest) NameIsw(nameIsw string) ApiExtrasConfigContextsListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiExtrasConfigContextsListRequest) NameNisw(nameNisw string) ApiExtrasConfigContextsListRequest {
	r.nameNisw = &nameNisw
	return r
}

func (r ApiExtrasConfigContextsListRequest) NameIe(nameIe string) ApiExtrasConfigContextsListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiExtrasConfigContextsListRequest) NameNie(nameNie string) ApiExtrasConfigContextsListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiExtrasConfigContextsListRequest) NameEmpty(nameEmpty string) ApiExtrasConfigContextsListRequest {
	r.nameEmpty = &nameEmpty
	return r
}

func (r ApiExtrasConfigContextsListRequest) RegionIdN(regionIdN string) ApiExtrasConfigContextsListRequest {
	r.regionIdN = &regionIdN
	return r
}

func (r ApiExtrasConfigContextsListRequest) RegionN(regionN string) ApiExtrasConfigContextsListRequest {
	r.regionN = &regionN
	return r
}

func (r ApiExtrasConfigContextsListRequest) SiteGroupN(siteGroupN string) ApiExtrasConfigContextsListRequest {
	r.siteGroupN = &siteGroupN
	return r
}

func (r ApiExtrasConfigContextsListRequest) SiteGroupIdN(siteGroupIdN string) ApiExtrasConfigContextsListRequest {
	r.siteGroupIdN = &siteGroupIdN
	return r
}

func (r ApiExtrasConfigContextsListRequest) SiteIdN(siteIdN string) ApiExtrasConfigContextsListRequest {
	r.siteIdN = &siteIdN
	return r
}

func (r ApiExtrasConfigContextsListRequest) SiteN(siteN string) ApiExtrasConfigContextsListRequest {
	r.siteN = &siteN
	return r
}

func (r ApiExtrasConfigContextsListRequest) DeviceTypeIdN(deviceTypeIdN string) ApiExtrasConfigContextsListRequest {
	r.deviceTypeIdN = &deviceTypeIdN
	return r
}

func (r ApiExtrasConfigContextsListRequest) RoleIdN(roleIdN string) ApiExtrasConfigContextsListRequest {
	r.roleIdN = &roleIdN
	return r
}

func (r ApiExtrasConfigContextsListRequest) RoleN(roleN string) ApiExtrasConfigContextsListRequest {
	r.roleN = &roleN
	return r
}

func (r ApiExtrasConfigContextsListRequest) PlatformIdN(platformIdN string) ApiExtrasConfigContextsListRequest {
	r.platformIdN = &platformIdN
	return r
}

func (r ApiExtrasConfigContextsListRequest) PlatformN(platformN string) ApiExtrasConfigContextsListRequest {
	r.platformN = &platformN
	return r
}

func (r ApiExtrasConfigContextsListRequest) ClusterGroupIdN(clusterGroupIdN string) ApiExtrasConfigContextsListRequest {
	r.clusterGroupIdN = &clusterGroupIdN
	return r
}

func (r ApiExtrasConfigContextsListRequest) ClusterGroupN(clusterGroupN string) ApiExtrasConfigContextsListRequest {
	r.clusterGroupN = &clusterGroupN
	return r
}

func (r ApiExtrasConfigContextsListRequest) ClusterIdN(clusterIdN string) ApiExtrasConfigContextsListRequest {
	r.clusterIdN = &clusterIdN
	return r
}

func (r ApiExtrasConfigContextsListRequest) TenantGroupIdN(tenantGroupIdN string) ApiExtrasConfigContextsListRequest {
	r.tenantGroupIdN = &tenantGroupIdN
	return r
}

func (r ApiExtrasConfigContextsListRequest) TenantGroupN(tenantGroupN string) ApiExtrasConfigContextsListRequest {
	r.tenantGroupN = &tenantGroupN
	return r
}

func (r ApiExtrasConfigContextsListRequest) TenantIdN(tenantIdN string) ApiExtrasConfigContextsListRequest {
	r.tenantIdN = &tenantIdN
	return r
}

func (r ApiExtrasConfigContextsListRequest) TenantN(tenantN string) ApiExtrasConfigContextsListRequest {
	r.tenantN = &tenantN
	return r
}

func (r ApiExtrasConfigContextsListRequest) TagN(tagN string) ApiExtrasConfigContextsListRequest {
	r.tagN = &tagN
	return r
}

// Number of results to return per page.
func (r ApiExtrasConfigContextsListRequest) Limit(limit int32) ApiExtrasConfigContextsListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiExtrasConfigContextsListRequest) Offset(offset int32) ApiExtrasConfigContextsListRequest {
	r.offset = &offset
	return r
}

func (r ApiExtrasConfigContextsListRequest) Execute() (*ExtrasConfigContextsList200Response, *http.Response, error) {
	return r.ApiService.ExtrasConfigContextsListExecute(r)
}

/*
ExtrasConfigContextsList Method for ExtrasConfigContextsList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiExtrasConfigContextsListRequest
*/
func (a *ExtrasApiService) ExtrasConfigContextsList(ctx context.Context) ApiExtrasConfigContextsListRequest {
	return ApiExtrasConfigContextsListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ExtrasConfigContextsList200Response
func (a *ExtrasApiService) ExtrasConfigContextsListExecute(r ApiExtrasConfigContextsListRequest) (*ExtrasConfigContextsList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ExtrasConfigContextsList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExtrasApiService.ExtrasConfigContextsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extras/config-contexts/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.isActive != nil {
		localVarQueryParams.Add("is_active", parameterToString(*r.isActive, ""))
	}
	if r.created != nil {
		localVarQueryParams.Add("created", parameterToString(*r.created, ""))
	}
	if r.createdGte != nil {
		localVarQueryParams.Add("created__gte", parameterToString(*r.createdGte, ""))
	}
	if r.createdLte != nil {
		localVarQueryParams.Add("created__lte", parameterToString(*r.createdLte, ""))
	}
	if r.lastUpdated != nil {
		localVarQueryParams.Add("last_updated", parameterToString(*r.lastUpdated, ""))
	}
	if r.lastUpdatedGte != nil {
		localVarQueryParams.Add("last_updated__gte", parameterToString(*r.lastUpdatedGte, ""))
	}
	if r.lastUpdatedLte != nil {
		localVarQueryParams.Add("last_updated__lte", parameterToString(*r.lastUpdatedLte, ""))
	}
	if r.q != nil {
		localVarQueryParams.Add("q", parameterToString(*r.q, ""))
	}
	if r.regionId != nil {
		localVarQueryParams.Add("region_id", parameterToString(*r.regionId, ""))
	}
	if r.region != nil {
		localVarQueryParams.Add("region", parameterToString(*r.region, ""))
	}
	if r.siteGroup != nil {
		localVarQueryParams.Add("site_group", parameterToString(*r.siteGroup, ""))
	}
	if r.siteGroupId != nil {
		localVarQueryParams.Add("site_group_id", parameterToString(*r.siteGroupId, ""))
	}
	if r.siteId != nil {
		localVarQueryParams.Add("site_id", parameterToString(*r.siteId, ""))
	}
	if r.site != nil {
		localVarQueryParams.Add("site", parameterToString(*r.site, ""))
	}
	if r.deviceTypeId != nil {
		localVarQueryParams.Add("device_type_id", parameterToString(*r.deviceTypeId, ""))
	}
	if r.roleId != nil {
		localVarQueryParams.Add("role_id", parameterToString(*r.roleId, ""))
	}
	if r.role != nil {
		localVarQueryParams.Add("role", parameterToString(*r.role, ""))
	}
	if r.platformId != nil {
		localVarQueryParams.Add("platform_id", parameterToString(*r.platformId, ""))
	}
	if r.platform != nil {
		localVarQueryParams.Add("platform", parameterToString(*r.platform, ""))
	}
	if r.clusterGroupId != nil {
		localVarQueryParams.Add("cluster_group_id", parameterToString(*r.clusterGroupId, ""))
	}
	if r.clusterGroup != nil {
		localVarQueryParams.Add("cluster_group", parameterToString(*r.clusterGroup, ""))
	}
	if r.clusterId != nil {
		localVarQueryParams.Add("cluster_id", parameterToString(*r.clusterId, ""))
	}
	if r.tenantGroupId != nil {
		localVarQueryParams.Add("tenant_group_id", parameterToString(*r.tenantGroupId, ""))
	}
	if r.tenantGroup != nil {
		localVarQueryParams.Add("tenant_group", parameterToString(*r.tenantGroup, ""))
	}
	if r.tenantId != nil {
		localVarQueryParams.Add("tenant_id", parameterToString(*r.tenantId, ""))
	}
	if r.tenant != nil {
		localVarQueryParams.Add("tenant", parameterToString(*r.tenant, ""))
	}
	if r.tag != nil {
		localVarQueryParams.Add("tag", parameterToString(*r.tag, ""))
	}
	if r.idN != nil {
		localVarQueryParams.Add("id__n", parameterToString(*r.idN, ""))
	}
	if r.idLte != nil {
		localVarQueryParams.Add("id__lte", parameterToString(*r.idLte, ""))
	}
	if r.idLt != nil {
		localVarQueryParams.Add("id__lt", parameterToString(*r.idLt, ""))
	}
	if r.idGte != nil {
		localVarQueryParams.Add("id__gte", parameterToString(*r.idGte, ""))
	}
	if r.idGt != nil {
		localVarQueryParams.Add("id__gt", parameterToString(*r.idGt, ""))
	}
	if r.nameN != nil {
		localVarQueryParams.Add("name__n", parameterToString(*r.nameN, ""))
	}
	if r.nameIc != nil {
		localVarQueryParams.Add("name__ic", parameterToString(*r.nameIc, ""))
	}
	if r.nameNic != nil {
		localVarQueryParams.Add("name__nic", parameterToString(*r.nameNic, ""))
	}
	if r.nameIew != nil {
		localVarQueryParams.Add("name__iew", parameterToString(*r.nameIew, ""))
	}
	if r.nameNiew != nil {
		localVarQueryParams.Add("name__niew", parameterToString(*r.nameNiew, ""))
	}
	if r.nameIsw != nil {
		localVarQueryParams.Add("name__isw", parameterToString(*r.nameIsw, ""))
	}
	if r.nameNisw != nil {
		localVarQueryParams.Add("name__nisw", parameterToString(*r.nameNisw, ""))
	}
	if r.nameIe != nil {
		localVarQueryParams.Add("name__ie", parameterToString(*r.nameIe, ""))
	}
	if r.nameNie != nil {
		localVarQueryParams.Add("name__nie", parameterToString(*r.nameNie, ""))
	}
	if r.nameEmpty != nil {
		localVarQueryParams.Add("name__empty", parameterToString(*r.nameEmpty, ""))
	}
	if r.regionIdN != nil {
		localVarQueryParams.Add("region_id__n", parameterToString(*r.regionIdN, ""))
	}
	if r.regionN != nil {
		localVarQueryParams.Add("region__n", parameterToString(*r.regionN, ""))
	}
	if r.siteGroupN != nil {
		localVarQueryParams.Add("site_group__n", parameterToString(*r.siteGroupN, ""))
	}
	if r.siteGroupIdN != nil {
		localVarQueryParams.Add("site_group_id__n", parameterToString(*r.siteGroupIdN, ""))
	}
	if r.siteIdN != nil {
		localVarQueryParams.Add("site_id__n", parameterToString(*r.siteIdN, ""))
	}
	if r.siteN != nil {
		localVarQueryParams.Add("site__n", parameterToString(*r.siteN, ""))
	}
	if r.deviceTypeIdN != nil {
		localVarQueryParams.Add("device_type_id__n", parameterToString(*r.deviceTypeIdN, ""))
	}
	if r.roleIdN != nil {
		localVarQueryParams.Add("role_id__n", parameterToString(*r.roleIdN, ""))
	}
	if r.roleN != nil {
		localVarQueryParams.Add("role__n", parameterToString(*r.roleN, ""))
	}
	if r.platformIdN != nil {
		localVarQueryParams.Add("platform_id__n", parameterToString(*r.platformIdN, ""))
	}
	if r.platformN != nil {
		localVarQueryParams.Add("platform__n", parameterToString(*r.platformN, ""))
	}
	if r.clusterGroupIdN != nil {
		localVarQueryParams.Add("cluster_group_id__n", parameterToString(*r.clusterGroupIdN, ""))
	}
	if r.clusterGroupN != nil {
		localVarQueryParams.Add("cluster_group__n", parameterToString(*r.clusterGroupN, ""))
	}
	if r.clusterIdN != nil {
		localVarQueryParams.Add("cluster_id__n", parameterToString(*r.clusterIdN, ""))
	}
	if r.tenantGroupIdN != nil {
		localVarQueryParams.Add("tenant_group_id__n", parameterToString(*r.tenantGroupIdN, ""))
	}
	if r.tenantGroupN != nil {
		localVarQueryParams.Add("tenant_group__n", parameterToString(*r.tenantGroupN, ""))
	}
	if r.tenantIdN != nil {
		localVarQueryParams.Add("tenant_id__n", parameterToString(*r.tenantIdN, ""))
	}
	if r.tenantN != nil {
		localVarQueryParams.Add("tenant__n", parameterToString(*r.tenantN, ""))
	}
	if r.tagN != nil {
		localVarQueryParams.Add("tag__n", parameterToString(*r.tagN, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiExtrasConfigContextsPartialUpdateRequest struct {
	ctx context.Context
	ApiService *ExtrasApiService
	id int32
	data *WritableConfigContext
}

func (r ApiExtrasConfigContextsPartialUpdateRequest) Data(data WritableConfigContext) ApiExtrasConfigContextsPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiExtrasConfigContextsPartialUpdateRequest) Execute() (*ConfigContext, *http.Response, error) {
	return r.ApiService.ExtrasConfigContextsPartialUpdateExecute(r)
}

/*
ExtrasConfigContextsPartialUpdate Method for ExtrasConfigContextsPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this config context.
 @return ApiExtrasConfigContextsPartialUpdateRequest
*/
func (a *ExtrasApiService) ExtrasConfigContextsPartialUpdate(ctx context.Context, id int32) ApiExtrasConfigContextsPartialUpdateRequest {
	return ApiExtrasConfigContextsPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ConfigContext
func (a *ExtrasApiService) ExtrasConfigContextsPartialUpdateExecute(r ApiExtrasConfigContextsPartialUpdateRequest) (*ConfigContext, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConfigContext
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExtrasApiService.ExtrasConfigContextsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extras/config-contexts/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiExtrasConfigContextsReadRequest struct {
	ctx context.Context
	ApiService *ExtrasApiService
	id int32
}

func (r ApiExtrasConfigContextsReadRequest) Execute() (*ConfigContext, *http.Response, error) {
	return r.ApiService.ExtrasConfigContextsReadExecute(r)
}

/*
ExtrasConfigContextsRead Method for ExtrasConfigContextsRead

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this config context.
 @return ApiExtrasConfigContextsReadRequest
*/
func (a *ExtrasApiService) ExtrasConfigContextsRead(ctx context.Context, id int32) ApiExtrasConfigContextsReadRequest {
	return ApiExtrasConfigContextsReadRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ConfigContext
func (a *ExtrasApiService) ExtrasConfigContextsReadExecute(r ApiExtrasConfigContextsReadRequest) (*ConfigContext, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConfigContext
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExtrasApiService.ExtrasConfigContextsRead")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extras/config-contexts/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiExtrasConfigContextsUpdateRequest struct {
	ctx context.Context
	ApiService *ExtrasApiService
	id int32
	data *WritableConfigContext
}

func (r ApiExtrasConfigContextsUpdateRequest) Data(data WritableConfigContext) ApiExtrasConfigContextsUpdateRequest {
	r.data = &data
	return r
}

func (r ApiExtrasConfigContextsUpdateRequest) Execute() (*ConfigContext, *http.Response, error) {
	return r.ApiService.ExtrasConfigContextsUpdateExecute(r)
}

/*
ExtrasConfigContextsUpdate Method for ExtrasConfigContextsUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this config context.
 @return ApiExtrasConfigContextsUpdateRequest
*/
func (a *ExtrasApiService) ExtrasConfigContextsUpdate(ctx context.Context, id int32) ApiExtrasConfigContextsUpdateRequest {
	return ApiExtrasConfigContextsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ConfigContext
func (a *ExtrasApiService) ExtrasConfigContextsUpdateExecute(r ApiExtrasConfigContextsUpdateRequest) (*ConfigContext, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConfigContext
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExtrasApiService.ExtrasConfigContextsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extras/config-contexts/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiExtrasContentTypesListRequest struct {
	ctx context.Context
	ApiService *ExtrasApiService
	id *float32
	appLabel *string
	model *string
	limit *int32
	offset *int32
}

func (r ApiExtrasContentTypesListRequest) Id(id float32) ApiExtrasContentTypesListRequest {
	r.id = &id
	return r
}

func (r ApiExtrasContentTypesListRequest) AppLabel(appLabel string) ApiExtrasContentTypesListRequest {
	r.appLabel = &appLabel
	return r
}

func (r ApiExtrasContentTypesListRequest) Model(model string) ApiExtrasContentTypesListRequest {
	r.model = &model
	return r
}

// Number of results to return per page.
func (r ApiExtrasContentTypesListRequest) Limit(limit int32) ApiExtrasContentTypesListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiExtrasContentTypesListRequest) Offset(offset int32) ApiExtrasContentTypesListRequest {
	r.offset = &offset
	return r
}

func (r ApiExtrasContentTypesListRequest) Execute() (*ExtrasContentTypesList200Response, *http.Response, error) {
	return r.ApiService.ExtrasContentTypesListExecute(r)
}

/*
ExtrasContentTypesList Method for ExtrasContentTypesList

Read-only list of ContentTypes. Limit results to ContentTypes pertinent to NetBox objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiExtrasContentTypesListRequest
*/
func (a *ExtrasApiService) ExtrasContentTypesList(ctx context.Context) ApiExtrasContentTypesListRequest {
	return ApiExtrasContentTypesListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ExtrasContentTypesList200Response
func (a *ExtrasApiService) ExtrasContentTypesListExecute(r ApiExtrasContentTypesListRequest) (*ExtrasContentTypesList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ExtrasContentTypesList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExtrasApiService.ExtrasContentTypesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extras/content-types/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.appLabel != nil {
		localVarQueryParams.Add("app_label", parameterToString(*r.appLabel, ""))
	}
	if r.model != nil {
		localVarQueryParams.Add("model", parameterToString(*r.model, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiExtrasContentTypesReadRequest struct {
	ctx context.Context
	ApiService *ExtrasApiService
	id int32
}

func (r ApiExtrasContentTypesReadRequest) Execute() (*ContentType, *http.Response, error) {
	return r.ApiService.ExtrasContentTypesReadExecute(r)
}

/*
ExtrasContentTypesRead Method for ExtrasContentTypesRead

Read-only list of ContentTypes. Limit results to ContentTypes pertinent to NetBox objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this content type.
 @return ApiExtrasContentTypesReadRequest
*/
func (a *ExtrasApiService) ExtrasContentTypesRead(ctx context.Context, id int32) ApiExtrasContentTypesReadRequest {
	return ApiExtrasContentTypesReadRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ContentType
func (a *ExtrasApiService) ExtrasContentTypesReadExecute(r ApiExtrasContentTypesReadRequest) (*ContentType, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ContentType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExtrasApiService.ExtrasContentTypesRead")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extras/content-types/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiExtrasCustomFieldsBulkDeleteRequest struct {
	ctx context.Context
	ApiService *ExtrasApiService
}

func (r ApiExtrasCustomFieldsBulkDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.ExtrasCustomFieldsBulkDeleteExecute(r)
}

/*
ExtrasCustomFieldsBulkDelete Method for ExtrasCustomFieldsBulkDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiExtrasCustomFieldsBulkDeleteRequest
*/
func (a *ExtrasApiService) ExtrasCustomFieldsBulkDelete(ctx context.Context) ApiExtrasCustomFieldsBulkDeleteRequest {
	return ApiExtrasCustomFieldsBulkDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ExtrasApiService) ExtrasCustomFieldsBulkDeleteExecute(r ApiExtrasCustomFieldsBulkDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExtrasApiService.ExtrasCustomFieldsBulkDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extras/custom-fields/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiExtrasCustomFieldsBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *ExtrasApiService
	data *WritableCustomField
}

func (r ApiExtrasCustomFieldsBulkPartialUpdateRequest) Data(data WritableCustomField) ApiExtrasCustomFieldsBulkPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiExtrasCustomFieldsBulkPartialUpdateRequest) Execute() (*CustomField, *http.Response, error) {
	return r.ApiService.ExtrasCustomFieldsBulkPartialUpdateExecute(r)
}

/*
ExtrasCustomFieldsBulkPartialUpdate Method for ExtrasCustomFieldsBulkPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiExtrasCustomFieldsBulkPartialUpdateRequest
*/
func (a *ExtrasApiService) ExtrasCustomFieldsBulkPartialUpdate(ctx context.Context) ApiExtrasCustomFieldsBulkPartialUpdateRequest {
	return ApiExtrasCustomFieldsBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CustomField
func (a *ExtrasApiService) ExtrasCustomFieldsBulkPartialUpdateExecute(r ApiExtrasCustomFieldsBulkPartialUpdateRequest) (*CustomField, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CustomField
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExtrasApiService.ExtrasCustomFieldsBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extras/custom-fields/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiExtrasCustomFieldsBulkUpdateRequest struct {
	ctx context.Context
	ApiService *ExtrasApiService
	data *WritableCustomField
}

func (r ApiExtrasCustomFieldsBulkUpdateRequest) Data(data WritableCustomField) ApiExtrasCustomFieldsBulkUpdateRequest {
	r.data = &data
	return r
}

func (r ApiExtrasCustomFieldsBulkUpdateRequest) Execute() (*CustomField, *http.Response, error) {
	return r.ApiService.ExtrasCustomFieldsBulkUpdateExecute(r)
}

/*
ExtrasCustomFieldsBulkUpdate Method for ExtrasCustomFieldsBulkUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiExtrasCustomFieldsBulkUpdateRequest
*/
func (a *ExtrasApiService) ExtrasCustomFieldsBulkUpdate(ctx context.Context) ApiExtrasCustomFieldsBulkUpdateRequest {
	return ApiExtrasCustomFieldsBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CustomField
func (a *ExtrasApiService) ExtrasCustomFieldsBulkUpdateExecute(r ApiExtrasCustomFieldsBulkUpdateRequest) (*CustomField, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CustomField
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExtrasApiService.ExtrasCustomFieldsBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extras/custom-fields/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiExtrasCustomFieldsCreateRequest struct {
	ctx context.Context
	ApiService *ExtrasApiService
	data *WritableCustomField
}

func (r ApiExtrasCustomFieldsCreateRequest) Data(data WritableCustomField) ApiExtrasCustomFieldsCreateRequest {
	r.data = &data
	return r
}

func (r ApiExtrasCustomFieldsCreateRequest) Execute() (*CustomField, *http.Response, error) {
	return r.ApiService.ExtrasCustomFieldsCreateExecute(r)
}

/*
ExtrasCustomFieldsCreate Method for ExtrasCustomFieldsCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiExtrasCustomFieldsCreateRequest
*/
func (a *ExtrasApiService) ExtrasCustomFieldsCreate(ctx context.Context) ApiExtrasCustomFieldsCreateRequest {
	return ApiExtrasCustomFieldsCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CustomField
func (a *ExtrasApiService) ExtrasCustomFieldsCreateExecute(r ApiExtrasCustomFieldsCreateRequest) (*CustomField, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CustomField
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExtrasApiService.ExtrasCustomFieldsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extras/custom-fields/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiExtrasCustomFieldsDeleteRequest struct {
	ctx context.Context
	ApiService *ExtrasApiService
	id int32
}

func (r ApiExtrasCustomFieldsDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.ExtrasCustomFieldsDeleteExecute(r)
}

/*
ExtrasCustomFieldsDelete Method for ExtrasCustomFieldsDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this custom field.
 @return ApiExtrasCustomFieldsDeleteRequest
*/
func (a *ExtrasApiService) ExtrasCustomFieldsDelete(ctx context.Context, id int32) ApiExtrasCustomFieldsDeleteRequest {
	return ApiExtrasCustomFieldsDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *ExtrasApiService) ExtrasCustomFieldsDeleteExecute(r ApiExtrasCustomFieldsDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExtrasApiService.ExtrasCustomFieldsDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extras/custom-fields/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiExtrasCustomFieldsListRequest struct {
	ctx context.Context
	ApiService *ExtrasApiService
	id *float32
	contentTypes *string
	name *string
	required *string
	filterLogic *string
	weight *float32
	limit *int32
	offset *int32
}

func (r ApiExtrasCustomFieldsListRequest) Id(id float32) ApiExtrasCustomFieldsListRequest {
	r.id = &id
	return r
}

func (r ApiExtrasCustomFieldsListRequest) ContentTypes(contentTypes string) ApiExtrasCustomFieldsListRequest {
	r.contentTypes = &contentTypes
	return r
}

func (r ApiExtrasCustomFieldsListRequest) Name(name string) ApiExtrasCustomFieldsListRequest {
	r.name = &name
	return r
}

func (r ApiExtrasCustomFieldsListRequest) Required(required string) ApiExtrasCustomFieldsListRequest {
	r.required = &required
	return r
}

func (r ApiExtrasCustomFieldsListRequest) FilterLogic(filterLogic string) ApiExtrasCustomFieldsListRequest {
	r.filterLogic = &filterLogic
	return r
}

func (r ApiExtrasCustomFieldsListRequest) Weight(weight float32) ApiExtrasCustomFieldsListRequest {
	r.weight = &weight
	return r
}

// Number of results to return per page.
func (r ApiExtrasCustomFieldsListRequest) Limit(limit int32) ApiExtrasCustomFieldsListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiExtrasCustomFieldsListRequest) Offset(offset int32) ApiExtrasCustomFieldsListRequest {
	r.offset = &offset
	return r
}

func (r ApiExtrasCustomFieldsListRequest) Execute() (*ExtrasCustomFieldsList200Response, *http.Response, error) {
	return r.ApiService.ExtrasCustomFieldsListExecute(r)
}

/*
ExtrasCustomFieldsList Method for ExtrasCustomFieldsList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiExtrasCustomFieldsListRequest
*/
func (a *ExtrasApiService) ExtrasCustomFieldsList(ctx context.Context) ApiExtrasCustomFieldsListRequest {
	return ApiExtrasCustomFieldsListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ExtrasCustomFieldsList200Response
func (a *ExtrasApiService) ExtrasCustomFieldsListExecute(r ApiExtrasCustomFieldsListRequest) (*ExtrasCustomFieldsList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ExtrasCustomFieldsList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExtrasApiService.ExtrasCustomFieldsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extras/custom-fields/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.contentTypes != nil {
		localVarQueryParams.Add("content_types", parameterToString(*r.contentTypes, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.required != nil {
		localVarQueryParams.Add("required", parameterToString(*r.required, ""))
	}
	if r.filterLogic != nil {
		localVarQueryParams.Add("filter_logic", parameterToString(*r.filterLogic, ""))
	}
	if r.weight != nil {
		localVarQueryParams.Add("weight", parameterToString(*r.weight, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiExtrasCustomFieldsPartialUpdateRequest struct {
	ctx context.Context
	ApiService *ExtrasApiService
	id int32
	data *WritableCustomField
}

func (r ApiExtrasCustomFieldsPartialUpdateRequest) Data(data WritableCustomField) ApiExtrasCustomFieldsPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiExtrasCustomFieldsPartialUpdateRequest) Execute() (*CustomField, *http.Response, error) {
	return r.ApiService.ExtrasCustomFieldsPartialUpdateExecute(r)
}

/*
ExtrasCustomFieldsPartialUpdate Method for ExtrasCustomFieldsPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this custom field.
 @return ApiExtrasCustomFieldsPartialUpdateRequest
*/
func (a *ExtrasApiService) ExtrasCustomFieldsPartialUpdate(ctx context.Context, id int32) ApiExtrasCustomFieldsPartialUpdateRequest {
	return ApiExtrasCustomFieldsPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return CustomField
func (a *ExtrasApiService) ExtrasCustomFieldsPartialUpdateExecute(r ApiExtrasCustomFieldsPartialUpdateRequest) (*CustomField, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CustomField
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExtrasApiService.ExtrasCustomFieldsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extras/custom-fields/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiExtrasCustomFieldsReadRequest struct {
	ctx context.Context
	ApiService *ExtrasApiService
	id int32
}

func (r ApiExtrasCustomFieldsReadRequest) Execute() (*CustomField, *http.Response, error) {
	return r.ApiService.ExtrasCustomFieldsReadExecute(r)
}

/*
ExtrasCustomFieldsRead Method for ExtrasCustomFieldsRead

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this custom field.
 @return ApiExtrasCustomFieldsReadRequest
*/
func (a *ExtrasApiService) ExtrasCustomFieldsRead(ctx context.Context, id int32) ApiExtrasCustomFieldsReadRequest {
	return ApiExtrasCustomFieldsReadRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return CustomField
func (a *ExtrasApiService) ExtrasCustomFieldsReadExecute(r ApiExtrasCustomFieldsReadRequest) (*CustomField, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CustomField
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExtrasApiService.ExtrasCustomFieldsRead")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extras/custom-fields/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiExtrasCustomFieldsUpdateRequest struct {
	ctx context.Context
	ApiService *ExtrasApiService
	id int32
	data *WritableCustomField
}

func (r ApiExtrasCustomFieldsUpdateRequest) Data(data WritableCustomField) ApiExtrasCustomFieldsUpdateRequest {
	r.data = &data
	return r
}

func (r ApiExtrasCustomFieldsUpdateRequest) Execute() (*CustomField, *http.Response, error) {
	return r.ApiService.ExtrasCustomFieldsUpdateExecute(r)
}

/*
ExtrasCustomFieldsUpdate Method for ExtrasCustomFieldsUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this custom field.
 @return ApiExtrasCustomFieldsUpdateRequest
*/
func (a *ExtrasApiService) ExtrasCustomFieldsUpdate(ctx context.Context, id int32) ApiExtrasCustomFieldsUpdateRequest {
	return ApiExtrasCustomFieldsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return CustomField
func (a *ExtrasApiService) ExtrasCustomFieldsUpdateExecute(r ApiExtrasCustomFieldsUpdateRequest) (*CustomField, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CustomField
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExtrasApiService.ExtrasCustomFieldsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extras/custom-fields/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiExtrasCustomLinksBulkDeleteRequest struct {
	ctx context.Context
	ApiService *ExtrasApiService
}

func (r ApiExtrasCustomLinksBulkDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.ExtrasCustomLinksBulkDeleteExecute(r)
}

/*
ExtrasCustomLinksBulkDelete Method for ExtrasCustomLinksBulkDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiExtrasCustomLinksBulkDeleteRequest
*/
func (a *ExtrasApiService) ExtrasCustomLinksBulkDelete(ctx context.Context) ApiExtrasCustomLinksBulkDeleteRequest {
	return ApiExtrasCustomLinksBulkDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ExtrasApiService) ExtrasCustomLinksBulkDeleteExecute(r ApiExtrasCustomLinksBulkDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExtrasApiService.ExtrasCustomLinksBulkDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extras/custom-links/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiExtrasCustomLinksBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *ExtrasApiService
	data *CustomLink
}

func (r ApiExtrasCustomLinksBulkPartialUpdateRequest) Data(data CustomLink) ApiExtrasCustomLinksBulkPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiExtrasCustomLinksBulkPartialUpdateRequest) Execute() (*CustomLink, *http.Response, error) {
	return r.ApiService.ExtrasCustomLinksBulkPartialUpdateExecute(r)
}

/*
ExtrasCustomLinksBulkPartialUpdate Method for ExtrasCustomLinksBulkPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiExtrasCustomLinksBulkPartialUpdateRequest
*/
func (a *ExtrasApiService) ExtrasCustomLinksBulkPartialUpdate(ctx context.Context) ApiExtrasCustomLinksBulkPartialUpdateRequest {
	return ApiExtrasCustomLinksBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CustomLink
func (a *ExtrasApiService) ExtrasCustomLinksBulkPartialUpdateExecute(r ApiExtrasCustomLinksBulkPartialUpdateRequest) (*CustomLink, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CustomLink
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExtrasApiService.ExtrasCustomLinksBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extras/custom-links/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiExtrasCustomLinksBulkUpdateRequest struct {
	ctx context.Context
	ApiService *ExtrasApiService
	data *CustomLink
}

func (r ApiExtrasCustomLinksBulkUpdateRequest) Data(data CustomLink) ApiExtrasCustomLinksBulkUpdateRequest {
	r.data = &data
	return r
}

func (r ApiExtrasCustomLinksBulkUpdateRequest) Execute() (*CustomLink, *http.Response, error) {
	return r.ApiService.ExtrasCustomLinksBulkUpdateExecute(r)
}

/*
ExtrasCustomLinksBulkUpdate Method for ExtrasCustomLinksBulkUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiExtrasCustomLinksBulkUpdateRequest
*/
func (a *ExtrasApiService) ExtrasCustomLinksBulkUpdate(ctx context.Context) ApiExtrasCustomLinksBulkUpdateRequest {
	return ApiExtrasCustomLinksBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CustomLink
func (a *ExtrasApiService) ExtrasCustomLinksBulkUpdateExecute(r ApiExtrasCustomLinksBulkUpdateRequest) (*CustomLink, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CustomLink
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExtrasApiService.ExtrasCustomLinksBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extras/custom-links/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiExtrasCustomLinksCreateRequest struct {
	ctx context.Context
	ApiService *ExtrasApiService
	data *CustomLink
}

func (r ApiExtrasCustomLinksCreateRequest) Data(data CustomLink) ApiExtrasCustomLinksCreateRequest {
	r.data = &data
	return r
}

func (r ApiExtrasCustomLinksCreateRequest) Execute() (*CustomLink, *http.Response, error) {
	return r.ApiService.ExtrasCustomLinksCreateExecute(r)
}

/*
ExtrasCustomLinksCreate Method for ExtrasCustomLinksCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiExtrasCustomLinksCreateRequest
*/
func (a *ExtrasApiService) ExtrasCustomLinksCreate(ctx context.Context) ApiExtrasCustomLinksCreateRequest {
	return ApiExtrasCustomLinksCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CustomLink
func (a *ExtrasApiService) ExtrasCustomLinksCreateExecute(r ApiExtrasCustomLinksCreateRequest) (*CustomLink, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CustomLink
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExtrasApiService.ExtrasCustomLinksCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extras/custom-links/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiExtrasCustomLinksDeleteRequest struct {
	ctx context.Context
	ApiService *ExtrasApiService
	id int32
}

func (r ApiExtrasCustomLinksDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.ExtrasCustomLinksDeleteExecute(r)
}

/*
ExtrasCustomLinksDelete Method for ExtrasCustomLinksDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this custom link.
 @return ApiExtrasCustomLinksDeleteRequest
*/
func (a *ExtrasApiService) ExtrasCustomLinksDelete(ctx context.Context, id int32) ApiExtrasCustomLinksDeleteRequest {
	return ApiExtrasCustomLinksDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *ExtrasApiService) ExtrasCustomLinksDeleteExecute(r ApiExtrasCustomLinksDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExtrasApiService.ExtrasCustomLinksDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extras/custom-links/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiExtrasCustomLinksListRequest struct {
	ctx context.Context
	ApiService *ExtrasApiService
	id *string
	contentType *string
	name *string
	linkText *string
	linkUrl *string
	weight *string
	groupName *string
	newWindow *string
	idN *string
	idLte *string
	idLt *string
	idGte *string
	idGt *string
	contentTypeN *string
	nameN *string
	nameIc *string
	nameNic *string
	nameIew *string
	nameNiew *string
	nameIsw *string
	nameNisw *string
	nameIe *string
	nameNie *string
	nameEmpty *string
	linkTextN *string
	linkTextIc *string
	linkTextNic *string
	linkTextIew *string
	linkTextNiew *string
	linkTextIsw *string
	linkTextNisw *string
	linkTextIe *string
	linkTextNie *string
	linkTextEmpty *string
	linkUrlN *string
	linkUrlIc *string
	linkUrlNic *string
	linkUrlIew *string
	linkUrlNiew *string
	linkUrlIsw *string
	linkUrlNisw *string
	linkUrlIe *string
	linkUrlNie *string
	linkUrlEmpty *string
	weightN *string
	weightLte *string
	weightLt *string
	weightGte *string
	weightGt *string
	groupNameN *string
	groupNameIc *string
	groupNameNic *string
	groupNameIew *string
	groupNameNiew *string
	groupNameIsw *string
	groupNameNisw *string
	groupNameIe *string
	groupNameNie *string
	groupNameEmpty *string
	limit *int32
	offset *int32
}

func (r ApiExtrasCustomLinksListRequest) Id(id string) ApiExtrasCustomLinksListRequest {
	r.id = &id
	return r
}

func (r ApiExtrasCustomLinksListRequest) ContentType(contentType string) ApiExtrasCustomLinksListRequest {
	r.contentType = &contentType
	return r
}

func (r ApiExtrasCustomLinksListRequest) Name(name string) ApiExtrasCustomLinksListRequest {
	r.name = &name
	return r
}

func (r ApiExtrasCustomLinksListRequest) LinkText(linkText string) ApiExtrasCustomLinksListRequest {
	r.linkText = &linkText
	return r
}

func (r ApiExtrasCustomLinksListRequest) LinkUrl(linkUrl string) ApiExtrasCustomLinksListRequest {
	r.linkUrl = &linkUrl
	return r
}

func (r ApiExtrasCustomLinksListRequest) Weight(weight string) ApiExtrasCustomLinksListRequest {
	r.weight = &weight
	return r
}

func (r ApiExtrasCustomLinksListRequest) GroupName(groupName string) ApiExtrasCustomLinksListRequest {
	r.groupName = &groupName
	return r
}

func (r ApiExtrasCustomLinksListRequest) NewWindow(newWindow string) ApiExtrasCustomLinksListRequest {
	r.newWindow = &newWindow
	return r
}

func (r ApiExtrasCustomLinksListRequest) IdN(idN string) ApiExtrasCustomLinksListRequest {
	r.idN = &idN
	return r
}

func (r ApiExtrasCustomLinksListRequest) IdLte(idLte string) ApiExtrasCustomLinksListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiExtrasCustomLinksListRequest) IdLt(idLt string) ApiExtrasCustomLinksListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiExtrasCustomLinksListRequest) IdGte(idGte string) ApiExtrasCustomLinksListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiExtrasCustomLinksListRequest) IdGt(idGt string) ApiExtrasCustomLinksListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiExtrasCustomLinksListRequest) ContentTypeN(contentTypeN string) ApiExtrasCustomLinksListRequest {
	r.contentTypeN = &contentTypeN
	return r
}

func (r ApiExtrasCustomLinksListRequest) NameN(nameN string) ApiExtrasCustomLinksListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiExtrasCustomLinksListRequest) NameIc(nameIc string) ApiExtrasCustomLinksListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiExtrasCustomLinksListRequest) NameNic(nameNic string) ApiExtrasCustomLinksListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiExtrasCustomLinksListRequest) NameIew(nameIew string) ApiExtrasCustomLinksListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiExtrasCustomLinksListRequest) NameNiew(nameNiew string) ApiExtrasCustomLinksListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiExtrasCustomLinksListRequest) NameIsw(nameIsw string) ApiExtrasCustomLinksListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiExtrasCustomLinksListRequest) NameNisw(nameNisw string) ApiExtrasCustomLinksListRequest {
	r.nameNisw = &nameNisw
	return r
}

func (r ApiExtrasCustomLinksListRequest) NameIe(nameIe string) ApiExtrasCustomLinksListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiExtrasCustomLinksListRequest) NameNie(nameNie string) ApiExtrasCustomLinksListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiExtrasCustomLinksListRequest) NameEmpty(nameEmpty string) ApiExtrasCustomLinksListRequest {
	r.nameEmpty = &nameEmpty
	return r
}

func (r ApiExtrasCustomLinksListRequest) LinkTextN(linkTextN string) ApiExtrasCustomLinksListRequest {
	r.linkTextN = &linkTextN
	return r
}

func (r ApiExtrasCustomLinksListRequest) LinkTextIc(linkTextIc string) ApiExtrasCustomLinksListRequest {
	r.linkTextIc = &linkTextIc
	return r
}

func (r ApiExtrasCustomLinksListRequest) LinkTextNic(linkTextNic string) ApiExtrasCustomLinksListRequest {
	r.linkTextNic = &linkTextNic
	return r
}

func (r ApiExtrasCustomLinksListRequest) LinkTextIew(linkTextIew string) ApiExtrasCustomLinksListRequest {
	r.linkTextIew = &linkTextIew
	return r
}

func (r ApiExtrasCustomLinksListRequest) LinkTextNiew(linkTextNiew string) ApiExtrasCustomLinksListRequest {
	r.linkTextNiew = &linkTextNiew
	return r
}

func (r ApiExtrasCustomLinksListRequest) LinkTextIsw(linkTextIsw string) ApiExtrasCustomLinksListRequest {
	r.linkTextIsw = &linkTextIsw
	return r
}

func (r ApiExtrasCustomLinksListRequest) LinkTextNisw(linkTextNisw string) ApiExtrasCustomLinksListRequest {
	r.linkTextNisw = &linkTextNisw
	return r
}

func (r ApiExtrasCustomLinksListRequest) LinkTextIe(linkTextIe string) ApiExtrasCustomLinksListRequest {
	r.linkTextIe = &linkTextIe
	return r
}

func (r ApiExtrasCustomLinksListRequest) LinkTextNie(linkTextNie string) ApiExtrasCustomLinksListRequest {
	r.linkTextNie = &linkTextNie
	return r
}

func (r ApiExtrasCustomLinksListRequest) LinkTextEmpty(linkTextEmpty string) ApiExtrasCustomLinksListRequest {
	r.linkTextEmpty = &linkTextEmpty
	return r
}

func (r ApiExtrasCustomLinksListRequest) LinkUrlN(linkUrlN string) ApiExtrasCustomLinksListRequest {
	r.linkUrlN = &linkUrlN
	return r
}

func (r ApiExtrasCustomLinksListRequest) LinkUrlIc(linkUrlIc string) ApiExtrasCustomLinksListRequest {
	r.linkUrlIc = &linkUrlIc
	return r
}

func (r ApiExtrasCustomLinksListRequest) LinkUrlNic(linkUrlNic string) ApiExtrasCustomLinksListRequest {
	r.linkUrlNic = &linkUrlNic
	return r
}

func (r ApiExtrasCustomLinksListRequest) LinkUrlIew(linkUrlIew string) ApiExtrasCustomLinksListRequest {
	r.linkUrlIew = &linkUrlIew
	return r
}

func (r ApiExtrasCustomLinksListRequest) LinkUrlNiew(linkUrlNiew string) ApiExtrasCustomLinksListRequest {
	r.linkUrlNiew = &linkUrlNiew
	return r
}

func (r ApiExtrasCustomLinksListRequest) LinkUrlIsw(linkUrlIsw string) ApiExtrasCustomLinksListRequest {
	r.linkUrlIsw = &linkUrlIsw
	return r
}

func (r ApiExtrasCustomLinksListRequest) LinkUrlNisw(linkUrlNisw string) ApiExtrasCustomLinksListRequest {
	r.linkUrlNisw = &linkUrlNisw
	return r
}

func (r ApiExtrasCustomLinksListRequest) LinkUrlIe(linkUrlIe string) ApiExtrasCustomLinksListRequest {
	r.linkUrlIe = &linkUrlIe
	return r
}

func (r ApiExtrasCustomLinksListRequest) LinkUrlNie(linkUrlNie string) ApiExtrasCustomLinksListRequest {
	r.linkUrlNie = &linkUrlNie
	return r
}

func (r ApiExtrasCustomLinksListRequest) LinkUrlEmpty(linkUrlEmpty string) ApiExtrasCustomLinksListRequest {
	r.linkUrlEmpty = &linkUrlEmpty
	return r
}

func (r ApiExtrasCustomLinksListRequest) WeightN(weightN string) ApiExtrasCustomLinksListRequest {
	r.weightN = &weightN
	return r
}

func (r ApiExtrasCustomLinksListRequest) WeightLte(weightLte string) ApiExtrasCustomLinksListRequest {
	r.weightLte = &weightLte
	return r
}

func (r ApiExtrasCustomLinksListRequest) WeightLt(weightLt string) ApiExtrasCustomLinksListRequest {
	r.weightLt = &weightLt
	return r
}

func (r ApiExtrasCustomLinksListRequest) WeightGte(weightGte string) ApiExtrasCustomLinksListRequest {
	r.weightGte = &weightGte
	return r
}

func (r ApiExtrasCustomLinksListRequest) WeightGt(weightGt string) ApiExtrasCustomLinksListRequest {
	r.weightGt = &weightGt
	return r
}

func (r ApiExtrasCustomLinksListRequest) GroupNameN(groupNameN string) ApiExtrasCustomLinksListRequest {
	r.groupNameN = &groupNameN
	return r
}

func (r ApiExtrasCustomLinksListRequest) GroupNameIc(groupNameIc string) ApiExtrasCustomLinksListRequest {
	r.groupNameIc = &groupNameIc
	return r
}

func (r ApiExtrasCustomLinksListRequest) GroupNameNic(groupNameNic string) ApiExtrasCustomLinksListRequest {
	r.groupNameNic = &groupNameNic
	return r
}

func (r ApiExtrasCustomLinksListRequest) GroupNameIew(groupNameIew string) ApiExtrasCustomLinksListRequest {
	r.groupNameIew = &groupNameIew
	return r
}

func (r ApiExtrasCustomLinksListRequest) GroupNameNiew(groupNameNiew string) ApiExtrasCustomLinksListRequest {
	r.groupNameNiew = &groupNameNiew
	return r
}

func (r ApiExtrasCustomLinksListRequest) GroupNameIsw(groupNameIsw string) ApiExtrasCustomLinksListRequest {
	r.groupNameIsw = &groupNameIsw
	return r
}

func (r ApiExtrasCustomLinksListRequest) GroupNameNisw(groupNameNisw string) ApiExtrasCustomLinksListRequest {
	r.groupNameNisw = &groupNameNisw
	return r
}

func (r ApiExtrasCustomLinksListRequest) GroupNameIe(groupNameIe string) ApiExtrasCustomLinksListRequest {
	r.groupNameIe = &groupNameIe
	return r
}

func (r ApiExtrasCustomLinksListRequest) GroupNameNie(groupNameNie string) ApiExtrasCustomLinksListRequest {
	r.groupNameNie = &groupNameNie
	return r
}

func (r ApiExtrasCustomLinksListRequest) GroupNameEmpty(groupNameEmpty string) ApiExtrasCustomLinksListRequest {
	r.groupNameEmpty = &groupNameEmpty
	return r
}

// Number of results to return per page.
func (r ApiExtrasCustomLinksListRequest) Limit(limit int32) ApiExtrasCustomLinksListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiExtrasCustomLinksListRequest) Offset(offset int32) ApiExtrasCustomLinksListRequest {
	r.offset = &offset
	return r
}

func (r ApiExtrasCustomLinksListRequest) Execute() (*ExtrasCustomLinksList200Response, *http.Response, error) {
	return r.ApiService.ExtrasCustomLinksListExecute(r)
}

/*
ExtrasCustomLinksList Method for ExtrasCustomLinksList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiExtrasCustomLinksListRequest
*/
func (a *ExtrasApiService) ExtrasCustomLinksList(ctx context.Context) ApiExtrasCustomLinksListRequest {
	return ApiExtrasCustomLinksListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ExtrasCustomLinksList200Response
func (a *ExtrasApiService) ExtrasCustomLinksListExecute(r ApiExtrasCustomLinksListRequest) (*ExtrasCustomLinksList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ExtrasCustomLinksList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExtrasApiService.ExtrasCustomLinksList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extras/custom-links/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.contentType != nil {
		localVarQueryParams.Add("content_type", parameterToString(*r.contentType, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.linkText != nil {
		localVarQueryParams.Add("link_text", parameterToString(*r.linkText, ""))
	}
	if r.linkUrl != nil {
		localVarQueryParams.Add("link_url", parameterToString(*r.linkUrl, ""))
	}
	if r.weight != nil {
		localVarQueryParams.Add("weight", parameterToString(*r.weight, ""))
	}
	if r.groupName != nil {
		localVarQueryParams.Add("group_name", parameterToString(*r.groupName, ""))
	}
	if r.newWindow != nil {
		localVarQueryParams.Add("new_window", parameterToString(*r.newWindow, ""))
	}
	if r.idN != nil {
		localVarQueryParams.Add("id__n", parameterToString(*r.idN, ""))
	}
	if r.idLte != nil {
		localVarQueryParams.Add("id__lte", parameterToString(*r.idLte, ""))
	}
	if r.idLt != nil {
		localVarQueryParams.Add("id__lt", parameterToString(*r.idLt, ""))
	}
	if r.idGte != nil {
		localVarQueryParams.Add("id__gte", parameterToString(*r.idGte, ""))
	}
	if r.idGt != nil {
		localVarQueryParams.Add("id__gt", parameterToString(*r.idGt, ""))
	}
	if r.contentTypeN != nil {
		localVarQueryParams.Add("content_type__n", parameterToString(*r.contentTypeN, ""))
	}
	if r.nameN != nil {
		localVarQueryParams.Add("name__n", parameterToString(*r.nameN, ""))
	}
	if r.nameIc != nil {
		localVarQueryParams.Add("name__ic", parameterToString(*r.nameIc, ""))
	}
	if r.nameNic != nil {
		localVarQueryParams.Add("name__nic", parameterToString(*r.nameNic, ""))
	}
	if r.nameIew != nil {
		localVarQueryParams.Add("name__iew", parameterToString(*r.nameIew, ""))
	}
	if r.nameNiew != nil {
		localVarQueryParams.Add("name__niew", parameterToString(*r.nameNiew, ""))
	}
	if r.nameIsw != nil {
		localVarQueryParams.Add("name__isw", parameterToString(*r.nameIsw, ""))
	}
	if r.nameNisw != nil {
		localVarQueryParams.Add("name__nisw", parameterToString(*r.nameNisw, ""))
	}
	if r.nameIe != nil {
		localVarQueryParams.Add("name__ie", parameterToString(*r.nameIe, ""))
	}
	if r.nameNie != nil {
		localVarQueryParams.Add("name__nie", parameterToString(*r.nameNie, ""))
	}
	if r.nameEmpty != nil {
		localVarQueryParams.Add("name__empty", parameterToString(*r.nameEmpty, ""))
	}
	if r.linkTextN != nil {
		localVarQueryParams.Add("link_text__n", parameterToString(*r.linkTextN, ""))
	}
	if r.linkTextIc != nil {
		localVarQueryParams.Add("link_text__ic", parameterToString(*r.linkTextIc, ""))
	}
	if r.linkTextNic != nil {
		localVarQueryParams.Add("link_text__nic", parameterToString(*r.linkTextNic, ""))
	}
	if r.linkTextIew != nil {
		localVarQueryParams.Add("link_text__iew", parameterToString(*r.linkTextIew, ""))
	}
	if r.linkTextNiew != nil {
		localVarQueryParams.Add("link_text__niew", parameterToString(*r.linkTextNiew, ""))
	}
	if r.linkTextIsw != nil {
		localVarQueryParams.Add("link_text__isw", parameterToString(*r.linkTextIsw, ""))
	}
	if r.linkTextNisw != nil {
		localVarQueryParams.Add("link_text__nisw", parameterToString(*r.linkTextNisw, ""))
	}
	if r.linkTextIe != nil {
		localVarQueryParams.Add("link_text__ie", parameterToString(*r.linkTextIe, ""))
	}
	if r.linkTextNie != nil {
		localVarQueryParams.Add("link_text__nie", parameterToString(*r.linkTextNie, ""))
	}
	if r.linkTextEmpty != nil {
		localVarQueryParams.Add("link_text__empty", parameterToString(*r.linkTextEmpty, ""))
	}
	if r.linkUrlN != nil {
		localVarQueryParams.Add("link_url__n", parameterToString(*r.linkUrlN, ""))
	}
	if r.linkUrlIc != nil {
		localVarQueryParams.Add("link_url__ic", parameterToString(*r.linkUrlIc, ""))
	}
	if r.linkUrlNic != nil {
		localVarQueryParams.Add("link_url__nic", parameterToString(*r.linkUrlNic, ""))
	}
	if r.linkUrlIew != nil {
		localVarQueryParams.Add("link_url__iew", parameterToString(*r.linkUrlIew, ""))
	}
	if r.linkUrlNiew != nil {
		localVarQueryParams.Add("link_url__niew", parameterToString(*r.linkUrlNiew, ""))
	}
	if r.linkUrlIsw != nil {
		localVarQueryParams.Add("link_url__isw", parameterToString(*r.linkUrlIsw, ""))
	}
	if r.linkUrlNisw != nil {
		localVarQueryParams.Add("link_url__nisw", parameterToString(*r.linkUrlNisw, ""))
	}
	if r.linkUrlIe != nil {
		localVarQueryParams.Add("link_url__ie", parameterToString(*r.linkUrlIe, ""))
	}
	if r.linkUrlNie != nil {
		localVarQueryParams.Add("link_url__nie", parameterToString(*r.linkUrlNie, ""))
	}
	if r.linkUrlEmpty != nil {
		localVarQueryParams.Add("link_url__empty", parameterToString(*r.linkUrlEmpty, ""))
	}
	if r.weightN != nil {
		localVarQueryParams.Add("weight__n", parameterToString(*r.weightN, ""))
	}
	if r.weightLte != nil {
		localVarQueryParams.Add("weight__lte", parameterToString(*r.weightLte, ""))
	}
	if r.weightLt != nil {
		localVarQueryParams.Add("weight__lt", parameterToString(*r.weightLt, ""))
	}
	if r.weightGte != nil {
		localVarQueryParams.Add("weight__gte", parameterToString(*r.weightGte, ""))
	}
	if r.weightGt != nil {
		localVarQueryParams.Add("weight__gt", parameterToString(*r.weightGt, ""))
	}
	if r.groupNameN != nil {
		localVarQueryParams.Add("group_name__n", parameterToString(*r.groupNameN, ""))
	}
	if r.groupNameIc != nil {
		localVarQueryParams.Add("group_name__ic", parameterToString(*r.groupNameIc, ""))
	}
	if r.groupNameNic != nil {
		localVarQueryParams.Add("group_name__nic", parameterToString(*r.groupNameNic, ""))
	}
	if r.groupNameIew != nil {
		localVarQueryParams.Add("group_name__iew", parameterToString(*r.groupNameIew, ""))
	}
	if r.groupNameNiew != nil {
		localVarQueryParams.Add("group_name__niew", parameterToString(*r.groupNameNiew, ""))
	}
	if r.groupNameIsw != nil {
		localVarQueryParams.Add("group_name__isw", parameterToString(*r.groupNameIsw, ""))
	}
	if r.groupNameNisw != nil {
		localVarQueryParams.Add("group_name__nisw", parameterToString(*r.groupNameNisw, ""))
	}
	if r.groupNameIe != nil {
		localVarQueryParams.Add("group_name__ie", parameterToString(*r.groupNameIe, ""))
	}
	if r.groupNameNie != nil {
		localVarQueryParams.Add("group_name__nie", parameterToString(*r.groupNameNie, ""))
	}
	if r.groupNameEmpty != nil {
		localVarQueryParams.Add("group_name__empty", parameterToString(*r.groupNameEmpty, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiExtrasCustomLinksPartialUpdateRequest struct {
	ctx context.Context
	ApiService *ExtrasApiService
	id int32
	data *CustomLink
}

func (r ApiExtrasCustomLinksPartialUpdateRequest) Data(data CustomLink) ApiExtrasCustomLinksPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiExtrasCustomLinksPartialUpdateRequest) Execute() (*CustomLink, *http.Response, error) {
	return r.ApiService.ExtrasCustomLinksPartialUpdateExecute(r)
}

/*
ExtrasCustomLinksPartialUpdate Method for ExtrasCustomLinksPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this custom link.
 @return ApiExtrasCustomLinksPartialUpdateRequest
*/
func (a *ExtrasApiService) ExtrasCustomLinksPartialUpdate(ctx context.Context, id int32) ApiExtrasCustomLinksPartialUpdateRequest {
	return ApiExtrasCustomLinksPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return CustomLink
func (a *ExtrasApiService) ExtrasCustomLinksPartialUpdateExecute(r ApiExtrasCustomLinksPartialUpdateRequest) (*CustomLink, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CustomLink
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExtrasApiService.ExtrasCustomLinksPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extras/custom-links/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiExtrasCustomLinksReadRequest struct {
	ctx context.Context
	ApiService *ExtrasApiService
	id int32
}

func (r ApiExtrasCustomLinksReadRequest) Execute() (*CustomLink, *http.Response, error) {
	return r.ApiService.ExtrasCustomLinksReadExecute(r)
}

/*
ExtrasCustomLinksRead Method for ExtrasCustomLinksRead

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this custom link.
 @return ApiExtrasCustomLinksReadRequest
*/
func (a *ExtrasApiService) ExtrasCustomLinksRead(ctx context.Context, id int32) ApiExtrasCustomLinksReadRequest {
	return ApiExtrasCustomLinksReadRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return CustomLink
func (a *ExtrasApiService) ExtrasCustomLinksReadExecute(r ApiExtrasCustomLinksReadRequest) (*CustomLink, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CustomLink
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExtrasApiService.ExtrasCustomLinksRead")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extras/custom-links/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiExtrasCustomLinksUpdateRequest struct {
	ctx context.Context
	ApiService *ExtrasApiService
	id int32
	data *CustomLink
}

func (r ApiExtrasCustomLinksUpdateRequest) Data(data CustomLink) ApiExtrasCustomLinksUpdateRequest {
	r.data = &data
	return r
}

func (r ApiExtrasCustomLinksUpdateRequest) Execute() (*CustomLink, *http.Response, error) {
	return r.ApiService.ExtrasCustomLinksUpdateExecute(r)
}

/*
ExtrasCustomLinksUpdate Method for ExtrasCustomLinksUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this custom link.
 @return ApiExtrasCustomLinksUpdateRequest
*/
func (a *ExtrasApiService) ExtrasCustomLinksUpdate(ctx context.Context, id int32) ApiExtrasCustomLinksUpdateRequest {
	return ApiExtrasCustomLinksUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return CustomLink
func (a *ExtrasApiService) ExtrasCustomLinksUpdateExecute(r ApiExtrasCustomLinksUpdateRequest) (*CustomLink, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CustomLink
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExtrasApiService.ExtrasCustomLinksUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extras/custom-links/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiExtrasExportTemplatesBulkDeleteRequest struct {
	ctx context.Context
	ApiService *ExtrasApiService
}

func (r ApiExtrasExportTemplatesBulkDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.ExtrasExportTemplatesBulkDeleteExecute(r)
}

/*
ExtrasExportTemplatesBulkDelete Method for ExtrasExportTemplatesBulkDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiExtrasExportTemplatesBulkDeleteRequest
*/
func (a *ExtrasApiService) ExtrasExportTemplatesBulkDelete(ctx context.Context) ApiExtrasExportTemplatesBulkDeleteRequest {
	return ApiExtrasExportTemplatesBulkDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ExtrasApiService) ExtrasExportTemplatesBulkDeleteExecute(r ApiExtrasExportTemplatesBulkDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExtrasApiService.ExtrasExportTemplatesBulkDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extras/export-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiExtrasExportTemplatesBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *ExtrasApiService
	data *ExportTemplate
}

func (r ApiExtrasExportTemplatesBulkPartialUpdateRequest) Data(data ExportTemplate) ApiExtrasExportTemplatesBulkPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiExtrasExportTemplatesBulkPartialUpdateRequest) Execute() (*ExportTemplate, *http.Response, error) {
	return r.ApiService.ExtrasExportTemplatesBulkPartialUpdateExecute(r)
}

/*
ExtrasExportTemplatesBulkPartialUpdate Method for ExtrasExportTemplatesBulkPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiExtrasExportTemplatesBulkPartialUpdateRequest
*/
func (a *ExtrasApiService) ExtrasExportTemplatesBulkPartialUpdate(ctx context.Context) ApiExtrasExportTemplatesBulkPartialUpdateRequest {
	return ApiExtrasExportTemplatesBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ExportTemplate
func (a *ExtrasApiService) ExtrasExportTemplatesBulkPartialUpdateExecute(r ApiExtrasExportTemplatesBulkPartialUpdateRequest) (*ExportTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ExportTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExtrasApiService.ExtrasExportTemplatesBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extras/export-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiExtrasExportTemplatesBulkUpdateRequest struct {
	ctx context.Context
	ApiService *ExtrasApiService
	data *ExportTemplate
}

func (r ApiExtrasExportTemplatesBulkUpdateRequest) Data(data ExportTemplate) ApiExtrasExportTemplatesBulkUpdateRequest {
	r.data = &data
	return r
}

func (r ApiExtrasExportTemplatesBulkUpdateRequest) Execute() (*ExportTemplate, *http.Response, error) {
	return r.ApiService.ExtrasExportTemplatesBulkUpdateExecute(r)
}

/*
ExtrasExportTemplatesBulkUpdate Method for ExtrasExportTemplatesBulkUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiExtrasExportTemplatesBulkUpdateRequest
*/
func (a *ExtrasApiService) ExtrasExportTemplatesBulkUpdate(ctx context.Context) ApiExtrasExportTemplatesBulkUpdateRequest {
	return ApiExtrasExportTemplatesBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ExportTemplate
func (a *ExtrasApiService) ExtrasExportTemplatesBulkUpdateExecute(r ApiExtrasExportTemplatesBulkUpdateRequest) (*ExportTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ExportTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExtrasApiService.ExtrasExportTemplatesBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extras/export-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiExtrasExportTemplatesCreateRequest struct {
	ctx context.Context
	ApiService *ExtrasApiService
	data *ExportTemplate
}

func (r ApiExtrasExportTemplatesCreateRequest) Data(data ExportTemplate) ApiExtrasExportTemplatesCreateRequest {
	r.data = &data
	return r
}

func (r ApiExtrasExportTemplatesCreateRequest) Execute() (*ExportTemplate, *http.Response, error) {
	return r.ApiService.ExtrasExportTemplatesCreateExecute(r)
}

/*
ExtrasExportTemplatesCreate Method for ExtrasExportTemplatesCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiExtrasExportTemplatesCreateRequest
*/
func (a *ExtrasApiService) ExtrasExportTemplatesCreate(ctx context.Context) ApiExtrasExportTemplatesCreateRequest {
	return ApiExtrasExportTemplatesCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ExportTemplate
func (a *ExtrasApiService) ExtrasExportTemplatesCreateExecute(r ApiExtrasExportTemplatesCreateRequest) (*ExportTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ExportTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExtrasApiService.ExtrasExportTemplatesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extras/export-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiExtrasExportTemplatesDeleteRequest struct {
	ctx context.Context
	ApiService *ExtrasApiService
	id int32
}

func (r ApiExtrasExportTemplatesDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.ExtrasExportTemplatesDeleteExecute(r)
}

/*
ExtrasExportTemplatesDelete Method for ExtrasExportTemplatesDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this export template.
 @return ApiExtrasExportTemplatesDeleteRequest
*/
func (a *ExtrasApiService) ExtrasExportTemplatesDelete(ctx context.Context, id int32) ApiExtrasExportTemplatesDeleteRequest {
	return ApiExtrasExportTemplatesDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *ExtrasApiService) ExtrasExportTemplatesDeleteExecute(r ApiExtrasExportTemplatesDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExtrasApiService.ExtrasExportTemplatesDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extras/export-templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiExtrasExportTemplatesListRequest struct {
	ctx context.Context
	ApiService *ExtrasApiService
	id *string
	contentType *string
	name *string
	idN *string
	idLte *string
	idLt *string
	idGte *string
	idGt *string
	contentTypeN *string
	nameN *string
	nameIc *string
	nameNic *string
	nameIew *string
	nameNiew *string
	nameIsw *string
	nameNisw *string
	nameIe *string
	nameNie *string
	nameEmpty *string
	limit *int32
	offset *int32
}

func (r ApiExtrasExportTemplatesListRequest) Id(id string) ApiExtrasExportTemplatesListRequest {
	r.id = &id
	return r
}

func (r ApiExtrasExportTemplatesListRequest) ContentType(contentType string) ApiExtrasExportTemplatesListRequest {
	r.contentType = &contentType
	return r
}

func (r ApiExtrasExportTemplatesListRequest) Name(name string) ApiExtrasExportTemplatesListRequest {
	r.name = &name
	return r
}

func (r ApiExtrasExportTemplatesListRequest) IdN(idN string) ApiExtrasExportTemplatesListRequest {
	r.idN = &idN
	return r
}

func (r ApiExtrasExportTemplatesListRequest) IdLte(idLte string) ApiExtrasExportTemplatesListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiExtrasExportTemplatesListRequest) IdLt(idLt string) ApiExtrasExportTemplatesListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiExtrasExportTemplatesListRequest) IdGte(idGte string) ApiExtrasExportTemplatesListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiExtrasExportTemplatesListRequest) IdGt(idGt string) ApiExtrasExportTemplatesListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiExtrasExportTemplatesListRequest) ContentTypeN(contentTypeN string) ApiExtrasExportTemplatesListRequest {
	r.contentTypeN = &contentTypeN
	return r
}

func (r ApiExtrasExportTemplatesListRequest) NameN(nameN string) ApiExtrasExportTemplatesListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiExtrasExportTemplatesListRequest) NameIc(nameIc string) ApiExtrasExportTemplatesListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiExtrasExportTemplatesListRequest) NameNic(nameNic string) ApiExtrasExportTemplatesListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiExtrasExportTemplatesListRequest) NameIew(nameIew string) ApiExtrasExportTemplatesListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiExtrasExportTemplatesListRequest) NameNiew(nameNiew string) ApiExtrasExportTemplatesListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiExtrasExportTemplatesListRequest) NameIsw(nameIsw string) ApiExtrasExportTemplatesListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiExtrasExportTemplatesListRequest) NameNisw(nameNisw string) ApiExtrasExportTemplatesListRequest {
	r.nameNisw = &nameNisw
	return r
}

func (r ApiExtrasExportTemplatesListRequest) NameIe(nameIe string) ApiExtrasExportTemplatesListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiExtrasExportTemplatesListRequest) NameNie(nameNie string) ApiExtrasExportTemplatesListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiExtrasExportTemplatesListRequest) NameEmpty(nameEmpty string) ApiExtrasExportTemplatesListRequest {
	r.nameEmpty = &nameEmpty
	return r
}

// Number of results to return per page.
func (r ApiExtrasExportTemplatesListRequest) Limit(limit int32) ApiExtrasExportTemplatesListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiExtrasExportTemplatesListRequest) Offset(offset int32) ApiExtrasExportTemplatesListRequest {
	r.offset = &offset
	return r
}

func (r ApiExtrasExportTemplatesListRequest) Execute() (*ExtrasExportTemplatesList200Response, *http.Response, error) {
	return r.ApiService.ExtrasExportTemplatesListExecute(r)
}

/*
ExtrasExportTemplatesList Method for ExtrasExportTemplatesList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiExtrasExportTemplatesListRequest
*/
func (a *ExtrasApiService) ExtrasExportTemplatesList(ctx context.Context) ApiExtrasExportTemplatesListRequest {
	return ApiExtrasExportTemplatesListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ExtrasExportTemplatesList200Response
func (a *ExtrasApiService) ExtrasExportTemplatesListExecute(r ApiExtrasExportTemplatesListRequest) (*ExtrasExportTemplatesList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ExtrasExportTemplatesList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExtrasApiService.ExtrasExportTemplatesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extras/export-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.contentType != nil {
		localVarQueryParams.Add("content_type", parameterToString(*r.contentType, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.idN != nil {
		localVarQueryParams.Add("id__n", parameterToString(*r.idN, ""))
	}
	if r.idLte != nil {
		localVarQueryParams.Add("id__lte", parameterToString(*r.idLte, ""))
	}
	if r.idLt != nil {
		localVarQueryParams.Add("id__lt", parameterToString(*r.idLt, ""))
	}
	if r.idGte != nil {
		localVarQueryParams.Add("id__gte", parameterToString(*r.idGte, ""))
	}
	if r.idGt != nil {
		localVarQueryParams.Add("id__gt", parameterToString(*r.idGt, ""))
	}
	if r.contentTypeN != nil {
		localVarQueryParams.Add("content_type__n", parameterToString(*r.contentTypeN, ""))
	}
	if r.nameN != nil {
		localVarQueryParams.Add("name__n", parameterToString(*r.nameN, ""))
	}
	if r.nameIc != nil {
		localVarQueryParams.Add("name__ic", parameterToString(*r.nameIc, ""))
	}
	if r.nameNic != nil {
		localVarQueryParams.Add("name__nic", parameterToString(*r.nameNic, ""))
	}
	if r.nameIew != nil {
		localVarQueryParams.Add("name__iew", parameterToString(*r.nameIew, ""))
	}
	if r.nameNiew != nil {
		localVarQueryParams.Add("name__niew", parameterToString(*r.nameNiew, ""))
	}
	if r.nameIsw != nil {
		localVarQueryParams.Add("name__isw", parameterToString(*r.nameIsw, ""))
	}
	if r.nameNisw != nil {
		localVarQueryParams.Add("name__nisw", parameterToString(*r.nameNisw, ""))
	}
	if r.nameIe != nil {
		localVarQueryParams.Add("name__ie", parameterToString(*r.nameIe, ""))
	}
	if r.nameNie != nil {
		localVarQueryParams.Add("name__nie", parameterToString(*r.nameNie, ""))
	}
	if r.nameEmpty != nil {
		localVarQueryParams.Add("name__empty", parameterToString(*r.nameEmpty, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiExtrasExportTemplatesPartialUpdateRequest struct {
	ctx context.Context
	ApiService *ExtrasApiService
	id int32
	data *ExportTemplate
}

func (r ApiExtrasExportTemplatesPartialUpdateRequest) Data(data ExportTemplate) ApiExtrasExportTemplatesPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiExtrasExportTemplatesPartialUpdateRequest) Execute() (*ExportTemplate, *http.Response, error) {
	return r.ApiService.ExtrasExportTemplatesPartialUpdateExecute(r)
}

/*
ExtrasExportTemplatesPartialUpdate Method for ExtrasExportTemplatesPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this export template.
 @return ApiExtrasExportTemplatesPartialUpdateRequest
*/
func (a *ExtrasApiService) ExtrasExportTemplatesPartialUpdate(ctx context.Context, id int32) ApiExtrasExportTemplatesPartialUpdateRequest {
	return ApiExtrasExportTemplatesPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ExportTemplate
func (a *ExtrasApiService) ExtrasExportTemplatesPartialUpdateExecute(r ApiExtrasExportTemplatesPartialUpdateRequest) (*ExportTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ExportTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExtrasApiService.ExtrasExportTemplatesPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extras/export-templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiExtrasExportTemplatesReadRequest struct {
	ctx context.Context
	ApiService *ExtrasApiService
	id int32
}

func (r ApiExtrasExportTemplatesReadRequest) Execute() (*ExportTemplate, *http.Response, error) {
	return r.ApiService.ExtrasExportTemplatesReadExecute(r)
}

/*
ExtrasExportTemplatesRead Method for ExtrasExportTemplatesRead

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this export template.
 @return ApiExtrasExportTemplatesReadRequest
*/
func (a *ExtrasApiService) ExtrasExportTemplatesRead(ctx context.Context, id int32) ApiExtrasExportTemplatesReadRequest {
	return ApiExtrasExportTemplatesReadRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ExportTemplate
func (a *ExtrasApiService) ExtrasExportTemplatesReadExecute(r ApiExtrasExportTemplatesReadRequest) (*ExportTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ExportTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExtrasApiService.ExtrasExportTemplatesRead")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extras/export-templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiExtrasExportTemplatesUpdateRequest struct {
	ctx context.Context
	ApiService *ExtrasApiService
	id int32
	data *ExportTemplate
}

func (r ApiExtrasExportTemplatesUpdateRequest) Data(data ExportTemplate) ApiExtrasExportTemplatesUpdateRequest {
	r.data = &data
	return r
}

func (r ApiExtrasExportTemplatesUpdateRequest) Execute() (*ExportTemplate, *http.Response, error) {
	return r.ApiService.ExtrasExportTemplatesUpdateExecute(r)
}

/*
ExtrasExportTemplatesUpdate Method for ExtrasExportTemplatesUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this export template.
 @return ApiExtrasExportTemplatesUpdateRequest
*/
func (a *ExtrasApiService) ExtrasExportTemplatesUpdate(ctx context.Context, id int32) ApiExtrasExportTemplatesUpdateRequest {
	return ApiExtrasExportTemplatesUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ExportTemplate
func (a *ExtrasApiService) ExtrasExportTemplatesUpdateExecute(r ApiExtrasExportTemplatesUpdateRequest) (*ExportTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ExportTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExtrasApiService.ExtrasExportTemplatesUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extras/export-templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiExtrasImageAttachmentsBulkDeleteRequest struct {
	ctx context.Context
	ApiService *ExtrasApiService
}

func (r ApiExtrasImageAttachmentsBulkDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.ExtrasImageAttachmentsBulkDeleteExecute(r)
}

/*
ExtrasImageAttachmentsBulkDelete Method for ExtrasImageAttachmentsBulkDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiExtrasImageAttachmentsBulkDeleteRequest
*/
func (a *ExtrasApiService) ExtrasImageAttachmentsBulkDelete(ctx context.Context) ApiExtrasImageAttachmentsBulkDeleteRequest {
	return ApiExtrasImageAttachmentsBulkDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ExtrasApiService) ExtrasImageAttachmentsBulkDeleteExecute(r ApiExtrasImageAttachmentsBulkDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExtrasApiService.ExtrasImageAttachmentsBulkDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extras/image-attachments/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiExtrasImageAttachmentsBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *ExtrasApiService
	data *ImageAttachment
}

func (r ApiExtrasImageAttachmentsBulkPartialUpdateRequest) Data(data ImageAttachment) ApiExtrasImageAttachmentsBulkPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiExtrasImageAttachmentsBulkPartialUpdateRequest) Execute() (*ImageAttachment, *http.Response, error) {
	return r.ApiService.ExtrasImageAttachmentsBulkPartialUpdateExecute(r)
}

/*
ExtrasImageAttachmentsBulkPartialUpdate Method for ExtrasImageAttachmentsBulkPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiExtrasImageAttachmentsBulkPartialUpdateRequest
*/
func (a *ExtrasApiService) ExtrasImageAttachmentsBulkPartialUpdate(ctx context.Context) ApiExtrasImageAttachmentsBulkPartialUpdateRequest {
	return ApiExtrasImageAttachmentsBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ImageAttachment
func (a *ExtrasApiService) ExtrasImageAttachmentsBulkPartialUpdateExecute(r ApiExtrasImageAttachmentsBulkPartialUpdateRequest) (*ImageAttachment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ImageAttachment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExtrasApiService.ExtrasImageAttachmentsBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extras/image-attachments/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiExtrasImageAttachmentsBulkUpdateRequest struct {
	ctx context.Context
	ApiService *ExtrasApiService
	data *ImageAttachment
}

func (r ApiExtrasImageAttachmentsBulkUpdateRequest) Data(data ImageAttachment) ApiExtrasImageAttachmentsBulkUpdateRequest {
	r.data = &data
	return r
}

func (r ApiExtrasImageAttachmentsBulkUpdateRequest) Execute() (*ImageAttachment, *http.Response, error) {
	return r.ApiService.ExtrasImageAttachmentsBulkUpdateExecute(r)
}

/*
ExtrasImageAttachmentsBulkUpdate Method for ExtrasImageAttachmentsBulkUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiExtrasImageAttachmentsBulkUpdateRequest
*/
func (a *ExtrasApiService) ExtrasImageAttachmentsBulkUpdate(ctx context.Context) ApiExtrasImageAttachmentsBulkUpdateRequest {
	return ApiExtrasImageAttachmentsBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ImageAttachment
func (a *ExtrasApiService) ExtrasImageAttachmentsBulkUpdateExecute(r ApiExtrasImageAttachmentsBulkUpdateRequest) (*ImageAttachment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ImageAttachment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExtrasApiService.ExtrasImageAttachmentsBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extras/image-attachments/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiExtrasImageAttachmentsCreateRequest struct {
	ctx context.Context
	ApiService *ExtrasApiService
	data *ImageAttachment
}

func (r ApiExtrasImageAttachmentsCreateRequest) Data(data ImageAttachment) ApiExtrasImageAttachmentsCreateRequest {
	r.data = &data
	return r
}

func (r ApiExtrasImageAttachmentsCreateRequest) Execute() (*ImageAttachment, *http.Response, error) {
	return r.ApiService.ExtrasImageAttachmentsCreateExecute(r)
}

/*
ExtrasImageAttachmentsCreate Method for ExtrasImageAttachmentsCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiExtrasImageAttachmentsCreateRequest
*/
func (a *ExtrasApiService) ExtrasImageAttachmentsCreate(ctx context.Context) ApiExtrasImageAttachmentsCreateRequest {
	return ApiExtrasImageAttachmentsCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ImageAttachment
func (a *ExtrasApiService) ExtrasImageAttachmentsCreateExecute(r ApiExtrasImageAttachmentsCreateRequest) (*ImageAttachment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ImageAttachment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExtrasApiService.ExtrasImageAttachmentsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extras/image-attachments/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiExtrasImageAttachmentsDeleteRequest struct {
	ctx context.Context
	ApiService *ExtrasApiService
	id int32
}

func (r ApiExtrasImageAttachmentsDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.ExtrasImageAttachmentsDeleteExecute(r)
}

/*
ExtrasImageAttachmentsDelete Method for ExtrasImageAttachmentsDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this image attachment.
 @return ApiExtrasImageAttachmentsDeleteRequest
*/
func (a *ExtrasApiService) ExtrasImageAttachmentsDelete(ctx context.Context, id int32) ApiExtrasImageAttachmentsDeleteRequest {
	return ApiExtrasImageAttachmentsDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *ExtrasApiService) ExtrasImageAttachmentsDeleteExecute(r ApiExtrasImageAttachmentsDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExtrasApiService.ExtrasImageAttachmentsDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extras/image-attachments/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiExtrasImageAttachmentsListRequest struct {
	ctx context.Context
	ApiService *ExtrasApiService
	id *string
	contentTypeId *string
	objectId *string
	name *string
	created *string
	contentType *string
	idN *string
	idLte *string
	idLt *string
	idGte *string
	idGt *string
	contentTypeIdN *string
	objectIdN *string
	objectIdLte *string
	objectIdLt *string
	objectIdGte *string
	objectIdGt *string
	nameN *string
	nameIc *string
	nameNic *string
	nameIew *string
	nameNiew *string
	nameIsw *string
	nameNisw *string
	nameIe *string
	nameNie *string
	nameEmpty *string
	contentTypeN *string
	limit *int32
	offset *int32
}

func (r ApiExtrasImageAttachmentsListRequest) Id(id string) ApiExtrasImageAttachmentsListRequest {
	r.id = &id
	return r
}

func (r ApiExtrasImageAttachmentsListRequest) ContentTypeId(contentTypeId string) ApiExtrasImageAttachmentsListRequest {
	r.contentTypeId = &contentTypeId
	return r
}

func (r ApiExtrasImageAttachmentsListRequest) ObjectId(objectId string) ApiExtrasImageAttachmentsListRequest {
	r.objectId = &objectId
	return r
}

func (r ApiExtrasImageAttachmentsListRequest) Name(name string) ApiExtrasImageAttachmentsListRequest {
	r.name = &name
	return r
}

func (r ApiExtrasImageAttachmentsListRequest) Created(created string) ApiExtrasImageAttachmentsListRequest {
	r.created = &created
	return r
}

func (r ApiExtrasImageAttachmentsListRequest) ContentType(contentType string) ApiExtrasImageAttachmentsListRequest {
	r.contentType = &contentType
	return r
}

func (r ApiExtrasImageAttachmentsListRequest) IdN(idN string) ApiExtrasImageAttachmentsListRequest {
	r.idN = &idN
	return r
}

func (r ApiExtrasImageAttachmentsListRequest) IdLte(idLte string) ApiExtrasImageAttachmentsListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiExtrasImageAttachmentsListRequest) IdLt(idLt string) ApiExtrasImageAttachmentsListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiExtrasImageAttachmentsListRequest) IdGte(idGte string) ApiExtrasImageAttachmentsListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiExtrasImageAttachmentsListRequest) IdGt(idGt string) ApiExtrasImageAttachmentsListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiExtrasImageAttachmentsListRequest) ContentTypeIdN(contentTypeIdN string) ApiExtrasImageAttachmentsListRequest {
	r.contentTypeIdN = &contentTypeIdN
	return r
}

func (r ApiExtrasImageAttachmentsListRequest) ObjectIdN(objectIdN string) ApiExtrasImageAttachmentsListRequest {
	r.objectIdN = &objectIdN
	return r
}

func (r ApiExtrasImageAttachmentsListRequest) ObjectIdLte(objectIdLte string) ApiExtrasImageAttachmentsListRequest {
	r.objectIdLte = &objectIdLte
	return r
}

func (r ApiExtrasImageAttachmentsListRequest) ObjectIdLt(objectIdLt string) ApiExtrasImageAttachmentsListRequest {
	r.objectIdLt = &objectIdLt
	return r
}

func (r ApiExtrasImageAttachmentsListRequest) ObjectIdGte(objectIdGte string) ApiExtrasImageAttachmentsListRequest {
	r.objectIdGte = &objectIdGte
	return r
}

func (r ApiExtrasImageAttachmentsListRequest) ObjectIdGt(objectIdGt string) ApiExtrasImageAttachmentsListRequest {
	r.objectIdGt = &objectIdGt
	return r
}

func (r ApiExtrasImageAttachmentsListRequest) NameN(nameN string) ApiExtrasImageAttachmentsListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiExtrasImageAttachmentsListRequest) NameIc(nameIc string) ApiExtrasImageAttachmentsListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiExtrasImageAttachmentsListRequest) NameNic(nameNic string) ApiExtrasImageAttachmentsListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiExtrasImageAttachmentsListRequest) NameIew(nameIew string) ApiExtrasImageAttachmentsListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiExtrasImageAttachmentsListRequest) NameNiew(nameNiew string) ApiExtrasImageAttachmentsListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiExtrasImageAttachmentsListRequest) NameIsw(nameIsw string) ApiExtrasImageAttachmentsListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiExtrasImageAttachmentsListRequest) NameNisw(nameNisw string) ApiExtrasImageAttachmentsListRequest {
	r.nameNisw = &nameNisw
	return r
}

func (r ApiExtrasImageAttachmentsListRequest) NameIe(nameIe string) ApiExtrasImageAttachmentsListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiExtrasImageAttachmentsListRequest) NameNie(nameNie string) ApiExtrasImageAttachmentsListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiExtrasImageAttachmentsListRequest) NameEmpty(nameEmpty string) ApiExtrasImageAttachmentsListRequest {
	r.nameEmpty = &nameEmpty
	return r
}

func (r ApiExtrasImageAttachmentsListRequest) ContentTypeN(contentTypeN string) ApiExtrasImageAttachmentsListRequest {
	r.contentTypeN = &contentTypeN
	return r
}

// Number of results to return per page.
func (r ApiExtrasImageAttachmentsListRequest) Limit(limit int32) ApiExtrasImageAttachmentsListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiExtrasImageAttachmentsListRequest) Offset(offset int32) ApiExtrasImageAttachmentsListRequest {
	r.offset = &offset
	return r
}

func (r ApiExtrasImageAttachmentsListRequest) Execute() (*ExtrasImageAttachmentsList200Response, *http.Response, error) {
	return r.ApiService.ExtrasImageAttachmentsListExecute(r)
}

/*
ExtrasImageAttachmentsList Method for ExtrasImageAttachmentsList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiExtrasImageAttachmentsListRequest
*/
func (a *ExtrasApiService) ExtrasImageAttachmentsList(ctx context.Context) ApiExtrasImageAttachmentsListRequest {
	return ApiExtrasImageAttachmentsListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ExtrasImageAttachmentsList200Response
func (a *ExtrasApiService) ExtrasImageAttachmentsListExecute(r ApiExtrasImageAttachmentsListRequest) (*ExtrasImageAttachmentsList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ExtrasImageAttachmentsList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExtrasApiService.ExtrasImageAttachmentsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extras/image-attachments/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.contentTypeId != nil {
		localVarQueryParams.Add("content_type_id", parameterToString(*r.contentTypeId, ""))
	}
	if r.objectId != nil {
		localVarQueryParams.Add("object_id", parameterToString(*r.objectId, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.created != nil {
		localVarQueryParams.Add("created", parameterToString(*r.created, ""))
	}
	if r.contentType != nil {
		localVarQueryParams.Add("content_type", parameterToString(*r.contentType, ""))
	}
	if r.idN != nil {
		localVarQueryParams.Add("id__n", parameterToString(*r.idN, ""))
	}
	if r.idLte != nil {
		localVarQueryParams.Add("id__lte", parameterToString(*r.idLte, ""))
	}
	if r.idLt != nil {
		localVarQueryParams.Add("id__lt", parameterToString(*r.idLt, ""))
	}
	if r.idGte != nil {
		localVarQueryParams.Add("id__gte", parameterToString(*r.idGte, ""))
	}
	if r.idGt != nil {
		localVarQueryParams.Add("id__gt", parameterToString(*r.idGt, ""))
	}
	if r.contentTypeIdN != nil {
		localVarQueryParams.Add("content_type_id__n", parameterToString(*r.contentTypeIdN, ""))
	}
	if r.objectIdN != nil {
		localVarQueryParams.Add("object_id__n", parameterToString(*r.objectIdN, ""))
	}
	if r.objectIdLte != nil {
		localVarQueryParams.Add("object_id__lte", parameterToString(*r.objectIdLte, ""))
	}
	if r.objectIdLt != nil {
		localVarQueryParams.Add("object_id__lt", parameterToString(*r.objectIdLt, ""))
	}
	if r.objectIdGte != nil {
		localVarQueryParams.Add("object_id__gte", parameterToString(*r.objectIdGte, ""))
	}
	if r.objectIdGt != nil {
		localVarQueryParams.Add("object_id__gt", parameterToString(*r.objectIdGt, ""))
	}
	if r.nameN != nil {
		localVarQueryParams.Add("name__n", parameterToString(*r.nameN, ""))
	}
	if r.nameIc != nil {
		localVarQueryParams.Add("name__ic", parameterToString(*r.nameIc, ""))
	}
	if r.nameNic != nil {
		localVarQueryParams.Add("name__nic", parameterToString(*r.nameNic, ""))
	}
	if r.nameIew != nil {
		localVarQueryParams.Add("name__iew", parameterToString(*r.nameIew, ""))
	}
	if r.nameNiew != nil {
		localVarQueryParams.Add("name__niew", parameterToString(*r.nameNiew, ""))
	}
	if r.nameIsw != nil {
		localVarQueryParams.Add("name__isw", parameterToString(*r.nameIsw, ""))
	}
	if r.nameNisw != nil {
		localVarQueryParams.Add("name__nisw", parameterToString(*r.nameNisw, ""))
	}
	if r.nameIe != nil {
		localVarQueryParams.Add("name__ie", parameterToString(*r.nameIe, ""))
	}
	if r.nameNie != nil {
		localVarQueryParams.Add("name__nie", parameterToString(*r.nameNie, ""))
	}
	if r.nameEmpty != nil {
		localVarQueryParams.Add("name__empty", parameterToString(*r.nameEmpty, ""))
	}
	if r.contentTypeN != nil {
		localVarQueryParams.Add("content_type__n", parameterToString(*r.contentTypeN, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiExtrasImageAttachmentsPartialUpdateRequest struct {
	ctx context.Context
	ApiService *ExtrasApiService
	id int32
	data *ImageAttachment
}

func (r ApiExtrasImageAttachmentsPartialUpdateRequest) Data(data ImageAttachment) ApiExtrasImageAttachmentsPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiExtrasImageAttachmentsPartialUpdateRequest) Execute() (*ImageAttachment, *http.Response, error) {
	return r.ApiService.ExtrasImageAttachmentsPartialUpdateExecute(r)
}

/*
ExtrasImageAttachmentsPartialUpdate Method for ExtrasImageAttachmentsPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this image attachment.
 @return ApiExtrasImageAttachmentsPartialUpdateRequest
*/
func (a *ExtrasApiService) ExtrasImageAttachmentsPartialUpdate(ctx context.Context, id int32) ApiExtrasImageAttachmentsPartialUpdateRequest {
	return ApiExtrasImageAttachmentsPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ImageAttachment
func (a *ExtrasApiService) ExtrasImageAttachmentsPartialUpdateExecute(r ApiExtrasImageAttachmentsPartialUpdateRequest) (*ImageAttachment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ImageAttachment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExtrasApiService.ExtrasImageAttachmentsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extras/image-attachments/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiExtrasImageAttachmentsReadRequest struct {
	ctx context.Context
	ApiService *ExtrasApiService
	id int32
}

func (r ApiExtrasImageAttachmentsReadRequest) Execute() (*ImageAttachment, *http.Response, error) {
	return r.ApiService.ExtrasImageAttachmentsReadExecute(r)
}

/*
ExtrasImageAttachmentsRead Method for ExtrasImageAttachmentsRead

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this image attachment.
 @return ApiExtrasImageAttachmentsReadRequest
*/
func (a *ExtrasApiService) ExtrasImageAttachmentsRead(ctx context.Context, id int32) ApiExtrasImageAttachmentsReadRequest {
	return ApiExtrasImageAttachmentsReadRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ImageAttachment
func (a *ExtrasApiService) ExtrasImageAttachmentsReadExecute(r ApiExtrasImageAttachmentsReadRequest) (*ImageAttachment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ImageAttachment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExtrasApiService.ExtrasImageAttachmentsRead")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extras/image-attachments/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiExtrasImageAttachmentsUpdateRequest struct {
	ctx context.Context
	ApiService *ExtrasApiService
	id int32
	data *ImageAttachment
}

func (r ApiExtrasImageAttachmentsUpdateRequest) Data(data ImageAttachment) ApiExtrasImageAttachmentsUpdateRequest {
	r.data = &data
	return r
}

func (r ApiExtrasImageAttachmentsUpdateRequest) Execute() (*ImageAttachment, *http.Response, error) {
	return r.ApiService.ExtrasImageAttachmentsUpdateExecute(r)
}

/*
ExtrasImageAttachmentsUpdate Method for ExtrasImageAttachmentsUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this image attachment.
 @return ApiExtrasImageAttachmentsUpdateRequest
*/
func (a *ExtrasApiService) ExtrasImageAttachmentsUpdate(ctx context.Context, id int32) ApiExtrasImageAttachmentsUpdateRequest {
	return ApiExtrasImageAttachmentsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ImageAttachment
func (a *ExtrasApiService) ExtrasImageAttachmentsUpdateExecute(r ApiExtrasImageAttachmentsUpdateRequest) (*ImageAttachment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ImageAttachment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExtrasApiService.ExtrasImageAttachmentsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extras/image-attachments/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiExtrasJobResultsListRequest struct {
	ctx context.Context
	ApiService *ExtrasApiService
	id *string
	created *string
	completed *string
	status *string
	user *string
	objType *string
	name *string
	q *string
	idN *string
	idLte *string
	idLt *string
	idGte *string
	idGt *string
	statusN *string
	userN *string
	objTypeN *string
	nameN *string
	nameIc *string
	nameNic *string
	nameIew *string
	nameNiew *string
	nameIsw *string
	nameNisw *string
	nameIe *string
	nameNie *string
	nameEmpty *string
	limit *int32
	offset *int32
}

func (r ApiExtrasJobResultsListRequest) Id(id string) ApiExtrasJobResultsListRequest {
	r.id = &id
	return r
}

func (r ApiExtrasJobResultsListRequest) Created(created string) ApiExtrasJobResultsListRequest {
	r.created = &created
	return r
}

func (r ApiExtrasJobResultsListRequest) Completed(completed string) ApiExtrasJobResultsListRequest {
	r.completed = &completed
	return r
}

func (r ApiExtrasJobResultsListRequest) Status(status string) ApiExtrasJobResultsListRequest {
	r.status = &status
	return r
}

func (r ApiExtrasJobResultsListRequest) User(user string) ApiExtrasJobResultsListRequest {
	r.user = &user
	return r
}

func (r ApiExtrasJobResultsListRequest) ObjType(objType string) ApiExtrasJobResultsListRequest {
	r.objType = &objType
	return r
}

func (r ApiExtrasJobResultsListRequest) Name(name string) ApiExtrasJobResultsListRequest {
	r.name = &name
	return r
}

func (r ApiExtrasJobResultsListRequest) Q(q string) ApiExtrasJobResultsListRequest {
	r.q = &q
	return r
}

func (r ApiExtrasJobResultsListRequest) IdN(idN string) ApiExtrasJobResultsListRequest {
	r.idN = &idN
	return r
}

func (r ApiExtrasJobResultsListRequest) IdLte(idLte string) ApiExtrasJobResultsListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiExtrasJobResultsListRequest) IdLt(idLt string) ApiExtrasJobResultsListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiExtrasJobResultsListRequest) IdGte(idGte string) ApiExtrasJobResultsListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiExtrasJobResultsListRequest) IdGt(idGt string) ApiExtrasJobResultsListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiExtrasJobResultsListRequest) StatusN(statusN string) ApiExtrasJobResultsListRequest {
	r.statusN = &statusN
	return r
}

func (r ApiExtrasJobResultsListRequest) UserN(userN string) ApiExtrasJobResultsListRequest {
	r.userN = &userN
	return r
}

func (r ApiExtrasJobResultsListRequest) ObjTypeN(objTypeN string) ApiExtrasJobResultsListRequest {
	r.objTypeN = &objTypeN
	return r
}

func (r ApiExtrasJobResultsListRequest) NameN(nameN string) ApiExtrasJobResultsListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiExtrasJobResultsListRequest) NameIc(nameIc string) ApiExtrasJobResultsListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiExtrasJobResultsListRequest) NameNic(nameNic string) ApiExtrasJobResultsListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiExtrasJobResultsListRequest) NameIew(nameIew string) ApiExtrasJobResultsListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiExtrasJobResultsListRequest) NameNiew(nameNiew string) ApiExtrasJobResultsListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiExtrasJobResultsListRequest) NameIsw(nameIsw string) ApiExtrasJobResultsListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiExtrasJobResultsListRequest) NameNisw(nameNisw string) ApiExtrasJobResultsListRequest {
	r.nameNisw = &nameNisw
	return r
}

func (r ApiExtrasJobResultsListRequest) NameIe(nameIe string) ApiExtrasJobResultsListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiExtrasJobResultsListRequest) NameNie(nameNie string) ApiExtrasJobResultsListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiExtrasJobResultsListRequest) NameEmpty(nameEmpty string) ApiExtrasJobResultsListRequest {
	r.nameEmpty = &nameEmpty
	return r
}

// Number of results to return per page.
func (r ApiExtrasJobResultsListRequest) Limit(limit int32) ApiExtrasJobResultsListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiExtrasJobResultsListRequest) Offset(offset int32) ApiExtrasJobResultsListRequest {
	r.offset = &offset
	return r
}

func (r ApiExtrasJobResultsListRequest) Execute() (*ExtrasJobResultsList200Response, *http.Response, error) {
	return r.ApiService.ExtrasJobResultsListExecute(r)
}

/*
ExtrasJobResultsList Method for ExtrasJobResultsList

Retrieve a list of job results

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiExtrasJobResultsListRequest
*/
func (a *ExtrasApiService) ExtrasJobResultsList(ctx context.Context) ApiExtrasJobResultsListRequest {
	return ApiExtrasJobResultsListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ExtrasJobResultsList200Response
func (a *ExtrasApiService) ExtrasJobResultsListExecute(r ApiExtrasJobResultsListRequest) (*ExtrasJobResultsList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ExtrasJobResultsList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExtrasApiService.ExtrasJobResultsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extras/job-results/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.created != nil {
		localVarQueryParams.Add("created", parameterToString(*r.created, ""))
	}
	if r.completed != nil {
		localVarQueryParams.Add("completed", parameterToString(*r.completed, ""))
	}
	if r.status != nil {
		localVarQueryParams.Add("status", parameterToString(*r.status, ""))
	}
	if r.user != nil {
		localVarQueryParams.Add("user", parameterToString(*r.user, ""))
	}
	if r.objType != nil {
		localVarQueryParams.Add("obj_type", parameterToString(*r.objType, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.q != nil {
		localVarQueryParams.Add("q", parameterToString(*r.q, ""))
	}
	if r.idN != nil {
		localVarQueryParams.Add("id__n", parameterToString(*r.idN, ""))
	}
	if r.idLte != nil {
		localVarQueryParams.Add("id__lte", parameterToString(*r.idLte, ""))
	}
	if r.idLt != nil {
		localVarQueryParams.Add("id__lt", parameterToString(*r.idLt, ""))
	}
	if r.idGte != nil {
		localVarQueryParams.Add("id__gte", parameterToString(*r.idGte, ""))
	}
	if r.idGt != nil {
		localVarQueryParams.Add("id__gt", parameterToString(*r.idGt, ""))
	}
	if r.statusN != nil {
		localVarQueryParams.Add("status__n", parameterToString(*r.statusN, ""))
	}
	if r.userN != nil {
		localVarQueryParams.Add("user__n", parameterToString(*r.userN, ""))
	}
	if r.objTypeN != nil {
		localVarQueryParams.Add("obj_type__n", parameterToString(*r.objTypeN, ""))
	}
	if r.nameN != nil {
		localVarQueryParams.Add("name__n", parameterToString(*r.nameN, ""))
	}
	if r.nameIc != nil {
		localVarQueryParams.Add("name__ic", parameterToString(*r.nameIc, ""))
	}
	if r.nameNic != nil {
		localVarQueryParams.Add("name__nic", parameterToString(*r.nameNic, ""))
	}
	if r.nameIew != nil {
		localVarQueryParams.Add("name__iew", parameterToString(*r.nameIew, ""))
	}
	if r.nameNiew != nil {
		localVarQueryParams.Add("name__niew", parameterToString(*r.nameNiew, ""))
	}
	if r.nameIsw != nil {
		localVarQueryParams.Add("name__isw", parameterToString(*r.nameIsw, ""))
	}
	if r.nameNisw != nil {
		localVarQueryParams.Add("name__nisw", parameterToString(*r.nameNisw, ""))
	}
	if r.nameIe != nil {
		localVarQueryParams.Add("name__ie", parameterToString(*r.nameIe, ""))
	}
	if r.nameNie != nil {
		localVarQueryParams.Add("name__nie", parameterToString(*r.nameNie, ""))
	}
	if r.nameEmpty != nil {
		localVarQueryParams.Add("name__empty", parameterToString(*r.nameEmpty, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiExtrasJobResultsReadRequest struct {
	ctx context.Context
	ApiService *ExtrasApiService
	id int32
}

func (r ApiExtrasJobResultsReadRequest) Execute() (*JobResult, *http.Response, error) {
	return r.ApiService.ExtrasJobResultsReadExecute(r)
}

/*
ExtrasJobResultsRead Method for ExtrasJobResultsRead

Retrieve a list of job results

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this job result.
 @return ApiExtrasJobResultsReadRequest
*/
func (a *ExtrasApiService) ExtrasJobResultsRead(ctx context.Context, id int32) ApiExtrasJobResultsReadRequest {
	return ApiExtrasJobResultsReadRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return JobResult
func (a *ExtrasApiService) ExtrasJobResultsReadExecute(r ApiExtrasJobResultsReadRequest) (*JobResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *JobResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExtrasApiService.ExtrasJobResultsRead")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extras/job-results/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiExtrasJournalEntriesBulkDeleteRequest struct {
	ctx context.Context
	ApiService *ExtrasApiService
}

func (r ApiExtrasJournalEntriesBulkDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.ExtrasJournalEntriesBulkDeleteExecute(r)
}

/*
ExtrasJournalEntriesBulkDelete Method for ExtrasJournalEntriesBulkDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiExtrasJournalEntriesBulkDeleteRequest
*/
func (a *ExtrasApiService) ExtrasJournalEntriesBulkDelete(ctx context.Context) ApiExtrasJournalEntriesBulkDeleteRequest {
	return ApiExtrasJournalEntriesBulkDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ExtrasApiService) ExtrasJournalEntriesBulkDeleteExecute(r ApiExtrasJournalEntriesBulkDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExtrasApiService.ExtrasJournalEntriesBulkDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extras/journal-entries/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiExtrasJournalEntriesBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *ExtrasApiService
	data *WritableJournalEntry
}

func (r ApiExtrasJournalEntriesBulkPartialUpdateRequest) Data(data WritableJournalEntry) ApiExtrasJournalEntriesBulkPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiExtrasJournalEntriesBulkPartialUpdateRequest) Execute() (*JournalEntry, *http.Response, error) {
	return r.ApiService.ExtrasJournalEntriesBulkPartialUpdateExecute(r)
}

/*
ExtrasJournalEntriesBulkPartialUpdate Method for ExtrasJournalEntriesBulkPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiExtrasJournalEntriesBulkPartialUpdateRequest
*/
func (a *ExtrasApiService) ExtrasJournalEntriesBulkPartialUpdate(ctx context.Context) ApiExtrasJournalEntriesBulkPartialUpdateRequest {
	return ApiExtrasJournalEntriesBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return JournalEntry
func (a *ExtrasApiService) ExtrasJournalEntriesBulkPartialUpdateExecute(r ApiExtrasJournalEntriesBulkPartialUpdateRequest) (*JournalEntry, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *JournalEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExtrasApiService.ExtrasJournalEntriesBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extras/journal-entries/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiExtrasJournalEntriesBulkUpdateRequest struct {
	ctx context.Context
	ApiService *ExtrasApiService
	data *WritableJournalEntry
}

func (r ApiExtrasJournalEntriesBulkUpdateRequest) Data(data WritableJournalEntry) ApiExtrasJournalEntriesBulkUpdateRequest {
	r.data = &data
	return r
}

func (r ApiExtrasJournalEntriesBulkUpdateRequest) Execute() (*JournalEntry, *http.Response, error) {
	return r.ApiService.ExtrasJournalEntriesBulkUpdateExecute(r)
}

/*
ExtrasJournalEntriesBulkUpdate Method for ExtrasJournalEntriesBulkUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiExtrasJournalEntriesBulkUpdateRequest
*/
func (a *ExtrasApiService) ExtrasJournalEntriesBulkUpdate(ctx context.Context) ApiExtrasJournalEntriesBulkUpdateRequest {
	return ApiExtrasJournalEntriesBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return JournalEntry
func (a *ExtrasApiService) ExtrasJournalEntriesBulkUpdateExecute(r ApiExtrasJournalEntriesBulkUpdateRequest) (*JournalEntry, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *JournalEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExtrasApiService.ExtrasJournalEntriesBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extras/journal-entries/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiExtrasJournalEntriesCreateRequest struct {
	ctx context.Context
	ApiService *ExtrasApiService
	data *WritableJournalEntry
}

func (r ApiExtrasJournalEntriesCreateRequest) Data(data WritableJournalEntry) ApiExtrasJournalEntriesCreateRequest {
	r.data = &data
	return r
}

func (r ApiExtrasJournalEntriesCreateRequest) Execute() (*JournalEntry, *http.Response, error) {
	return r.ApiService.ExtrasJournalEntriesCreateExecute(r)
}

/*
ExtrasJournalEntriesCreate Method for ExtrasJournalEntriesCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiExtrasJournalEntriesCreateRequest
*/
func (a *ExtrasApiService) ExtrasJournalEntriesCreate(ctx context.Context) ApiExtrasJournalEntriesCreateRequest {
	return ApiExtrasJournalEntriesCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return JournalEntry
func (a *ExtrasApiService) ExtrasJournalEntriesCreateExecute(r ApiExtrasJournalEntriesCreateRequest) (*JournalEntry, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *JournalEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExtrasApiService.ExtrasJournalEntriesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extras/journal-entries/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiExtrasJournalEntriesDeleteRequest struct {
	ctx context.Context
	ApiService *ExtrasApiService
	id int32
}

func (r ApiExtrasJournalEntriesDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.ExtrasJournalEntriesDeleteExecute(r)
}

/*
ExtrasJournalEntriesDelete Method for ExtrasJournalEntriesDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this journal entry.
 @return ApiExtrasJournalEntriesDeleteRequest
*/
func (a *ExtrasApiService) ExtrasJournalEntriesDelete(ctx context.Context, id int32) ApiExtrasJournalEntriesDeleteRequest {
	return ApiExtrasJournalEntriesDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *ExtrasApiService) ExtrasJournalEntriesDeleteExecute(r ApiExtrasJournalEntriesDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExtrasApiService.ExtrasJournalEntriesDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extras/journal-entries/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiExtrasJournalEntriesListRequest struct {
	ctx context.Context
	ApiService *ExtrasApiService
	id *string
	assignedObjectTypeId *string
	assignedObjectId *string
	created *string
	kind *string
	createdGte *string
	createdLte *string
	lastUpdated *string
	lastUpdatedGte *string
	lastUpdatedLte *string
	q *string
	assignedObjectType *string
	createdById *string
	createdBy *string
	idN *string
	idLte *string
	idLt *string
	idGte *string
	idGt *string
	assignedObjectTypeIdN *string
	assignedObjectIdN *string
	assignedObjectIdLte *string
	assignedObjectIdLt *string
	assignedObjectIdGte *string
	assignedObjectIdGt *string
	kindN *string
	assignedObjectTypeN *string
	createdByIdN *string
	createdByN *string
	limit *int32
	offset *int32
}

func (r ApiExtrasJournalEntriesListRequest) Id(id string) ApiExtrasJournalEntriesListRequest {
	r.id = &id
	return r
}

func (r ApiExtrasJournalEntriesListRequest) AssignedObjectTypeId(assignedObjectTypeId string) ApiExtrasJournalEntriesListRequest {
	r.assignedObjectTypeId = &assignedObjectTypeId
	return r
}

func (r ApiExtrasJournalEntriesListRequest) AssignedObjectId(assignedObjectId string) ApiExtrasJournalEntriesListRequest {
	r.assignedObjectId = &assignedObjectId
	return r
}

func (r ApiExtrasJournalEntriesListRequest) Created(created string) ApiExtrasJournalEntriesListRequest {
	r.created = &created
	return r
}

func (r ApiExtrasJournalEntriesListRequest) Kind(kind string) ApiExtrasJournalEntriesListRequest {
	r.kind = &kind
	return r
}

func (r ApiExtrasJournalEntriesListRequest) CreatedGte(createdGte string) ApiExtrasJournalEntriesListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiExtrasJournalEntriesListRequest) CreatedLte(createdLte string) ApiExtrasJournalEntriesListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiExtrasJournalEntriesListRequest) LastUpdated(lastUpdated string) ApiExtrasJournalEntriesListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiExtrasJournalEntriesListRequest) LastUpdatedGte(lastUpdatedGte string) ApiExtrasJournalEntriesListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiExtrasJournalEntriesListRequest) LastUpdatedLte(lastUpdatedLte string) ApiExtrasJournalEntriesListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiExtrasJournalEntriesListRequest) Q(q string) ApiExtrasJournalEntriesListRequest {
	r.q = &q
	return r
}

func (r ApiExtrasJournalEntriesListRequest) AssignedObjectType(assignedObjectType string) ApiExtrasJournalEntriesListRequest {
	r.assignedObjectType = &assignedObjectType
	return r
}

func (r ApiExtrasJournalEntriesListRequest) CreatedById(createdById string) ApiExtrasJournalEntriesListRequest {
	r.createdById = &createdById
	return r
}

func (r ApiExtrasJournalEntriesListRequest) CreatedBy(createdBy string) ApiExtrasJournalEntriesListRequest {
	r.createdBy = &createdBy
	return r
}

func (r ApiExtrasJournalEntriesListRequest) IdN(idN string) ApiExtrasJournalEntriesListRequest {
	r.idN = &idN
	return r
}

func (r ApiExtrasJournalEntriesListRequest) IdLte(idLte string) ApiExtrasJournalEntriesListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiExtrasJournalEntriesListRequest) IdLt(idLt string) ApiExtrasJournalEntriesListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiExtrasJournalEntriesListRequest) IdGte(idGte string) ApiExtrasJournalEntriesListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiExtrasJournalEntriesListRequest) IdGt(idGt string) ApiExtrasJournalEntriesListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiExtrasJournalEntriesListRequest) AssignedObjectTypeIdN(assignedObjectTypeIdN string) ApiExtrasJournalEntriesListRequest {
	r.assignedObjectTypeIdN = &assignedObjectTypeIdN
	return r
}

func (r ApiExtrasJournalEntriesListRequest) AssignedObjectIdN(assignedObjectIdN string) ApiExtrasJournalEntriesListRequest {
	r.assignedObjectIdN = &assignedObjectIdN
	return r
}

func (r ApiExtrasJournalEntriesListRequest) AssignedObjectIdLte(assignedObjectIdLte string) ApiExtrasJournalEntriesListRequest {
	r.assignedObjectIdLte = &assignedObjectIdLte
	return r
}

func (r ApiExtrasJournalEntriesListRequest) AssignedObjectIdLt(assignedObjectIdLt string) ApiExtrasJournalEntriesListRequest {
	r.assignedObjectIdLt = &assignedObjectIdLt
	return r
}

func (r ApiExtrasJournalEntriesListRequest) AssignedObjectIdGte(assignedObjectIdGte string) ApiExtrasJournalEntriesListRequest {
	r.assignedObjectIdGte = &assignedObjectIdGte
	return r
}

func (r ApiExtrasJournalEntriesListRequest) AssignedObjectIdGt(assignedObjectIdGt string) ApiExtrasJournalEntriesListRequest {
	r.assignedObjectIdGt = &assignedObjectIdGt
	return r
}

func (r ApiExtrasJournalEntriesListRequest) KindN(kindN string) ApiExtrasJournalEntriesListRequest {
	r.kindN = &kindN
	return r
}

func (r ApiExtrasJournalEntriesListRequest) AssignedObjectTypeN(assignedObjectTypeN string) ApiExtrasJournalEntriesListRequest {
	r.assignedObjectTypeN = &assignedObjectTypeN
	return r
}

func (r ApiExtrasJournalEntriesListRequest) CreatedByIdN(createdByIdN string) ApiExtrasJournalEntriesListRequest {
	r.createdByIdN = &createdByIdN
	return r
}

func (r ApiExtrasJournalEntriesListRequest) CreatedByN(createdByN string) ApiExtrasJournalEntriesListRequest {
	r.createdByN = &createdByN
	return r
}

// Number of results to return per page.
func (r ApiExtrasJournalEntriesListRequest) Limit(limit int32) ApiExtrasJournalEntriesListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiExtrasJournalEntriesListRequest) Offset(offset int32) ApiExtrasJournalEntriesListRequest {
	r.offset = &offset
	return r
}

func (r ApiExtrasJournalEntriesListRequest) Execute() (*ExtrasJournalEntriesList200Response, *http.Response, error) {
	return r.ApiService.ExtrasJournalEntriesListExecute(r)
}

/*
ExtrasJournalEntriesList Method for ExtrasJournalEntriesList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiExtrasJournalEntriesListRequest
*/
func (a *ExtrasApiService) ExtrasJournalEntriesList(ctx context.Context) ApiExtrasJournalEntriesListRequest {
	return ApiExtrasJournalEntriesListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ExtrasJournalEntriesList200Response
func (a *ExtrasApiService) ExtrasJournalEntriesListExecute(r ApiExtrasJournalEntriesListRequest) (*ExtrasJournalEntriesList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ExtrasJournalEntriesList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExtrasApiService.ExtrasJournalEntriesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extras/journal-entries/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.assignedObjectTypeId != nil {
		localVarQueryParams.Add("assigned_object_type_id", parameterToString(*r.assignedObjectTypeId, ""))
	}
	if r.assignedObjectId != nil {
		localVarQueryParams.Add("assigned_object_id", parameterToString(*r.assignedObjectId, ""))
	}
	if r.created != nil {
		localVarQueryParams.Add("created", parameterToString(*r.created, ""))
	}
	if r.kind != nil {
		localVarQueryParams.Add("kind", parameterToString(*r.kind, ""))
	}
	if r.createdGte != nil {
		localVarQueryParams.Add("created__gte", parameterToString(*r.createdGte, ""))
	}
	if r.createdLte != nil {
		localVarQueryParams.Add("created__lte", parameterToString(*r.createdLte, ""))
	}
	if r.lastUpdated != nil {
		localVarQueryParams.Add("last_updated", parameterToString(*r.lastUpdated, ""))
	}
	if r.lastUpdatedGte != nil {
		localVarQueryParams.Add("last_updated__gte", parameterToString(*r.lastUpdatedGte, ""))
	}
	if r.lastUpdatedLte != nil {
		localVarQueryParams.Add("last_updated__lte", parameterToString(*r.lastUpdatedLte, ""))
	}
	if r.q != nil {
		localVarQueryParams.Add("q", parameterToString(*r.q, ""))
	}
	if r.assignedObjectType != nil {
		localVarQueryParams.Add("assigned_object_type", parameterToString(*r.assignedObjectType, ""))
	}
	if r.createdById != nil {
		localVarQueryParams.Add("created_by_id", parameterToString(*r.createdById, ""))
	}
	if r.createdBy != nil {
		localVarQueryParams.Add("created_by", parameterToString(*r.createdBy, ""))
	}
	if r.idN != nil {
		localVarQueryParams.Add("id__n", parameterToString(*r.idN, ""))
	}
	if r.idLte != nil {
		localVarQueryParams.Add("id__lte", parameterToString(*r.idLte, ""))
	}
	if r.idLt != nil {
		localVarQueryParams.Add("id__lt", parameterToString(*r.idLt, ""))
	}
	if r.idGte != nil {
		localVarQueryParams.Add("id__gte", parameterToString(*r.idGte, ""))
	}
	if r.idGt != nil {
		localVarQueryParams.Add("id__gt", parameterToString(*r.idGt, ""))
	}
	if r.assignedObjectTypeIdN != nil {
		localVarQueryParams.Add("assigned_object_type_id__n", parameterToString(*r.assignedObjectTypeIdN, ""))
	}
	if r.assignedObjectIdN != nil {
		localVarQueryParams.Add("assigned_object_id__n", parameterToString(*r.assignedObjectIdN, ""))
	}
	if r.assignedObjectIdLte != nil {
		localVarQueryParams.Add("assigned_object_id__lte", parameterToString(*r.assignedObjectIdLte, ""))
	}
	if r.assignedObjectIdLt != nil {
		localVarQueryParams.Add("assigned_object_id__lt", parameterToString(*r.assignedObjectIdLt, ""))
	}
	if r.assignedObjectIdGte != nil {
		localVarQueryParams.Add("assigned_object_id__gte", parameterToString(*r.assignedObjectIdGte, ""))
	}
	if r.assignedObjectIdGt != nil {
		localVarQueryParams.Add("assigned_object_id__gt", parameterToString(*r.assignedObjectIdGt, ""))
	}
	if r.kindN != nil {
		localVarQueryParams.Add("kind__n", parameterToString(*r.kindN, ""))
	}
	if r.assignedObjectTypeN != nil {
		localVarQueryParams.Add("assigned_object_type__n", parameterToString(*r.assignedObjectTypeN, ""))
	}
	if r.createdByIdN != nil {
		localVarQueryParams.Add("created_by_id__n", parameterToString(*r.createdByIdN, ""))
	}
	if r.createdByN != nil {
		localVarQueryParams.Add("created_by__n", parameterToString(*r.createdByN, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiExtrasJournalEntriesPartialUpdateRequest struct {
	ctx context.Context
	ApiService *ExtrasApiService
	id int32
	data *WritableJournalEntry
}

func (r ApiExtrasJournalEntriesPartialUpdateRequest) Data(data WritableJournalEntry) ApiExtrasJournalEntriesPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiExtrasJournalEntriesPartialUpdateRequest) Execute() (*JournalEntry, *http.Response, error) {
	return r.ApiService.ExtrasJournalEntriesPartialUpdateExecute(r)
}

/*
ExtrasJournalEntriesPartialUpdate Method for ExtrasJournalEntriesPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this journal entry.
 @return ApiExtrasJournalEntriesPartialUpdateRequest
*/
func (a *ExtrasApiService) ExtrasJournalEntriesPartialUpdate(ctx context.Context, id int32) ApiExtrasJournalEntriesPartialUpdateRequest {
	return ApiExtrasJournalEntriesPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return JournalEntry
func (a *ExtrasApiService) ExtrasJournalEntriesPartialUpdateExecute(r ApiExtrasJournalEntriesPartialUpdateRequest) (*JournalEntry, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *JournalEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExtrasApiService.ExtrasJournalEntriesPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extras/journal-entries/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiExtrasJournalEntriesReadRequest struct {
	ctx context.Context
	ApiService *ExtrasApiService
	id int32
}

func (r ApiExtrasJournalEntriesReadRequest) Execute() (*JournalEntry, *http.Response, error) {
	return r.ApiService.ExtrasJournalEntriesReadExecute(r)
}

/*
ExtrasJournalEntriesRead Method for ExtrasJournalEntriesRead

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this journal entry.
 @return ApiExtrasJournalEntriesReadRequest
*/
func (a *ExtrasApiService) ExtrasJournalEntriesRead(ctx context.Context, id int32) ApiExtrasJournalEntriesReadRequest {
	return ApiExtrasJournalEntriesReadRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return JournalEntry
func (a *ExtrasApiService) ExtrasJournalEntriesReadExecute(r ApiExtrasJournalEntriesReadRequest) (*JournalEntry, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *JournalEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExtrasApiService.ExtrasJournalEntriesRead")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extras/journal-entries/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiExtrasJournalEntriesUpdateRequest struct {
	ctx context.Context
	ApiService *ExtrasApiService
	id int32
	data *WritableJournalEntry
}

func (r ApiExtrasJournalEntriesUpdateRequest) Data(data WritableJournalEntry) ApiExtrasJournalEntriesUpdateRequest {
	r.data = &data
	return r
}

func (r ApiExtrasJournalEntriesUpdateRequest) Execute() (*JournalEntry, *http.Response, error) {
	return r.ApiService.ExtrasJournalEntriesUpdateExecute(r)
}

/*
ExtrasJournalEntriesUpdate Method for ExtrasJournalEntriesUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this journal entry.
 @return ApiExtrasJournalEntriesUpdateRequest
*/
func (a *ExtrasApiService) ExtrasJournalEntriesUpdate(ctx context.Context, id int32) ApiExtrasJournalEntriesUpdateRequest {
	return ApiExtrasJournalEntriesUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return JournalEntry
func (a *ExtrasApiService) ExtrasJournalEntriesUpdateExecute(r ApiExtrasJournalEntriesUpdateRequest) (*JournalEntry, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *JournalEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExtrasApiService.ExtrasJournalEntriesUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extras/journal-entries/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiExtrasObjectChangesListRequest struct {
	ctx context.Context
	ApiService *ExtrasApiService
	id *string
	user *string
	userName *string
	requestId *string
	action *string
	changedObjectTypeId *string
	changedObjectId *string
	objectRepr *string
	q *string
	time *string
	changedObjectType *string
	userId *string
	idN *string
	idLte *string
	idLt *string
	idGte *string
	idGt *string
	userN *string
	userNameN *string
	userNameIc *string
	userNameNic *string
	userNameIew *string
	userNameNiew *string
	userNameIsw *string
	userNameNisw *string
	userNameIe *string
	userNameNie *string
	userNameEmpty *string
	actionN *string
	changedObjectTypeIdN *string
	changedObjectIdN *string
	changedObjectIdLte *string
	changedObjectIdLt *string
	changedObjectIdGte *string
	changedObjectIdGt *string
	objectReprN *string
	objectReprIc *string
	objectReprNic *string
	objectReprIew *string
	objectReprNiew *string
	objectReprIsw *string
	objectReprNisw *string
	objectReprIe *string
	objectReprNie *string
	objectReprEmpty *string
	changedObjectTypeN *string
	userIdN *string
	limit *int32
	offset *int32
}

func (r ApiExtrasObjectChangesListRequest) Id(id string) ApiExtrasObjectChangesListRequest {
	r.id = &id
	return r
}

func (r ApiExtrasObjectChangesListRequest) User(user string) ApiExtrasObjectChangesListRequest {
	r.user = &user
	return r
}

func (r ApiExtrasObjectChangesListRequest) UserName(userName string) ApiExtrasObjectChangesListRequest {
	r.userName = &userName
	return r
}

func (r ApiExtrasObjectChangesListRequest) RequestId(requestId string) ApiExtrasObjectChangesListRequest {
	r.requestId = &requestId
	return r
}

func (r ApiExtrasObjectChangesListRequest) Action(action string) ApiExtrasObjectChangesListRequest {
	r.action = &action
	return r
}

func (r ApiExtrasObjectChangesListRequest) ChangedObjectTypeId(changedObjectTypeId string) ApiExtrasObjectChangesListRequest {
	r.changedObjectTypeId = &changedObjectTypeId
	return r
}

func (r ApiExtrasObjectChangesListRequest) ChangedObjectId(changedObjectId string) ApiExtrasObjectChangesListRequest {
	r.changedObjectId = &changedObjectId
	return r
}

func (r ApiExtrasObjectChangesListRequest) ObjectRepr(objectRepr string) ApiExtrasObjectChangesListRequest {
	r.objectRepr = &objectRepr
	return r
}

func (r ApiExtrasObjectChangesListRequest) Q(q string) ApiExtrasObjectChangesListRequest {
	r.q = &q
	return r
}

func (r ApiExtrasObjectChangesListRequest) Time(time string) ApiExtrasObjectChangesListRequest {
	r.time = &time
	return r
}

func (r ApiExtrasObjectChangesListRequest) ChangedObjectType(changedObjectType string) ApiExtrasObjectChangesListRequest {
	r.changedObjectType = &changedObjectType
	return r
}

func (r ApiExtrasObjectChangesListRequest) UserId(userId string) ApiExtrasObjectChangesListRequest {
	r.userId = &userId
	return r
}

func (r ApiExtrasObjectChangesListRequest) IdN(idN string) ApiExtrasObjectChangesListRequest {
	r.idN = &idN
	return r
}

func (r ApiExtrasObjectChangesListRequest) IdLte(idLte string) ApiExtrasObjectChangesListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiExtrasObjectChangesListRequest) IdLt(idLt string) ApiExtrasObjectChangesListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiExtrasObjectChangesListRequest) IdGte(idGte string) ApiExtrasObjectChangesListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiExtrasObjectChangesListRequest) IdGt(idGt string) ApiExtrasObjectChangesListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiExtrasObjectChangesListRequest) UserN(userN string) ApiExtrasObjectChangesListRequest {
	r.userN = &userN
	return r
}

func (r ApiExtrasObjectChangesListRequest) UserNameN(userNameN string) ApiExtrasObjectChangesListRequest {
	r.userNameN = &userNameN
	return r
}

func (r ApiExtrasObjectChangesListRequest) UserNameIc(userNameIc string) ApiExtrasObjectChangesListRequest {
	r.userNameIc = &userNameIc
	return r
}

func (r ApiExtrasObjectChangesListRequest) UserNameNic(userNameNic string) ApiExtrasObjectChangesListRequest {
	r.userNameNic = &userNameNic
	return r
}

func (r ApiExtrasObjectChangesListRequest) UserNameIew(userNameIew string) ApiExtrasObjectChangesListRequest {
	r.userNameIew = &userNameIew
	return r
}

func (r ApiExtrasObjectChangesListRequest) UserNameNiew(userNameNiew string) ApiExtrasObjectChangesListRequest {
	r.userNameNiew = &userNameNiew
	return r
}

func (r ApiExtrasObjectChangesListRequest) UserNameIsw(userNameIsw string) ApiExtrasObjectChangesListRequest {
	r.userNameIsw = &userNameIsw
	return r
}

func (r ApiExtrasObjectChangesListRequest) UserNameNisw(userNameNisw string) ApiExtrasObjectChangesListRequest {
	r.userNameNisw = &userNameNisw
	return r
}

func (r ApiExtrasObjectChangesListRequest) UserNameIe(userNameIe string) ApiExtrasObjectChangesListRequest {
	r.userNameIe = &userNameIe
	return r
}

func (r ApiExtrasObjectChangesListRequest) UserNameNie(userNameNie string) ApiExtrasObjectChangesListRequest {
	r.userNameNie = &userNameNie
	return r
}

func (r ApiExtrasObjectChangesListRequest) UserNameEmpty(userNameEmpty string) ApiExtrasObjectChangesListRequest {
	r.userNameEmpty = &userNameEmpty
	return r
}

func (r ApiExtrasObjectChangesListRequest) ActionN(actionN string) ApiExtrasObjectChangesListRequest {
	r.actionN = &actionN
	return r
}

func (r ApiExtrasObjectChangesListRequest) ChangedObjectTypeIdN(changedObjectTypeIdN string) ApiExtrasObjectChangesListRequest {
	r.changedObjectTypeIdN = &changedObjectTypeIdN
	return r
}

func (r ApiExtrasObjectChangesListRequest) ChangedObjectIdN(changedObjectIdN string) ApiExtrasObjectChangesListRequest {
	r.changedObjectIdN = &changedObjectIdN
	return r
}

func (r ApiExtrasObjectChangesListRequest) ChangedObjectIdLte(changedObjectIdLte string) ApiExtrasObjectChangesListRequest {
	r.changedObjectIdLte = &changedObjectIdLte
	return r
}

func (r ApiExtrasObjectChangesListRequest) ChangedObjectIdLt(changedObjectIdLt string) ApiExtrasObjectChangesListRequest {
	r.changedObjectIdLt = &changedObjectIdLt
	return r
}

func (r ApiExtrasObjectChangesListRequest) ChangedObjectIdGte(changedObjectIdGte string) ApiExtrasObjectChangesListRequest {
	r.changedObjectIdGte = &changedObjectIdGte
	return r
}

func (r ApiExtrasObjectChangesListRequest) ChangedObjectIdGt(changedObjectIdGt string) ApiExtrasObjectChangesListRequest {
	r.changedObjectIdGt = &changedObjectIdGt
	return r
}

func (r ApiExtrasObjectChangesListRequest) ObjectReprN(objectReprN string) ApiExtrasObjectChangesListRequest {
	r.objectReprN = &objectReprN
	return r
}

func (r ApiExtrasObjectChangesListRequest) ObjectReprIc(objectReprIc string) ApiExtrasObjectChangesListRequest {
	r.objectReprIc = &objectReprIc
	return r
}

func (r ApiExtrasObjectChangesListRequest) ObjectReprNic(objectReprNic string) ApiExtrasObjectChangesListRequest {
	r.objectReprNic = &objectReprNic
	return r
}

func (r ApiExtrasObjectChangesListRequest) ObjectReprIew(objectReprIew string) ApiExtrasObjectChangesListRequest {
	r.objectReprIew = &objectReprIew
	return r
}

func (r ApiExtrasObjectChangesListRequest) ObjectReprNiew(objectReprNiew string) ApiExtrasObjectChangesListRequest {
	r.objectReprNiew = &objectReprNiew
	return r
}

func (r ApiExtrasObjectChangesListRequest) ObjectReprIsw(objectReprIsw string) ApiExtrasObjectChangesListRequest {
	r.objectReprIsw = &objectReprIsw
	return r
}

func (r ApiExtrasObjectChangesListRequest) ObjectReprNisw(objectReprNisw string) ApiExtrasObjectChangesListRequest {
	r.objectReprNisw = &objectReprNisw
	return r
}

func (r ApiExtrasObjectChangesListRequest) ObjectReprIe(objectReprIe string) ApiExtrasObjectChangesListRequest {
	r.objectReprIe = &objectReprIe
	return r
}

func (r ApiExtrasObjectChangesListRequest) ObjectReprNie(objectReprNie string) ApiExtrasObjectChangesListRequest {
	r.objectReprNie = &objectReprNie
	return r
}

func (r ApiExtrasObjectChangesListRequest) ObjectReprEmpty(objectReprEmpty string) ApiExtrasObjectChangesListRequest {
	r.objectReprEmpty = &objectReprEmpty
	return r
}

func (r ApiExtrasObjectChangesListRequest) ChangedObjectTypeN(changedObjectTypeN string) ApiExtrasObjectChangesListRequest {
	r.changedObjectTypeN = &changedObjectTypeN
	return r
}

func (r ApiExtrasObjectChangesListRequest) UserIdN(userIdN string) ApiExtrasObjectChangesListRequest {
	r.userIdN = &userIdN
	return r
}

// Number of results to return per page.
func (r ApiExtrasObjectChangesListRequest) Limit(limit int32) ApiExtrasObjectChangesListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiExtrasObjectChangesListRequest) Offset(offset int32) ApiExtrasObjectChangesListRequest {
	r.offset = &offset
	return r
}

func (r ApiExtrasObjectChangesListRequest) Execute() (*ExtrasObjectChangesList200Response, *http.Response, error) {
	return r.ApiService.ExtrasObjectChangesListExecute(r)
}

/*
ExtrasObjectChangesList Method for ExtrasObjectChangesList

Retrieve a list of recent changes.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiExtrasObjectChangesListRequest
*/
func (a *ExtrasApiService) ExtrasObjectChangesList(ctx context.Context) ApiExtrasObjectChangesListRequest {
	return ApiExtrasObjectChangesListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ExtrasObjectChangesList200Response
func (a *ExtrasApiService) ExtrasObjectChangesListExecute(r ApiExtrasObjectChangesListRequest) (*ExtrasObjectChangesList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ExtrasObjectChangesList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExtrasApiService.ExtrasObjectChangesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extras/object-changes/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.user != nil {
		localVarQueryParams.Add("user", parameterToString(*r.user, ""))
	}
	if r.userName != nil {
		localVarQueryParams.Add("user_name", parameterToString(*r.userName, ""))
	}
	if r.requestId != nil {
		localVarQueryParams.Add("request_id", parameterToString(*r.requestId, ""))
	}
	if r.action != nil {
		localVarQueryParams.Add("action", parameterToString(*r.action, ""))
	}
	if r.changedObjectTypeId != nil {
		localVarQueryParams.Add("changed_object_type_id", parameterToString(*r.changedObjectTypeId, ""))
	}
	if r.changedObjectId != nil {
		localVarQueryParams.Add("changed_object_id", parameterToString(*r.changedObjectId, ""))
	}
	if r.objectRepr != nil {
		localVarQueryParams.Add("object_repr", parameterToString(*r.objectRepr, ""))
	}
	if r.q != nil {
		localVarQueryParams.Add("q", parameterToString(*r.q, ""))
	}
	if r.time != nil {
		localVarQueryParams.Add("time", parameterToString(*r.time, ""))
	}
	if r.changedObjectType != nil {
		localVarQueryParams.Add("changed_object_type", parameterToString(*r.changedObjectType, ""))
	}
	if r.userId != nil {
		localVarQueryParams.Add("user_id", parameterToString(*r.userId, ""))
	}
	if r.idN != nil {
		localVarQueryParams.Add("id__n", parameterToString(*r.idN, ""))
	}
	if r.idLte != nil {
		localVarQueryParams.Add("id__lte", parameterToString(*r.idLte, ""))
	}
	if r.idLt != nil {
		localVarQueryParams.Add("id__lt", parameterToString(*r.idLt, ""))
	}
	if r.idGte != nil {
		localVarQueryParams.Add("id__gte", parameterToString(*r.idGte, ""))
	}
	if r.idGt != nil {
		localVarQueryParams.Add("id__gt", parameterToString(*r.idGt, ""))
	}
	if r.userN != nil {
		localVarQueryParams.Add("user__n", parameterToString(*r.userN, ""))
	}
	if r.userNameN != nil {
		localVarQueryParams.Add("user_name__n", parameterToString(*r.userNameN, ""))
	}
	if r.userNameIc != nil {
		localVarQueryParams.Add("user_name__ic", parameterToString(*r.userNameIc, ""))
	}
	if r.userNameNic != nil {
		localVarQueryParams.Add("user_name__nic", parameterToString(*r.userNameNic, ""))
	}
	if r.userNameIew != nil {
		localVarQueryParams.Add("user_name__iew", parameterToString(*r.userNameIew, ""))
	}
	if r.userNameNiew != nil {
		localVarQueryParams.Add("user_name__niew", parameterToString(*r.userNameNiew, ""))
	}
	if r.userNameIsw != nil {
		localVarQueryParams.Add("user_name__isw", parameterToString(*r.userNameIsw, ""))
	}
	if r.userNameNisw != nil {
		localVarQueryParams.Add("user_name__nisw", parameterToString(*r.userNameNisw, ""))
	}
	if r.userNameIe != nil {
		localVarQueryParams.Add("user_name__ie", parameterToString(*r.userNameIe, ""))
	}
	if r.userNameNie != nil {
		localVarQueryParams.Add("user_name__nie", parameterToString(*r.userNameNie, ""))
	}
	if r.userNameEmpty != nil {
		localVarQueryParams.Add("user_name__empty", parameterToString(*r.userNameEmpty, ""))
	}
	if r.actionN != nil {
		localVarQueryParams.Add("action__n", parameterToString(*r.actionN, ""))
	}
	if r.changedObjectTypeIdN != nil {
		localVarQueryParams.Add("changed_object_type_id__n", parameterToString(*r.changedObjectTypeIdN, ""))
	}
	if r.changedObjectIdN != nil {
		localVarQueryParams.Add("changed_object_id__n", parameterToString(*r.changedObjectIdN, ""))
	}
	if r.changedObjectIdLte != nil {
		localVarQueryParams.Add("changed_object_id__lte", parameterToString(*r.changedObjectIdLte, ""))
	}
	if r.changedObjectIdLt != nil {
		localVarQueryParams.Add("changed_object_id__lt", parameterToString(*r.changedObjectIdLt, ""))
	}
	if r.changedObjectIdGte != nil {
		localVarQueryParams.Add("changed_object_id__gte", parameterToString(*r.changedObjectIdGte, ""))
	}
	if r.changedObjectIdGt != nil {
		localVarQueryParams.Add("changed_object_id__gt", parameterToString(*r.changedObjectIdGt, ""))
	}
	if r.objectReprN != nil {
		localVarQueryParams.Add("object_repr__n", parameterToString(*r.objectReprN, ""))
	}
	if r.objectReprIc != nil {
		localVarQueryParams.Add("object_repr__ic", parameterToString(*r.objectReprIc, ""))
	}
	if r.objectReprNic != nil {
		localVarQueryParams.Add("object_repr__nic", parameterToString(*r.objectReprNic, ""))
	}
	if r.objectReprIew != nil {
		localVarQueryParams.Add("object_repr__iew", parameterToString(*r.objectReprIew, ""))
	}
	if r.objectReprNiew != nil {
		localVarQueryParams.Add("object_repr__niew", parameterToString(*r.objectReprNiew, ""))
	}
	if r.objectReprIsw != nil {
		localVarQueryParams.Add("object_repr__isw", parameterToString(*r.objectReprIsw, ""))
	}
	if r.objectReprNisw != nil {
		localVarQueryParams.Add("object_repr__nisw", parameterToString(*r.objectReprNisw, ""))
	}
	if r.objectReprIe != nil {
		localVarQueryParams.Add("object_repr__ie", parameterToString(*r.objectReprIe, ""))
	}
	if r.objectReprNie != nil {
		localVarQueryParams.Add("object_repr__nie", parameterToString(*r.objectReprNie, ""))
	}
	if r.objectReprEmpty != nil {
		localVarQueryParams.Add("object_repr__empty", parameterToString(*r.objectReprEmpty, ""))
	}
	if r.changedObjectTypeN != nil {
		localVarQueryParams.Add("changed_object_type__n", parameterToString(*r.changedObjectTypeN, ""))
	}
	if r.userIdN != nil {
		localVarQueryParams.Add("user_id__n", parameterToString(*r.userIdN, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiExtrasObjectChangesReadRequest struct {
	ctx context.Context
	ApiService *ExtrasApiService
	id int32
}

func (r ApiExtrasObjectChangesReadRequest) Execute() (*ObjectChange, *http.Response, error) {
	return r.ApiService.ExtrasObjectChangesReadExecute(r)
}

/*
ExtrasObjectChangesRead Method for ExtrasObjectChangesRead

Retrieve a list of recent changes.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this object change.
 @return ApiExtrasObjectChangesReadRequest
*/
func (a *ExtrasApiService) ExtrasObjectChangesRead(ctx context.Context, id int32) ApiExtrasObjectChangesReadRequest {
	return ApiExtrasObjectChangesReadRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ObjectChange
func (a *ExtrasApiService) ExtrasObjectChangesReadExecute(r ApiExtrasObjectChangesReadRequest) (*ObjectChange, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ObjectChange
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExtrasApiService.ExtrasObjectChangesRead")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extras/object-changes/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiExtrasReportsListRequest struct {
	ctx context.Context
	ApiService *ExtrasApiService
}

func (r ApiExtrasReportsListRequest) Execute() (*http.Response, error) {
	return r.ApiService.ExtrasReportsListExecute(r)
}

/*
ExtrasReportsList Method for ExtrasReportsList

Compile all reports and their related results (if any). Result data is deferred in the list view.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiExtrasReportsListRequest
*/
func (a *ExtrasApiService) ExtrasReportsList(ctx context.Context) ApiExtrasReportsListRequest {
	return ApiExtrasReportsListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ExtrasApiService) ExtrasReportsListExecute(r ApiExtrasReportsListRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExtrasApiService.ExtrasReportsList")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extras/reports/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiExtrasReportsReadRequest struct {
	ctx context.Context
	ApiService *ExtrasApiService
	id string
}

func (r ApiExtrasReportsReadRequest) Execute() (*http.Response, error) {
	return r.ApiService.ExtrasReportsReadExecute(r)
}

/*
ExtrasReportsRead Method for ExtrasReportsRead

Retrieve a single Report identified as "<module>.<report>".

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiExtrasReportsReadRequest
*/
func (a *ExtrasApiService) ExtrasReportsRead(ctx context.Context, id string) ApiExtrasReportsReadRequest {
	return ApiExtrasReportsReadRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *ExtrasApiService) ExtrasReportsReadExecute(r ApiExtrasReportsReadRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExtrasApiService.ExtrasReportsRead")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extras/reports/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiExtrasReportsRunRequest struct {
	ctx context.Context
	ApiService *ExtrasApiService
	id string
}

func (r ApiExtrasReportsRunRequest) Execute() (*http.Response, error) {
	return r.ApiService.ExtrasReportsRunExecute(r)
}

/*
ExtrasReportsRun Method for ExtrasReportsRun

Run a Report identified as "<module>.<script>" and return the pending JobResult as the result

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiExtrasReportsRunRequest
*/
func (a *ExtrasApiService) ExtrasReportsRun(ctx context.Context, id string) ApiExtrasReportsRunRequest {
	return ApiExtrasReportsRunRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *ExtrasApiService) ExtrasReportsRunExecute(r ApiExtrasReportsRunRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExtrasApiService.ExtrasReportsRun")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extras/reports/{id}/run/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiExtrasScriptsListRequest struct {
	ctx context.Context
	ApiService *ExtrasApiService
}

func (r ApiExtrasScriptsListRequest) Execute() (*http.Response, error) {
	return r.ApiService.ExtrasScriptsListExecute(r)
}

/*
ExtrasScriptsList Method for ExtrasScriptsList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiExtrasScriptsListRequest
*/
func (a *ExtrasApiService) ExtrasScriptsList(ctx context.Context) ApiExtrasScriptsListRequest {
	return ApiExtrasScriptsListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ExtrasApiService) ExtrasScriptsListExecute(r ApiExtrasScriptsListRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExtrasApiService.ExtrasScriptsList")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extras/scripts/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiExtrasScriptsReadRequest struct {
	ctx context.Context
	ApiService *ExtrasApiService
	id string
}

func (r ApiExtrasScriptsReadRequest) Execute() (*http.Response, error) {
	return r.ApiService.ExtrasScriptsReadExecute(r)
}

/*
ExtrasScriptsRead Method for ExtrasScriptsRead

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiExtrasScriptsReadRequest
*/
func (a *ExtrasApiService) ExtrasScriptsRead(ctx context.Context, id string) ApiExtrasScriptsReadRequest {
	return ApiExtrasScriptsReadRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *ExtrasApiService) ExtrasScriptsReadExecute(r ApiExtrasScriptsReadRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExtrasApiService.ExtrasScriptsRead")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extras/scripts/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiExtrasTagsBulkDeleteRequest struct {
	ctx context.Context
	ApiService *ExtrasApiService
}

func (r ApiExtrasTagsBulkDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.ExtrasTagsBulkDeleteExecute(r)
}

/*
ExtrasTagsBulkDelete Method for ExtrasTagsBulkDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiExtrasTagsBulkDeleteRequest
*/
func (a *ExtrasApiService) ExtrasTagsBulkDelete(ctx context.Context) ApiExtrasTagsBulkDeleteRequest {
	return ApiExtrasTagsBulkDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ExtrasApiService) ExtrasTagsBulkDeleteExecute(r ApiExtrasTagsBulkDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExtrasApiService.ExtrasTagsBulkDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extras/tags/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiExtrasTagsBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *ExtrasApiService
	data *Tag
}

func (r ApiExtrasTagsBulkPartialUpdateRequest) Data(data Tag) ApiExtrasTagsBulkPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiExtrasTagsBulkPartialUpdateRequest) Execute() (*Tag, *http.Response, error) {
	return r.ApiService.ExtrasTagsBulkPartialUpdateExecute(r)
}

/*
ExtrasTagsBulkPartialUpdate Method for ExtrasTagsBulkPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiExtrasTagsBulkPartialUpdateRequest
*/
func (a *ExtrasApiService) ExtrasTagsBulkPartialUpdate(ctx context.Context) ApiExtrasTagsBulkPartialUpdateRequest {
	return ApiExtrasTagsBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Tag
func (a *ExtrasApiService) ExtrasTagsBulkPartialUpdateExecute(r ApiExtrasTagsBulkPartialUpdateRequest) (*Tag, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Tag
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExtrasApiService.ExtrasTagsBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extras/tags/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiExtrasTagsBulkUpdateRequest struct {
	ctx context.Context
	ApiService *ExtrasApiService
	data *Tag
}

func (r ApiExtrasTagsBulkUpdateRequest) Data(data Tag) ApiExtrasTagsBulkUpdateRequest {
	r.data = &data
	return r
}

func (r ApiExtrasTagsBulkUpdateRequest) Execute() (*Tag, *http.Response, error) {
	return r.ApiService.ExtrasTagsBulkUpdateExecute(r)
}

/*
ExtrasTagsBulkUpdate Method for ExtrasTagsBulkUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiExtrasTagsBulkUpdateRequest
*/
func (a *ExtrasApiService) ExtrasTagsBulkUpdate(ctx context.Context) ApiExtrasTagsBulkUpdateRequest {
	return ApiExtrasTagsBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Tag
func (a *ExtrasApiService) ExtrasTagsBulkUpdateExecute(r ApiExtrasTagsBulkUpdateRequest) (*Tag, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Tag
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExtrasApiService.ExtrasTagsBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extras/tags/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiExtrasTagsCreateRequest struct {
	ctx context.Context
	ApiService *ExtrasApiService
	data *Tag
}

func (r ApiExtrasTagsCreateRequest) Data(data Tag) ApiExtrasTagsCreateRequest {
	r.data = &data
	return r
}

func (r ApiExtrasTagsCreateRequest) Execute() (*Tag, *http.Response, error) {
	return r.ApiService.ExtrasTagsCreateExecute(r)
}

/*
ExtrasTagsCreate Method for ExtrasTagsCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiExtrasTagsCreateRequest
*/
func (a *ExtrasApiService) ExtrasTagsCreate(ctx context.Context) ApiExtrasTagsCreateRequest {
	return ApiExtrasTagsCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Tag
func (a *ExtrasApiService) ExtrasTagsCreateExecute(r ApiExtrasTagsCreateRequest) (*Tag, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Tag
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExtrasApiService.ExtrasTagsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extras/tags/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiExtrasTagsDeleteRequest struct {
	ctx context.Context
	ApiService *ExtrasApiService
	id int32
}

func (r ApiExtrasTagsDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.ExtrasTagsDeleteExecute(r)
}

/*
ExtrasTagsDelete Method for ExtrasTagsDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this tag.
 @return ApiExtrasTagsDeleteRequest
*/
func (a *ExtrasApiService) ExtrasTagsDelete(ctx context.Context, id int32) ApiExtrasTagsDeleteRequest {
	return ApiExtrasTagsDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *ExtrasApiService) ExtrasTagsDeleteExecute(r ApiExtrasTagsDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExtrasApiService.ExtrasTagsDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extras/tags/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiExtrasTagsListRequest struct {
	ctx context.Context
	ApiService *ExtrasApiService
	id *string
	name *string
	slug *string
	color *string
	created *string
	createdGte *string
	createdLte *string
	lastUpdated *string
	lastUpdatedGte *string
	lastUpdatedLte *string
	q *string
	contentType *string
	contentTypeId *string
	idN *string
	idLte *string
	idLt *string
	idGte *string
	idGt *string
	nameN *string
	nameIc *string
	nameNic *string
	nameIew *string
	nameNiew *string
	nameIsw *string
	nameNisw *string
	nameIe *string
	nameNie *string
	nameEmpty *string
	slugN *string
	slugIc *string
	slugNic *string
	slugIew *string
	slugNiew *string
	slugIsw *string
	slugNisw *string
	slugIe *string
	slugNie *string
	slugEmpty *string
	colorN *string
	colorIc *string
	colorNic *string
	colorIew *string
	colorNiew *string
	colorIsw *string
	colorNisw *string
	colorIe *string
	colorNie *string
	colorEmpty *string
	limit *int32
	offset *int32
}

func (r ApiExtrasTagsListRequest) Id(id string) ApiExtrasTagsListRequest {
	r.id = &id
	return r
}

func (r ApiExtrasTagsListRequest) Name(name string) ApiExtrasTagsListRequest {
	r.name = &name
	return r
}

func (r ApiExtrasTagsListRequest) Slug(slug string) ApiExtrasTagsListRequest {
	r.slug = &slug
	return r
}

func (r ApiExtrasTagsListRequest) Color(color string) ApiExtrasTagsListRequest {
	r.color = &color
	return r
}

func (r ApiExtrasTagsListRequest) Created(created string) ApiExtrasTagsListRequest {
	r.created = &created
	return r
}

func (r ApiExtrasTagsListRequest) CreatedGte(createdGte string) ApiExtrasTagsListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiExtrasTagsListRequest) CreatedLte(createdLte string) ApiExtrasTagsListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiExtrasTagsListRequest) LastUpdated(lastUpdated string) ApiExtrasTagsListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiExtrasTagsListRequest) LastUpdatedGte(lastUpdatedGte string) ApiExtrasTagsListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiExtrasTagsListRequest) LastUpdatedLte(lastUpdatedLte string) ApiExtrasTagsListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiExtrasTagsListRequest) Q(q string) ApiExtrasTagsListRequest {
	r.q = &q
	return r
}

func (r ApiExtrasTagsListRequest) ContentType(contentType string) ApiExtrasTagsListRequest {
	r.contentType = &contentType
	return r
}

func (r ApiExtrasTagsListRequest) ContentTypeId(contentTypeId string) ApiExtrasTagsListRequest {
	r.contentTypeId = &contentTypeId
	return r
}

func (r ApiExtrasTagsListRequest) IdN(idN string) ApiExtrasTagsListRequest {
	r.idN = &idN
	return r
}

func (r ApiExtrasTagsListRequest) IdLte(idLte string) ApiExtrasTagsListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiExtrasTagsListRequest) IdLt(idLt string) ApiExtrasTagsListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiExtrasTagsListRequest) IdGte(idGte string) ApiExtrasTagsListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiExtrasTagsListRequest) IdGt(idGt string) ApiExtrasTagsListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiExtrasTagsListRequest) NameN(nameN string) ApiExtrasTagsListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiExtrasTagsListRequest) NameIc(nameIc string) ApiExtrasTagsListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiExtrasTagsListRequest) NameNic(nameNic string) ApiExtrasTagsListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiExtrasTagsListRequest) NameIew(nameIew string) ApiExtrasTagsListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiExtrasTagsListRequest) NameNiew(nameNiew string) ApiExtrasTagsListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiExtrasTagsListRequest) NameIsw(nameIsw string) ApiExtrasTagsListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiExtrasTagsListRequest) NameNisw(nameNisw string) ApiExtrasTagsListRequest {
	r.nameNisw = &nameNisw
	return r
}

func (r ApiExtrasTagsListRequest) NameIe(nameIe string) ApiExtrasTagsListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiExtrasTagsListRequest) NameNie(nameNie string) ApiExtrasTagsListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiExtrasTagsListRequest) NameEmpty(nameEmpty string) ApiExtrasTagsListRequest {
	r.nameEmpty = &nameEmpty
	return r
}

func (r ApiExtrasTagsListRequest) SlugN(slugN string) ApiExtrasTagsListRequest {
	r.slugN = &slugN
	return r
}

func (r ApiExtrasTagsListRequest) SlugIc(slugIc string) ApiExtrasTagsListRequest {
	r.slugIc = &slugIc
	return r
}

func (r ApiExtrasTagsListRequest) SlugNic(slugNic string) ApiExtrasTagsListRequest {
	r.slugNic = &slugNic
	return r
}

func (r ApiExtrasTagsListRequest) SlugIew(slugIew string) ApiExtrasTagsListRequest {
	r.slugIew = &slugIew
	return r
}

func (r ApiExtrasTagsListRequest) SlugNiew(slugNiew string) ApiExtrasTagsListRequest {
	r.slugNiew = &slugNiew
	return r
}

func (r ApiExtrasTagsListRequest) SlugIsw(slugIsw string) ApiExtrasTagsListRequest {
	r.slugIsw = &slugIsw
	return r
}

func (r ApiExtrasTagsListRequest) SlugNisw(slugNisw string) ApiExtrasTagsListRequest {
	r.slugNisw = &slugNisw
	return r
}

func (r ApiExtrasTagsListRequest) SlugIe(slugIe string) ApiExtrasTagsListRequest {
	r.slugIe = &slugIe
	return r
}

func (r ApiExtrasTagsListRequest) SlugNie(slugNie string) ApiExtrasTagsListRequest {
	r.slugNie = &slugNie
	return r
}

func (r ApiExtrasTagsListRequest) SlugEmpty(slugEmpty string) ApiExtrasTagsListRequest {
	r.slugEmpty = &slugEmpty
	return r
}

func (r ApiExtrasTagsListRequest) ColorN(colorN string) ApiExtrasTagsListRequest {
	r.colorN = &colorN
	return r
}

func (r ApiExtrasTagsListRequest) ColorIc(colorIc string) ApiExtrasTagsListRequest {
	r.colorIc = &colorIc
	return r
}

func (r ApiExtrasTagsListRequest) ColorNic(colorNic string) ApiExtrasTagsListRequest {
	r.colorNic = &colorNic
	return r
}

func (r ApiExtrasTagsListRequest) ColorIew(colorIew string) ApiExtrasTagsListRequest {
	r.colorIew = &colorIew
	return r
}

func (r ApiExtrasTagsListRequest) ColorNiew(colorNiew string) ApiExtrasTagsListRequest {
	r.colorNiew = &colorNiew
	return r
}

func (r ApiExtrasTagsListRequest) ColorIsw(colorIsw string) ApiExtrasTagsListRequest {
	r.colorIsw = &colorIsw
	return r
}

func (r ApiExtrasTagsListRequest) ColorNisw(colorNisw string) ApiExtrasTagsListRequest {
	r.colorNisw = &colorNisw
	return r
}

func (r ApiExtrasTagsListRequest) ColorIe(colorIe string) ApiExtrasTagsListRequest {
	r.colorIe = &colorIe
	return r
}

func (r ApiExtrasTagsListRequest) ColorNie(colorNie string) ApiExtrasTagsListRequest {
	r.colorNie = &colorNie
	return r
}

func (r ApiExtrasTagsListRequest) ColorEmpty(colorEmpty string) ApiExtrasTagsListRequest {
	r.colorEmpty = &colorEmpty
	return r
}

// Number of results to return per page.
func (r ApiExtrasTagsListRequest) Limit(limit int32) ApiExtrasTagsListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiExtrasTagsListRequest) Offset(offset int32) ApiExtrasTagsListRequest {
	r.offset = &offset
	return r
}

func (r ApiExtrasTagsListRequest) Execute() (*ExtrasTagsList200Response, *http.Response, error) {
	return r.ApiService.ExtrasTagsListExecute(r)
}

/*
ExtrasTagsList Method for ExtrasTagsList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiExtrasTagsListRequest
*/
func (a *ExtrasApiService) ExtrasTagsList(ctx context.Context) ApiExtrasTagsListRequest {
	return ApiExtrasTagsListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ExtrasTagsList200Response
func (a *ExtrasApiService) ExtrasTagsListExecute(r ApiExtrasTagsListRequest) (*ExtrasTagsList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ExtrasTagsList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExtrasApiService.ExtrasTagsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extras/tags/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.slug != nil {
		localVarQueryParams.Add("slug", parameterToString(*r.slug, ""))
	}
	if r.color != nil {
		localVarQueryParams.Add("color", parameterToString(*r.color, ""))
	}
	if r.created != nil {
		localVarQueryParams.Add("created", parameterToString(*r.created, ""))
	}
	if r.createdGte != nil {
		localVarQueryParams.Add("created__gte", parameterToString(*r.createdGte, ""))
	}
	if r.createdLte != nil {
		localVarQueryParams.Add("created__lte", parameterToString(*r.createdLte, ""))
	}
	if r.lastUpdated != nil {
		localVarQueryParams.Add("last_updated", parameterToString(*r.lastUpdated, ""))
	}
	if r.lastUpdatedGte != nil {
		localVarQueryParams.Add("last_updated__gte", parameterToString(*r.lastUpdatedGte, ""))
	}
	if r.lastUpdatedLte != nil {
		localVarQueryParams.Add("last_updated__lte", parameterToString(*r.lastUpdatedLte, ""))
	}
	if r.q != nil {
		localVarQueryParams.Add("q", parameterToString(*r.q, ""))
	}
	if r.contentType != nil {
		localVarQueryParams.Add("content_type", parameterToString(*r.contentType, ""))
	}
	if r.contentTypeId != nil {
		localVarQueryParams.Add("content_type_id", parameterToString(*r.contentTypeId, ""))
	}
	if r.idN != nil {
		localVarQueryParams.Add("id__n", parameterToString(*r.idN, ""))
	}
	if r.idLte != nil {
		localVarQueryParams.Add("id__lte", parameterToString(*r.idLte, ""))
	}
	if r.idLt != nil {
		localVarQueryParams.Add("id__lt", parameterToString(*r.idLt, ""))
	}
	if r.idGte != nil {
		localVarQueryParams.Add("id__gte", parameterToString(*r.idGte, ""))
	}
	if r.idGt != nil {
		localVarQueryParams.Add("id__gt", parameterToString(*r.idGt, ""))
	}
	if r.nameN != nil {
		localVarQueryParams.Add("name__n", parameterToString(*r.nameN, ""))
	}
	if r.nameIc != nil {
		localVarQueryParams.Add("name__ic", parameterToString(*r.nameIc, ""))
	}
	if r.nameNic != nil {
		localVarQueryParams.Add("name__nic", parameterToString(*r.nameNic, ""))
	}
	if r.nameIew != nil {
		localVarQueryParams.Add("name__iew", parameterToString(*r.nameIew, ""))
	}
	if r.nameNiew != nil {
		localVarQueryParams.Add("name__niew", parameterToString(*r.nameNiew, ""))
	}
	if r.nameIsw != nil {
		localVarQueryParams.Add("name__isw", parameterToString(*r.nameIsw, ""))
	}
	if r.nameNisw != nil {
		localVarQueryParams.Add("name__nisw", parameterToString(*r.nameNisw, ""))
	}
	if r.nameIe != nil {
		localVarQueryParams.Add("name__ie", parameterToString(*r.nameIe, ""))
	}
	if r.nameNie != nil {
		localVarQueryParams.Add("name__nie", parameterToString(*r.nameNie, ""))
	}
	if r.nameEmpty != nil {
		localVarQueryParams.Add("name__empty", parameterToString(*r.nameEmpty, ""))
	}
	if r.slugN != nil {
		localVarQueryParams.Add("slug__n", parameterToString(*r.slugN, ""))
	}
	if r.slugIc != nil {
		localVarQueryParams.Add("slug__ic", parameterToString(*r.slugIc, ""))
	}
	if r.slugNic != nil {
		localVarQueryParams.Add("slug__nic", parameterToString(*r.slugNic, ""))
	}
	if r.slugIew != nil {
		localVarQueryParams.Add("slug__iew", parameterToString(*r.slugIew, ""))
	}
	if r.slugNiew != nil {
		localVarQueryParams.Add("slug__niew", parameterToString(*r.slugNiew, ""))
	}
	if r.slugIsw != nil {
		localVarQueryParams.Add("slug__isw", parameterToString(*r.slugIsw, ""))
	}
	if r.slugNisw != nil {
		localVarQueryParams.Add("slug__nisw", parameterToString(*r.slugNisw, ""))
	}
	if r.slugIe != nil {
		localVarQueryParams.Add("slug__ie", parameterToString(*r.slugIe, ""))
	}
	if r.slugNie != nil {
		localVarQueryParams.Add("slug__nie", parameterToString(*r.slugNie, ""))
	}
	if r.slugEmpty != nil {
		localVarQueryParams.Add("slug__empty", parameterToString(*r.slugEmpty, ""))
	}
	if r.colorN != nil {
		localVarQueryParams.Add("color__n", parameterToString(*r.colorN, ""))
	}
	if r.colorIc != nil {
		localVarQueryParams.Add("color__ic", parameterToString(*r.colorIc, ""))
	}
	if r.colorNic != nil {
		localVarQueryParams.Add("color__nic", parameterToString(*r.colorNic, ""))
	}
	if r.colorIew != nil {
		localVarQueryParams.Add("color__iew", parameterToString(*r.colorIew, ""))
	}
	if r.colorNiew != nil {
		localVarQueryParams.Add("color__niew", parameterToString(*r.colorNiew, ""))
	}
	if r.colorIsw != nil {
		localVarQueryParams.Add("color__isw", parameterToString(*r.colorIsw, ""))
	}
	if r.colorNisw != nil {
		localVarQueryParams.Add("color__nisw", parameterToString(*r.colorNisw, ""))
	}
	if r.colorIe != nil {
		localVarQueryParams.Add("color__ie", parameterToString(*r.colorIe, ""))
	}
	if r.colorNie != nil {
		localVarQueryParams.Add("color__nie", parameterToString(*r.colorNie, ""))
	}
	if r.colorEmpty != nil {
		localVarQueryParams.Add("color__empty", parameterToString(*r.colorEmpty, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiExtrasTagsPartialUpdateRequest struct {
	ctx context.Context
	ApiService *ExtrasApiService
	id int32
	data *Tag
}

func (r ApiExtrasTagsPartialUpdateRequest) Data(data Tag) ApiExtrasTagsPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiExtrasTagsPartialUpdateRequest) Execute() (*Tag, *http.Response, error) {
	return r.ApiService.ExtrasTagsPartialUpdateExecute(r)
}

/*
ExtrasTagsPartialUpdate Method for ExtrasTagsPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this tag.
 @return ApiExtrasTagsPartialUpdateRequest
*/
func (a *ExtrasApiService) ExtrasTagsPartialUpdate(ctx context.Context, id int32) ApiExtrasTagsPartialUpdateRequest {
	return ApiExtrasTagsPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Tag
func (a *ExtrasApiService) ExtrasTagsPartialUpdateExecute(r ApiExtrasTagsPartialUpdateRequest) (*Tag, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Tag
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExtrasApiService.ExtrasTagsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extras/tags/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiExtrasTagsReadRequest struct {
	ctx context.Context
	ApiService *ExtrasApiService
	id int32
}

func (r ApiExtrasTagsReadRequest) Execute() (*Tag, *http.Response, error) {
	return r.ApiService.ExtrasTagsReadExecute(r)
}

/*
ExtrasTagsRead Method for ExtrasTagsRead

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this tag.
 @return ApiExtrasTagsReadRequest
*/
func (a *ExtrasApiService) ExtrasTagsRead(ctx context.Context, id int32) ApiExtrasTagsReadRequest {
	return ApiExtrasTagsReadRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Tag
func (a *ExtrasApiService) ExtrasTagsReadExecute(r ApiExtrasTagsReadRequest) (*Tag, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Tag
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExtrasApiService.ExtrasTagsRead")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extras/tags/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiExtrasTagsUpdateRequest struct {
	ctx context.Context
	ApiService *ExtrasApiService
	id int32
	data *Tag
}

func (r ApiExtrasTagsUpdateRequest) Data(data Tag) ApiExtrasTagsUpdateRequest {
	r.data = &data
	return r
}

func (r ApiExtrasTagsUpdateRequest) Execute() (*Tag, *http.Response, error) {
	return r.ApiService.ExtrasTagsUpdateExecute(r)
}

/*
ExtrasTagsUpdate Method for ExtrasTagsUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this tag.
 @return ApiExtrasTagsUpdateRequest
*/
func (a *ExtrasApiService) ExtrasTagsUpdate(ctx context.Context, id int32) ApiExtrasTagsUpdateRequest {
	return ApiExtrasTagsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Tag
func (a *ExtrasApiService) ExtrasTagsUpdateExecute(r ApiExtrasTagsUpdateRequest) (*Tag, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Tag
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExtrasApiService.ExtrasTagsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extras/tags/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiExtrasWebhooksBulkDeleteRequest struct {
	ctx context.Context
	ApiService *ExtrasApiService
}

func (r ApiExtrasWebhooksBulkDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.ExtrasWebhooksBulkDeleteExecute(r)
}

/*
ExtrasWebhooksBulkDelete Method for ExtrasWebhooksBulkDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiExtrasWebhooksBulkDeleteRequest
*/
func (a *ExtrasApiService) ExtrasWebhooksBulkDelete(ctx context.Context) ApiExtrasWebhooksBulkDeleteRequest {
	return ApiExtrasWebhooksBulkDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ExtrasApiService) ExtrasWebhooksBulkDeleteExecute(r ApiExtrasWebhooksBulkDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExtrasApiService.ExtrasWebhooksBulkDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extras/webhooks/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiExtrasWebhooksBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *ExtrasApiService
	data *Webhook
}

func (r ApiExtrasWebhooksBulkPartialUpdateRequest) Data(data Webhook) ApiExtrasWebhooksBulkPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiExtrasWebhooksBulkPartialUpdateRequest) Execute() (*Webhook, *http.Response, error) {
	return r.ApiService.ExtrasWebhooksBulkPartialUpdateExecute(r)
}

/*
ExtrasWebhooksBulkPartialUpdate Method for ExtrasWebhooksBulkPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiExtrasWebhooksBulkPartialUpdateRequest
*/
func (a *ExtrasApiService) ExtrasWebhooksBulkPartialUpdate(ctx context.Context) ApiExtrasWebhooksBulkPartialUpdateRequest {
	return ApiExtrasWebhooksBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Webhook
func (a *ExtrasApiService) ExtrasWebhooksBulkPartialUpdateExecute(r ApiExtrasWebhooksBulkPartialUpdateRequest) (*Webhook, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Webhook
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExtrasApiService.ExtrasWebhooksBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extras/webhooks/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiExtrasWebhooksBulkUpdateRequest struct {
	ctx context.Context
	ApiService *ExtrasApiService
	data *Webhook
}

func (r ApiExtrasWebhooksBulkUpdateRequest) Data(data Webhook) ApiExtrasWebhooksBulkUpdateRequest {
	r.data = &data
	return r
}

func (r ApiExtrasWebhooksBulkUpdateRequest) Execute() (*Webhook, *http.Response, error) {
	return r.ApiService.ExtrasWebhooksBulkUpdateExecute(r)
}

/*
ExtrasWebhooksBulkUpdate Method for ExtrasWebhooksBulkUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiExtrasWebhooksBulkUpdateRequest
*/
func (a *ExtrasApiService) ExtrasWebhooksBulkUpdate(ctx context.Context) ApiExtrasWebhooksBulkUpdateRequest {
	return ApiExtrasWebhooksBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Webhook
func (a *ExtrasApiService) ExtrasWebhooksBulkUpdateExecute(r ApiExtrasWebhooksBulkUpdateRequest) (*Webhook, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Webhook
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExtrasApiService.ExtrasWebhooksBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extras/webhooks/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiExtrasWebhooksCreateRequest struct {
	ctx context.Context
	ApiService *ExtrasApiService
	data *Webhook
}

func (r ApiExtrasWebhooksCreateRequest) Data(data Webhook) ApiExtrasWebhooksCreateRequest {
	r.data = &data
	return r
}

func (r ApiExtrasWebhooksCreateRequest) Execute() (*Webhook, *http.Response, error) {
	return r.ApiService.ExtrasWebhooksCreateExecute(r)
}

/*
ExtrasWebhooksCreate Method for ExtrasWebhooksCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiExtrasWebhooksCreateRequest
*/
func (a *ExtrasApiService) ExtrasWebhooksCreate(ctx context.Context) ApiExtrasWebhooksCreateRequest {
	return ApiExtrasWebhooksCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Webhook
func (a *ExtrasApiService) ExtrasWebhooksCreateExecute(r ApiExtrasWebhooksCreateRequest) (*Webhook, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Webhook
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExtrasApiService.ExtrasWebhooksCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extras/webhooks/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiExtrasWebhooksDeleteRequest struct {
	ctx context.Context
	ApiService *ExtrasApiService
	id int32
}

func (r ApiExtrasWebhooksDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.ExtrasWebhooksDeleteExecute(r)
}

/*
ExtrasWebhooksDelete Method for ExtrasWebhooksDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this webhook.
 @return ApiExtrasWebhooksDeleteRequest
*/
func (a *ExtrasApiService) ExtrasWebhooksDelete(ctx context.Context, id int32) ApiExtrasWebhooksDeleteRequest {
	return ApiExtrasWebhooksDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *ExtrasApiService) ExtrasWebhooksDeleteExecute(r ApiExtrasWebhooksDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExtrasApiService.ExtrasWebhooksDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extras/webhooks/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiExtrasWebhooksListRequest struct {
	ctx context.Context
	ApiService *ExtrasApiService
	id *string
	contentTypes *string
	name *string
	typeCreate *string
	typeUpdate *string
	typeDelete *string
	payloadUrl *string
	enabled *string
	httpMethod *string
	httpContentType *string
	secret *string
	sslVerification *string
	caFilePath *string
	idN *string
	idLte *string
	idLt *string
	idGte *string
	idGt *string
	contentTypesN *string
	contentTypesIc *string
	contentTypesNic *string
	contentTypesIew *string
	contentTypesNiew *string
	contentTypesIsw *string
	contentTypesNisw *string
	contentTypesIe *string
	contentTypesNie *string
	nameN *string
	nameIc *string
	nameNic *string
	nameIew *string
	nameNiew *string
	nameIsw *string
	nameNisw *string
	nameIe *string
	nameNie *string
	nameEmpty *string
	payloadUrlN *string
	payloadUrlIc *string
	payloadUrlNic *string
	payloadUrlIew *string
	payloadUrlNiew *string
	payloadUrlIsw *string
	payloadUrlNisw *string
	payloadUrlIe *string
	payloadUrlNie *string
	payloadUrlEmpty *string
	httpMethodN *string
	httpContentTypeN *string
	httpContentTypeIc *string
	httpContentTypeNic *string
	httpContentTypeIew *string
	httpContentTypeNiew *string
	httpContentTypeIsw *string
	httpContentTypeNisw *string
	httpContentTypeIe *string
	httpContentTypeNie *string
	httpContentTypeEmpty *string
	secretN *string
	secretIc *string
	secretNic *string
	secretIew *string
	secretNiew *string
	secretIsw *string
	secretNisw *string
	secretIe *string
	secretNie *string
	secretEmpty *string
	caFilePathN *string
	caFilePathIc *string
	caFilePathNic *string
	caFilePathIew *string
	caFilePathNiew *string
	caFilePathIsw *string
	caFilePathNisw *string
	caFilePathIe *string
	caFilePathNie *string
	caFilePathEmpty *string
	limit *int32
	offset *int32
}

func (r ApiExtrasWebhooksListRequest) Id(id string) ApiExtrasWebhooksListRequest {
	r.id = &id
	return r
}

func (r ApiExtrasWebhooksListRequest) ContentTypes(contentTypes string) ApiExtrasWebhooksListRequest {
	r.contentTypes = &contentTypes
	return r
}

func (r ApiExtrasWebhooksListRequest) Name(name string) ApiExtrasWebhooksListRequest {
	r.name = &name
	return r
}

func (r ApiExtrasWebhooksListRequest) TypeCreate(typeCreate string) ApiExtrasWebhooksListRequest {
	r.typeCreate = &typeCreate
	return r
}

func (r ApiExtrasWebhooksListRequest) TypeUpdate(typeUpdate string) ApiExtrasWebhooksListRequest {
	r.typeUpdate = &typeUpdate
	return r
}

func (r ApiExtrasWebhooksListRequest) TypeDelete(typeDelete string) ApiExtrasWebhooksListRequest {
	r.typeDelete = &typeDelete
	return r
}

func (r ApiExtrasWebhooksListRequest) PayloadUrl(payloadUrl string) ApiExtrasWebhooksListRequest {
	r.payloadUrl = &payloadUrl
	return r
}

func (r ApiExtrasWebhooksListRequest) Enabled(enabled string) ApiExtrasWebhooksListRequest {
	r.enabled = &enabled
	return r
}

func (r ApiExtrasWebhooksListRequest) HttpMethod(httpMethod string) ApiExtrasWebhooksListRequest {
	r.httpMethod = &httpMethod
	return r
}

func (r ApiExtrasWebhooksListRequest) HttpContentType(httpContentType string) ApiExtrasWebhooksListRequest {
	r.httpContentType = &httpContentType
	return r
}

func (r ApiExtrasWebhooksListRequest) Secret(secret string) ApiExtrasWebhooksListRequest {
	r.secret = &secret
	return r
}

func (r ApiExtrasWebhooksListRequest) SslVerification(sslVerification string) ApiExtrasWebhooksListRequest {
	r.sslVerification = &sslVerification
	return r
}

func (r ApiExtrasWebhooksListRequest) CaFilePath(caFilePath string) ApiExtrasWebhooksListRequest {
	r.caFilePath = &caFilePath
	return r
}

func (r ApiExtrasWebhooksListRequest) IdN(idN string) ApiExtrasWebhooksListRequest {
	r.idN = &idN
	return r
}

func (r ApiExtrasWebhooksListRequest) IdLte(idLte string) ApiExtrasWebhooksListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiExtrasWebhooksListRequest) IdLt(idLt string) ApiExtrasWebhooksListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiExtrasWebhooksListRequest) IdGte(idGte string) ApiExtrasWebhooksListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiExtrasWebhooksListRequest) IdGt(idGt string) ApiExtrasWebhooksListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiExtrasWebhooksListRequest) ContentTypesN(contentTypesN string) ApiExtrasWebhooksListRequest {
	r.contentTypesN = &contentTypesN
	return r
}

func (r ApiExtrasWebhooksListRequest) ContentTypesIc(contentTypesIc string) ApiExtrasWebhooksListRequest {
	r.contentTypesIc = &contentTypesIc
	return r
}

func (r ApiExtrasWebhooksListRequest) ContentTypesNic(contentTypesNic string) ApiExtrasWebhooksListRequest {
	r.contentTypesNic = &contentTypesNic
	return r
}

func (r ApiExtrasWebhooksListRequest) ContentTypesIew(contentTypesIew string) ApiExtrasWebhooksListRequest {
	r.contentTypesIew = &contentTypesIew
	return r
}

func (r ApiExtrasWebhooksListRequest) ContentTypesNiew(contentTypesNiew string) ApiExtrasWebhooksListRequest {
	r.contentTypesNiew = &contentTypesNiew
	return r
}

func (r ApiExtrasWebhooksListRequest) ContentTypesIsw(contentTypesIsw string) ApiExtrasWebhooksListRequest {
	r.contentTypesIsw = &contentTypesIsw
	return r
}

func (r ApiExtrasWebhooksListRequest) ContentTypesNisw(contentTypesNisw string) ApiExtrasWebhooksListRequest {
	r.contentTypesNisw = &contentTypesNisw
	return r
}

func (r ApiExtrasWebhooksListRequest) ContentTypesIe(contentTypesIe string) ApiExtrasWebhooksListRequest {
	r.contentTypesIe = &contentTypesIe
	return r
}

func (r ApiExtrasWebhooksListRequest) ContentTypesNie(contentTypesNie string) ApiExtrasWebhooksListRequest {
	r.contentTypesNie = &contentTypesNie
	return r
}

func (r ApiExtrasWebhooksListRequest) NameN(nameN string) ApiExtrasWebhooksListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiExtrasWebhooksListRequest) NameIc(nameIc string) ApiExtrasWebhooksListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiExtrasWebhooksListRequest) NameNic(nameNic string) ApiExtrasWebhooksListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiExtrasWebhooksListRequest) NameIew(nameIew string) ApiExtrasWebhooksListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiExtrasWebhooksListRequest) NameNiew(nameNiew string) ApiExtrasWebhooksListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiExtrasWebhooksListRequest) NameIsw(nameIsw string) ApiExtrasWebhooksListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiExtrasWebhooksListRequest) NameNisw(nameNisw string) ApiExtrasWebhooksListRequest {
	r.nameNisw = &nameNisw
	return r
}

func (r ApiExtrasWebhooksListRequest) NameIe(nameIe string) ApiExtrasWebhooksListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiExtrasWebhooksListRequest) NameNie(nameNie string) ApiExtrasWebhooksListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiExtrasWebhooksListRequest) NameEmpty(nameEmpty string) ApiExtrasWebhooksListRequest {
	r.nameEmpty = &nameEmpty
	return r
}

func (r ApiExtrasWebhooksListRequest) PayloadUrlN(payloadUrlN string) ApiExtrasWebhooksListRequest {
	r.payloadUrlN = &payloadUrlN
	return r
}

func (r ApiExtrasWebhooksListRequest) PayloadUrlIc(payloadUrlIc string) ApiExtrasWebhooksListRequest {
	r.payloadUrlIc = &payloadUrlIc
	return r
}

func (r ApiExtrasWebhooksListRequest) PayloadUrlNic(payloadUrlNic string) ApiExtrasWebhooksListRequest {
	r.payloadUrlNic = &payloadUrlNic
	return r
}

func (r ApiExtrasWebhooksListRequest) PayloadUrlIew(payloadUrlIew string) ApiExtrasWebhooksListRequest {
	r.payloadUrlIew = &payloadUrlIew
	return r
}

func (r ApiExtrasWebhooksListRequest) PayloadUrlNiew(payloadUrlNiew string) ApiExtrasWebhooksListRequest {
	r.payloadUrlNiew = &payloadUrlNiew
	return r
}

func (r ApiExtrasWebhooksListRequest) PayloadUrlIsw(payloadUrlIsw string) ApiExtrasWebhooksListRequest {
	r.payloadUrlIsw = &payloadUrlIsw
	return r
}

func (r ApiExtrasWebhooksListRequest) PayloadUrlNisw(payloadUrlNisw string) ApiExtrasWebhooksListRequest {
	r.payloadUrlNisw = &payloadUrlNisw
	return r
}

func (r ApiExtrasWebhooksListRequest) PayloadUrlIe(payloadUrlIe string) ApiExtrasWebhooksListRequest {
	r.payloadUrlIe = &payloadUrlIe
	return r
}

func (r ApiExtrasWebhooksListRequest) PayloadUrlNie(payloadUrlNie string) ApiExtrasWebhooksListRequest {
	r.payloadUrlNie = &payloadUrlNie
	return r
}

func (r ApiExtrasWebhooksListRequest) PayloadUrlEmpty(payloadUrlEmpty string) ApiExtrasWebhooksListRequest {
	r.payloadUrlEmpty = &payloadUrlEmpty
	return r
}

func (r ApiExtrasWebhooksListRequest) HttpMethodN(httpMethodN string) ApiExtrasWebhooksListRequest {
	r.httpMethodN = &httpMethodN
	return r
}

func (r ApiExtrasWebhooksListRequest) HttpContentTypeN(httpContentTypeN string) ApiExtrasWebhooksListRequest {
	r.httpContentTypeN = &httpContentTypeN
	return r
}

func (r ApiExtrasWebhooksListRequest) HttpContentTypeIc(httpContentTypeIc string) ApiExtrasWebhooksListRequest {
	r.httpContentTypeIc = &httpContentTypeIc
	return r
}

func (r ApiExtrasWebhooksListRequest) HttpContentTypeNic(httpContentTypeNic string) ApiExtrasWebhooksListRequest {
	r.httpContentTypeNic = &httpContentTypeNic
	return r
}

func (r ApiExtrasWebhooksListRequest) HttpContentTypeIew(httpContentTypeIew string) ApiExtrasWebhooksListRequest {
	r.httpContentTypeIew = &httpContentTypeIew
	return r
}

func (r ApiExtrasWebhooksListRequest) HttpContentTypeNiew(httpContentTypeNiew string) ApiExtrasWebhooksListRequest {
	r.httpContentTypeNiew = &httpContentTypeNiew
	return r
}

func (r ApiExtrasWebhooksListRequest) HttpContentTypeIsw(httpContentTypeIsw string) ApiExtrasWebhooksListRequest {
	r.httpContentTypeIsw = &httpContentTypeIsw
	return r
}

func (r ApiExtrasWebhooksListRequest) HttpContentTypeNisw(httpContentTypeNisw string) ApiExtrasWebhooksListRequest {
	r.httpContentTypeNisw = &httpContentTypeNisw
	return r
}

func (r ApiExtrasWebhooksListRequest) HttpContentTypeIe(httpContentTypeIe string) ApiExtrasWebhooksListRequest {
	r.httpContentTypeIe = &httpContentTypeIe
	return r
}

func (r ApiExtrasWebhooksListRequest) HttpContentTypeNie(httpContentTypeNie string) ApiExtrasWebhooksListRequest {
	r.httpContentTypeNie = &httpContentTypeNie
	return r
}

func (r ApiExtrasWebhooksListRequest) HttpContentTypeEmpty(httpContentTypeEmpty string) ApiExtrasWebhooksListRequest {
	r.httpContentTypeEmpty = &httpContentTypeEmpty
	return r
}

func (r ApiExtrasWebhooksListRequest) SecretN(secretN string) ApiExtrasWebhooksListRequest {
	r.secretN = &secretN
	return r
}

func (r ApiExtrasWebhooksListRequest) SecretIc(secretIc string) ApiExtrasWebhooksListRequest {
	r.secretIc = &secretIc
	return r
}

func (r ApiExtrasWebhooksListRequest) SecretNic(secretNic string) ApiExtrasWebhooksListRequest {
	r.secretNic = &secretNic
	return r
}

func (r ApiExtrasWebhooksListRequest) SecretIew(secretIew string) ApiExtrasWebhooksListRequest {
	r.secretIew = &secretIew
	return r
}

func (r ApiExtrasWebhooksListRequest) SecretNiew(secretNiew string) ApiExtrasWebhooksListRequest {
	r.secretNiew = &secretNiew
	return r
}

func (r ApiExtrasWebhooksListRequest) SecretIsw(secretIsw string) ApiExtrasWebhooksListRequest {
	r.secretIsw = &secretIsw
	return r
}

func (r ApiExtrasWebhooksListRequest) SecretNisw(secretNisw string) ApiExtrasWebhooksListRequest {
	r.secretNisw = &secretNisw
	return r
}

func (r ApiExtrasWebhooksListRequest) SecretIe(secretIe string) ApiExtrasWebhooksListRequest {
	r.secretIe = &secretIe
	return r
}

func (r ApiExtrasWebhooksListRequest) SecretNie(secretNie string) ApiExtrasWebhooksListRequest {
	r.secretNie = &secretNie
	return r
}

func (r ApiExtrasWebhooksListRequest) SecretEmpty(secretEmpty string) ApiExtrasWebhooksListRequest {
	r.secretEmpty = &secretEmpty
	return r
}

func (r ApiExtrasWebhooksListRequest) CaFilePathN(caFilePathN string) ApiExtrasWebhooksListRequest {
	r.caFilePathN = &caFilePathN
	return r
}

func (r ApiExtrasWebhooksListRequest) CaFilePathIc(caFilePathIc string) ApiExtrasWebhooksListRequest {
	r.caFilePathIc = &caFilePathIc
	return r
}

func (r ApiExtrasWebhooksListRequest) CaFilePathNic(caFilePathNic string) ApiExtrasWebhooksListRequest {
	r.caFilePathNic = &caFilePathNic
	return r
}

func (r ApiExtrasWebhooksListRequest) CaFilePathIew(caFilePathIew string) ApiExtrasWebhooksListRequest {
	r.caFilePathIew = &caFilePathIew
	return r
}

func (r ApiExtrasWebhooksListRequest) CaFilePathNiew(caFilePathNiew string) ApiExtrasWebhooksListRequest {
	r.caFilePathNiew = &caFilePathNiew
	return r
}

func (r ApiExtrasWebhooksListRequest) CaFilePathIsw(caFilePathIsw string) ApiExtrasWebhooksListRequest {
	r.caFilePathIsw = &caFilePathIsw
	return r
}

func (r ApiExtrasWebhooksListRequest) CaFilePathNisw(caFilePathNisw string) ApiExtrasWebhooksListRequest {
	r.caFilePathNisw = &caFilePathNisw
	return r
}

func (r ApiExtrasWebhooksListRequest) CaFilePathIe(caFilePathIe string) ApiExtrasWebhooksListRequest {
	r.caFilePathIe = &caFilePathIe
	return r
}

func (r ApiExtrasWebhooksListRequest) CaFilePathNie(caFilePathNie string) ApiExtrasWebhooksListRequest {
	r.caFilePathNie = &caFilePathNie
	return r
}

func (r ApiExtrasWebhooksListRequest) CaFilePathEmpty(caFilePathEmpty string) ApiExtrasWebhooksListRequest {
	r.caFilePathEmpty = &caFilePathEmpty
	return r
}

// Number of results to return per page.
func (r ApiExtrasWebhooksListRequest) Limit(limit int32) ApiExtrasWebhooksListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiExtrasWebhooksListRequest) Offset(offset int32) ApiExtrasWebhooksListRequest {
	r.offset = &offset
	return r
}

func (r ApiExtrasWebhooksListRequest) Execute() (*ExtrasWebhooksList200Response, *http.Response, error) {
	return r.ApiService.ExtrasWebhooksListExecute(r)
}

/*
ExtrasWebhooksList Method for ExtrasWebhooksList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiExtrasWebhooksListRequest
*/
func (a *ExtrasApiService) ExtrasWebhooksList(ctx context.Context) ApiExtrasWebhooksListRequest {
	return ApiExtrasWebhooksListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ExtrasWebhooksList200Response
func (a *ExtrasApiService) ExtrasWebhooksListExecute(r ApiExtrasWebhooksListRequest) (*ExtrasWebhooksList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ExtrasWebhooksList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExtrasApiService.ExtrasWebhooksList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extras/webhooks/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.contentTypes != nil {
		localVarQueryParams.Add("content_types", parameterToString(*r.contentTypes, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.typeCreate != nil {
		localVarQueryParams.Add("type_create", parameterToString(*r.typeCreate, ""))
	}
	if r.typeUpdate != nil {
		localVarQueryParams.Add("type_update", parameterToString(*r.typeUpdate, ""))
	}
	if r.typeDelete != nil {
		localVarQueryParams.Add("type_delete", parameterToString(*r.typeDelete, ""))
	}
	if r.payloadUrl != nil {
		localVarQueryParams.Add("payload_url", parameterToString(*r.payloadUrl, ""))
	}
	if r.enabled != nil {
		localVarQueryParams.Add("enabled", parameterToString(*r.enabled, ""))
	}
	if r.httpMethod != nil {
		localVarQueryParams.Add("http_method", parameterToString(*r.httpMethod, ""))
	}
	if r.httpContentType != nil {
		localVarQueryParams.Add("http_content_type", parameterToString(*r.httpContentType, ""))
	}
	if r.secret != nil {
		localVarQueryParams.Add("secret", parameterToString(*r.secret, ""))
	}
	if r.sslVerification != nil {
		localVarQueryParams.Add("ssl_verification", parameterToString(*r.sslVerification, ""))
	}
	if r.caFilePath != nil {
		localVarQueryParams.Add("ca_file_path", parameterToString(*r.caFilePath, ""))
	}
	if r.idN != nil {
		localVarQueryParams.Add("id__n", parameterToString(*r.idN, ""))
	}
	if r.idLte != nil {
		localVarQueryParams.Add("id__lte", parameterToString(*r.idLte, ""))
	}
	if r.idLt != nil {
		localVarQueryParams.Add("id__lt", parameterToString(*r.idLt, ""))
	}
	if r.idGte != nil {
		localVarQueryParams.Add("id__gte", parameterToString(*r.idGte, ""))
	}
	if r.idGt != nil {
		localVarQueryParams.Add("id__gt", parameterToString(*r.idGt, ""))
	}
	if r.contentTypesN != nil {
		localVarQueryParams.Add("content_types__n", parameterToString(*r.contentTypesN, ""))
	}
	if r.contentTypesIc != nil {
		localVarQueryParams.Add("content_types__ic", parameterToString(*r.contentTypesIc, ""))
	}
	if r.contentTypesNic != nil {
		localVarQueryParams.Add("content_types__nic", parameterToString(*r.contentTypesNic, ""))
	}
	if r.contentTypesIew != nil {
		localVarQueryParams.Add("content_types__iew", parameterToString(*r.contentTypesIew, ""))
	}
	if r.contentTypesNiew != nil {
		localVarQueryParams.Add("content_types__niew", parameterToString(*r.contentTypesNiew, ""))
	}
	if r.contentTypesIsw != nil {
		localVarQueryParams.Add("content_types__isw", parameterToString(*r.contentTypesIsw, ""))
	}
	if r.contentTypesNisw != nil {
		localVarQueryParams.Add("content_types__nisw", parameterToString(*r.contentTypesNisw, ""))
	}
	if r.contentTypesIe != nil {
		localVarQueryParams.Add("content_types__ie", parameterToString(*r.contentTypesIe, ""))
	}
	if r.contentTypesNie != nil {
		localVarQueryParams.Add("content_types__nie", parameterToString(*r.contentTypesNie, ""))
	}
	if r.nameN != nil {
		localVarQueryParams.Add("name__n", parameterToString(*r.nameN, ""))
	}
	if r.nameIc != nil {
		localVarQueryParams.Add("name__ic", parameterToString(*r.nameIc, ""))
	}
	if r.nameNic != nil {
		localVarQueryParams.Add("name__nic", parameterToString(*r.nameNic, ""))
	}
	if r.nameIew != nil {
		localVarQueryParams.Add("name__iew", parameterToString(*r.nameIew, ""))
	}
	if r.nameNiew != nil {
		localVarQueryParams.Add("name__niew", parameterToString(*r.nameNiew, ""))
	}
	if r.nameIsw != nil {
		localVarQueryParams.Add("name__isw", parameterToString(*r.nameIsw, ""))
	}
	if r.nameNisw != nil {
		localVarQueryParams.Add("name__nisw", parameterToString(*r.nameNisw, ""))
	}
	if r.nameIe != nil {
		localVarQueryParams.Add("name__ie", parameterToString(*r.nameIe, ""))
	}
	if r.nameNie != nil {
		localVarQueryParams.Add("name__nie", parameterToString(*r.nameNie, ""))
	}
	if r.nameEmpty != nil {
		localVarQueryParams.Add("name__empty", parameterToString(*r.nameEmpty, ""))
	}
	if r.payloadUrlN != nil {
		localVarQueryParams.Add("payload_url__n", parameterToString(*r.payloadUrlN, ""))
	}
	if r.payloadUrlIc != nil {
		localVarQueryParams.Add("payload_url__ic", parameterToString(*r.payloadUrlIc, ""))
	}
	if r.payloadUrlNic != nil {
		localVarQueryParams.Add("payload_url__nic", parameterToString(*r.payloadUrlNic, ""))
	}
	if r.payloadUrlIew != nil {
		localVarQueryParams.Add("payload_url__iew", parameterToString(*r.payloadUrlIew, ""))
	}
	if r.payloadUrlNiew != nil {
		localVarQueryParams.Add("payload_url__niew", parameterToString(*r.payloadUrlNiew, ""))
	}
	if r.payloadUrlIsw != nil {
		localVarQueryParams.Add("payload_url__isw", parameterToString(*r.payloadUrlIsw, ""))
	}
	if r.payloadUrlNisw != nil {
		localVarQueryParams.Add("payload_url__nisw", parameterToString(*r.payloadUrlNisw, ""))
	}
	if r.payloadUrlIe != nil {
		localVarQueryParams.Add("payload_url__ie", parameterToString(*r.payloadUrlIe, ""))
	}
	if r.payloadUrlNie != nil {
		localVarQueryParams.Add("payload_url__nie", parameterToString(*r.payloadUrlNie, ""))
	}
	if r.payloadUrlEmpty != nil {
		localVarQueryParams.Add("payload_url__empty", parameterToString(*r.payloadUrlEmpty, ""))
	}
	if r.httpMethodN != nil {
		localVarQueryParams.Add("http_method__n", parameterToString(*r.httpMethodN, ""))
	}
	if r.httpContentTypeN != nil {
		localVarQueryParams.Add("http_content_type__n", parameterToString(*r.httpContentTypeN, ""))
	}
	if r.httpContentTypeIc != nil {
		localVarQueryParams.Add("http_content_type__ic", parameterToString(*r.httpContentTypeIc, ""))
	}
	if r.httpContentTypeNic != nil {
		localVarQueryParams.Add("http_content_type__nic", parameterToString(*r.httpContentTypeNic, ""))
	}
	if r.httpContentTypeIew != nil {
		localVarQueryParams.Add("http_content_type__iew", parameterToString(*r.httpContentTypeIew, ""))
	}
	if r.httpContentTypeNiew != nil {
		localVarQueryParams.Add("http_content_type__niew", parameterToString(*r.httpContentTypeNiew, ""))
	}
	if r.httpContentTypeIsw != nil {
		localVarQueryParams.Add("http_content_type__isw", parameterToString(*r.httpContentTypeIsw, ""))
	}
	if r.httpContentTypeNisw != nil {
		localVarQueryParams.Add("http_content_type__nisw", parameterToString(*r.httpContentTypeNisw, ""))
	}
	if r.httpContentTypeIe != nil {
		localVarQueryParams.Add("http_content_type__ie", parameterToString(*r.httpContentTypeIe, ""))
	}
	if r.httpContentTypeNie != nil {
		localVarQueryParams.Add("http_content_type__nie", parameterToString(*r.httpContentTypeNie, ""))
	}
	if r.httpContentTypeEmpty != nil {
		localVarQueryParams.Add("http_content_type__empty", parameterToString(*r.httpContentTypeEmpty, ""))
	}
	if r.secretN != nil {
		localVarQueryParams.Add("secret__n", parameterToString(*r.secretN, ""))
	}
	if r.secretIc != nil {
		localVarQueryParams.Add("secret__ic", parameterToString(*r.secretIc, ""))
	}
	if r.secretNic != nil {
		localVarQueryParams.Add("secret__nic", parameterToString(*r.secretNic, ""))
	}
	if r.secretIew != nil {
		localVarQueryParams.Add("secret__iew", parameterToString(*r.secretIew, ""))
	}
	if r.secretNiew != nil {
		localVarQueryParams.Add("secret__niew", parameterToString(*r.secretNiew, ""))
	}
	if r.secretIsw != nil {
		localVarQueryParams.Add("secret__isw", parameterToString(*r.secretIsw, ""))
	}
	if r.secretNisw != nil {
		localVarQueryParams.Add("secret__nisw", parameterToString(*r.secretNisw, ""))
	}
	if r.secretIe != nil {
		localVarQueryParams.Add("secret__ie", parameterToString(*r.secretIe, ""))
	}
	if r.secretNie != nil {
		localVarQueryParams.Add("secret__nie", parameterToString(*r.secretNie, ""))
	}
	if r.secretEmpty != nil {
		localVarQueryParams.Add("secret__empty", parameterToString(*r.secretEmpty, ""))
	}
	if r.caFilePathN != nil {
		localVarQueryParams.Add("ca_file_path__n", parameterToString(*r.caFilePathN, ""))
	}
	if r.caFilePathIc != nil {
		localVarQueryParams.Add("ca_file_path__ic", parameterToString(*r.caFilePathIc, ""))
	}
	if r.caFilePathNic != nil {
		localVarQueryParams.Add("ca_file_path__nic", parameterToString(*r.caFilePathNic, ""))
	}
	if r.caFilePathIew != nil {
		localVarQueryParams.Add("ca_file_path__iew", parameterToString(*r.caFilePathIew, ""))
	}
	if r.caFilePathNiew != nil {
		localVarQueryParams.Add("ca_file_path__niew", parameterToString(*r.caFilePathNiew, ""))
	}
	if r.caFilePathIsw != nil {
		localVarQueryParams.Add("ca_file_path__isw", parameterToString(*r.caFilePathIsw, ""))
	}
	if r.caFilePathNisw != nil {
		localVarQueryParams.Add("ca_file_path__nisw", parameterToString(*r.caFilePathNisw, ""))
	}
	if r.caFilePathIe != nil {
		localVarQueryParams.Add("ca_file_path__ie", parameterToString(*r.caFilePathIe, ""))
	}
	if r.caFilePathNie != nil {
		localVarQueryParams.Add("ca_file_path__nie", parameterToString(*r.caFilePathNie, ""))
	}
	if r.caFilePathEmpty != nil {
		localVarQueryParams.Add("ca_file_path__empty", parameterToString(*r.caFilePathEmpty, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiExtrasWebhooksPartialUpdateRequest struct {
	ctx context.Context
	ApiService *ExtrasApiService
	id int32
	data *Webhook
}

func (r ApiExtrasWebhooksPartialUpdateRequest) Data(data Webhook) ApiExtrasWebhooksPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiExtrasWebhooksPartialUpdateRequest) Execute() (*Webhook, *http.Response, error) {
	return r.ApiService.ExtrasWebhooksPartialUpdateExecute(r)
}

/*
ExtrasWebhooksPartialUpdate Method for ExtrasWebhooksPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this webhook.
 @return ApiExtrasWebhooksPartialUpdateRequest
*/
func (a *ExtrasApiService) ExtrasWebhooksPartialUpdate(ctx context.Context, id int32) ApiExtrasWebhooksPartialUpdateRequest {
	return ApiExtrasWebhooksPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Webhook
func (a *ExtrasApiService) ExtrasWebhooksPartialUpdateExecute(r ApiExtrasWebhooksPartialUpdateRequest) (*Webhook, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Webhook
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExtrasApiService.ExtrasWebhooksPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extras/webhooks/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiExtrasWebhooksReadRequest struct {
	ctx context.Context
	ApiService *ExtrasApiService
	id int32
}

func (r ApiExtrasWebhooksReadRequest) Execute() (*Webhook, *http.Response, error) {
	return r.ApiService.ExtrasWebhooksReadExecute(r)
}

/*
ExtrasWebhooksRead Method for ExtrasWebhooksRead

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this webhook.
 @return ApiExtrasWebhooksReadRequest
*/
func (a *ExtrasApiService) ExtrasWebhooksRead(ctx context.Context, id int32) ApiExtrasWebhooksReadRequest {
	return ApiExtrasWebhooksReadRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Webhook
func (a *ExtrasApiService) ExtrasWebhooksReadExecute(r ApiExtrasWebhooksReadRequest) (*Webhook, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Webhook
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExtrasApiService.ExtrasWebhooksRead")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extras/webhooks/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiExtrasWebhooksUpdateRequest struct {
	ctx context.Context
	ApiService *ExtrasApiService
	id int32
	data *Webhook
}

func (r ApiExtrasWebhooksUpdateRequest) Data(data Webhook) ApiExtrasWebhooksUpdateRequest {
	r.data = &data
	return r
}

func (r ApiExtrasWebhooksUpdateRequest) Execute() (*Webhook, *http.Response, error) {
	return r.ApiService.ExtrasWebhooksUpdateExecute(r)
}

/*
ExtrasWebhooksUpdate Method for ExtrasWebhooksUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this webhook.
 @return ApiExtrasWebhooksUpdateRequest
*/
func (a *ExtrasApiService) ExtrasWebhooksUpdate(ctx context.Context, id int32) ApiExtrasWebhooksUpdateRequest {
	return ApiExtrasWebhooksUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Webhook
func (a *ExtrasApiService) ExtrasWebhooksUpdateExecute(r ApiExtrasWebhooksUpdateRequest) (*Webhook, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Webhook
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExtrasApiService.ExtrasWebhooksUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extras/webhooks/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
