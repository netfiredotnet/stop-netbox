/*
NetBox API

API to access NetBox

API version: 2.11
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package netbox

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


// SecretsApiService SecretsApi service
type SecretsApiService service

type ApiSecretsGenerateRsaKeyPairListRequest struct {
	ctx context.Context
	ApiService *SecretsApiService
}

func (r ApiSecretsGenerateRsaKeyPairListRequest) Execute() (*http.Response, error) {
	return r.ApiService.SecretsGenerateRsaKeyPairListExecute(r)
}

/*
SecretsGenerateRsaKeyPairList This endpoint can be used to generate a new RSA key pair. The keys are returned in PEM format.

{
        "public_key": "<public key>",
        "private_key": "<private key>"
    }

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSecretsGenerateRsaKeyPairListRequest
*/
func (a *SecretsApiService) SecretsGenerateRsaKeyPairList(ctx context.Context) ApiSecretsGenerateRsaKeyPairListRequest {
	return ApiSecretsGenerateRsaKeyPairListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SecretsApiService) SecretsGenerateRsaKeyPairListExecute(r ApiSecretsGenerateRsaKeyPairListRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SecretsApiService.SecretsGenerateRsaKeyPairList")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/secrets/generate-rsa-key-pair/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSecretsGetSessionKeyCreateRequest struct {
	ctx context.Context
	ApiService *SecretsApiService
}

func (r ApiSecretsGetSessionKeyCreateRequest) Execute() (*http.Response, error) {
	return r.ApiService.SecretsGetSessionKeyCreateExecute(r)
}

/*
SecretsGetSessionKeyCreate Method for SecretsGetSessionKeyCreate

Retrieve a temporary session key to use for encrypting and decrypting secrets via the API. The user's private RSA
key is POSTed with the name `private_key`. An example:

    curl -v -X POST -H "Authorization: Token <token>" -H "Accept: application/json; indent=4" \
    --data-urlencode "private_key@<filename>" https://netbox/api/secrets/get-session-key/

This request will yield a base64-encoded session key to be included in an `X-Session-Key` header in future requests:

    {
        "session_key": "+8t4SI6XikgVmB5+/urhozx9O5qCQANyOk1MNe6taRf="
    }

This endpoint accepts one optional parameter: `preserve_key`. If True and a session key exists, the existing session
key will be returned instead of a new one.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSecretsGetSessionKeyCreateRequest
*/
func (a *SecretsApiService) SecretsGetSessionKeyCreate(ctx context.Context) ApiSecretsGetSessionKeyCreateRequest {
	return ApiSecretsGetSessionKeyCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SecretsApiService) SecretsGetSessionKeyCreateExecute(r ApiSecretsGetSessionKeyCreateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SecretsApiService.SecretsGetSessionKeyCreate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/secrets/get-session-key/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSecretsSecretRolesBulkDeleteRequest struct {
	ctx context.Context
	ApiService *SecretsApiService
}

func (r ApiSecretsSecretRolesBulkDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.SecretsSecretRolesBulkDeleteExecute(r)
}

/*
SecretsSecretRolesBulkDelete Method for SecretsSecretRolesBulkDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSecretsSecretRolesBulkDeleteRequest
*/
func (a *SecretsApiService) SecretsSecretRolesBulkDelete(ctx context.Context) ApiSecretsSecretRolesBulkDeleteRequest {
	return ApiSecretsSecretRolesBulkDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SecretsApiService) SecretsSecretRolesBulkDeleteExecute(r ApiSecretsSecretRolesBulkDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SecretsApiService.SecretsSecretRolesBulkDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/secrets/secret-roles/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSecretsSecretRolesBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *SecretsApiService
	data *SecretRole
}

func (r ApiSecretsSecretRolesBulkPartialUpdateRequest) Data(data SecretRole) ApiSecretsSecretRolesBulkPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiSecretsSecretRolesBulkPartialUpdateRequest) Execute() (*SecretRole, *http.Response, error) {
	return r.ApiService.SecretsSecretRolesBulkPartialUpdateExecute(r)
}

/*
SecretsSecretRolesBulkPartialUpdate Method for SecretsSecretRolesBulkPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSecretsSecretRolesBulkPartialUpdateRequest
*/
func (a *SecretsApiService) SecretsSecretRolesBulkPartialUpdate(ctx context.Context) ApiSecretsSecretRolesBulkPartialUpdateRequest {
	return ApiSecretsSecretRolesBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SecretRole
func (a *SecretsApiService) SecretsSecretRolesBulkPartialUpdateExecute(r ApiSecretsSecretRolesBulkPartialUpdateRequest) (*SecretRole, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SecretRole
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SecretsApiService.SecretsSecretRolesBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/secrets/secret-roles/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSecretsSecretRolesBulkUpdateRequest struct {
	ctx context.Context
	ApiService *SecretsApiService
	data *SecretRole
}

func (r ApiSecretsSecretRolesBulkUpdateRequest) Data(data SecretRole) ApiSecretsSecretRolesBulkUpdateRequest {
	r.data = &data
	return r
}

func (r ApiSecretsSecretRolesBulkUpdateRequest) Execute() (*SecretRole, *http.Response, error) {
	return r.ApiService.SecretsSecretRolesBulkUpdateExecute(r)
}

/*
SecretsSecretRolesBulkUpdate Method for SecretsSecretRolesBulkUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSecretsSecretRolesBulkUpdateRequest
*/
func (a *SecretsApiService) SecretsSecretRolesBulkUpdate(ctx context.Context) ApiSecretsSecretRolesBulkUpdateRequest {
	return ApiSecretsSecretRolesBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SecretRole
func (a *SecretsApiService) SecretsSecretRolesBulkUpdateExecute(r ApiSecretsSecretRolesBulkUpdateRequest) (*SecretRole, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SecretRole
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SecretsApiService.SecretsSecretRolesBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/secrets/secret-roles/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSecretsSecretRolesCreateRequest struct {
	ctx context.Context
	ApiService *SecretsApiService
	data *SecretRole
}

func (r ApiSecretsSecretRolesCreateRequest) Data(data SecretRole) ApiSecretsSecretRolesCreateRequest {
	r.data = &data
	return r
}

func (r ApiSecretsSecretRolesCreateRequest) Execute() (*SecretRole, *http.Response, error) {
	return r.ApiService.SecretsSecretRolesCreateExecute(r)
}

/*
SecretsSecretRolesCreate Method for SecretsSecretRolesCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSecretsSecretRolesCreateRequest
*/
func (a *SecretsApiService) SecretsSecretRolesCreate(ctx context.Context) ApiSecretsSecretRolesCreateRequest {
	return ApiSecretsSecretRolesCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SecretRole
func (a *SecretsApiService) SecretsSecretRolesCreateExecute(r ApiSecretsSecretRolesCreateRequest) (*SecretRole, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SecretRole
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SecretsApiService.SecretsSecretRolesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/secrets/secret-roles/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSecretsSecretRolesDeleteRequest struct {
	ctx context.Context
	ApiService *SecretsApiService
	id int32
}

func (r ApiSecretsSecretRolesDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.SecretsSecretRolesDeleteExecute(r)
}

/*
SecretsSecretRolesDelete Method for SecretsSecretRolesDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this secret role.
 @return ApiSecretsSecretRolesDeleteRequest
*/
func (a *SecretsApiService) SecretsSecretRolesDelete(ctx context.Context, id int32) ApiSecretsSecretRolesDeleteRequest {
	return ApiSecretsSecretRolesDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *SecretsApiService) SecretsSecretRolesDeleteExecute(r ApiSecretsSecretRolesDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SecretsApiService.SecretsSecretRolesDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/secrets/secret-roles/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSecretsSecretRolesListRequest struct {
	ctx context.Context
	ApiService *SecretsApiService
	id *string
	name *string
	slug *string
	created *string
	createdGte *string
	createdLte *string
	lastUpdated *string
	lastUpdatedGte *string
	lastUpdatedLte *string
	q *string
	idN *string
	idLte *string
	idLt *string
	idGte *string
	idGt *string
	nameN *string
	nameIc *string
	nameNic *string
	nameIew *string
	nameNiew *string
	nameIsw *string
	nameNisw *string
	nameIe *string
	nameNie *string
	nameEmpty *string
	slugN *string
	slugIc *string
	slugNic *string
	slugIew *string
	slugNiew *string
	slugIsw *string
	slugNisw *string
	slugIe *string
	slugNie *string
	slugEmpty *string
	limit *int32
	offset *int32
}

func (r ApiSecretsSecretRolesListRequest) Id(id string) ApiSecretsSecretRolesListRequest {
	r.id = &id
	return r
}

func (r ApiSecretsSecretRolesListRequest) Name(name string) ApiSecretsSecretRolesListRequest {
	r.name = &name
	return r
}

func (r ApiSecretsSecretRolesListRequest) Slug(slug string) ApiSecretsSecretRolesListRequest {
	r.slug = &slug
	return r
}

func (r ApiSecretsSecretRolesListRequest) Created(created string) ApiSecretsSecretRolesListRequest {
	r.created = &created
	return r
}

func (r ApiSecretsSecretRolesListRequest) CreatedGte(createdGte string) ApiSecretsSecretRolesListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiSecretsSecretRolesListRequest) CreatedLte(createdLte string) ApiSecretsSecretRolesListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiSecretsSecretRolesListRequest) LastUpdated(lastUpdated string) ApiSecretsSecretRolesListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiSecretsSecretRolesListRequest) LastUpdatedGte(lastUpdatedGte string) ApiSecretsSecretRolesListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiSecretsSecretRolesListRequest) LastUpdatedLte(lastUpdatedLte string) ApiSecretsSecretRolesListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiSecretsSecretRolesListRequest) Q(q string) ApiSecretsSecretRolesListRequest {
	r.q = &q
	return r
}

func (r ApiSecretsSecretRolesListRequest) IdN(idN string) ApiSecretsSecretRolesListRequest {
	r.idN = &idN
	return r
}

func (r ApiSecretsSecretRolesListRequest) IdLte(idLte string) ApiSecretsSecretRolesListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiSecretsSecretRolesListRequest) IdLt(idLt string) ApiSecretsSecretRolesListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiSecretsSecretRolesListRequest) IdGte(idGte string) ApiSecretsSecretRolesListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiSecretsSecretRolesListRequest) IdGt(idGt string) ApiSecretsSecretRolesListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiSecretsSecretRolesListRequest) NameN(nameN string) ApiSecretsSecretRolesListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiSecretsSecretRolesListRequest) NameIc(nameIc string) ApiSecretsSecretRolesListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiSecretsSecretRolesListRequest) NameNic(nameNic string) ApiSecretsSecretRolesListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiSecretsSecretRolesListRequest) NameIew(nameIew string) ApiSecretsSecretRolesListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiSecretsSecretRolesListRequest) NameNiew(nameNiew string) ApiSecretsSecretRolesListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiSecretsSecretRolesListRequest) NameIsw(nameIsw string) ApiSecretsSecretRolesListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiSecretsSecretRolesListRequest) NameNisw(nameNisw string) ApiSecretsSecretRolesListRequest {
	r.nameNisw = &nameNisw
	return r
}

func (r ApiSecretsSecretRolesListRequest) NameIe(nameIe string) ApiSecretsSecretRolesListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiSecretsSecretRolesListRequest) NameNie(nameNie string) ApiSecretsSecretRolesListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiSecretsSecretRolesListRequest) NameEmpty(nameEmpty string) ApiSecretsSecretRolesListRequest {
	r.nameEmpty = &nameEmpty
	return r
}

func (r ApiSecretsSecretRolesListRequest) SlugN(slugN string) ApiSecretsSecretRolesListRequest {
	r.slugN = &slugN
	return r
}

func (r ApiSecretsSecretRolesListRequest) SlugIc(slugIc string) ApiSecretsSecretRolesListRequest {
	r.slugIc = &slugIc
	return r
}

func (r ApiSecretsSecretRolesListRequest) SlugNic(slugNic string) ApiSecretsSecretRolesListRequest {
	r.slugNic = &slugNic
	return r
}

func (r ApiSecretsSecretRolesListRequest) SlugIew(slugIew string) ApiSecretsSecretRolesListRequest {
	r.slugIew = &slugIew
	return r
}

func (r ApiSecretsSecretRolesListRequest) SlugNiew(slugNiew string) ApiSecretsSecretRolesListRequest {
	r.slugNiew = &slugNiew
	return r
}

func (r ApiSecretsSecretRolesListRequest) SlugIsw(slugIsw string) ApiSecretsSecretRolesListRequest {
	r.slugIsw = &slugIsw
	return r
}

func (r ApiSecretsSecretRolesListRequest) SlugNisw(slugNisw string) ApiSecretsSecretRolesListRequest {
	r.slugNisw = &slugNisw
	return r
}

func (r ApiSecretsSecretRolesListRequest) SlugIe(slugIe string) ApiSecretsSecretRolesListRequest {
	r.slugIe = &slugIe
	return r
}

func (r ApiSecretsSecretRolesListRequest) SlugNie(slugNie string) ApiSecretsSecretRolesListRequest {
	r.slugNie = &slugNie
	return r
}

func (r ApiSecretsSecretRolesListRequest) SlugEmpty(slugEmpty string) ApiSecretsSecretRolesListRequest {
	r.slugEmpty = &slugEmpty
	return r
}

// Number of results to return per page.
func (r ApiSecretsSecretRolesListRequest) Limit(limit int32) ApiSecretsSecretRolesListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiSecretsSecretRolesListRequest) Offset(offset int32) ApiSecretsSecretRolesListRequest {
	r.offset = &offset
	return r
}

func (r ApiSecretsSecretRolesListRequest) Execute() (*SecretsSecretRolesList200Response, *http.Response, error) {
	return r.ApiService.SecretsSecretRolesListExecute(r)
}

/*
SecretsSecretRolesList Method for SecretsSecretRolesList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSecretsSecretRolesListRequest
*/
func (a *SecretsApiService) SecretsSecretRolesList(ctx context.Context) ApiSecretsSecretRolesListRequest {
	return ApiSecretsSecretRolesListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SecretsSecretRolesList200Response
func (a *SecretsApiService) SecretsSecretRolesListExecute(r ApiSecretsSecretRolesListRequest) (*SecretsSecretRolesList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SecretsSecretRolesList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SecretsApiService.SecretsSecretRolesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/secrets/secret-roles/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.slug != nil {
		localVarQueryParams.Add("slug", parameterToString(*r.slug, ""))
	}
	if r.created != nil {
		localVarQueryParams.Add("created", parameterToString(*r.created, ""))
	}
	if r.createdGte != nil {
		localVarQueryParams.Add("created__gte", parameterToString(*r.createdGte, ""))
	}
	if r.createdLte != nil {
		localVarQueryParams.Add("created__lte", parameterToString(*r.createdLte, ""))
	}
	if r.lastUpdated != nil {
		localVarQueryParams.Add("last_updated", parameterToString(*r.lastUpdated, ""))
	}
	if r.lastUpdatedGte != nil {
		localVarQueryParams.Add("last_updated__gte", parameterToString(*r.lastUpdatedGte, ""))
	}
	if r.lastUpdatedLte != nil {
		localVarQueryParams.Add("last_updated__lte", parameterToString(*r.lastUpdatedLte, ""))
	}
	if r.q != nil {
		localVarQueryParams.Add("q", parameterToString(*r.q, ""))
	}
	if r.idN != nil {
		localVarQueryParams.Add("id__n", parameterToString(*r.idN, ""))
	}
	if r.idLte != nil {
		localVarQueryParams.Add("id__lte", parameterToString(*r.idLte, ""))
	}
	if r.idLt != nil {
		localVarQueryParams.Add("id__lt", parameterToString(*r.idLt, ""))
	}
	if r.idGte != nil {
		localVarQueryParams.Add("id__gte", parameterToString(*r.idGte, ""))
	}
	if r.idGt != nil {
		localVarQueryParams.Add("id__gt", parameterToString(*r.idGt, ""))
	}
	if r.nameN != nil {
		localVarQueryParams.Add("name__n", parameterToString(*r.nameN, ""))
	}
	if r.nameIc != nil {
		localVarQueryParams.Add("name__ic", parameterToString(*r.nameIc, ""))
	}
	if r.nameNic != nil {
		localVarQueryParams.Add("name__nic", parameterToString(*r.nameNic, ""))
	}
	if r.nameIew != nil {
		localVarQueryParams.Add("name__iew", parameterToString(*r.nameIew, ""))
	}
	if r.nameNiew != nil {
		localVarQueryParams.Add("name__niew", parameterToString(*r.nameNiew, ""))
	}
	if r.nameIsw != nil {
		localVarQueryParams.Add("name__isw", parameterToString(*r.nameIsw, ""))
	}
	if r.nameNisw != nil {
		localVarQueryParams.Add("name__nisw", parameterToString(*r.nameNisw, ""))
	}
	if r.nameIe != nil {
		localVarQueryParams.Add("name__ie", parameterToString(*r.nameIe, ""))
	}
	if r.nameNie != nil {
		localVarQueryParams.Add("name__nie", parameterToString(*r.nameNie, ""))
	}
	if r.nameEmpty != nil {
		localVarQueryParams.Add("name__empty", parameterToString(*r.nameEmpty, ""))
	}
	if r.slugN != nil {
		localVarQueryParams.Add("slug__n", parameterToString(*r.slugN, ""))
	}
	if r.slugIc != nil {
		localVarQueryParams.Add("slug__ic", parameterToString(*r.slugIc, ""))
	}
	if r.slugNic != nil {
		localVarQueryParams.Add("slug__nic", parameterToString(*r.slugNic, ""))
	}
	if r.slugIew != nil {
		localVarQueryParams.Add("slug__iew", parameterToString(*r.slugIew, ""))
	}
	if r.slugNiew != nil {
		localVarQueryParams.Add("slug__niew", parameterToString(*r.slugNiew, ""))
	}
	if r.slugIsw != nil {
		localVarQueryParams.Add("slug__isw", parameterToString(*r.slugIsw, ""))
	}
	if r.slugNisw != nil {
		localVarQueryParams.Add("slug__nisw", parameterToString(*r.slugNisw, ""))
	}
	if r.slugIe != nil {
		localVarQueryParams.Add("slug__ie", parameterToString(*r.slugIe, ""))
	}
	if r.slugNie != nil {
		localVarQueryParams.Add("slug__nie", parameterToString(*r.slugNie, ""))
	}
	if r.slugEmpty != nil {
		localVarQueryParams.Add("slug__empty", parameterToString(*r.slugEmpty, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSecretsSecretRolesPartialUpdateRequest struct {
	ctx context.Context
	ApiService *SecretsApiService
	id int32
	data *SecretRole
}

func (r ApiSecretsSecretRolesPartialUpdateRequest) Data(data SecretRole) ApiSecretsSecretRolesPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiSecretsSecretRolesPartialUpdateRequest) Execute() (*SecretRole, *http.Response, error) {
	return r.ApiService.SecretsSecretRolesPartialUpdateExecute(r)
}

/*
SecretsSecretRolesPartialUpdate Method for SecretsSecretRolesPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this secret role.
 @return ApiSecretsSecretRolesPartialUpdateRequest
*/
func (a *SecretsApiService) SecretsSecretRolesPartialUpdate(ctx context.Context, id int32) ApiSecretsSecretRolesPartialUpdateRequest {
	return ApiSecretsSecretRolesPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return SecretRole
func (a *SecretsApiService) SecretsSecretRolesPartialUpdateExecute(r ApiSecretsSecretRolesPartialUpdateRequest) (*SecretRole, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SecretRole
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SecretsApiService.SecretsSecretRolesPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/secrets/secret-roles/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSecretsSecretRolesReadRequest struct {
	ctx context.Context
	ApiService *SecretsApiService
	id int32
}

func (r ApiSecretsSecretRolesReadRequest) Execute() (*SecretRole, *http.Response, error) {
	return r.ApiService.SecretsSecretRolesReadExecute(r)
}

/*
SecretsSecretRolesRead Method for SecretsSecretRolesRead

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this secret role.
 @return ApiSecretsSecretRolesReadRequest
*/
func (a *SecretsApiService) SecretsSecretRolesRead(ctx context.Context, id int32) ApiSecretsSecretRolesReadRequest {
	return ApiSecretsSecretRolesReadRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return SecretRole
func (a *SecretsApiService) SecretsSecretRolesReadExecute(r ApiSecretsSecretRolesReadRequest) (*SecretRole, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SecretRole
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SecretsApiService.SecretsSecretRolesRead")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/secrets/secret-roles/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSecretsSecretRolesUpdateRequest struct {
	ctx context.Context
	ApiService *SecretsApiService
	id int32
	data *SecretRole
}

func (r ApiSecretsSecretRolesUpdateRequest) Data(data SecretRole) ApiSecretsSecretRolesUpdateRequest {
	r.data = &data
	return r
}

func (r ApiSecretsSecretRolesUpdateRequest) Execute() (*SecretRole, *http.Response, error) {
	return r.ApiService.SecretsSecretRolesUpdateExecute(r)
}

/*
SecretsSecretRolesUpdate Method for SecretsSecretRolesUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this secret role.
 @return ApiSecretsSecretRolesUpdateRequest
*/
func (a *SecretsApiService) SecretsSecretRolesUpdate(ctx context.Context, id int32) ApiSecretsSecretRolesUpdateRequest {
	return ApiSecretsSecretRolesUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return SecretRole
func (a *SecretsApiService) SecretsSecretRolesUpdateExecute(r ApiSecretsSecretRolesUpdateRequest) (*SecretRole, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SecretRole
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SecretsApiService.SecretsSecretRolesUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/secrets/secret-roles/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSecretsSecretsBulkDeleteRequest struct {
	ctx context.Context
	ApiService *SecretsApiService
}

func (r ApiSecretsSecretsBulkDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.SecretsSecretsBulkDeleteExecute(r)
}

/*
SecretsSecretsBulkDelete Method for SecretsSecretsBulkDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSecretsSecretsBulkDeleteRequest
*/
func (a *SecretsApiService) SecretsSecretsBulkDelete(ctx context.Context) ApiSecretsSecretsBulkDeleteRequest {
	return ApiSecretsSecretsBulkDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SecretsApiService) SecretsSecretsBulkDeleteExecute(r ApiSecretsSecretsBulkDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SecretsApiService.SecretsSecretsBulkDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/secrets/secrets/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSecretsSecretsBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *SecretsApiService
	data *WritableSecret
}

func (r ApiSecretsSecretsBulkPartialUpdateRequest) Data(data WritableSecret) ApiSecretsSecretsBulkPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiSecretsSecretsBulkPartialUpdateRequest) Execute() (*Secret, *http.Response, error) {
	return r.ApiService.SecretsSecretsBulkPartialUpdateExecute(r)
}

/*
SecretsSecretsBulkPartialUpdate Method for SecretsSecretsBulkPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSecretsSecretsBulkPartialUpdateRequest
*/
func (a *SecretsApiService) SecretsSecretsBulkPartialUpdate(ctx context.Context) ApiSecretsSecretsBulkPartialUpdateRequest {
	return ApiSecretsSecretsBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Secret
func (a *SecretsApiService) SecretsSecretsBulkPartialUpdateExecute(r ApiSecretsSecretsBulkPartialUpdateRequest) (*Secret, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Secret
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SecretsApiService.SecretsSecretsBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/secrets/secrets/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSecretsSecretsBulkUpdateRequest struct {
	ctx context.Context
	ApiService *SecretsApiService
	data *WritableSecret
}

func (r ApiSecretsSecretsBulkUpdateRequest) Data(data WritableSecret) ApiSecretsSecretsBulkUpdateRequest {
	r.data = &data
	return r
}

func (r ApiSecretsSecretsBulkUpdateRequest) Execute() (*Secret, *http.Response, error) {
	return r.ApiService.SecretsSecretsBulkUpdateExecute(r)
}

/*
SecretsSecretsBulkUpdate Method for SecretsSecretsBulkUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSecretsSecretsBulkUpdateRequest
*/
func (a *SecretsApiService) SecretsSecretsBulkUpdate(ctx context.Context) ApiSecretsSecretsBulkUpdateRequest {
	return ApiSecretsSecretsBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Secret
func (a *SecretsApiService) SecretsSecretsBulkUpdateExecute(r ApiSecretsSecretsBulkUpdateRequest) (*Secret, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Secret
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SecretsApiService.SecretsSecretsBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/secrets/secrets/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSecretsSecretsCreateRequest struct {
	ctx context.Context
	ApiService *SecretsApiService
	data *WritableSecret
}

func (r ApiSecretsSecretsCreateRequest) Data(data WritableSecret) ApiSecretsSecretsCreateRequest {
	r.data = &data
	return r
}

func (r ApiSecretsSecretsCreateRequest) Execute() (*Secret, *http.Response, error) {
	return r.ApiService.SecretsSecretsCreateExecute(r)
}

/*
SecretsSecretsCreate Method for SecretsSecretsCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSecretsSecretsCreateRequest
*/
func (a *SecretsApiService) SecretsSecretsCreate(ctx context.Context) ApiSecretsSecretsCreateRequest {
	return ApiSecretsSecretsCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Secret
func (a *SecretsApiService) SecretsSecretsCreateExecute(r ApiSecretsSecretsCreateRequest) (*Secret, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Secret
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SecretsApiService.SecretsSecretsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/secrets/secrets/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSecretsSecretsDeleteRequest struct {
	ctx context.Context
	ApiService *SecretsApiService
	id int32
}

func (r ApiSecretsSecretsDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.SecretsSecretsDeleteExecute(r)
}

/*
SecretsSecretsDelete Method for SecretsSecretsDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this secret.
 @return ApiSecretsSecretsDeleteRequest
*/
func (a *SecretsApiService) SecretsSecretsDelete(ctx context.Context, id int32) ApiSecretsSecretsDeleteRequest {
	return ApiSecretsSecretsDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *SecretsApiService) SecretsSecretsDeleteExecute(r ApiSecretsSecretsDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SecretsApiService.SecretsSecretsDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/secrets/secrets/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSecretsSecretsListRequest struct {
	ctx context.Context
	ApiService *SecretsApiService
	id *string
	name *string
	created *string
	createdGte *string
	createdLte *string
	lastUpdated *string
	lastUpdatedGte *string
	lastUpdatedLte *string
	q *string
	roleId *string
	role *string
	device *string
	deviceId *string
	virtualMachine *string
	virtualMachineId *string
	tag *string
	idN *string
	idLte *string
	idLt *string
	idGte *string
	idGt *string
	nameN *string
	nameIc *string
	nameNic *string
	nameIew *string
	nameNiew *string
	nameIsw *string
	nameNisw *string
	nameIe *string
	nameNie *string
	nameEmpty *string
	roleIdN *string
	roleN *string
	deviceN *string
	deviceIdN *string
	virtualMachineN *string
	virtualMachineIdN *string
	tagN *string
	limit *int32
	offset *int32
}

func (r ApiSecretsSecretsListRequest) Id(id string) ApiSecretsSecretsListRequest {
	r.id = &id
	return r
}

func (r ApiSecretsSecretsListRequest) Name(name string) ApiSecretsSecretsListRequest {
	r.name = &name
	return r
}

func (r ApiSecretsSecretsListRequest) Created(created string) ApiSecretsSecretsListRequest {
	r.created = &created
	return r
}

func (r ApiSecretsSecretsListRequest) CreatedGte(createdGte string) ApiSecretsSecretsListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiSecretsSecretsListRequest) CreatedLte(createdLte string) ApiSecretsSecretsListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiSecretsSecretsListRequest) LastUpdated(lastUpdated string) ApiSecretsSecretsListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiSecretsSecretsListRequest) LastUpdatedGte(lastUpdatedGte string) ApiSecretsSecretsListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiSecretsSecretsListRequest) LastUpdatedLte(lastUpdatedLte string) ApiSecretsSecretsListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiSecretsSecretsListRequest) Q(q string) ApiSecretsSecretsListRequest {
	r.q = &q
	return r
}

func (r ApiSecretsSecretsListRequest) RoleId(roleId string) ApiSecretsSecretsListRequest {
	r.roleId = &roleId
	return r
}

func (r ApiSecretsSecretsListRequest) Role(role string) ApiSecretsSecretsListRequest {
	r.role = &role
	return r
}

func (r ApiSecretsSecretsListRequest) Device(device string) ApiSecretsSecretsListRequest {
	r.device = &device
	return r
}

func (r ApiSecretsSecretsListRequest) DeviceId(deviceId string) ApiSecretsSecretsListRequest {
	r.deviceId = &deviceId
	return r
}

func (r ApiSecretsSecretsListRequest) VirtualMachine(virtualMachine string) ApiSecretsSecretsListRequest {
	r.virtualMachine = &virtualMachine
	return r
}

func (r ApiSecretsSecretsListRequest) VirtualMachineId(virtualMachineId string) ApiSecretsSecretsListRequest {
	r.virtualMachineId = &virtualMachineId
	return r
}

func (r ApiSecretsSecretsListRequest) Tag(tag string) ApiSecretsSecretsListRequest {
	r.tag = &tag
	return r
}

func (r ApiSecretsSecretsListRequest) IdN(idN string) ApiSecretsSecretsListRequest {
	r.idN = &idN
	return r
}

func (r ApiSecretsSecretsListRequest) IdLte(idLte string) ApiSecretsSecretsListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiSecretsSecretsListRequest) IdLt(idLt string) ApiSecretsSecretsListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiSecretsSecretsListRequest) IdGte(idGte string) ApiSecretsSecretsListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiSecretsSecretsListRequest) IdGt(idGt string) ApiSecretsSecretsListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiSecretsSecretsListRequest) NameN(nameN string) ApiSecretsSecretsListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiSecretsSecretsListRequest) NameIc(nameIc string) ApiSecretsSecretsListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiSecretsSecretsListRequest) NameNic(nameNic string) ApiSecretsSecretsListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiSecretsSecretsListRequest) NameIew(nameIew string) ApiSecretsSecretsListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiSecretsSecretsListRequest) NameNiew(nameNiew string) ApiSecretsSecretsListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiSecretsSecretsListRequest) NameIsw(nameIsw string) ApiSecretsSecretsListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiSecretsSecretsListRequest) NameNisw(nameNisw string) ApiSecretsSecretsListRequest {
	r.nameNisw = &nameNisw
	return r
}

func (r ApiSecretsSecretsListRequest) NameIe(nameIe string) ApiSecretsSecretsListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiSecretsSecretsListRequest) NameNie(nameNie string) ApiSecretsSecretsListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiSecretsSecretsListRequest) NameEmpty(nameEmpty string) ApiSecretsSecretsListRequest {
	r.nameEmpty = &nameEmpty
	return r
}

func (r ApiSecretsSecretsListRequest) RoleIdN(roleIdN string) ApiSecretsSecretsListRequest {
	r.roleIdN = &roleIdN
	return r
}

func (r ApiSecretsSecretsListRequest) RoleN(roleN string) ApiSecretsSecretsListRequest {
	r.roleN = &roleN
	return r
}

func (r ApiSecretsSecretsListRequest) DeviceN(deviceN string) ApiSecretsSecretsListRequest {
	r.deviceN = &deviceN
	return r
}

func (r ApiSecretsSecretsListRequest) DeviceIdN(deviceIdN string) ApiSecretsSecretsListRequest {
	r.deviceIdN = &deviceIdN
	return r
}

func (r ApiSecretsSecretsListRequest) VirtualMachineN(virtualMachineN string) ApiSecretsSecretsListRequest {
	r.virtualMachineN = &virtualMachineN
	return r
}

func (r ApiSecretsSecretsListRequest) VirtualMachineIdN(virtualMachineIdN string) ApiSecretsSecretsListRequest {
	r.virtualMachineIdN = &virtualMachineIdN
	return r
}

func (r ApiSecretsSecretsListRequest) TagN(tagN string) ApiSecretsSecretsListRequest {
	r.tagN = &tagN
	return r
}

// Number of results to return per page.
func (r ApiSecretsSecretsListRequest) Limit(limit int32) ApiSecretsSecretsListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiSecretsSecretsListRequest) Offset(offset int32) ApiSecretsSecretsListRequest {
	r.offset = &offset
	return r
}

func (r ApiSecretsSecretsListRequest) Execute() (*SecretsSecretsList200Response, *http.Response, error) {
	return r.ApiService.SecretsSecretsListExecute(r)
}

/*
SecretsSecretsList Method for SecretsSecretsList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSecretsSecretsListRequest
*/
func (a *SecretsApiService) SecretsSecretsList(ctx context.Context) ApiSecretsSecretsListRequest {
	return ApiSecretsSecretsListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SecretsSecretsList200Response
func (a *SecretsApiService) SecretsSecretsListExecute(r ApiSecretsSecretsListRequest) (*SecretsSecretsList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SecretsSecretsList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SecretsApiService.SecretsSecretsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/secrets/secrets/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.created != nil {
		localVarQueryParams.Add("created", parameterToString(*r.created, ""))
	}
	if r.createdGte != nil {
		localVarQueryParams.Add("created__gte", parameterToString(*r.createdGte, ""))
	}
	if r.createdLte != nil {
		localVarQueryParams.Add("created__lte", parameterToString(*r.createdLte, ""))
	}
	if r.lastUpdated != nil {
		localVarQueryParams.Add("last_updated", parameterToString(*r.lastUpdated, ""))
	}
	if r.lastUpdatedGte != nil {
		localVarQueryParams.Add("last_updated__gte", parameterToString(*r.lastUpdatedGte, ""))
	}
	if r.lastUpdatedLte != nil {
		localVarQueryParams.Add("last_updated__lte", parameterToString(*r.lastUpdatedLte, ""))
	}
	if r.q != nil {
		localVarQueryParams.Add("q", parameterToString(*r.q, ""))
	}
	if r.roleId != nil {
		localVarQueryParams.Add("role_id", parameterToString(*r.roleId, ""))
	}
	if r.role != nil {
		localVarQueryParams.Add("role", parameterToString(*r.role, ""))
	}
	if r.device != nil {
		localVarQueryParams.Add("device", parameterToString(*r.device, ""))
	}
	if r.deviceId != nil {
		localVarQueryParams.Add("device_id", parameterToString(*r.deviceId, ""))
	}
	if r.virtualMachine != nil {
		localVarQueryParams.Add("virtual_machine", parameterToString(*r.virtualMachine, ""))
	}
	if r.virtualMachineId != nil {
		localVarQueryParams.Add("virtual_machine_id", parameterToString(*r.virtualMachineId, ""))
	}
	if r.tag != nil {
		localVarQueryParams.Add("tag", parameterToString(*r.tag, ""))
	}
	if r.idN != nil {
		localVarQueryParams.Add("id__n", parameterToString(*r.idN, ""))
	}
	if r.idLte != nil {
		localVarQueryParams.Add("id__lte", parameterToString(*r.idLte, ""))
	}
	if r.idLt != nil {
		localVarQueryParams.Add("id__lt", parameterToString(*r.idLt, ""))
	}
	if r.idGte != nil {
		localVarQueryParams.Add("id__gte", parameterToString(*r.idGte, ""))
	}
	if r.idGt != nil {
		localVarQueryParams.Add("id__gt", parameterToString(*r.idGt, ""))
	}
	if r.nameN != nil {
		localVarQueryParams.Add("name__n", parameterToString(*r.nameN, ""))
	}
	if r.nameIc != nil {
		localVarQueryParams.Add("name__ic", parameterToString(*r.nameIc, ""))
	}
	if r.nameNic != nil {
		localVarQueryParams.Add("name__nic", parameterToString(*r.nameNic, ""))
	}
	if r.nameIew != nil {
		localVarQueryParams.Add("name__iew", parameterToString(*r.nameIew, ""))
	}
	if r.nameNiew != nil {
		localVarQueryParams.Add("name__niew", parameterToString(*r.nameNiew, ""))
	}
	if r.nameIsw != nil {
		localVarQueryParams.Add("name__isw", parameterToString(*r.nameIsw, ""))
	}
	if r.nameNisw != nil {
		localVarQueryParams.Add("name__nisw", parameterToString(*r.nameNisw, ""))
	}
	if r.nameIe != nil {
		localVarQueryParams.Add("name__ie", parameterToString(*r.nameIe, ""))
	}
	if r.nameNie != nil {
		localVarQueryParams.Add("name__nie", parameterToString(*r.nameNie, ""))
	}
	if r.nameEmpty != nil {
		localVarQueryParams.Add("name__empty", parameterToString(*r.nameEmpty, ""))
	}
	if r.roleIdN != nil {
		localVarQueryParams.Add("role_id__n", parameterToString(*r.roleIdN, ""))
	}
	if r.roleN != nil {
		localVarQueryParams.Add("role__n", parameterToString(*r.roleN, ""))
	}
	if r.deviceN != nil {
		localVarQueryParams.Add("device__n", parameterToString(*r.deviceN, ""))
	}
	if r.deviceIdN != nil {
		localVarQueryParams.Add("device_id__n", parameterToString(*r.deviceIdN, ""))
	}
	if r.virtualMachineN != nil {
		localVarQueryParams.Add("virtual_machine__n", parameterToString(*r.virtualMachineN, ""))
	}
	if r.virtualMachineIdN != nil {
		localVarQueryParams.Add("virtual_machine_id__n", parameterToString(*r.virtualMachineIdN, ""))
	}
	if r.tagN != nil {
		localVarQueryParams.Add("tag__n", parameterToString(*r.tagN, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSecretsSecretsPartialUpdateRequest struct {
	ctx context.Context
	ApiService *SecretsApiService
	id int32
	data *WritableSecret
}

func (r ApiSecretsSecretsPartialUpdateRequest) Data(data WritableSecret) ApiSecretsSecretsPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiSecretsSecretsPartialUpdateRequest) Execute() (*Secret, *http.Response, error) {
	return r.ApiService.SecretsSecretsPartialUpdateExecute(r)
}

/*
SecretsSecretsPartialUpdate Method for SecretsSecretsPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this secret.
 @return ApiSecretsSecretsPartialUpdateRequest
*/
func (a *SecretsApiService) SecretsSecretsPartialUpdate(ctx context.Context, id int32) ApiSecretsSecretsPartialUpdateRequest {
	return ApiSecretsSecretsPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Secret
func (a *SecretsApiService) SecretsSecretsPartialUpdateExecute(r ApiSecretsSecretsPartialUpdateRequest) (*Secret, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Secret
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SecretsApiService.SecretsSecretsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/secrets/secrets/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSecretsSecretsReadRequest struct {
	ctx context.Context
	ApiService *SecretsApiService
	id int32
}

func (r ApiSecretsSecretsReadRequest) Execute() (*Secret, *http.Response, error) {
	return r.ApiService.SecretsSecretsReadExecute(r)
}

/*
SecretsSecretsRead Method for SecretsSecretsRead

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this secret.
 @return ApiSecretsSecretsReadRequest
*/
func (a *SecretsApiService) SecretsSecretsRead(ctx context.Context, id int32) ApiSecretsSecretsReadRequest {
	return ApiSecretsSecretsReadRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Secret
func (a *SecretsApiService) SecretsSecretsReadExecute(r ApiSecretsSecretsReadRequest) (*Secret, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Secret
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SecretsApiService.SecretsSecretsRead")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/secrets/secrets/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSecretsSecretsUpdateRequest struct {
	ctx context.Context
	ApiService *SecretsApiService
	id int32
	data *WritableSecret
}

func (r ApiSecretsSecretsUpdateRequest) Data(data WritableSecret) ApiSecretsSecretsUpdateRequest {
	r.data = &data
	return r
}

func (r ApiSecretsSecretsUpdateRequest) Execute() (*Secret, *http.Response, error) {
	return r.ApiService.SecretsSecretsUpdateExecute(r)
}

/*
SecretsSecretsUpdate Method for SecretsSecretsUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this secret.
 @return ApiSecretsSecretsUpdateRequest
*/
func (a *SecretsApiService) SecretsSecretsUpdate(ctx context.Context, id int32) ApiSecretsSecretsUpdateRequest {
	return ApiSecretsSecretsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Secret
func (a *SecretsApiService) SecretsSecretsUpdateExecute(r ApiSecretsSecretsUpdateRequest) (*Secret, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Secret
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SecretsApiService.SecretsSecretsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/secrets/secrets/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
