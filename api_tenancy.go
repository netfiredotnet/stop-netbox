/*
NetBox API

API to access NetBox

API version: 2.11
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


// TenancyApiService TenancyApi service
type TenancyApiService service

type ApiTenancyTenantGroupsBulkDeleteRequest struct {
	ctx context.Context
	ApiService *TenancyApiService
}

func (r ApiTenancyTenantGroupsBulkDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.TenancyTenantGroupsBulkDeleteExecute(r)
}

/*
TenancyTenantGroupsBulkDelete Method for TenancyTenantGroupsBulkDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTenancyTenantGroupsBulkDeleteRequest
*/
func (a *TenancyApiService) TenancyTenantGroupsBulkDelete(ctx context.Context) ApiTenancyTenantGroupsBulkDeleteRequest {
	return ApiTenancyTenantGroupsBulkDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *TenancyApiService) TenancyTenantGroupsBulkDeleteExecute(r ApiTenancyTenantGroupsBulkDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TenancyApiService.TenancyTenantGroupsBulkDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tenancy/tenant-groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTenancyTenantGroupsBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *TenancyApiService
	data *WritableTenantGroup
}

func (r ApiTenancyTenantGroupsBulkPartialUpdateRequest) Data(data WritableTenantGroup) ApiTenancyTenantGroupsBulkPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiTenancyTenantGroupsBulkPartialUpdateRequest) Execute() (*TenantGroup, *http.Response, error) {
	return r.ApiService.TenancyTenantGroupsBulkPartialUpdateExecute(r)
}

/*
TenancyTenantGroupsBulkPartialUpdate Method for TenancyTenantGroupsBulkPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTenancyTenantGroupsBulkPartialUpdateRequest
*/
func (a *TenancyApiService) TenancyTenantGroupsBulkPartialUpdate(ctx context.Context) ApiTenancyTenantGroupsBulkPartialUpdateRequest {
	return ApiTenancyTenantGroupsBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TenantGroup
func (a *TenancyApiService) TenancyTenantGroupsBulkPartialUpdateExecute(r ApiTenancyTenantGroupsBulkPartialUpdateRequest) (*TenantGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TenantGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TenancyApiService.TenancyTenantGroupsBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tenancy/tenant-groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTenancyTenantGroupsBulkUpdateRequest struct {
	ctx context.Context
	ApiService *TenancyApiService
	data *WritableTenantGroup
}

func (r ApiTenancyTenantGroupsBulkUpdateRequest) Data(data WritableTenantGroup) ApiTenancyTenantGroupsBulkUpdateRequest {
	r.data = &data
	return r
}

func (r ApiTenancyTenantGroupsBulkUpdateRequest) Execute() (*TenantGroup, *http.Response, error) {
	return r.ApiService.TenancyTenantGroupsBulkUpdateExecute(r)
}

/*
TenancyTenantGroupsBulkUpdate Method for TenancyTenantGroupsBulkUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTenancyTenantGroupsBulkUpdateRequest
*/
func (a *TenancyApiService) TenancyTenantGroupsBulkUpdate(ctx context.Context) ApiTenancyTenantGroupsBulkUpdateRequest {
	return ApiTenancyTenantGroupsBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TenantGroup
func (a *TenancyApiService) TenancyTenantGroupsBulkUpdateExecute(r ApiTenancyTenantGroupsBulkUpdateRequest) (*TenantGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TenantGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TenancyApiService.TenancyTenantGroupsBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tenancy/tenant-groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTenancyTenantGroupsCreateRequest struct {
	ctx context.Context
	ApiService *TenancyApiService
	data *WritableTenantGroup
}

func (r ApiTenancyTenantGroupsCreateRequest) Data(data WritableTenantGroup) ApiTenancyTenantGroupsCreateRequest {
	r.data = &data
	return r
}

func (r ApiTenancyTenantGroupsCreateRequest) Execute() (*TenantGroup, *http.Response, error) {
	return r.ApiService.TenancyTenantGroupsCreateExecute(r)
}

/*
TenancyTenantGroupsCreate Method for TenancyTenantGroupsCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTenancyTenantGroupsCreateRequest
*/
func (a *TenancyApiService) TenancyTenantGroupsCreate(ctx context.Context) ApiTenancyTenantGroupsCreateRequest {
	return ApiTenancyTenantGroupsCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TenantGroup
func (a *TenancyApiService) TenancyTenantGroupsCreateExecute(r ApiTenancyTenantGroupsCreateRequest) (*TenantGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TenantGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TenancyApiService.TenancyTenantGroupsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tenancy/tenant-groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTenancyTenantGroupsDeleteRequest struct {
	ctx context.Context
	ApiService *TenancyApiService
	id int32
}

func (r ApiTenancyTenantGroupsDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.TenancyTenantGroupsDeleteExecute(r)
}

/*
TenancyTenantGroupsDelete Method for TenancyTenantGroupsDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this tenant group.
 @return ApiTenancyTenantGroupsDeleteRequest
*/
func (a *TenancyApiService) TenancyTenantGroupsDelete(ctx context.Context, id int32) ApiTenancyTenantGroupsDeleteRequest {
	return ApiTenancyTenantGroupsDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *TenancyApiService) TenancyTenantGroupsDeleteExecute(r ApiTenancyTenantGroupsDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TenancyApiService.TenancyTenantGroupsDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tenancy/tenant-groups/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTenancyTenantGroupsListRequest struct {
	ctx context.Context
	ApiService *TenancyApiService
	id *string
	name *string
	slug *string
	description *string
	created *string
	createdGte *string
	createdLte *string
	lastUpdated *string
	lastUpdatedGte *string
	lastUpdatedLte *string
	q *string
	parentId *string
	parent *string
	idN *string
	idLte *string
	idLt *string
	idGte *string
	idGt *string
	nameN *string
	nameIc *string
	nameNic *string
	nameIew *string
	nameNiew *string
	nameIsw *string
	nameNisw *string
	nameIe *string
	nameNie *string
	nameEmpty *string
	slugN *string
	slugIc *string
	slugNic *string
	slugIew *string
	slugNiew *string
	slugIsw *string
	slugNisw *string
	slugIe *string
	slugNie *string
	slugEmpty *string
	descriptionN *string
	descriptionIc *string
	descriptionNic *string
	descriptionIew *string
	descriptionNiew *string
	descriptionIsw *string
	descriptionNisw *string
	descriptionIe *string
	descriptionNie *string
	descriptionEmpty *string
	parentIdN *string
	parentN *string
	limit *int32
	offset *int32
}

func (r ApiTenancyTenantGroupsListRequest) Id(id string) ApiTenancyTenantGroupsListRequest {
	r.id = &id
	return r
}

func (r ApiTenancyTenantGroupsListRequest) Name(name string) ApiTenancyTenantGroupsListRequest {
	r.name = &name
	return r
}

func (r ApiTenancyTenantGroupsListRequest) Slug(slug string) ApiTenancyTenantGroupsListRequest {
	r.slug = &slug
	return r
}

func (r ApiTenancyTenantGroupsListRequest) Description(description string) ApiTenancyTenantGroupsListRequest {
	r.description = &description
	return r
}

func (r ApiTenancyTenantGroupsListRequest) Created(created string) ApiTenancyTenantGroupsListRequest {
	r.created = &created
	return r
}

func (r ApiTenancyTenantGroupsListRequest) CreatedGte(createdGte string) ApiTenancyTenantGroupsListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiTenancyTenantGroupsListRequest) CreatedLte(createdLte string) ApiTenancyTenantGroupsListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiTenancyTenantGroupsListRequest) LastUpdated(lastUpdated string) ApiTenancyTenantGroupsListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiTenancyTenantGroupsListRequest) LastUpdatedGte(lastUpdatedGte string) ApiTenancyTenantGroupsListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiTenancyTenantGroupsListRequest) LastUpdatedLte(lastUpdatedLte string) ApiTenancyTenantGroupsListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiTenancyTenantGroupsListRequest) Q(q string) ApiTenancyTenantGroupsListRequest {
	r.q = &q
	return r
}

func (r ApiTenancyTenantGroupsListRequest) ParentId(parentId string) ApiTenancyTenantGroupsListRequest {
	r.parentId = &parentId
	return r
}

func (r ApiTenancyTenantGroupsListRequest) Parent(parent string) ApiTenancyTenantGroupsListRequest {
	r.parent = &parent
	return r
}

func (r ApiTenancyTenantGroupsListRequest) IdN(idN string) ApiTenancyTenantGroupsListRequest {
	r.idN = &idN
	return r
}

func (r ApiTenancyTenantGroupsListRequest) IdLte(idLte string) ApiTenancyTenantGroupsListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiTenancyTenantGroupsListRequest) IdLt(idLt string) ApiTenancyTenantGroupsListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiTenancyTenantGroupsListRequest) IdGte(idGte string) ApiTenancyTenantGroupsListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiTenancyTenantGroupsListRequest) IdGt(idGt string) ApiTenancyTenantGroupsListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiTenancyTenantGroupsListRequest) NameN(nameN string) ApiTenancyTenantGroupsListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiTenancyTenantGroupsListRequest) NameIc(nameIc string) ApiTenancyTenantGroupsListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiTenancyTenantGroupsListRequest) NameNic(nameNic string) ApiTenancyTenantGroupsListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiTenancyTenantGroupsListRequest) NameIew(nameIew string) ApiTenancyTenantGroupsListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiTenancyTenantGroupsListRequest) NameNiew(nameNiew string) ApiTenancyTenantGroupsListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiTenancyTenantGroupsListRequest) NameIsw(nameIsw string) ApiTenancyTenantGroupsListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiTenancyTenantGroupsListRequest) NameNisw(nameNisw string) ApiTenancyTenantGroupsListRequest {
	r.nameNisw = &nameNisw
	return r
}

func (r ApiTenancyTenantGroupsListRequest) NameIe(nameIe string) ApiTenancyTenantGroupsListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiTenancyTenantGroupsListRequest) NameNie(nameNie string) ApiTenancyTenantGroupsListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiTenancyTenantGroupsListRequest) NameEmpty(nameEmpty string) ApiTenancyTenantGroupsListRequest {
	r.nameEmpty = &nameEmpty
	return r
}

func (r ApiTenancyTenantGroupsListRequest) SlugN(slugN string) ApiTenancyTenantGroupsListRequest {
	r.slugN = &slugN
	return r
}

func (r ApiTenancyTenantGroupsListRequest) SlugIc(slugIc string) ApiTenancyTenantGroupsListRequest {
	r.slugIc = &slugIc
	return r
}

func (r ApiTenancyTenantGroupsListRequest) SlugNic(slugNic string) ApiTenancyTenantGroupsListRequest {
	r.slugNic = &slugNic
	return r
}

func (r ApiTenancyTenantGroupsListRequest) SlugIew(slugIew string) ApiTenancyTenantGroupsListRequest {
	r.slugIew = &slugIew
	return r
}

func (r ApiTenancyTenantGroupsListRequest) SlugNiew(slugNiew string) ApiTenancyTenantGroupsListRequest {
	r.slugNiew = &slugNiew
	return r
}

func (r ApiTenancyTenantGroupsListRequest) SlugIsw(slugIsw string) ApiTenancyTenantGroupsListRequest {
	r.slugIsw = &slugIsw
	return r
}

func (r ApiTenancyTenantGroupsListRequest) SlugNisw(slugNisw string) ApiTenancyTenantGroupsListRequest {
	r.slugNisw = &slugNisw
	return r
}

func (r ApiTenancyTenantGroupsListRequest) SlugIe(slugIe string) ApiTenancyTenantGroupsListRequest {
	r.slugIe = &slugIe
	return r
}

func (r ApiTenancyTenantGroupsListRequest) SlugNie(slugNie string) ApiTenancyTenantGroupsListRequest {
	r.slugNie = &slugNie
	return r
}

func (r ApiTenancyTenantGroupsListRequest) SlugEmpty(slugEmpty string) ApiTenancyTenantGroupsListRequest {
	r.slugEmpty = &slugEmpty
	return r
}

func (r ApiTenancyTenantGroupsListRequest) DescriptionN(descriptionN string) ApiTenancyTenantGroupsListRequest {
	r.descriptionN = &descriptionN
	return r
}

func (r ApiTenancyTenantGroupsListRequest) DescriptionIc(descriptionIc string) ApiTenancyTenantGroupsListRequest {
	r.descriptionIc = &descriptionIc
	return r
}

func (r ApiTenancyTenantGroupsListRequest) DescriptionNic(descriptionNic string) ApiTenancyTenantGroupsListRequest {
	r.descriptionNic = &descriptionNic
	return r
}

func (r ApiTenancyTenantGroupsListRequest) DescriptionIew(descriptionIew string) ApiTenancyTenantGroupsListRequest {
	r.descriptionIew = &descriptionIew
	return r
}

func (r ApiTenancyTenantGroupsListRequest) DescriptionNiew(descriptionNiew string) ApiTenancyTenantGroupsListRequest {
	r.descriptionNiew = &descriptionNiew
	return r
}

func (r ApiTenancyTenantGroupsListRequest) DescriptionIsw(descriptionIsw string) ApiTenancyTenantGroupsListRequest {
	r.descriptionIsw = &descriptionIsw
	return r
}

func (r ApiTenancyTenantGroupsListRequest) DescriptionNisw(descriptionNisw string) ApiTenancyTenantGroupsListRequest {
	r.descriptionNisw = &descriptionNisw
	return r
}

func (r ApiTenancyTenantGroupsListRequest) DescriptionIe(descriptionIe string) ApiTenancyTenantGroupsListRequest {
	r.descriptionIe = &descriptionIe
	return r
}

func (r ApiTenancyTenantGroupsListRequest) DescriptionNie(descriptionNie string) ApiTenancyTenantGroupsListRequest {
	r.descriptionNie = &descriptionNie
	return r
}

func (r ApiTenancyTenantGroupsListRequest) DescriptionEmpty(descriptionEmpty string) ApiTenancyTenantGroupsListRequest {
	r.descriptionEmpty = &descriptionEmpty
	return r
}

func (r ApiTenancyTenantGroupsListRequest) ParentIdN(parentIdN string) ApiTenancyTenantGroupsListRequest {
	r.parentIdN = &parentIdN
	return r
}

func (r ApiTenancyTenantGroupsListRequest) ParentN(parentN string) ApiTenancyTenantGroupsListRequest {
	r.parentN = &parentN
	return r
}

// Number of results to return per page.
func (r ApiTenancyTenantGroupsListRequest) Limit(limit int32) ApiTenancyTenantGroupsListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiTenancyTenantGroupsListRequest) Offset(offset int32) ApiTenancyTenantGroupsListRequest {
	r.offset = &offset
	return r
}

func (r ApiTenancyTenantGroupsListRequest) Execute() (*TenancyTenantGroupsList200Response, *http.Response, error) {
	return r.ApiService.TenancyTenantGroupsListExecute(r)
}

/*
TenancyTenantGroupsList Method for TenancyTenantGroupsList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTenancyTenantGroupsListRequest
*/
func (a *TenancyApiService) TenancyTenantGroupsList(ctx context.Context) ApiTenancyTenantGroupsListRequest {
	return ApiTenancyTenantGroupsListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TenancyTenantGroupsList200Response
func (a *TenancyApiService) TenancyTenantGroupsListExecute(r ApiTenancyTenantGroupsListRequest) (*TenancyTenantGroupsList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TenancyTenantGroupsList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TenancyApiService.TenancyTenantGroupsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tenancy/tenant-groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.slug != nil {
		localVarQueryParams.Add("slug", parameterToString(*r.slug, ""))
	}
	if r.description != nil {
		localVarQueryParams.Add("description", parameterToString(*r.description, ""))
	}
	if r.created != nil {
		localVarQueryParams.Add("created", parameterToString(*r.created, ""))
	}
	if r.createdGte != nil {
		localVarQueryParams.Add("created__gte", parameterToString(*r.createdGte, ""))
	}
	if r.createdLte != nil {
		localVarQueryParams.Add("created__lte", parameterToString(*r.createdLte, ""))
	}
	if r.lastUpdated != nil {
		localVarQueryParams.Add("last_updated", parameterToString(*r.lastUpdated, ""))
	}
	if r.lastUpdatedGte != nil {
		localVarQueryParams.Add("last_updated__gte", parameterToString(*r.lastUpdatedGte, ""))
	}
	if r.lastUpdatedLte != nil {
		localVarQueryParams.Add("last_updated__lte", parameterToString(*r.lastUpdatedLte, ""))
	}
	if r.q != nil {
		localVarQueryParams.Add("q", parameterToString(*r.q, ""))
	}
	if r.parentId != nil {
		localVarQueryParams.Add("parent_id", parameterToString(*r.parentId, ""))
	}
	if r.parent != nil {
		localVarQueryParams.Add("parent", parameterToString(*r.parent, ""))
	}
	if r.idN != nil {
		localVarQueryParams.Add("id__n", parameterToString(*r.idN, ""))
	}
	if r.idLte != nil {
		localVarQueryParams.Add("id__lte", parameterToString(*r.idLte, ""))
	}
	if r.idLt != nil {
		localVarQueryParams.Add("id__lt", parameterToString(*r.idLt, ""))
	}
	if r.idGte != nil {
		localVarQueryParams.Add("id__gte", parameterToString(*r.idGte, ""))
	}
	if r.idGt != nil {
		localVarQueryParams.Add("id__gt", parameterToString(*r.idGt, ""))
	}
	if r.nameN != nil {
		localVarQueryParams.Add("name__n", parameterToString(*r.nameN, ""))
	}
	if r.nameIc != nil {
		localVarQueryParams.Add("name__ic", parameterToString(*r.nameIc, ""))
	}
	if r.nameNic != nil {
		localVarQueryParams.Add("name__nic", parameterToString(*r.nameNic, ""))
	}
	if r.nameIew != nil {
		localVarQueryParams.Add("name__iew", parameterToString(*r.nameIew, ""))
	}
	if r.nameNiew != nil {
		localVarQueryParams.Add("name__niew", parameterToString(*r.nameNiew, ""))
	}
	if r.nameIsw != nil {
		localVarQueryParams.Add("name__isw", parameterToString(*r.nameIsw, ""))
	}
	if r.nameNisw != nil {
		localVarQueryParams.Add("name__nisw", parameterToString(*r.nameNisw, ""))
	}
	if r.nameIe != nil {
		localVarQueryParams.Add("name__ie", parameterToString(*r.nameIe, ""))
	}
	if r.nameNie != nil {
		localVarQueryParams.Add("name__nie", parameterToString(*r.nameNie, ""))
	}
	if r.nameEmpty != nil {
		localVarQueryParams.Add("name__empty", parameterToString(*r.nameEmpty, ""))
	}
	if r.slugN != nil {
		localVarQueryParams.Add("slug__n", parameterToString(*r.slugN, ""))
	}
	if r.slugIc != nil {
		localVarQueryParams.Add("slug__ic", parameterToString(*r.slugIc, ""))
	}
	if r.slugNic != nil {
		localVarQueryParams.Add("slug__nic", parameterToString(*r.slugNic, ""))
	}
	if r.slugIew != nil {
		localVarQueryParams.Add("slug__iew", parameterToString(*r.slugIew, ""))
	}
	if r.slugNiew != nil {
		localVarQueryParams.Add("slug__niew", parameterToString(*r.slugNiew, ""))
	}
	if r.slugIsw != nil {
		localVarQueryParams.Add("slug__isw", parameterToString(*r.slugIsw, ""))
	}
	if r.slugNisw != nil {
		localVarQueryParams.Add("slug__nisw", parameterToString(*r.slugNisw, ""))
	}
	if r.slugIe != nil {
		localVarQueryParams.Add("slug__ie", parameterToString(*r.slugIe, ""))
	}
	if r.slugNie != nil {
		localVarQueryParams.Add("slug__nie", parameterToString(*r.slugNie, ""))
	}
	if r.slugEmpty != nil {
		localVarQueryParams.Add("slug__empty", parameterToString(*r.slugEmpty, ""))
	}
	if r.descriptionN != nil {
		localVarQueryParams.Add("description__n", parameterToString(*r.descriptionN, ""))
	}
	if r.descriptionIc != nil {
		localVarQueryParams.Add("description__ic", parameterToString(*r.descriptionIc, ""))
	}
	if r.descriptionNic != nil {
		localVarQueryParams.Add("description__nic", parameterToString(*r.descriptionNic, ""))
	}
	if r.descriptionIew != nil {
		localVarQueryParams.Add("description__iew", parameterToString(*r.descriptionIew, ""))
	}
	if r.descriptionNiew != nil {
		localVarQueryParams.Add("description__niew", parameterToString(*r.descriptionNiew, ""))
	}
	if r.descriptionIsw != nil {
		localVarQueryParams.Add("description__isw", parameterToString(*r.descriptionIsw, ""))
	}
	if r.descriptionNisw != nil {
		localVarQueryParams.Add("description__nisw", parameterToString(*r.descriptionNisw, ""))
	}
	if r.descriptionIe != nil {
		localVarQueryParams.Add("description__ie", parameterToString(*r.descriptionIe, ""))
	}
	if r.descriptionNie != nil {
		localVarQueryParams.Add("description__nie", parameterToString(*r.descriptionNie, ""))
	}
	if r.descriptionEmpty != nil {
		localVarQueryParams.Add("description__empty", parameterToString(*r.descriptionEmpty, ""))
	}
	if r.parentIdN != nil {
		localVarQueryParams.Add("parent_id__n", parameterToString(*r.parentIdN, ""))
	}
	if r.parentN != nil {
		localVarQueryParams.Add("parent__n", parameterToString(*r.parentN, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTenancyTenantGroupsPartialUpdateRequest struct {
	ctx context.Context
	ApiService *TenancyApiService
	id int32
	data *WritableTenantGroup
}

func (r ApiTenancyTenantGroupsPartialUpdateRequest) Data(data WritableTenantGroup) ApiTenancyTenantGroupsPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiTenancyTenantGroupsPartialUpdateRequest) Execute() (*TenantGroup, *http.Response, error) {
	return r.ApiService.TenancyTenantGroupsPartialUpdateExecute(r)
}

/*
TenancyTenantGroupsPartialUpdate Method for TenancyTenantGroupsPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this tenant group.
 @return ApiTenancyTenantGroupsPartialUpdateRequest
*/
func (a *TenancyApiService) TenancyTenantGroupsPartialUpdate(ctx context.Context, id int32) ApiTenancyTenantGroupsPartialUpdateRequest {
	return ApiTenancyTenantGroupsPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return TenantGroup
func (a *TenancyApiService) TenancyTenantGroupsPartialUpdateExecute(r ApiTenancyTenantGroupsPartialUpdateRequest) (*TenantGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TenantGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TenancyApiService.TenancyTenantGroupsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tenancy/tenant-groups/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTenancyTenantGroupsReadRequest struct {
	ctx context.Context
	ApiService *TenancyApiService
	id int32
}

func (r ApiTenancyTenantGroupsReadRequest) Execute() (*TenantGroup, *http.Response, error) {
	return r.ApiService.TenancyTenantGroupsReadExecute(r)
}

/*
TenancyTenantGroupsRead Method for TenancyTenantGroupsRead

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this tenant group.
 @return ApiTenancyTenantGroupsReadRequest
*/
func (a *TenancyApiService) TenancyTenantGroupsRead(ctx context.Context, id int32) ApiTenancyTenantGroupsReadRequest {
	return ApiTenancyTenantGroupsReadRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return TenantGroup
func (a *TenancyApiService) TenancyTenantGroupsReadExecute(r ApiTenancyTenantGroupsReadRequest) (*TenantGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TenantGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TenancyApiService.TenancyTenantGroupsRead")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tenancy/tenant-groups/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTenancyTenantGroupsUpdateRequest struct {
	ctx context.Context
	ApiService *TenancyApiService
	id int32
	data *WritableTenantGroup
}

func (r ApiTenancyTenantGroupsUpdateRequest) Data(data WritableTenantGroup) ApiTenancyTenantGroupsUpdateRequest {
	r.data = &data
	return r
}

func (r ApiTenancyTenantGroupsUpdateRequest) Execute() (*TenantGroup, *http.Response, error) {
	return r.ApiService.TenancyTenantGroupsUpdateExecute(r)
}

/*
TenancyTenantGroupsUpdate Method for TenancyTenantGroupsUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this tenant group.
 @return ApiTenancyTenantGroupsUpdateRequest
*/
func (a *TenancyApiService) TenancyTenantGroupsUpdate(ctx context.Context, id int32) ApiTenancyTenantGroupsUpdateRequest {
	return ApiTenancyTenantGroupsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return TenantGroup
func (a *TenancyApiService) TenancyTenantGroupsUpdateExecute(r ApiTenancyTenantGroupsUpdateRequest) (*TenantGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TenantGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TenancyApiService.TenancyTenantGroupsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tenancy/tenant-groups/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTenancyTenantsBulkDeleteRequest struct {
	ctx context.Context
	ApiService *TenancyApiService
}

func (r ApiTenancyTenantsBulkDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.TenancyTenantsBulkDeleteExecute(r)
}

/*
TenancyTenantsBulkDelete Method for TenancyTenantsBulkDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTenancyTenantsBulkDeleteRequest
*/
func (a *TenancyApiService) TenancyTenantsBulkDelete(ctx context.Context) ApiTenancyTenantsBulkDeleteRequest {
	return ApiTenancyTenantsBulkDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *TenancyApiService) TenancyTenantsBulkDeleteExecute(r ApiTenancyTenantsBulkDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TenancyApiService.TenancyTenantsBulkDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tenancy/tenants/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTenancyTenantsBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *TenancyApiService
	data *WritableTenant
}

func (r ApiTenancyTenantsBulkPartialUpdateRequest) Data(data WritableTenant) ApiTenancyTenantsBulkPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiTenancyTenantsBulkPartialUpdateRequest) Execute() (*Tenant, *http.Response, error) {
	return r.ApiService.TenancyTenantsBulkPartialUpdateExecute(r)
}

/*
TenancyTenantsBulkPartialUpdate Method for TenancyTenantsBulkPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTenancyTenantsBulkPartialUpdateRequest
*/
func (a *TenancyApiService) TenancyTenantsBulkPartialUpdate(ctx context.Context) ApiTenancyTenantsBulkPartialUpdateRequest {
	return ApiTenancyTenantsBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Tenant
func (a *TenancyApiService) TenancyTenantsBulkPartialUpdateExecute(r ApiTenancyTenantsBulkPartialUpdateRequest) (*Tenant, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Tenant
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TenancyApiService.TenancyTenantsBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tenancy/tenants/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTenancyTenantsBulkUpdateRequest struct {
	ctx context.Context
	ApiService *TenancyApiService
	data *WritableTenant
}

func (r ApiTenancyTenantsBulkUpdateRequest) Data(data WritableTenant) ApiTenancyTenantsBulkUpdateRequest {
	r.data = &data
	return r
}

func (r ApiTenancyTenantsBulkUpdateRequest) Execute() (*Tenant, *http.Response, error) {
	return r.ApiService.TenancyTenantsBulkUpdateExecute(r)
}

/*
TenancyTenantsBulkUpdate Method for TenancyTenantsBulkUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTenancyTenantsBulkUpdateRequest
*/
func (a *TenancyApiService) TenancyTenantsBulkUpdate(ctx context.Context) ApiTenancyTenantsBulkUpdateRequest {
	return ApiTenancyTenantsBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Tenant
func (a *TenancyApiService) TenancyTenantsBulkUpdateExecute(r ApiTenancyTenantsBulkUpdateRequest) (*Tenant, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Tenant
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TenancyApiService.TenancyTenantsBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tenancy/tenants/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTenancyTenantsCreateRequest struct {
	ctx context.Context
	ApiService *TenancyApiService
	data *WritableTenant
}

func (r ApiTenancyTenantsCreateRequest) Data(data WritableTenant) ApiTenancyTenantsCreateRequest {
	r.data = &data
	return r
}

func (r ApiTenancyTenantsCreateRequest) Execute() (*Tenant, *http.Response, error) {
	return r.ApiService.TenancyTenantsCreateExecute(r)
}

/*
TenancyTenantsCreate Method for TenancyTenantsCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTenancyTenantsCreateRequest
*/
func (a *TenancyApiService) TenancyTenantsCreate(ctx context.Context) ApiTenancyTenantsCreateRequest {
	return ApiTenancyTenantsCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Tenant
func (a *TenancyApiService) TenancyTenantsCreateExecute(r ApiTenancyTenantsCreateRequest) (*Tenant, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Tenant
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TenancyApiService.TenancyTenantsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tenancy/tenants/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTenancyTenantsDeleteRequest struct {
	ctx context.Context
	ApiService *TenancyApiService
	id int32
}

func (r ApiTenancyTenantsDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.TenancyTenantsDeleteExecute(r)
}

/*
TenancyTenantsDelete Method for TenancyTenantsDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this tenant.
 @return ApiTenancyTenantsDeleteRequest
*/
func (a *TenancyApiService) TenancyTenantsDelete(ctx context.Context, id int32) ApiTenancyTenantsDeleteRequest {
	return ApiTenancyTenantsDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *TenancyApiService) TenancyTenantsDeleteExecute(r ApiTenancyTenantsDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TenancyApiService.TenancyTenantsDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tenancy/tenants/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTenancyTenantsListRequest struct {
	ctx context.Context
	ApiService *TenancyApiService
	id *string
	name *string
	slug *string
	created *string
	createdGte *string
	createdLte *string
	lastUpdated *string
	lastUpdatedGte *string
	lastUpdatedLte *string
	q *string
	groupId *string
	group *string
	tag *string
	idN *string
	idLte *string
	idLt *string
	idGte *string
	idGt *string
	nameN *string
	nameIc *string
	nameNic *string
	nameIew *string
	nameNiew *string
	nameIsw *string
	nameNisw *string
	nameIe *string
	nameNie *string
	nameEmpty *string
	slugN *string
	slugIc *string
	slugNic *string
	slugIew *string
	slugNiew *string
	slugIsw *string
	slugNisw *string
	slugIe *string
	slugNie *string
	slugEmpty *string
	groupIdN *string
	groupN *string
	tagN *string
	limit *int32
	offset *int32
}

func (r ApiTenancyTenantsListRequest) Id(id string) ApiTenancyTenantsListRequest {
	r.id = &id
	return r
}

func (r ApiTenancyTenantsListRequest) Name(name string) ApiTenancyTenantsListRequest {
	r.name = &name
	return r
}

func (r ApiTenancyTenantsListRequest) Slug(slug string) ApiTenancyTenantsListRequest {
	r.slug = &slug
	return r
}

func (r ApiTenancyTenantsListRequest) Created(created string) ApiTenancyTenantsListRequest {
	r.created = &created
	return r
}

func (r ApiTenancyTenantsListRequest) CreatedGte(createdGte string) ApiTenancyTenantsListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiTenancyTenantsListRequest) CreatedLte(createdLte string) ApiTenancyTenantsListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiTenancyTenantsListRequest) LastUpdated(lastUpdated string) ApiTenancyTenantsListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiTenancyTenantsListRequest) LastUpdatedGte(lastUpdatedGte string) ApiTenancyTenantsListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiTenancyTenantsListRequest) LastUpdatedLte(lastUpdatedLte string) ApiTenancyTenantsListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiTenancyTenantsListRequest) Q(q string) ApiTenancyTenantsListRequest {
	r.q = &q
	return r
}

func (r ApiTenancyTenantsListRequest) GroupId(groupId string) ApiTenancyTenantsListRequest {
	r.groupId = &groupId
	return r
}

func (r ApiTenancyTenantsListRequest) Group(group string) ApiTenancyTenantsListRequest {
	r.group = &group
	return r
}

func (r ApiTenancyTenantsListRequest) Tag(tag string) ApiTenancyTenantsListRequest {
	r.tag = &tag
	return r
}

func (r ApiTenancyTenantsListRequest) IdN(idN string) ApiTenancyTenantsListRequest {
	r.idN = &idN
	return r
}

func (r ApiTenancyTenantsListRequest) IdLte(idLte string) ApiTenancyTenantsListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiTenancyTenantsListRequest) IdLt(idLt string) ApiTenancyTenantsListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiTenancyTenantsListRequest) IdGte(idGte string) ApiTenancyTenantsListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiTenancyTenantsListRequest) IdGt(idGt string) ApiTenancyTenantsListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiTenancyTenantsListRequest) NameN(nameN string) ApiTenancyTenantsListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiTenancyTenantsListRequest) NameIc(nameIc string) ApiTenancyTenantsListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiTenancyTenantsListRequest) NameNic(nameNic string) ApiTenancyTenantsListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiTenancyTenantsListRequest) NameIew(nameIew string) ApiTenancyTenantsListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiTenancyTenantsListRequest) NameNiew(nameNiew string) ApiTenancyTenantsListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiTenancyTenantsListRequest) NameIsw(nameIsw string) ApiTenancyTenantsListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiTenancyTenantsListRequest) NameNisw(nameNisw string) ApiTenancyTenantsListRequest {
	r.nameNisw = &nameNisw
	return r
}

func (r ApiTenancyTenantsListRequest) NameIe(nameIe string) ApiTenancyTenantsListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiTenancyTenantsListRequest) NameNie(nameNie string) ApiTenancyTenantsListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiTenancyTenantsListRequest) NameEmpty(nameEmpty string) ApiTenancyTenantsListRequest {
	r.nameEmpty = &nameEmpty
	return r
}

func (r ApiTenancyTenantsListRequest) SlugN(slugN string) ApiTenancyTenantsListRequest {
	r.slugN = &slugN
	return r
}

func (r ApiTenancyTenantsListRequest) SlugIc(slugIc string) ApiTenancyTenantsListRequest {
	r.slugIc = &slugIc
	return r
}

func (r ApiTenancyTenantsListRequest) SlugNic(slugNic string) ApiTenancyTenantsListRequest {
	r.slugNic = &slugNic
	return r
}

func (r ApiTenancyTenantsListRequest) SlugIew(slugIew string) ApiTenancyTenantsListRequest {
	r.slugIew = &slugIew
	return r
}

func (r ApiTenancyTenantsListRequest) SlugNiew(slugNiew string) ApiTenancyTenantsListRequest {
	r.slugNiew = &slugNiew
	return r
}

func (r ApiTenancyTenantsListRequest) SlugIsw(slugIsw string) ApiTenancyTenantsListRequest {
	r.slugIsw = &slugIsw
	return r
}

func (r ApiTenancyTenantsListRequest) SlugNisw(slugNisw string) ApiTenancyTenantsListRequest {
	r.slugNisw = &slugNisw
	return r
}

func (r ApiTenancyTenantsListRequest) SlugIe(slugIe string) ApiTenancyTenantsListRequest {
	r.slugIe = &slugIe
	return r
}

func (r ApiTenancyTenantsListRequest) SlugNie(slugNie string) ApiTenancyTenantsListRequest {
	r.slugNie = &slugNie
	return r
}

func (r ApiTenancyTenantsListRequest) SlugEmpty(slugEmpty string) ApiTenancyTenantsListRequest {
	r.slugEmpty = &slugEmpty
	return r
}

func (r ApiTenancyTenantsListRequest) GroupIdN(groupIdN string) ApiTenancyTenantsListRequest {
	r.groupIdN = &groupIdN
	return r
}

func (r ApiTenancyTenantsListRequest) GroupN(groupN string) ApiTenancyTenantsListRequest {
	r.groupN = &groupN
	return r
}

func (r ApiTenancyTenantsListRequest) TagN(tagN string) ApiTenancyTenantsListRequest {
	r.tagN = &tagN
	return r
}

// Number of results to return per page.
func (r ApiTenancyTenantsListRequest) Limit(limit int32) ApiTenancyTenantsListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiTenancyTenantsListRequest) Offset(offset int32) ApiTenancyTenantsListRequest {
	r.offset = &offset
	return r
}

func (r ApiTenancyTenantsListRequest) Execute() (*TenancyTenantsList200Response, *http.Response, error) {
	return r.ApiService.TenancyTenantsListExecute(r)
}

/*
TenancyTenantsList Method for TenancyTenantsList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTenancyTenantsListRequest
*/
func (a *TenancyApiService) TenancyTenantsList(ctx context.Context) ApiTenancyTenantsListRequest {
	return ApiTenancyTenantsListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TenancyTenantsList200Response
func (a *TenancyApiService) TenancyTenantsListExecute(r ApiTenancyTenantsListRequest) (*TenancyTenantsList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TenancyTenantsList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TenancyApiService.TenancyTenantsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tenancy/tenants/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.slug != nil {
		localVarQueryParams.Add("slug", parameterToString(*r.slug, ""))
	}
	if r.created != nil {
		localVarQueryParams.Add("created", parameterToString(*r.created, ""))
	}
	if r.createdGte != nil {
		localVarQueryParams.Add("created__gte", parameterToString(*r.createdGte, ""))
	}
	if r.createdLte != nil {
		localVarQueryParams.Add("created__lte", parameterToString(*r.createdLte, ""))
	}
	if r.lastUpdated != nil {
		localVarQueryParams.Add("last_updated", parameterToString(*r.lastUpdated, ""))
	}
	if r.lastUpdatedGte != nil {
		localVarQueryParams.Add("last_updated__gte", parameterToString(*r.lastUpdatedGte, ""))
	}
	if r.lastUpdatedLte != nil {
		localVarQueryParams.Add("last_updated__lte", parameterToString(*r.lastUpdatedLte, ""))
	}
	if r.q != nil {
		localVarQueryParams.Add("q", parameterToString(*r.q, ""))
	}
	if r.groupId != nil {
		localVarQueryParams.Add("group_id", parameterToString(*r.groupId, ""))
	}
	if r.group != nil {
		localVarQueryParams.Add("group", parameterToString(*r.group, ""))
	}
	if r.tag != nil {
		localVarQueryParams.Add("tag", parameterToString(*r.tag, ""))
	}
	if r.idN != nil {
		localVarQueryParams.Add("id__n", parameterToString(*r.idN, ""))
	}
	if r.idLte != nil {
		localVarQueryParams.Add("id__lte", parameterToString(*r.idLte, ""))
	}
	if r.idLt != nil {
		localVarQueryParams.Add("id__lt", parameterToString(*r.idLt, ""))
	}
	if r.idGte != nil {
		localVarQueryParams.Add("id__gte", parameterToString(*r.idGte, ""))
	}
	if r.idGt != nil {
		localVarQueryParams.Add("id__gt", parameterToString(*r.idGt, ""))
	}
	if r.nameN != nil {
		localVarQueryParams.Add("name__n", parameterToString(*r.nameN, ""))
	}
	if r.nameIc != nil {
		localVarQueryParams.Add("name__ic", parameterToString(*r.nameIc, ""))
	}
	if r.nameNic != nil {
		localVarQueryParams.Add("name__nic", parameterToString(*r.nameNic, ""))
	}
	if r.nameIew != nil {
		localVarQueryParams.Add("name__iew", parameterToString(*r.nameIew, ""))
	}
	if r.nameNiew != nil {
		localVarQueryParams.Add("name__niew", parameterToString(*r.nameNiew, ""))
	}
	if r.nameIsw != nil {
		localVarQueryParams.Add("name__isw", parameterToString(*r.nameIsw, ""))
	}
	if r.nameNisw != nil {
		localVarQueryParams.Add("name__nisw", parameterToString(*r.nameNisw, ""))
	}
	if r.nameIe != nil {
		localVarQueryParams.Add("name__ie", parameterToString(*r.nameIe, ""))
	}
	if r.nameNie != nil {
		localVarQueryParams.Add("name__nie", parameterToString(*r.nameNie, ""))
	}
	if r.nameEmpty != nil {
		localVarQueryParams.Add("name__empty", parameterToString(*r.nameEmpty, ""))
	}
	if r.slugN != nil {
		localVarQueryParams.Add("slug__n", parameterToString(*r.slugN, ""))
	}
	if r.slugIc != nil {
		localVarQueryParams.Add("slug__ic", parameterToString(*r.slugIc, ""))
	}
	if r.slugNic != nil {
		localVarQueryParams.Add("slug__nic", parameterToString(*r.slugNic, ""))
	}
	if r.slugIew != nil {
		localVarQueryParams.Add("slug__iew", parameterToString(*r.slugIew, ""))
	}
	if r.slugNiew != nil {
		localVarQueryParams.Add("slug__niew", parameterToString(*r.slugNiew, ""))
	}
	if r.slugIsw != nil {
		localVarQueryParams.Add("slug__isw", parameterToString(*r.slugIsw, ""))
	}
	if r.slugNisw != nil {
		localVarQueryParams.Add("slug__nisw", parameterToString(*r.slugNisw, ""))
	}
	if r.slugIe != nil {
		localVarQueryParams.Add("slug__ie", parameterToString(*r.slugIe, ""))
	}
	if r.slugNie != nil {
		localVarQueryParams.Add("slug__nie", parameterToString(*r.slugNie, ""))
	}
	if r.slugEmpty != nil {
		localVarQueryParams.Add("slug__empty", parameterToString(*r.slugEmpty, ""))
	}
	if r.groupIdN != nil {
		localVarQueryParams.Add("group_id__n", parameterToString(*r.groupIdN, ""))
	}
	if r.groupN != nil {
		localVarQueryParams.Add("group__n", parameterToString(*r.groupN, ""))
	}
	if r.tagN != nil {
		localVarQueryParams.Add("tag__n", parameterToString(*r.tagN, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTenancyTenantsPartialUpdateRequest struct {
	ctx context.Context
	ApiService *TenancyApiService
	id int32
	data *WritableTenant
}

func (r ApiTenancyTenantsPartialUpdateRequest) Data(data WritableTenant) ApiTenancyTenantsPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiTenancyTenantsPartialUpdateRequest) Execute() (*Tenant, *http.Response, error) {
	return r.ApiService.TenancyTenantsPartialUpdateExecute(r)
}

/*
TenancyTenantsPartialUpdate Method for TenancyTenantsPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this tenant.
 @return ApiTenancyTenantsPartialUpdateRequest
*/
func (a *TenancyApiService) TenancyTenantsPartialUpdate(ctx context.Context, id int32) ApiTenancyTenantsPartialUpdateRequest {
	return ApiTenancyTenantsPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Tenant
func (a *TenancyApiService) TenancyTenantsPartialUpdateExecute(r ApiTenancyTenantsPartialUpdateRequest) (*Tenant, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Tenant
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TenancyApiService.TenancyTenantsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tenancy/tenants/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTenancyTenantsReadRequest struct {
	ctx context.Context
	ApiService *TenancyApiService
	id int32
}

func (r ApiTenancyTenantsReadRequest) Execute() (*Tenant, *http.Response, error) {
	return r.ApiService.TenancyTenantsReadExecute(r)
}

/*
TenancyTenantsRead Method for TenancyTenantsRead

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this tenant.
 @return ApiTenancyTenantsReadRequest
*/
func (a *TenancyApiService) TenancyTenantsRead(ctx context.Context, id int32) ApiTenancyTenantsReadRequest {
	return ApiTenancyTenantsReadRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Tenant
func (a *TenancyApiService) TenancyTenantsReadExecute(r ApiTenancyTenantsReadRequest) (*Tenant, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Tenant
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TenancyApiService.TenancyTenantsRead")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tenancy/tenants/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTenancyTenantsUpdateRequest struct {
	ctx context.Context
	ApiService *TenancyApiService
	id int32
	data *WritableTenant
}

func (r ApiTenancyTenantsUpdateRequest) Data(data WritableTenant) ApiTenancyTenantsUpdateRequest {
	r.data = &data
	return r
}

func (r ApiTenancyTenantsUpdateRequest) Execute() (*Tenant, *http.Response, error) {
	return r.ApiService.TenancyTenantsUpdateExecute(r)
}

/*
TenancyTenantsUpdate Method for TenancyTenantsUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this tenant.
 @return ApiTenancyTenantsUpdateRequest
*/
func (a *TenancyApiService) TenancyTenantsUpdate(ctx context.Context, id int32) ApiTenancyTenantsUpdateRequest {
	return ApiTenancyTenantsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Tenant
func (a *TenancyApiService) TenancyTenantsUpdateExecute(r ApiTenancyTenantsUpdateRequest) (*Tenant, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Tenant
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TenancyApiService.TenancyTenantsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tenancy/tenants/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
