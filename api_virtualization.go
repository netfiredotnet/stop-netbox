/*
NetBox API

API to access NetBox

API version: 2.11
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


// VirtualizationApiService VirtualizationApi service
type VirtualizationApiService service

type ApiVirtualizationClusterGroupsBulkDeleteRequest struct {
	ctx context.Context
	ApiService *VirtualizationApiService
}

func (r ApiVirtualizationClusterGroupsBulkDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.VirtualizationClusterGroupsBulkDeleteExecute(r)
}

/*
VirtualizationClusterGroupsBulkDelete Method for VirtualizationClusterGroupsBulkDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiVirtualizationClusterGroupsBulkDeleteRequest
*/
func (a *VirtualizationApiService) VirtualizationClusterGroupsBulkDelete(ctx context.Context) ApiVirtualizationClusterGroupsBulkDeleteRequest {
	return ApiVirtualizationClusterGroupsBulkDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *VirtualizationApiService) VirtualizationClusterGroupsBulkDeleteExecute(r ApiVirtualizationClusterGroupsBulkDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirtualizationApiService.VirtualizationClusterGroupsBulkDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/virtualization/cluster-groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiVirtualizationClusterGroupsBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *VirtualizationApiService
	data *ClusterGroup
}

func (r ApiVirtualizationClusterGroupsBulkPartialUpdateRequest) Data(data ClusterGroup) ApiVirtualizationClusterGroupsBulkPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiVirtualizationClusterGroupsBulkPartialUpdateRequest) Execute() (*ClusterGroup, *http.Response, error) {
	return r.ApiService.VirtualizationClusterGroupsBulkPartialUpdateExecute(r)
}

/*
VirtualizationClusterGroupsBulkPartialUpdate Method for VirtualizationClusterGroupsBulkPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiVirtualizationClusterGroupsBulkPartialUpdateRequest
*/
func (a *VirtualizationApiService) VirtualizationClusterGroupsBulkPartialUpdate(ctx context.Context) ApiVirtualizationClusterGroupsBulkPartialUpdateRequest {
	return ApiVirtualizationClusterGroupsBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ClusterGroup
func (a *VirtualizationApiService) VirtualizationClusterGroupsBulkPartialUpdateExecute(r ApiVirtualizationClusterGroupsBulkPartialUpdateRequest) (*ClusterGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ClusterGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirtualizationApiService.VirtualizationClusterGroupsBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/virtualization/cluster-groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVirtualizationClusterGroupsBulkUpdateRequest struct {
	ctx context.Context
	ApiService *VirtualizationApiService
	data *ClusterGroup
}

func (r ApiVirtualizationClusterGroupsBulkUpdateRequest) Data(data ClusterGroup) ApiVirtualizationClusterGroupsBulkUpdateRequest {
	r.data = &data
	return r
}

func (r ApiVirtualizationClusterGroupsBulkUpdateRequest) Execute() (*ClusterGroup, *http.Response, error) {
	return r.ApiService.VirtualizationClusterGroupsBulkUpdateExecute(r)
}

/*
VirtualizationClusterGroupsBulkUpdate Method for VirtualizationClusterGroupsBulkUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiVirtualizationClusterGroupsBulkUpdateRequest
*/
func (a *VirtualizationApiService) VirtualizationClusterGroupsBulkUpdate(ctx context.Context) ApiVirtualizationClusterGroupsBulkUpdateRequest {
	return ApiVirtualizationClusterGroupsBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ClusterGroup
func (a *VirtualizationApiService) VirtualizationClusterGroupsBulkUpdateExecute(r ApiVirtualizationClusterGroupsBulkUpdateRequest) (*ClusterGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ClusterGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirtualizationApiService.VirtualizationClusterGroupsBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/virtualization/cluster-groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVirtualizationClusterGroupsCreateRequest struct {
	ctx context.Context
	ApiService *VirtualizationApiService
	data *ClusterGroup
}

func (r ApiVirtualizationClusterGroupsCreateRequest) Data(data ClusterGroup) ApiVirtualizationClusterGroupsCreateRequest {
	r.data = &data
	return r
}

func (r ApiVirtualizationClusterGroupsCreateRequest) Execute() (*ClusterGroup, *http.Response, error) {
	return r.ApiService.VirtualizationClusterGroupsCreateExecute(r)
}

/*
VirtualizationClusterGroupsCreate Method for VirtualizationClusterGroupsCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiVirtualizationClusterGroupsCreateRequest
*/
func (a *VirtualizationApiService) VirtualizationClusterGroupsCreate(ctx context.Context) ApiVirtualizationClusterGroupsCreateRequest {
	return ApiVirtualizationClusterGroupsCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ClusterGroup
func (a *VirtualizationApiService) VirtualizationClusterGroupsCreateExecute(r ApiVirtualizationClusterGroupsCreateRequest) (*ClusterGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ClusterGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirtualizationApiService.VirtualizationClusterGroupsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/virtualization/cluster-groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVirtualizationClusterGroupsDeleteRequest struct {
	ctx context.Context
	ApiService *VirtualizationApiService
	id int32
}

func (r ApiVirtualizationClusterGroupsDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.VirtualizationClusterGroupsDeleteExecute(r)
}

/*
VirtualizationClusterGroupsDelete Method for VirtualizationClusterGroupsDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this cluster group.
 @return ApiVirtualizationClusterGroupsDeleteRequest
*/
func (a *VirtualizationApiService) VirtualizationClusterGroupsDelete(ctx context.Context, id int32) ApiVirtualizationClusterGroupsDeleteRequest {
	return ApiVirtualizationClusterGroupsDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *VirtualizationApiService) VirtualizationClusterGroupsDeleteExecute(r ApiVirtualizationClusterGroupsDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirtualizationApiService.VirtualizationClusterGroupsDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/virtualization/cluster-groups/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiVirtualizationClusterGroupsListRequest struct {
	ctx context.Context
	ApiService *VirtualizationApiService
	id *string
	name *string
	slug *string
	description *string
	created *string
	createdGte *string
	createdLte *string
	lastUpdated *string
	lastUpdatedGte *string
	lastUpdatedLte *string
	q *string
	idN *string
	idLte *string
	idLt *string
	idGte *string
	idGt *string
	nameN *string
	nameIc *string
	nameNic *string
	nameIew *string
	nameNiew *string
	nameIsw *string
	nameNisw *string
	nameIe *string
	nameNie *string
	nameEmpty *string
	slugN *string
	slugIc *string
	slugNic *string
	slugIew *string
	slugNiew *string
	slugIsw *string
	slugNisw *string
	slugIe *string
	slugNie *string
	slugEmpty *string
	descriptionN *string
	descriptionIc *string
	descriptionNic *string
	descriptionIew *string
	descriptionNiew *string
	descriptionIsw *string
	descriptionNisw *string
	descriptionIe *string
	descriptionNie *string
	descriptionEmpty *string
	limit *int32
	offset *int32
}

func (r ApiVirtualizationClusterGroupsListRequest) Id(id string) ApiVirtualizationClusterGroupsListRequest {
	r.id = &id
	return r
}

func (r ApiVirtualizationClusterGroupsListRequest) Name(name string) ApiVirtualizationClusterGroupsListRequest {
	r.name = &name
	return r
}

func (r ApiVirtualizationClusterGroupsListRequest) Slug(slug string) ApiVirtualizationClusterGroupsListRequest {
	r.slug = &slug
	return r
}

func (r ApiVirtualizationClusterGroupsListRequest) Description(description string) ApiVirtualizationClusterGroupsListRequest {
	r.description = &description
	return r
}

func (r ApiVirtualizationClusterGroupsListRequest) Created(created string) ApiVirtualizationClusterGroupsListRequest {
	r.created = &created
	return r
}

func (r ApiVirtualizationClusterGroupsListRequest) CreatedGte(createdGte string) ApiVirtualizationClusterGroupsListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiVirtualizationClusterGroupsListRequest) CreatedLte(createdLte string) ApiVirtualizationClusterGroupsListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiVirtualizationClusterGroupsListRequest) LastUpdated(lastUpdated string) ApiVirtualizationClusterGroupsListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiVirtualizationClusterGroupsListRequest) LastUpdatedGte(lastUpdatedGte string) ApiVirtualizationClusterGroupsListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiVirtualizationClusterGroupsListRequest) LastUpdatedLte(lastUpdatedLte string) ApiVirtualizationClusterGroupsListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiVirtualizationClusterGroupsListRequest) Q(q string) ApiVirtualizationClusterGroupsListRequest {
	r.q = &q
	return r
}

func (r ApiVirtualizationClusterGroupsListRequest) IdN(idN string) ApiVirtualizationClusterGroupsListRequest {
	r.idN = &idN
	return r
}

func (r ApiVirtualizationClusterGroupsListRequest) IdLte(idLte string) ApiVirtualizationClusterGroupsListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiVirtualizationClusterGroupsListRequest) IdLt(idLt string) ApiVirtualizationClusterGroupsListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiVirtualizationClusterGroupsListRequest) IdGte(idGte string) ApiVirtualizationClusterGroupsListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiVirtualizationClusterGroupsListRequest) IdGt(idGt string) ApiVirtualizationClusterGroupsListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiVirtualizationClusterGroupsListRequest) NameN(nameN string) ApiVirtualizationClusterGroupsListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiVirtualizationClusterGroupsListRequest) NameIc(nameIc string) ApiVirtualizationClusterGroupsListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiVirtualizationClusterGroupsListRequest) NameNic(nameNic string) ApiVirtualizationClusterGroupsListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiVirtualizationClusterGroupsListRequest) NameIew(nameIew string) ApiVirtualizationClusterGroupsListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiVirtualizationClusterGroupsListRequest) NameNiew(nameNiew string) ApiVirtualizationClusterGroupsListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiVirtualizationClusterGroupsListRequest) NameIsw(nameIsw string) ApiVirtualizationClusterGroupsListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiVirtualizationClusterGroupsListRequest) NameNisw(nameNisw string) ApiVirtualizationClusterGroupsListRequest {
	r.nameNisw = &nameNisw
	return r
}

func (r ApiVirtualizationClusterGroupsListRequest) NameIe(nameIe string) ApiVirtualizationClusterGroupsListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiVirtualizationClusterGroupsListRequest) NameNie(nameNie string) ApiVirtualizationClusterGroupsListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiVirtualizationClusterGroupsListRequest) NameEmpty(nameEmpty string) ApiVirtualizationClusterGroupsListRequest {
	r.nameEmpty = &nameEmpty
	return r
}

func (r ApiVirtualizationClusterGroupsListRequest) SlugN(slugN string) ApiVirtualizationClusterGroupsListRequest {
	r.slugN = &slugN
	return r
}

func (r ApiVirtualizationClusterGroupsListRequest) SlugIc(slugIc string) ApiVirtualizationClusterGroupsListRequest {
	r.slugIc = &slugIc
	return r
}

func (r ApiVirtualizationClusterGroupsListRequest) SlugNic(slugNic string) ApiVirtualizationClusterGroupsListRequest {
	r.slugNic = &slugNic
	return r
}

func (r ApiVirtualizationClusterGroupsListRequest) SlugIew(slugIew string) ApiVirtualizationClusterGroupsListRequest {
	r.slugIew = &slugIew
	return r
}

func (r ApiVirtualizationClusterGroupsListRequest) SlugNiew(slugNiew string) ApiVirtualizationClusterGroupsListRequest {
	r.slugNiew = &slugNiew
	return r
}

func (r ApiVirtualizationClusterGroupsListRequest) SlugIsw(slugIsw string) ApiVirtualizationClusterGroupsListRequest {
	r.slugIsw = &slugIsw
	return r
}

func (r ApiVirtualizationClusterGroupsListRequest) SlugNisw(slugNisw string) ApiVirtualizationClusterGroupsListRequest {
	r.slugNisw = &slugNisw
	return r
}

func (r ApiVirtualizationClusterGroupsListRequest) SlugIe(slugIe string) ApiVirtualizationClusterGroupsListRequest {
	r.slugIe = &slugIe
	return r
}

func (r ApiVirtualizationClusterGroupsListRequest) SlugNie(slugNie string) ApiVirtualizationClusterGroupsListRequest {
	r.slugNie = &slugNie
	return r
}

func (r ApiVirtualizationClusterGroupsListRequest) SlugEmpty(slugEmpty string) ApiVirtualizationClusterGroupsListRequest {
	r.slugEmpty = &slugEmpty
	return r
}

func (r ApiVirtualizationClusterGroupsListRequest) DescriptionN(descriptionN string) ApiVirtualizationClusterGroupsListRequest {
	r.descriptionN = &descriptionN
	return r
}

func (r ApiVirtualizationClusterGroupsListRequest) DescriptionIc(descriptionIc string) ApiVirtualizationClusterGroupsListRequest {
	r.descriptionIc = &descriptionIc
	return r
}

func (r ApiVirtualizationClusterGroupsListRequest) DescriptionNic(descriptionNic string) ApiVirtualizationClusterGroupsListRequest {
	r.descriptionNic = &descriptionNic
	return r
}

func (r ApiVirtualizationClusterGroupsListRequest) DescriptionIew(descriptionIew string) ApiVirtualizationClusterGroupsListRequest {
	r.descriptionIew = &descriptionIew
	return r
}

func (r ApiVirtualizationClusterGroupsListRequest) DescriptionNiew(descriptionNiew string) ApiVirtualizationClusterGroupsListRequest {
	r.descriptionNiew = &descriptionNiew
	return r
}

func (r ApiVirtualizationClusterGroupsListRequest) DescriptionIsw(descriptionIsw string) ApiVirtualizationClusterGroupsListRequest {
	r.descriptionIsw = &descriptionIsw
	return r
}

func (r ApiVirtualizationClusterGroupsListRequest) DescriptionNisw(descriptionNisw string) ApiVirtualizationClusterGroupsListRequest {
	r.descriptionNisw = &descriptionNisw
	return r
}

func (r ApiVirtualizationClusterGroupsListRequest) DescriptionIe(descriptionIe string) ApiVirtualizationClusterGroupsListRequest {
	r.descriptionIe = &descriptionIe
	return r
}

func (r ApiVirtualizationClusterGroupsListRequest) DescriptionNie(descriptionNie string) ApiVirtualizationClusterGroupsListRequest {
	r.descriptionNie = &descriptionNie
	return r
}

func (r ApiVirtualizationClusterGroupsListRequest) DescriptionEmpty(descriptionEmpty string) ApiVirtualizationClusterGroupsListRequest {
	r.descriptionEmpty = &descriptionEmpty
	return r
}

// Number of results to return per page.
func (r ApiVirtualizationClusterGroupsListRequest) Limit(limit int32) ApiVirtualizationClusterGroupsListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiVirtualizationClusterGroupsListRequest) Offset(offset int32) ApiVirtualizationClusterGroupsListRequest {
	r.offset = &offset
	return r
}

func (r ApiVirtualizationClusterGroupsListRequest) Execute() (*VirtualizationClusterGroupsList200Response, *http.Response, error) {
	return r.ApiService.VirtualizationClusterGroupsListExecute(r)
}

/*
VirtualizationClusterGroupsList Method for VirtualizationClusterGroupsList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiVirtualizationClusterGroupsListRequest
*/
func (a *VirtualizationApiService) VirtualizationClusterGroupsList(ctx context.Context) ApiVirtualizationClusterGroupsListRequest {
	return ApiVirtualizationClusterGroupsListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return VirtualizationClusterGroupsList200Response
func (a *VirtualizationApiService) VirtualizationClusterGroupsListExecute(r ApiVirtualizationClusterGroupsListRequest) (*VirtualizationClusterGroupsList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VirtualizationClusterGroupsList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirtualizationApiService.VirtualizationClusterGroupsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/virtualization/cluster-groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.slug != nil {
		localVarQueryParams.Add("slug", parameterToString(*r.slug, ""))
	}
	if r.description != nil {
		localVarQueryParams.Add("description", parameterToString(*r.description, ""))
	}
	if r.created != nil {
		localVarQueryParams.Add("created", parameterToString(*r.created, ""))
	}
	if r.createdGte != nil {
		localVarQueryParams.Add("created__gte", parameterToString(*r.createdGte, ""))
	}
	if r.createdLte != nil {
		localVarQueryParams.Add("created__lte", parameterToString(*r.createdLte, ""))
	}
	if r.lastUpdated != nil {
		localVarQueryParams.Add("last_updated", parameterToString(*r.lastUpdated, ""))
	}
	if r.lastUpdatedGte != nil {
		localVarQueryParams.Add("last_updated__gte", parameterToString(*r.lastUpdatedGte, ""))
	}
	if r.lastUpdatedLte != nil {
		localVarQueryParams.Add("last_updated__lte", parameterToString(*r.lastUpdatedLte, ""))
	}
	if r.q != nil {
		localVarQueryParams.Add("q", parameterToString(*r.q, ""))
	}
	if r.idN != nil {
		localVarQueryParams.Add("id__n", parameterToString(*r.idN, ""))
	}
	if r.idLte != nil {
		localVarQueryParams.Add("id__lte", parameterToString(*r.idLte, ""))
	}
	if r.idLt != nil {
		localVarQueryParams.Add("id__lt", parameterToString(*r.idLt, ""))
	}
	if r.idGte != nil {
		localVarQueryParams.Add("id__gte", parameterToString(*r.idGte, ""))
	}
	if r.idGt != nil {
		localVarQueryParams.Add("id__gt", parameterToString(*r.idGt, ""))
	}
	if r.nameN != nil {
		localVarQueryParams.Add("name__n", parameterToString(*r.nameN, ""))
	}
	if r.nameIc != nil {
		localVarQueryParams.Add("name__ic", parameterToString(*r.nameIc, ""))
	}
	if r.nameNic != nil {
		localVarQueryParams.Add("name__nic", parameterToString(*r.nameNic, ""))
	}
	if r.nameIew != nil {
		localVarQueryParams.Add("name__iew", parameterToString(*r.nameIew, ""))
	}
	if r.nameNiew != nil {
		localVarQueryParams.Add("name__niew", parameterToString(*r.nameNiew, ""))
	}
	if r.nameIsw != nil {
		localVarQueryParams.Add("name__isw", parameterToString(*r.nameIsw, ""))
	}
	if r.nameNisw != nil {
		localVarQueryParams.Add("name__nisw", parameterToString(*r.nameNisw, ""))
	}
	if r.nameIe != nil {
		localVarQueryParams.Add("name__ie", parameterToString(*r.nameIe, ""))
	}
	if r.nameNie != nil {
		localVarQueryParams.Add("name__nie", parameterToString(*r.nameNie, ""))
	}
	if r.nameEmpty != nil {
		localVarQueryParams.Add("name__empty", parameterToString(*r.nameEmpty, ""))
	}
	if r.slugN != nil {
		localVarQueryParams.Add("slug__n", parameterToString(*r.slugN, ""))
	}
	if r.slugIc != nil {
		localVarQueryParams.Add("slug__ic", parameterToString(*r.slugIc, ""))
	}
	if r.slugNic != nil {
		localVarQueryParams.Add("slug__nic", parameterToString(*r.slugNic, ""))
	}
	if r.slugIew != nil {
		localVarQueryParams.Add("slug__iew", parameterToString(*r.slugIew, ""))
	}
	if r.slugNiew != nil {
		localVarQueryParams.Add("slug__niew", parameterToString(*r.slugNiew, ""))
	}
	if r.slugIsw != nil {
		localVarQueryParams.Add("slug__isw", parameterToString(*r.slugIsw, ""))
	}
	if r.slugNisw != nil {
		localVarQueryParams.Add("slug__nisw", parameterToString(*r.slugNisw, ""))
	}
	if r.slugIe != nil {
		localVarQueryParams.Add("slug__ie", parameterToString(*r.slugIe, ""))
	}
	if r.slugNie != nil {
		localVarQueryParams.Add("slug__nie", parameterToString(*r.slugNie, ""))
	}
	if r.slugEmpty != nil {
		localVarQueryParams.Add("slug__empty", parameterToString(*r.slugEmpty, ""))
	}
	if r.descriptionN != nil {
		localVarQueryParams.Add("description__n", parameterToString(*r.descriptionN, ""))
	}
	if r.descriptionIc != nil {
		localVarQueryParams.Add("description__ic", parameterToString(*r.descriptionIc, ""))
	}
	if r.descriptionNic != nil {
		localVarQueryParams.Add("description__nic", parameterToString(*r.descriptionNic, ""))
	}
	if r.descriptionIew != nil {
		localVarQueryParams.Add("description__iew", parameterToString(*r.descriptionIew, ""))
	}
	if r.descriptionNiew != nil {
		localVarQueryParams.Add("description__niew", parameterToString(*r.descriptionNiew, ""))
	}
	if r.descriptionIsw != nil {
		localVarQueryParams.Add("description__isw", parameterToString(*r.descriptionIsw, ""))
	}
	if r.descriptionNisw != nil {
		localVarQueryParams.Add("description__nisw", parameterToString(*r.descriptionNisw, ""))
	}
	if r.descriptionIe != nil {
		localVarQueryParams.Add("description__ie", parameterToString(*r.descriptionIe, ""))
	}
	if r.descriptionNie != nil {
		localVarQueryParams.Add("description__nie", parameterToString(*r.descriptionNie, ""))
	}
	if r.descriptionEmpty != nil {
		localVarQueryParams.Add("description__empty", parameterToString(*r.descriptionEmpty, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVirtualizationClusterGroupsPartialUpdateRequest struct {
	ctx context.Context
	ApiService *VirtualizationApiService
	id int32
	data *ClusterGroup
}

func (r ApiVirtualizationClusterGroupsPartialUpdateRequest) Data(data ClusterGroup) ApiVirtualizationClusterGroupsPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiVirtualizationClusterGroupsPartialUpdateRequest) Execute() (*ClusterGroup, *http.Response, error) {
	return r.ApiService.VirtualizationClusterGroupsPartialUpdateExecute(r)
}

/*
VirtualizationClusterGroupsPartialUpdate Method for VirtualizationClusterGroupsPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this cluster group.
 @return ApiVirtualizationClusterGroupsPartialUpdateRequest
*/
func (a *VirtualizationApiService) VirtualizationClusterGroupsPartialUpdate(ctx context.Context, id int32) ApiVirtualizationClusterGroupsPartialUpdateRequest {
	return ApiVirtualizationClusterGroupsPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ClusterGroup
func (a *VirtualizationApiService) VirtualizationClusterGroupsPartialUpdateExecute(r ApiVirtualizationClusterGroupsPartialUpdateRequest) (*ClusterGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ClusterGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirtualizationApiService.VirtualizationClusterGroupsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/virtualization/cluster-groups/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVirtualizationClusterGroupsReadRequest struct {
	ctx context.Context
	ApiService *VirtualizationApiService
	id int32
}

func (r ApiVirtualizationClusterGroupsReadRequest) Execute() (*ClusterGroup, *http.Response, error) {
	return r.ApiService.VirtualizationClusterGroupsReadExecute(r)
}

/*
VirtualizationClusterGroupsRead Method for VirtualizationClusterGroupsRead

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this cluster group.
 @return ApiVirtualizationClusterGroupsReadRequest
*/
func (a *VirtualizationApiService) VirtualizationClusterGroupsRead(ctx context.Context, id int32) ApiVirtualizationClusterGroupsReadRequest {
	return ApiVirtualizationClusterGroupsReadRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ClusterGroup
func (a *VirtualizationApiService) VirtualizationClusterGroupsReadExecute(r ApiVirtualizationClusterGroupsReadRequest) (*ClusterGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ClusterGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirtualizationApiService.VirtualizationClusterGroupsRead")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/virtualization/cluster-groups/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVirtualizationClusterGroupsUpdateRequest struct {
	ctx context.Context
	ApiService *VirtualizationApiService
	id int32
	data *ClusterGroup
}

func (r ApiVirtualizationClusterGroupsUpdateRequest) Data(data ClusterGroup) ApiVirtualizationClusterGroupsUpdateRequest {
	r.data = &data
	return r
}

func (r ApiVirtualizationClusterGroupsUpdateRequest) Execute() (*ClusterGroup, *http.Response, error) {
	return r.ApiService.VirtualizationClusterGroupsUpdateExecute(r)
}

/*
VirtualizationClusterGroupsUpdate Method for VirtualizationClusterGroupsUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this cluster group.
 @return ApiVirtualizationClusterGroupsUpdateRequest
*/
func (a *VirtualizationApiService) VirtualizationClusterGroupsUpdate(ctx context.Context, id int32) ApiVirtualizationClusterGroupsUpdateRequest {
	return ApiVirtualizationClusterGroupsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ClusterGroup
func (a *VirtualizationApiService) VirtualizationClusterGroupsUpdateExecute(r ApiVirtualizationClusterGroupsUpdateRequest) (*ClusterGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ClusterGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirtualizationApiService.VirtualizationClusterGroupsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/virtualization/cluster-groups/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVirtualizationClusterTypesBulkDeleteRequest struct {
	ctx context.Context
	ApiService *VirtualizationApiService
}

func (r ApiVirtualizationClusterTypesBulkDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.VirtualizationClusterTypesBulkDeleteExecute(r)
}

/*
VirtualizationClusterTypesBulkDelete Method for VirtualizationClusterTypesBulkDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiVirtualizationClusterTypesBulkDeleteRequest
*/
func (a *VirtualizationApiService) VirtualizationClusterTypesBulkDelete(ctx context.Context) ApiVirtualizationClusterTypesBulkDeleteRequest {
	return ApiVirtualizationClusterTypesBulkDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *VirtualizationApiService) VirtualizationClusterTypesBulkDeleteExecute(r ApiVirtualizationClusterTypesBulkDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirtualizationApiService.VirtualizationClusterTypesBulkDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/virtualization/cluster-types/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiVirtualizationClusterTypesBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *VirtualizationApiService
	data *ClusterType
}

func (r ApiVirtualizationClusterTypesBulkPartialUpdateRequest) Data(data ClusterType) ApiVirtualizationClusterTypesBulkPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiVirtualizationClusterTypesBulkPartialUpdateRequest) Execute() (*ClusterType, *http.Response, error) {
	return r.ApiService.VirtualizationClusterTypesBulkPartialUpdateExecute(r)
}

/*
VirtualizationClusterTypesBulkPartialUpdate Method for VirtualizationClusterTypesBulkPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiVirtualizationClusterTypesBulkPartialUpdateRequest
*/
func (a *VirtualizationApiService) VirtualizationClusterTypesBulkPartialUpdate(ctx context.Context) ApiVirtualizationClusterTypesBulkPartialUpdateRequest {
	return ApiVirtualizationClusterTypesBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ClusterType
func (a *VirtualizationApiService) VirtualizationClusterTypesBulkPartialUpdateExecute(r ApiVirtualizationClusterTypesBulkPartialUpdateRequest) (*ClusterType, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ClusterType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirtualizationApiService.VirtualizationClusterTypesBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/virtualization/cluster-types/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVirtualizationClusterTypesBulkUpdateRequest struct {
	ctx context.Context
	ApiService *VirtualizationApiService
	data *ClusterType
}

func (r ApiVirtualizationClusterTypesBulkUpdateRequest) Data(data ClusterType) ApiVirtualizationClusterTypesBulkUpdateRequest {
	r.data = &data
	return r
}

func (r ApiVirtualizationClusterTypesBulkUpdateRequest) Execute() (*ClusterType, *http.Response, error) {
	return r.ApiService.VirtualizationClusterTypesBulkUpdateExecute(r)
}

/*
VirtualizationClusterTypesBulkUpdate Method for VirtualizationClusterTypesBulkUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiVirtualizationClusterTypesBulkUpdateRequest
*/
func (a *VirtualizationApiService) VirtualizationClusterTypesBulkUpdate(ctx context.Context) ApiVirtualizationClusterTypesBulkUpdateRequest {
	return ApiVirtualizationClusterTypesBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ClusterType
func (a *VirtualizationApiService) VirtualizationClusterTypesBulkUpdateExecute(r ApiVirtualizationClusterTypesBulkUpdateRequest) (*ClusterType, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ClusterType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirtualizationApiService.VirtualizationClusterTypesBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/virtualization/cluster-types/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVirtualizationClusterTypesCreateRequest struct {
	ctx context.Context
	ApiService *VirtualizationApiService
	data *ClusterType
}

func (r ApiVirtualizationClusterTypesCreateRequest) Data(data ClusterType) ApiVirtualizationClusterTypesCreateRequest {
	r.data = &data
	return r
}

func (r ApiVirtualizationClusterTypesCreateRequest) Execute() (*ClusterType, *http.Response, error) {
	return r.ApiService.VirtualizationClusterTypesCreateExecute(r)
}

/*
VirtualizationClusterTypesCreate Method for VirtualizationClusterTypesCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiVirtualizationClusterTypesCreateRequest
*/
func (a *VirtualizationApiService) VirtualizationClusterTypesCreate(ctx context.Context) ApiVirtualizationClusterTypesCreateRequest {
	return ApiVirtualizationClusterTypesCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ClusterType
func (a *VirtualizationApiService) VirtualizationClusterTypesCreateExecute(r ApiVirtualizationClusterTypesCreateRequest) (*ClusterType, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ClusterType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirtualizationApiService.VirtualizationClusterTypesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/virtualization/cluster-types/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVirtualizationClusterTypesDeleteRequest struct {
	ctx context.Context
	ApiService *VirtualizationApiService
	id int32
}

func (r ApiVirtualizationClusterTypesDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.VirtualizationClusterTypesDeleteExecute(r)
}

/*
VirtualizationClusterTypesDelete Method for VirtualizationClusterTypesDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this cluster type.
 @return ApiVirtualizationClusterTypesDeleteRequest
*/
func (a *VirtualizationApiService) VirtualizationClusterTypesDelete(ctx context.Context, id int32) ApiVirtualizationClusterTypesDeleteRequest {
	return ApiVirtualizationClusterTypesDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *VirtualizationApiService) VirtualizationClusterTypesDeleteExecute(r ApiVirtualizationClusterTypesDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirtualizationApiService.VirtualizationClusterTypesDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/virtualization/cluster-types/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiVirtualizationClusterTypesListRequest struct {
	ctx context.Context
	ApiService *VirtualizationApiService
	id *string
	name *string
	slug *string
	description *string
	created *string
	createdGte *string
	createdLte *string
	lastUpdated *string
	lastUpdatedGte *string
	lastUpdatedLte *string
	q *string
	idN *string
	idLte *string
	idLt *string
	idGte *string
	idGt *string
	nameN *string
	nameIc *string
	nameNic *string
	nameIew *string
	nameNiew *string
	nameIsw *string
	nameNisw *string
	nameIe *string
	nameNie *string
	nameEmpty *string
	slugN *string
	slugIc *string
	slugNic *string
	slugIew *string
	slugNiew *string
	slugIsw *string
	slugNisw *string
	slugIe *string
	slugNie *string
	slugEmpty *string
	descriptionN *string
	descriptionIc *string
	descriptionNic *string
	descriptionIew *string
	descriptionNiew *string
	descriptionIsw *string
	descriptionNisw *string
	descriptionIe *string
	descriptionNie *string
	descriptionEmpty *string
	limit *int32
	offset *int32
}

func (r ApiVirtualizationClusterTypesListRequest) Id(id string) ApiVirtualizationClusterTypesListRequest {
	r.id = &id
	return r
}

func (r ApiVirtualizationClusterTypesListRequest) Name(name string) ApiVirtualizationClusterTypesListRequest {
	r.name = &name
	return r
}

func (r ApiVirtualizationClusterTypesListRequest) Slug(slug string) ApiVirtualizationClusterTypesListRequest {
	r.slug = &slug
	return r
}

func (r ApiVirtualizationClusterTypesListRequest) Description(description string) ApiVirtualizationClusterTypesListRequest {
	r.description = &description
	return r
}

func (r ApiVirtualizationClusterTypesListRequest) Created(created string) ApiVirtualizationClusterTypesListRequest {
	r.created = &created
	return r
}

func (r ApiVirtualizationClusterTypesListRequest) CreatedGte(createdGte string) ApiVirtualizationClusterTypesListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiVirtualizationClusterTypesListRequest) CreatedLte(createdLte string) ApiVirtualizationClusterTypesListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiVirtualizationClusterTypesListRequest) LastUpdated(lastUpdated string) ApiVirtualizationClusterTypesListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiVirtualizationClusterTypesListRequest) LastUpdatedGte(lastUpdatedGte string) ApiVirtualizationClusterTypesListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiVirtualizationClusterTypesListRequest) LastUpdatedLte(lastUpdatedLte string) ApiVirtualizationClusterTypesListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiVirtualizationClusterTypesListRequest) Q(q string) ApiVirtualizationClusterTypesListRequest {
	r.q = &q
	return r
}

func (r ApiVirtualizationClusterTypesListRequest) IdN(idN string) ApiVirtualizationClusterTypesListRequest {
	r.idN = &idN
	return r
}

func (r ApiVirtualizationClusterTypesListRequest) IdLte(idLte string) ApiVirtualizationClusterTypesListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiVirtualizationClusterTypesListRequest) IdLt(idLt string) ApiVirtualizationClusterTypesListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiVirtualizationClusterTypesListRequest) IdGte(idGte string) ApiVirtualizationClusterTypesListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiVirtualizationClusterTypesListRequest) IdGt(idGt string) ApiVirtualizationClusterTypesListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiVirtualizationClusterTypesListRequest) NameN(nameN string) ApiVirtualizationClusterTypesListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiVirtualizationClusterTypesListRequest) NameIc(nameIc string) ApiVirtualizationClusterTypesListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiVirtualizationClusterTypesListRequest) NameNic(nameNic string) ApiVirtualizationClusterTypesListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiVirtualizationClusterTypesListRequest) NameIew(nameIew string) ApiVirtualizationClusterTypesListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiVirtualizationClusterTypesListRequest) NameNiew(nameNiew string) ApiVirtualizationClusterTypesListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiVirtualizationClusterTypesListRequest) NameIsw(nameIsw string) ApiVirtualizationClusterTypesListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiVirtualizationClusterTypesListRequest) NameNisw(nameNisw string) ApiVirtualizationClusterTypesListRequest {
	r.nameNisw = &nameNisw
	return r
}

func (r ApiVirtualizationClusterTypesListRequest) NameIe(nameIe string) ApiVirtualizationClusterTypesListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiVirtualizationClusterTypesListRequest) NameNie(nameNie string) ApiVirtualizationClusterTypesListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiVirtualizationClusterTypesListRequest) NameEmpty(nameEmpty string) ApiVirtualizationClusterTypesListRequest {
	r.nameEmpty = &nameEmpty
	return r
}

func (r ApiVirtualizationClusterTypesListRequest) SlugN(slugN string) ApiVirtualizationClusterTypesListRequest {
	r.slugN = &slugN
	return r
}

func (r ApiVirtualizationClusterTypesListRequest) SlugIc(slugIc string) ApiVirtualizationClusterTypesListRequest {
	r.slugIc = &slugIc
	return r
}

func (r ApiVirtualizationClusterTypesListRequest) SlugNic(slugNic string) ApiVirtualizationClusterTypesListRequest {
	r.slugNic = &slugNic
	return r
}

func (r ApiVirtualizationClusterTypesListRequest) SlugIew(slugIew string) ApiVirtualizationClusterTypesListRequest {
	r.slugIew = &slugIew
	return r
}

func (r ApiVirtualizationClusterTypesListRequest) SlugNiew(slugNiew string) ApiVirtualizationClusterTypesListRequest {
	r.slugNiew = &slugNiew
	return r
}

func (r ApiVirtualizationClusterTypesListRequest) SlugIsw(slugIsw string) ApiVirtualizationClusterTypesListRequest {
	r.slugIsw = &slugIsw
	return r
}

func (r ApiVirtualizationClusterTypesListRequest) SlugNisw(slugNisw string) ApiVirtualizationClusterTypesListRequest {
	r.slugNisw = &slugNisw
	return r
}

func (r ApiVirtualizationClusterTypesListRequest) SlugIe(slugIe string) ApiVirtualizationClusterTypesListRequest {
	r.slugIe = &slugIe
	return r
}

func (r ApiVirtualizationClusterTypesListRequest) SlugNie(slugNie string) ApiVirtualizationClusterTypesListRequest {
	r.slugNie = &slugNie
	return r
}

func (r ApiVirtualizationClusterTypesListRequest) SlugEmpty(slugEmpty string) ApiVirtualizationClusterTypesListRequest {
	r.slugEmpty = &slugEmpty
	return r
}

func (r ApiVirtualizationClusterTypesListRequest) DescriptionN(descriptionN string) ApiVirtualizationClusterTypesListRequest {
	r.descriptionN = &descriptionN
	return r
}

func (r ApiVirtualizationClusterTypesListRequest) DescriptionIc(descriptionIc string) ApiVirtualizationClusterTypesListRequest {
	r.descriptionIc = &descriptionIc
	return r
}

func (r ApiVirtualizationClusterTypesListRequest) DescriptionNic(descriptionNic string) ApiVirtualizationClusterTypesListRequest {
	r.descriptionNic = &descriptionNic
	return r
}

func (r ApiVirtualizationClusterTypesListRequest) DescriptionIew(descriptionIew string) ApiVirtualizationClusterTypesListRequest {
	r.descriptionIew = &descriptionIew
	return r
}

func (r ApiVirtualizationClusterTypesListRequest) DescriptionNiew(descriptionNiew string) ApiVirtualizationClusterTypesListRequest {
	r.descriptionNiew = &descriptionNiew
	return r
}

func (r ApiVirtualizationClusterTypesListRequest) DescriptionIsw(descriptionIsw string) ApiVirtualizationClusterTypesListRequest {
	r.descriptionIsw = &descriptionIsw
	return r
}

func (r ApiVirtualizationClusterTypesListRequest) DescriptionNisw(descriptionNisw string) ApiVirtualizationClusterTypesListRequest {
	r.descriptionNisw = &descriptionNisw
	return r
}

func (r ApiVirtualizationClusterTypesListRequest) DescriptionIe(descriptionIe string) ApiVirtualizationClusterTypesListRequest {
	r.descriptionIe = &descriptionIe
	return r
}

func (r ApiVirtualizationClusterTypesListRequest) DescriptionNie(descriptionNie string) ApiVirtualizationClusterTypesListRequest {
	r.descriptionNie = &descriptionNie
	return r
}

func (r ApiVirtualizationClusterTypesListRequest) DescriptionEmpty(descriptionEmpty string) ApiVirtualizationClusterTypesListRequest {
	r.descriptionEmpty = &descriptionEmpty
	return r
}

// Number of results to return per page.
func (r ApiVirtualizationClusterTypesListRequest) Limit(limit int32) ApiVirtualizationClusterTypesListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiVirtualizationClusterTypesListRequest) Offset(offset int32) ApiVirtualizationClusterTypesListRequest {
	r.offset = &offset
	return r
}

func (r ApiVirtualizationClusterTypesListRequest) Execute() (*VirtualizationClusterTypesList200Response, *http.Response, error) {
	return r.ApiService.VirtualizationClusterTypesListExecute(r)
}

/*
VirtualizationClusterTypesList Method for VirtualizationClusterTypesList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiVirtualizationClusterTypesListRequest
*/
func (a *VirtualizationApiService) VirtualizationClusterTypesList(ctx context.Context) ApiVirtualizationClusterTypesListRequest {
	return ApiVirtualizationClusterTypesListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return VirtualizationClusterTypesList200Response
func (a *VirtualizationApiService) VirtualizationClusterTypesListExecute(r ApiVirtualizationClusterTypesListRequest) (*VirtualizationClusterTypesList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VirtualizationClusterTypesList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirtualizationApiService.VirtualizationClusterTypesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/virtualization/cluster-types/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.slug != nil {
		localVarQueryParams.Add("slug", parameterToString(*r.slug, ""))
	}
	if r.description != nil {
		localVarQueryParams.Add("description", parameterToString(*r.description, ""))
	}
	if r.created != nil {
		localVarQueryParams.Add("created", parameterToString(*r.created, ""))
	}
	if r.createdGte != nil {
		localVarQueryParams.Add("created__gte", parameterToString(*r.createdGte, ""))
	}
	if r.createdLte != nil {
		localVarQueryParams.Add("created__lte", parameterToString(*r.createdLte, ""))
	}
	if r.lastUpdated != nil {
		localVarQueryParams.Add("last_updated", parameterToString(*r.lastUpdated, ""))
	}
	if r.lastUpdatedGte != nil {
		localVarQueryParams.Add("last_updated__gte", parameterToString(*r.lastUpdatedGte, ""))
	}
	if r.lastUpdatedLte != nil {
		localVarQueryParams.Add("last_updated__lte", parameterToString(*r.lastUpdatedLte, ""))
	}
	if r.q != nil {
		localVarQueryParams.Add("q", parameterToString(*r.q, ""))
	}
	if r.idN != nil {
		localVarQueryParams.Add("id__n", parameterToString(*r.idN, ""))
	}
	if r.idLte != nil {
		localVarQueryParams.Add("id__lte", parameterToString(*r.idLte, ""))
	}
	if r.idLt != nil {
		localVarQueryParams.Add("id__lt", parameterToString(*r.idLt, ""))
	}
	if r.idGte != nil {
		localVarQueryParams.Add("id__gte", parameterToString(*r.idGte, ""))
	}
	if r.idGt != nil {
		localVarQueryParams.Add("id__gt", parameterToString(*r.idGt, ""))
	}
	if r.nameN != nil {
		localVarQueryParams.Add("name__n", parameterToString(*r.nameN, ""))
	}
	if r.nameIc != nil {
		localVarQueryParams.Add("name__ic", parameterToString(*r.nameIc, ""))
	}
	if r.nameNic != nil {
		localVarQueryParams.Add("name__nic", parameterToString(*r.nameNic, ""))
	}
	if r.nameIew != nil {
		localVarQueryParams.Add("name__iew", parameterToString(*r.nameIew, ""))
	}
	if r.nameNiew != nil {
		localVarQueryParams.Add("name__niew", parameterToString(*r.nameNiew, ""))
	}
	if r.nameIsw != nil {
		localVarQueryParams.Add("name__isw", parameterToString(*r.nameIsw, ""))
	}
	if r.nameNisw != nil {
		localVarQueryParams.Add("name__nisw", parameterToString(*r.nameNisw, ""))
	}
	if r.nameIe != nil {
		localVarQueryParams.Add("name__ie", parameterToString(*r.nameIe, ""))
	}
	if r.nameNie != nil {
		localVarQueryParams.Add("name__nie", parameterToString(*r.nameNie, ""))
	}
	if r.nameEmpty != nil {
		localVarQueryParams.Add("name__empty", parameterToString(*r.nameEmpty, ""))
	}
	if r.slugN != nil {
		localVarQueryParams.Add("slug__n", parameterToString(*r.slugN, ""))
	}
	if r.slugIc != nil {
		localVarQueryParams.Add("slug__ic", parameterToString(*r.slugIc, ""))
	}
	if r.slugNic != nil {
		localVarQueryParams.Add("slug__nic", parameterToString(*r.slugNic, ""))
	}
	if r.slugIew != nil {
		localVarQueryParams.Add("slug__iew", parameterToString(*r.slugIew, ""))
	}
	if r.slugNiew != nil {
		localVarQueryParams.Add("slug__niew", parameterToString(*r.slugNiew, ""))
	}
	if r.slugIsw != nil {
		localVarQueryParams.Add("slug__isw", parameterToString(*r.slugIsw, ""))
	}
	if r.slugNisw != nil {
		localVarQueryParams.Add("slug__nisw", parameterToString(*r.slugNisw, ""))
	}
	if r.slugIe != nil {
		localVarQueryParams.Add("slug__ie", parameterToString(*r.slugIe, ""))
	}
	if r.slugNie != nil {
		localVarQueryParams.Add("slug__nie", parameterToString(*r.slugNie, ""))
	}
	if r.slugEmpty != nil {
		localVarQueryParams.Add("slug__empty", parameterToString(*r.slugEmpty, ""))
	}
	if r.descriptionN != nil {
		localVarQueryParams.Add("description__n", parameterToString(*r.descriptionN, ""))
	}
	if r.descriptionIc != nil {
		localVarQueryParams.Add("description__ic", parameterToString(*r.descriptionIc, ""))
	}
	if r.descriptionNic != nil {
		localVarQueryParams.Add("description__nic", parameterToString(*r.descriptionNic, ""))
	}
	if r.descriptionIew != nil {
		localVarQueryParams.Add("description__iew", parameterToString(*r.descriptionIew, ""))
	}
	if r.descriptionNiew != nil {
		localVarQueryParams.Add("description__niew", parameterToString(*r.descriptionNiew, ""))
	}
	if r.descriptionIsw != nil {
		localVarQueryParams.Add("description__isw", parameterToString(*r.descriptionIsw, ""))
	}
	if r.descriptionNisw != nil {
		localVarQueryParams.Add("description__nisw", parameterToString(*r.descriptionNisw, ""))
	}
	if r.descriptionIe != nil {
		localVarQueryParams.Add("description__ie", parameterToString(*r.descriptionIe, ""))
	}
	if r.descriptionNie != nil {
		localVarQueryParams.Add("description__nie", parameterToString(*r.descriptionNie, ""))
	}
	if r.descriptionEmpty != nil {
		localVarQueryParams.Add("description__empty", parameterToString(*r.descriptionEmpty, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVirtualizationClusterTypesPartialUpdateRequest struct {
	ctx context.Context
	ApiService *VirtualizationApiService
	id int32
	data *ClusterType
}

func (r ApiVirtualizationClusterTypesPartialUpdateRequest) Data(data ClusterType) ApiVirtualizationClusterTypesPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiVirtualizationClusterTypesPartialUpdateRequest) Execute() (*ClusterType, *http.Response, error) {
	return r.ApiService.VirtualizationClusterTypesPartialUpdateExecute(r)
}

/*
VirtualizationClusterTypesPartialUpdate Method for VirtualizationClusterTypesPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this cluster type.
 @return ApiVirtualizationClusterTypesPartialUpdateRequest
*/
func (a *VirtualizationApiService) VirtualizationClusterTypesPartialUpdate(ctx context.Context, id int32) ApiVirtualizationClusterTypesPartialUpdateRequest {
	return ApiVirtualizationClusterTypesPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ClusterType
func (a *VirtualizationApiService) VirtualizationClusterTypesPartialUpdateExecute(r ApiVirtualizationClusterTypesPartialUpdateRequest) (*ClusterType, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ClusterType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirtualizationApiService.VirtualizationClusterTypesPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/virtualization/cluster-types/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVirtualizationClusterTypesReadRequest struct {
	ctx context.Context
	ApiService *VirtualizationApiService
	id int32
}

func (r ApiVirtualizationClusterTypesReadRequest) Execute() (*ClusterType, *http.Response, error) {
	return r.ApiService.VirtualizationClusterTypesReadExecute(r)
}

/*
VirtualizationClusterTypesRead Method for VirtualizationClusterTypesRead

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this cluster type.
 @return ApiVirtualizationClusterTypesReadRequest
*/
func (a *VirtualizationApiService) VirtualizationClusterTypesRead(ctx context.Context, id int32) ApiVirtualizationClusterTypesReadRequest {
	return ApiVirtualizationClusterTypesReadRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ClusterType
func (a *VirtualizationApiService) VirtualizationClusterTypesReadExecute(r ApiVirtualizationClusterTypesReadRequest) (*ClusterType, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ClusterType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirtualizationApiService.VirtualizationClusterTypesRead")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/virtualization/cluster-types/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVirtualizationClusterTypesUpdateRequest struct {
	ctx context.Context
	ApiService *VirtualizationApiService
	id int32
	data *ClusterType
}

func (r ApiVirtualizationClusterTypesUpdateRequest) Data(data ClusterType) ApiVirtualizationClusterTypesUpdateRequest {
	r.data = &data
	return r
}

func (r ApiVirtualizationClusterTypesUpdateRequest) Execute() (*ClusterType, *http.Response, error) {
	return r.ApiService.VirtualizationClusterTypesUpdateExecute(r)
}

/*
VirtualizationClusterTypesUpdate Method for VirtualizationClusterTypesUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this cluster type.
 @return ApiVirtualizationClusterTypesUpdateRequest
*/
func (a *VirtualizationApiService) VirtualizationClusterTypesUpdate(ctx context.Context, id int32) ApiVirtualizationClusterTypesUpdateRequest {
	return ApiVirtualizationClusterTypesUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ClusterType
func (a *VirtualizationApiService) VirtualizationClusterTypesUpdateExecute(r ApiVirtualizationClusterTypesUpdateRequest) (*ClusterType, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ClusterType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirtualizationApiService.VirtualizationClusterTypesUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/virtualization/cluster-types/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVirtualizationClustersBulkDeleteRequest struct {
	ctx context.Context
	ApiService *VirtualizationApiService
}

func (r ApiVirtualizationClustersBulkDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.VirtualizationClustersBulkDeleteExecute(r)
}

/*
VirtualizationClustersBulkDelete Method for VirtualizationClustersBulkDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiVirtualizationClustersBulkDeleteRequest
*/
func (a *VirtualizationApiService) VirtualizationClustersBulkDelete(ctx context.Context) ApiVirtualizationClustersBulkDeleteRequest {
	return ApiVirtualizationClustersBulkDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *VirtualizationApiService) VirtualizationClustersBulkDeleteExecute(r ApiVirtualizationClustersBulkDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirtualizationApiService.VirtualizationClustersBulkDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/virtualization/clusters/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiVirtualizationClustersBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *VirtualizationApiService
	data *WritableCluster
}

func (r ApiVirtualizationClustersBulkPartialUpdateRequest) Data(data WritableCluster) ApiVirtualizationClustersBulkPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiVirtualizationClustersBulkPartialUpdateRequest) Execute() (*Cluster, *http.Response, error) {
	return r.ApiService.VirtualizationClustersBulkPartialUpdateExecute(r)
}

/*
VirtualizationClustersBulkPartialUpdate Method for VirtualizationClustersBulkPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiVirtualizationClustersBulkPartialUpdateRequest
*/
func (a *VirtualizationApiService) VirtualizationClustersBulkPartialUpdate(ctx context.Context) ApiVirtualizationClustersBulkPartialUpdateRequest {
	return ApiVirtualizationClustersBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Cluster
func (a *VirtualizationApiService) VirtualizationClustersBulkPartialUpdateExecute(r ApiVirtualizationClustersBulkPartialUpdateRequest) (*Cluster, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Cluster
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirtualizationApiService.VirtualizationClustersBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/virtualization/clusters/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVirtualizationClustersBulkUpdateRequest struct {
	ctx context.Context
	ApiService *VirtualizationApiService
	data *WritableCluster
}

func (r ApiVirtualizationClustersBulkUpdateRequest) Data(data WritableCluster) ApiVirtualizationClustersBulkUpdateRequest {
	r.data = &data
	return r
}

func (r ApiVirtualizationClustersBulkUpdateRequest) Execute() (*Cluster, *http.Response, error) {
	return r.ApiService.VirtualizationClustersBulkUpdateExecute(r)
}

/*
VirtualizationClustersBulkUpdate Method for VirtualizationClustersBulkUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiVirtualizationClustersBulkUpdateRequest
*/
func (a *VirtualizationApiService) VirtualizationClustersBulkUpdate(ctx context.Context) ApiVirtualizationClustersBulkUpdateRequest {
	return ApiVirtualizationClustersBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Cluster
func (a *VirtualizationApiService) VirtualizationClustersBulkUpdateExecute(r ApiVirtualizationClustersBulkUpdateRequest) (*Cluster, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Cluster
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirtualizationApiService.VirtualizationClustersBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/virtualization/clusters/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVirtualizationClustersCreateRequest struct {
	ctx context.Context
	ApiService *VirtualizationApiService
	data *WritableCluster
}

func (r ApiVirtualizationClustersCreateRequest) Data(data WritableCluster) ApiVirtualizationClustersCreateRequest {
	r.data = &data
	return r
}

func (r ApiVirtualizationClustersCreateRequest) Execute() (*Cluster, *http.Response, error) {
	return r.ApiService.VirtualizationClustersCreateExecute(r)
}

/*
VirtualizationClustersCreate Method for VirtualizationClustersCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiVirtualizationClustersCreateRequest
*/
func (a *VirtualizationApiService) VirtualizationClustersCreate(ctx context.Context) ApiVirtualizationClustersCreateRequest {
	return ApiVirtualizationClustersCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Cluster
func (a *VirtualizationApiService) VirtualizationClustersCreateExecute(r ApiVirtualizationClustersCreateRequest) (*Cluster, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Cluster
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirtualizationApiService.VirtualizationClustersCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/virtualization/clusters/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVirtualizationClustersDeleteRequest struct {
	ctx context.Context
	ApiService *VirtualizationApiService
	id int32
}

func (r ApiVirtualizationClustersDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.VirtualizationClustersDeleteExecute(r)
}

/*
VirtualizationClustersDelete Method for VirtualizationClustersDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this cluster.
 @return ApiVirtualizationClustersDeleteRequest
*/
func (a *VirtualizationApiService) VirtualizationClustersDelete(ctx context.Context, id int32) ApiVirtualizationClustersDeleteRequest {
	return ApiVirtualizationClustersDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *VirtualizationApiService) VirtualizationClustersDeleteExecute(r ApiVirtualizationClustersDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirtualizationApiService.VirtualizationClustersDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/virtualization/clusters/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiVirtualizationClustersListRequest struct {
	ctx context.Context
	ApiService *VirtualizationApiService
	id *string
	name *string
	created *string
	createdGte *string
	createdLte *string
	lastUpdated *string
	lastUpdatedGte *string
	lastUpdatedLte *string
	tenantGroupId *string
	tenantGroup *string
	tenantId *string
	tenant *string
	q *string
	regionId *string
	region *string
	siteGroupId *string
	siteGroup *string
	siteId *string
	site *string
	groupId *string
	group *string
	typeId *string
	type_ *string
	tag *string
	idN *string
	idLte *string
	idLt *string
	idGte *string
	idGt *string
	nameN *string
	nameIc *string
	nameNic *string
	nameIew *string
	nameNiew *string
	nameIsw *string
	nameNisw *string
	nameIe *string
	nameNie *string
	nameEmpty *string
	tenantGroupIdN *string
	tenantGroupN *string
	tenantIdN *string
	tenantN *string
	regionIdN *string
	regionN *string
	siteGroupIdN *string
	siteGroupN *string
	siteIdN *string
	siteN *string
	groupIdN *string
	groupN *string
	typeIdN *string
	typeN *string
	tagN *string
	limit *int32
	offset *int32
}

func (r ApiVirtualizationClustersListRequest) Id(id string) ApiVirtualizationClustersListRequest {
	r.id = &id
	return r
}

func (r ApiVirtualizationClustersListRequest) Name(name string) ApiVirtualizationClustersListRequest {
	r.name = &name
	return r
}

func (r ApiVirtualizationClustersListRequest) Created(created string) ApiVirtualizationClustersListRequest {
	r.created = &created
	return r
}

func (r ApiVirtualizationClustersListRequest) CreatedGte(createdGte string) ApiVirtualizationClustersListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiVirtualizationClustersListRequest) CreatedLte(createdLte string) ApiVirtualizationClustersListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiVirtualizationClustersListRequest) LastUpdated(lastUpdated string) ApiVirtualizationClustersListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiVirtualizationClustersListRequest) LastUpdatedGte(lastUpdatedGte string) ApiVirtualizationClustersListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiVirtualizationClustersListRequest) LastUpdatedLte(lastUpdatedLte string) ApiVirtualizationClustersListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiVirtualizationClustersListRequest) TenantGroupId(tenantGroupId string) ApiVirtualizationClustersListRequest {
	r.tenantGroupId = &tenantGroupId
	return r
}

func (r ApiVirtualizationClustersListRequest) TenantGroup(tenantGroup string) ApiVirtualizationClustersListRequest {
	r.tenantGroup = &tenantGroup
	return r
}

func (r ApiVirtualizationClustersListRequest) TenantId(tenantId string) ApiVirtualizationClustersListRequest {
	r.tenantId = &tenantId
	return r
}

func (r ApiVirtualizationClustersListRequest) Tenant(tenant string) ApiVirtualizationClustersListRequest {
	r.tenant = &tenant
	return r
}

func (r ApiVirtualizationClustersListRequest) Q(q string) ApiVirtualizationClustersListRequest {
	r.q = &q
	return r
}

func (r ApiVirtualizationClustersListRequest) RegionId(regionId string) ApiVirtualizationClustersListRequest {
	r.regionId = &regionId
	return r
}

func (r ApiVirtualizationClustersListRequest) Region(region string) ApiVirtualizationClustersListRequest {
	r.region = &region
	return r
}

func (r ApiVirtualizationClustersListRequest) SiteGroupId(siteGroupId string) ApiVirtualizationClustersListRequest {
	r.siteGroupId = &siteGroupId
	return r
}

func (r ApiVirtualizationClustersListRequest) SiteGroup(siteGroup string) ApiVirtualizationClustersListRequest {
	r.siteGroup = &siteGroup
	return r
}

func (r ApiVirtualizationClustersListRequest) SiteId(siteId string) ApiVirtualizationClustersListRequest {
	r.siteId = &siteId
	return r
}

func (r ApiVirtualizationClustersListRequest) Site(site string) ApiVirtualizationClustersListRequest {
	r.site = &site
	return r
}

func (r ApiVirtualizationClustersListRequest) GroupId(groupId string) ApiVirtualizationClustersListRequest {
	r.groupId = &groupId
	return r
}

func (r ApiVirtualizationClustersListRequest) Group(group string) ApiVirtualizationClustersListRequest {
	r.group = &group
	return r
}

func (r ApiVirtualizationClustersListRequest) TypeId(typeId string) ApiVirtualizationClustersListRequest {
	r.typeId = &typeId
	return r
}

func (r ApiVirtualizationClustersListRequest) Type_(type_ string) ApiVirtualizationClustersListRequest {
	r.type_ = &type_
	return r
}

func (r ApiVirtualizationClustersListRequest) Tag(tag string) ApiVirtualizationClustersListRequest {
	r.tag = &tag
	return r
}

func (r ApiVirtualizationClustersListRequest) IdN(idN string) ApiVirtualizationClustersListRequest {
	r.idN = &idN
	return r
}

func (r ApiVirtualizationClustersListRequest) IdLte(idLte string) ApiVirtualizationClustersListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiVirtualizationClustersListRequest) IdLt(idLt string) ApiVirtualizationClustersListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiVirtualizationClustersListRequest) IdGte(idGte string) ApiVirtualizationClustersListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiVirtualizationClustersListRequest) IdGt(idGt string) ApiVirtualizationClustersListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiVirtualizationClustersListRequest) NameN(nameN string) ApiVirtualizationClustersListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiVirtualizationClustersListRequest) NameIc(nameIc string) ApiVirtualizationClustersListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiVirtualizationClustersListRequest) NameNic(nameNic string) ApiVirtualizationClustersListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiVirtualizationClustersListRequest) NameIew(nameIew string) ApiVirtualizationClustersListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiVirtualizationClustersListRequest) NameNiew(nameNiew string) ApiVirtualizationClustersListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiVirtualizationClustersListRequest) NameIsw(nameIsw string) ApiVirtualizationClustersListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiVirtualizationClustersListRequest) NameNisw(nameNisw string) ApiVirtualizationClustersListRequest {
	r.nameNisw = &nameNisw
	return r
}

func (r ApiVirtualizationClustersListRequest) NameIe(nameIe string) ApiVirtualizationClustersListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiVirtualizationClustersListRequest) NameNie(nameNie string) ApiVirtualizationClustersListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiVirtualizationClustersListRequest) NameEmpty(nameEmpty string) ApiVirtualizationClustersListRequest {
	r.nameEmpty = &nameEmpty
	return r
}

func (r ApiVirtualizationClustersListRequest) TenantGroupIdN(tenantGroupIdN string) ApiVirtualizationClustersListRequest {
	r.tenantGroupIdN = &tenantGroupIdN
	return r
}

func (r ApiVirtualizationClustersListRequest) TenantGroupN(tenantGroupN string) ApiVirtualizationClustersListRequest {
	r.tenantGroupN = &tenantGroupN
	return r
}

func (r ApiVirtualizationClustersListRequest) TenantIdN(tenantIdN string) ApiVirtualizationClustersListRequest {
	r.tenantIdN = &tenantIdN
	return r
}

func (r ApiVirtualizationClustersListRequest) TenantN(tenantN string) ApiVirtualizationClustersListRequest {
	r.tenantN = &tenantN
	return r
}

func (r ApiVirtualizationClustersListRequest) RegionIdN(regionIdN string) ApiVirtualizationClustersListRequest {
	r.regionIdN = &regionIdN
	return r
}

func (r ApiVirtualizationClustersListRequest) RegionN(regionN string) ApiVirtualizationClustersListRequest {
	r.regionN = &regionN
	return r
}

func (r ApiVirtualizationClustersListRequest) SiteGroupIdN(siteGroupIdN string) ApiVirtualizationClustersListRequest {
	r.siteGroupIdN = &siteGroupIdN
	return r
}

func (r ApiVirtualizationClustersListRequest) SiteGroupN(siteGroupN string) ApiVirtualizationClustersListRequest {
	r.siteGroupN = &siteGroupN
	return r
}

func (r ApiVirtualizationClustersListRequest) SiteIdN(siteIdN string) ApiVirtualizationClustersListRequest {
	r.siteIdN = &siteIdN
	return r
}

func (r ApiVirtualizationClustersListRequest) SiteN(siteN string) ApiVirtualizationClustersListRequest {
	r.siteN = &siteN
	return r
}

func (r ApiVirtualizationClustersListRequest) GroupIdN(groupIdN string) ApiVirtualizationClustersListRequest {
	r.groupIdN = &groupIdN
	return r
}

func (r ApiVirtualizationClustersListRequest) GroupN(groupN string) ApiVirtualizationClustersListRequest {
	r.groupN = &groupN
	return r
}

func (r ApiVirtualizationClustersListRequest) TypeIdN(typeIdN string) ApiVirtualizationClustersListRequest {
	r.typeIdN = &typeIdN
	return r
}

func (r ApiVirtualizationClustersListRequest) TypeN(typeN string) ApiVirtualizationClustersListRequest {
	r.typeN = &typeN
	return r
}

func (r ApiVirtualizationClustersListRequest) TagN(tagN string) ApiVirtualizationClustersListRequest {
	r.tagN = &tagN
	return r
}

// Number of results to return per page.
func (r ApiVirtualizationClustersListRequest) Limit(limit int32) ApiVirtualizationClustersListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiVirtualizationClustersListRequest) Offset(offset int32) ApiVirtualizationClustersListRequest {
	r.offset = &offset
	return r
}

func (r ApiVirtualizationClustersListRequest) Execute() (*VirtualizationClustersList200Response, *http.Response, error) {
	return r.ApiService.VirtualizationClustersListExecute(r)
}

/*
VirtualizationClustersList Method for VirtualizationClustersList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiVirtualizationClustersListRequest
*/
func (a *VirtualizationApiService) VirtualizationClustersList(ctx context.Context) ApiVirtualizationClustersListRequest {
	return ApiVirtualizationClustersListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return VirtualizationClustersList200Response
func (a *VirtualizationApiService) VirtualizationClustersListExecute(r ApiVirtualizationClustersListRequest) (*VirtualizationClustersList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VirtualizationClustersList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirtualizationApiService.VirtualizationClustersList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/virtualization/clusters/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.created != nil {
		localVarQueryParams.Add("created", parameterToString(*r.created, ""))
	}
	if r.createdGte != nil {
		localVarQueryParams.Add("created__gte", parameterToString(*r.createdGte, ""))
	}
	if r.createdLte != nil {
		localVarQueryParams.Add("created__lte", parameterToString(*r.createdLte, ""))
	}
	if r.lastUpdated != nil {
		localVarQueryParams.Add("last_updated", parameterToString(*r.lastUpdated, ""))
	}
	if r.lastUpdatedGte != nil {
		localVarQueryParams.Add("last_updated__gte", parameterToString(*r.lastUpdatedGte, ""))
	}
	if r.lastUpdatedLte != nil {
		localVarQueryParams.Add("last_updated__lte", parameterToString(*r.lastUpdatedLte, ""))
	}
	if r.tenantGroupId != nil {
		localVarQueryParams.Add("tenant_group_id", parameterToString(*r.tenantGroupId, ""))
	}
	if r.tenantGroup != nil {
		localVarQueryParams.Add("tenant_group", parameterToString(*r.tenantGroup, ""))
	}
	if r.tenantId != nil {
		localVarQueryParams.Add("tenant_id", parameterToString(*r.tenantId, ""))
	}
	if r.tenant != nil {
		localVarQueryParams.Add("tenant", parameterToString(*r.tenant, ""))
	}
	if r.q != nil {
		localVarQueryParams.Add("q", parameterToString(*r.q, ""))
	}
	if r.regionId != nil {
		localVarQueryParams.Add("region_id", parameterToString(*r.regionId, ""))
	}
	if r.region != nil {
		localVarQueryParams.Add("region", parameterToString(*r.region, ""))
	}
	if r.siteGroupId != nil {
		localVarQueryParams.Add("site_group_id", parameterToString(*r.siteGroupId, ""))
	}
	if r.siteGroup != nil {
		localVarQueryParams.Add("site_group", parameterToString(*r.siteGroup, ""))
	}
	if r.siteId != nil {
		localVarQueryParams.Add("site_id", parameterToString(*r.siteId, ""))
	}
	if r.site != nil {
		localVarQueryParams.Add("site", parameterToString(*r.site, ""))
	}
	if r.groupId != nil {
		localVarQueryParams.Add("group_id", parameterToString(*r.groupId, ""))
	}
	if r.group != nil {
		localVarQueryParams.Add("group", parameterToString(*r.group, ""))
	}
	if r.typeId != nil {
		localVarQueryParams.Add("type_id", parameterToString(*r.typeId, ""))
	}
	if r.type_ != nil {
		localVarQueryParams.Add("type", parameterToString(*r.type_, ""))
	}
	if r.tag != nil {
		localVarQueryParams.Add("tag", parameterToString(*r.tag, ""))
	}
	if r.idN != nil {
		localVarQueryParams.Add("id__n", parameterToString(*r.idN, ""))
	}
	if r.idLte != nil {
		localVarQueryParams.Add("id__lte", parameterToString(*r.idLte, ""))
	}
	if r.idLt != nil {
		localVarQueryParams.Add("id__lt", parameterToString(*r.idLt, ""))
	}
	if r.idGte != nil {
		localVarQueryParams.Add("id__gte", parameterToString(*r.idGte, ""))
	}
	if r.idGt != nil {
		localVarQueryParams.Add("id__gt", parameterToString(*r.idGt, ""))
	}
	if r.nameN != nil {
		localVarQueryParams.Add("name__n", parameterToString(*r.nameN, ""))
	}
	if r.nameIc != nil {
		localVarQueryParams.Add("name__ic", parameterToString(*r.nameIc, ""))
	}
	if r.nameNic != nil {
		localVarQueryParams.Add("name__nic", parameterToString(*r.nameNic, ""))
	}
	if r.nameIew != nil {
		localVarQueryParams.Add("name__iew", parameterToString(*r.nameIew, ""))
	}
	if r.nameNiew != nil {
		localVarQueryParams.Add("name__niew", parameterToString(*r.nameNiew, ""))
	}
	if r.nameIsw != nil {
		localVarQueryParams.Add("name__isw", parameterToString(*r.nameIsw, ""))
	}
	if r.nameNisw != nil {
		localVarQueryParams.Add("name__nisw", parameterToString(*r.nameNisw, ""))
	}
	if r.nameIe != nil {
		localVarQueryParams.Add("name__ie", parameterToString(*r.nameIe, ""))
	}
	if r.nameNie != nil {
		localVarQueryParams.Add("name__nie", parameterToString(*r.nameNie, ""))
	}
	if r.nameEmpty != nil {
		localVarQueryParams.Add("name__empty", parameterToString(*r.nameEmpty, ""))
	}
	if r.tenantGroupIdN != nil {
		localVarQueryParams.Add("tenant_group_id__n", parameterToString(*r.tenantGroupIdN, ""))
	}
	if r.tenantGroupN != nil {
		localVarQueryParams.Add("tenant_group__n", parameterToString(*r.tenantGroupN, ""))
	}
	if r.tenantIdN != nil {
		localVarQueryParams.Add("tenant_id__n", parameterToString(*r.tenantIdN, ""))
	}
	if r.tenantN != nil {
		localVarQueryParams.Add("tenant__n", parameterToString(*r.tenantN, ""))
	}
	if r.regionIdN != nil {
		localVarQueryParams.Add("region_id__n", parameterToString(*r.regionIdN, ""))
	}
	if r.regionN != nil {
		localVarQueryParams.Add("region__n", parameterToString(*r.regionN, ""))
	}
	if r.siteGroupIdN != nil {
		localVarQueryParams.Add("site_group_id__n", parameterToString(*r.siteGroupIdN, ""))
	}
	if r.siteGroupN != nil {
		localVarQueryParams.Add("site_group__n", parameterToString(*r.siteGroupN, ""))
	}
	if r.siteIdN != nil {
		localVarQueryParams.Add("site_id__n", parameterToString(*r.siteIdN, ""))
	}
	if r.siteN != nil {
		localVarQueryParams.Add("site__n", parameterToString(*r.siteN, ""))
	}
	if r.groupIdN != nil {
		localVarQueryParams.Add("group_id__n", parameterToString(*r.groupIdN, ""))
	}
	if r.groupN != nil {
		localVarQueryParams.Add("group__n", parameterToString(*r.groupN, ""))
	}
	if r.typeIdN != nil {
		localVarQueryParams.Add("type_id__n", parameterToString(*r.typeIdN, ""))
	}
	if r.typeN != nil {
		localVarQueryParams.Add("type__n", parameterToString(*r.typeN, ""))
	}
	if r.tagN != nil {
		localVarQueryParams.Add("tag__n", parameterToString(*r.tagN, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVirtualizationClustersPartialUpdateRequest struct {
	ctx context.Context
	ApiService *VirtualizationApiService
	id int32
	data *WritableCluster
}

func (r ApiVirtualizationClustersPartialUpdateRequest) Data(data WritableCluster) ApiVirtualizationClustersPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiVirtualizationClustersPartialUpdateRequest) Execute() (*Cluster, *http.Response, error) {
	return r.ApiService.VirtualizationClustersPartialUpdateExecute(r)
}

/*
VirtualizationClustersPartialUpdate Method for VirtualizationClustersPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this cluster.
 @return ApiVirtualizationClustersPartialUpdateRequest
*/
func (a *VirtualizationApiService) VirtualizationClustersPartialUpdate(ctx context.Context, id int32) ApiVirtualizationClustersPartialUpdateRequest {
	return ApiVirtualizationClustersPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Cluster
func (a *VirtualizationApiService) VirtualizationClustersPartialUpdateExecute(r ApiVirtualizationClustersPartialUpdateRequest) (*Cluster, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Cluster
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirtualizationApiService.VirtualizationClustersPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/virtualization/clusters/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVirtualizationClustersReadRequest struct {
	ctx context.Context
	ApiService *VirtualizationApiService
	id int32
}

func (r ApiVirtualizationClustersReadRequest) Execute() (*Cluster, *http.Response, error) {
	return r.ApiService.VirtualizationClustersReadExecute(r)
}

/*
VirtualizationClustersRead Method for VirtualizationClustersRead

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this cluster.
 @return ApiVirtualizationClustersReadRequest
*/
func (a *VirtualizationApiService) VirtualizationClustersRead(ctx context.Context, id int32) ApiVirtualizationClustersReadRequest {
	return ApiVirtualizationClustersReadRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Cluster
func (a *VirtualizationApiService) VirtualizationClustersReadExecute(r ApiVirtualizationClustersReadRequest) (*Cluster, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Cluster
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirtualizationApiService.VirtualizationClustersRead")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/virtualization/clusters/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVirtualizationClustersUpdateRequest struct {
	ctx context.Context
	ApiService *VirtualizationApiService
	id int32
	data *WritableCluster
}

func (r ApiVirtualizationClustersUpdateRequest) Data(data WritableCluster) ApiVirtualizationClustersUpdateRequest {
	r.data = &data
	return r
}

func (r ApiVirtualizationClustersUpdateRequest) Execute() (*Cluster, *http.Response, error) {
	return r.ApiService.VirtualizationClustersUpdateExecute(r)
}

/*
VirtualizationClustersUpdate Method for VirtualizationClustersUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this cluster.
 @return ApiVirtualizationClustersUpdateRequest
*/
func (a *VirtualizationApiService) VirtualizationClustersUpdate(ctx context.Context, id int32) ApiVirtualizationClustersUpdateRequest {
	return ApiVirtualizationClustersUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Cluster
func (a *VirtualizationApiService) VirtualizationClustersUpdateExecute(r ApiVirtualizationClustersUpdateRequest) (*Cluster, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Cluster
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirtualizationApiService.VirtualizationClustersUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/virtualization/clusters/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVirtualizationInterfacesBulkDeleteRequest struct {
	ctx context.Context
	ApiService *VirtualizationApiService
}

func (r ApiVirtualizationInterfacesBulkDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.VirtualizationInterfacesBulkDeleteExecute(r)
}

/*
VirtualizationInterfacesBulkDelete Method for VirtualizationInterfacesBulkDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiVirtualizationInterfacesBulkDeleteRequest
*/
func (a *VirtualizationApiService) VirtualizationInterfacesBulkDelete(ctx context.Context) ApiVirtualizationInterfacesBulkDeleteRequest {
	return ApiVirtualizationInterfacesBulkDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *VirtualizationApiService) VirtualizationInterfacesBulkDeleteExecute(r ApiVirtualizationInterfacesBulkDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirtualizationApiService.VirtualizationInterfacesBulkDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/virtualization/interfaces/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiVirtualizationInterfacesBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *VirtualizationApiService
	data *WritableVMInterface
}

func (r ApiVirtualizationInterfacesBulkPartialUpdateRequest) Data(data WritableVMInterface) ApiVirtualizationInterfacesBulkPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiVirtualizationInterfacesBulkPartialUpdateRequest) Execute() (*VMInterface, *http.Response, error) {
	return r.ApiService.VirtualizationInterfacesBulkPartialUpdateExecute(r)
}

/*
VirtualizationInterfacesBulkPartialUpdate Method for VirtualizationInterfacesBulkPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiVirtualizationInterfacesBulkPartialUpdateRequest
*/
func (a *VirtualizationApiService) VirtualizationInterfacesBulkPartialUpdate(ctx context.Context) ApiVirtualizationInterfacesBulkPartialUpdateRequest {
	return ApiVirtualizationInterfacesBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return VMInterface
func (a *VirtualizationApiService) VirtualizationInterfacesBulkPartialUpdateExecute(r ApiVirtualizationInterfacesBulkPartialUpdateRequest) (*VMInterface, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VMInterface
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirtualizationApiService.VirtualizationInterfacesBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/virtualization/interfaces/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVirtualizationInterfacesBulkUpdateRequest struct {
	ctx context.Context
	ApiService *VirtualizationApiService
	data *WritableVMInterface
}

func (r ApiVirtualizationInterfacesBulkUpdateRequest) Data(data WritableVMInterface) ApiVirtualizationInterfacesBulkUpdateRequest {
	r.data = &data
	return r
}

func (r ApiVirtualizationInterfacesBulkUpdateRequest) Execute() (*VMInterface, *http.Response, error) {
	return r.ApiService.VirtualizationInterfacesBulkUpdateExecute(r)
}

/*
VirtualizationInterfacesBulkUpdate Method for VirtualizationInterfacesBulkUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiVirtualizationInterfacesBulkUpdateRequest
*/
func (a *VirtualizationApiService) VirtualizationInterfacesBulkUpdate(ctx context.Context) ApiVirtualizationInterfacesBulkUpdateRequest {
	return ApiVirtualizationInterfacesBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return VMInterface
func (a *VirtualizationApiService) VirtualizationInterfacesBulkUpdateExecute(r ApiVirtualizationInterfacesBulkUpdateRequest) (*VMInterface, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VMInterface
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirtualizationApiService.VirtualizationInterfacesBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/virtualization/interfaces/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVirtualizationInterfacesCreateRequest struct {
	ctx context.Context
	ApiService *VirtualizationApiService
	data *WritableVMInterface
}

func (r ApiVirtualizationInterfacesCreateRequest) Data(data WritableVMInterface) ApiVirtualizationInterfacesCreateRequest {
	r.data = &data
	return r
}

func (r ApiVirtualizationInterfacesCreateRequest) Execute() (*VMInterface, *http.Response, error) {
	return r.ApiService.VirtualizationInterfacesCreateExecute(r)
}

/*
VirtualizationInterfacesCreate Method for VirtualizationInterfacesCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiVirtualizationInterfacesCreateRequest
*/
func (a *VirtualizationApiService) VirtualizationInterfacesCreate(ctx context.Context) ApiVirtualizationInterfacesCreateRequest {
	return ApiVirtualizationInterfacesCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return VMInterface
func (a *VirtualizationApiService) VirtualizationInterfacesCreateExecute(r ApiVirtualizationInterfacesCreateRequest) (*VMInterface, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VMInterface
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirtualizationApiService.VirtualizationInterfacesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/virtualization/interfaces/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVirtualizationInterfacesDeleteRequest struct {
	ctx context.Context
	ApiService *VirtualizationApiService
	id int32
}

func (r ApiVirtualizationInterfacesDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.VirtualizationInterfacesDeleteExecute(r)
}

/*
VirtualizationInterfacesDelete Method for VirtualizationInterfacesDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this interface.
 @return ApiVirtualizationInterfacesDeleteRequest
*/
func (a *VirtualizationApiService) VirtualizationInterfacesDelete(ctx context.Context, id int32) ApiVirtualizationInterfacesDeleteRequest {
	return ApiVirtualizationInterfacesDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *VirtualizationApiService) VirtualizationInterfacesDeleteExecute(r ApiVirtualizationInterfacesDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirtualizationApiService.VirtualizationInterfacesDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/virtualization/interfaces/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiVirtualizationInterfacesListRequest struct {
	ctx context.Context
	ApiService *VirtualizationApiService
	id *string
	name *string
	enabled *string
	mtu *string
	created *string
	createdGte *string
	createdLte *string
	lastUpdated *string
	lastUpdatedGte *string
	lastUpdatedLte *string
	q *string
	clusterId *string
	cluster *string
	virtualMachineId *string
	virtualMachine *string
	parentId *string
	macAddress *string
	tag *string
	idN *string
	idLte *string
	idLt *string
	idGte *string
	idGt *string
	nameN *string
	nameIc *string
	nameNic *string
	nameIew *string
	nameNiew *string
	nameIsw *string
	nameNisw *string
	nameIe *string
	nameNie *string
	nameEmpty *string
	mtuN *string
	mtuLte *string
	mtuLt *string
	mtuGte *string
	mtuGt *string
	clusterIdN *string
	clusterN *string
	virtualMachineIdN *string
	virtualMachineN *string
	parentIdN *string
	macAddressN *string
	macAddressIc *string
	macAddressNic *string
	macAddressIew *string
	macAddressNiew *string
	macAddressIsw *string
	macAddressNisw *string
	macAddressIe *string
	macAddressNie *string
	tagN *string
	limit *int32
	offset *int32
}

func (r ApiVirtualizationInterfacesListRequest) Id(id string) ApiVirtualizationInterfacesListRequest {
	r.id = &id
	return r
}

func (r ApiVirtualizationInterfacesListRequest) Name(name string) ApiVirtualizationInterfacesListRequest {
	r.name = &name
	return r
}

func (r ApiVirtualizationInterfacesListRequest) Enabled(enabled string) ApiVirtualizationInterfacesListRequest {
	r.enabled = &enabled
	return r
}

func (r ApiVirtualizationInterfacesListRequest) Mtu(mtu string) ApiVirtualizationInterfacesListRequest {
	r.mtu = &mtu
	return r
}

func (r ApiVirtualizationInterfacesListRequest) Created(created string) ApiVirtualizationInterfacesListRequest {
	r.created = &created
	return r
}

func (r ApiVirtualizationInterfacesListRequest) CreatedGte(createdGte string) ApiVirtualizationInterfacesListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiVirtualizationInterfacesListRequest) CreatedLte(createdLte string) ApiVirtualizationInterfacesListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiVirtualizationInterfacesListRequest) LastUpdated(lastUpdated string) ApiVirtualizationInterfacesListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiVirtualizationInterfacesListRequest) LastUpdatedGte(lastUpdatedGte string) ApiVirtualizationInterfacesListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiVirtualizationInterfacesListRequest) LastUpdatedLte(lastUpdatedLte string) ApiVirtualizationInterfacesListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiVirtualizationInterfacesListRequest) Q(q string) ApiVirtualizationInterfacesListRequest {
	r.q = &q
	return r
}

func (r ApiVirtualizationInterfacesListRequest) ClusterId(clusterId string) ApiVirtualizationInterfacesListRequest {
	r.clusterId = &clusterId
	return r
}

func (r ApiVirtualizationInterfacesListRequest) Cluster(cluster string) ApiVirtualizationInterfacesListRequest {
	r.cluster = &cluster
	return r
}

func (r ApiVirtualizationInterfacesListRequest) VirtualMachineId(virtualMachineId string) ApiVirtualizationInterfacesListRequest {
	r.virtualMachineId = &virtualMachineId
	return r
}

func (r ApiVirtualizationInterfacesListRequest) VirtualMachine(virtualMachine string) ApiVirtualizationInterfacesListRequest {
	r.virtualMachine = &virtualMachine
	return r
}

func (r ApiVirtualizationInterfacesListRequest) ParentId(parentId string) ApiVirtualizationInterfacesListRequest {
	r.parentId = &parentId
	return r
}

func (r ApiVirtualizationInterfacesListRequest) MacAddress(macAddress string) ApiVirtualizationInterfacesListRequest {
	r.macAddress = &macAddress
	return r
}

func (r ApiVirtualizationInterfacesListRequest) Tag(tag string) ApiVirtualizationInterfacesListRequest {
	r.tag = &tag
	return r
}

func (r ApiVirtualizationInterfacesListRequest) IdN(idN string) ApiVirtualizationInterfacesListRequest {
	r.idN = &idN
	return r
}

func (r ApiVirtualizationInterfacesListRequest) IdLte(idLte string) ApiVirtualizationInterfacesListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiVirtualizationInterfacesListRequest) IdLt(idLt string) ApiVirtualizationInterfacesListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiVirtualizationInterfacesListRequest) IdGte(idGte string) ApiVirtualizationInterfacesListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiVirtualizationInterfacesListRequest) IdGt(idGt string) ApiVirtualizationInterfacesListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiVirtualizationInterfacesListRequest) NameN(nameN string) ApiVirtualizationInterfacesListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiVirtualizationInterfacesListRequest) NameIc(nameIc string) ApiVirtualizationInterfacesListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiVirtualizationInterfacesListRequest) NameNic(nameNic string) ApiVirtualizationInterfacesListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiVirtualizationInterfacesListRequest) NameIew(nameIew string) ApiVirtualizationInterfacesListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiVirtualizationInterfacesListRequest) NameNiew(nameNiew string) ApiVirtualizationInterfacesListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiVirtualizationInterfacesListRequest) NameIsw(nameIsw string) ApiVirtualizationInterfacesListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiVirtualizationInterfacesListRequest) NameNisw(nameNisw string) ApiVirtualizationInterfacesListRequest {
	r.nameNisw = &nameNisw
	return r
}

func (r ApiVirtualizationInterfacesListRequest) NameIe(nameIe string) ApiVirtualizationInterfacesListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiVirtualizationInterfacesListRequest) NameNie(nameNie string) ApiVirtualizationInterfacesListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiVirtualizationInterfacesListRequest) NameEmpty(nameEmpty string) ApiVirtualizationInterfacesListRequest {
	r.nameEmpty = &nameEmpty
	return r
}

func (r ApiVirtualizationInterfacesListRequest) MtuN(mtuN string) ApiVirtualizationInterfacesListRequest {
	r.mtuN = &mtuN
	return r
}

func (r ApiVirtualizationInterfacesListRequest) MtuLte(mtuLte string) ApiVirtualizationInterfacesListRequest {
	r.mtuLte = &mtuLte
	return r
}

func (r ApiVirtualizationInterfacesListRequest) MtuLt(mtuLt string) ApiVirtualizationInterfacesListRequest {
	r.mtuLt = &mtuLt
	return r
}

func (r ApiVirtualizationInterfacesListRequest) MtuGte(mtuGte string) ApiVirtualizationInterfacesListRequest {
	r.mtuGte = &mtuGte
	return r
}

func (r ApiVirtualizationInterfacesListRequest) MtuGt(mtuGt string) ApiVirtualizationInterfacesListRequest {
	r.mtuGt = &mtuGt
	return r
}

func (r ApiVirtualizationInterfacesListRequest) ClusterIdN(clusterIdN string) ApiVirtualizationInterfacesListRequest {
	r.clusterIdN = &clusterIdN
	return r
}

func (r ApiVirtualizationInterfacesListRequest) ClusterN(clusterN string) ApiVirtualizationInterfacesListRequest {
	r.clusterN = &clusterN
	return r
}

func (r ApiVirtualizationInterfacesListRequest) VirtualMachineIdN(virtualMachineIdN string) ApiVirtualizationInterfacesListRequest {
	r.virtualMachineIdN = &virtualMachineIdN
	return r
}

func (r ApiVirtualizationInterfacesListRequest) VirtualMachineN(virtualMachineN string) ApiVirtualizationInterfacesListRequest {
	r.virtualMachineN = &virtualMachineN
	return r
}

func (r ApiVirtualizationInterfacesListRequest) ParentIdN(parentIdN string) ApiVirtualizationInterfacesListRequest {
	r.parentIdN = &parentIdN
	return r
}

func (r ApiVirtualizationInterfacesListRequest) MacAddressN(macAddressN string) ApiVirtualizationInterfacesListRequest {
	r.macAddressN = &macAddressN
	return r
}

func (r ApiVirtualizationInterfacesListRequest) MacAddressIc(macAddressIc string) ApiVirtualizationInterfacesListRequest {
	r.macAddressIc = &macAddressIc
	return r
}

func (r ApiVirtualizationInterfacesListRequest) MacAddressNic(macAddressNic string) ApiVirtualizationInterfacesListRequest {
	r.macAddressNic = &macAddressNic
	return r
}

func (r ApiVirtualizationInterfacesListRequest) MacAddressIew(macAddressIew string) ApiVirtualizationInterfacesListRequest {
	r.macAddressIew = &macAddressIew
	return r
}

func (r ApiVirtualizationInterfacesListRequest) MacAddressNiew(macAddressNiew string) ApiVirtualizationInterfacesListRequest {
	r.macAddressNiew = &macAddressNiew
	return r
}

func (r ApiVirtualizationInterfacesListRequest) MacAddressIsw(macAddressIsw string) ApiVirtualizationInterfacesListRequest {
	r.macAddressIsw = &macAddressIsw
	return r
}

func (r ApiVirtualizationInterfacesListRequest) MacAddressNisw(macAddressNisw string) ApiVirtualizationInterfacesListRequest {
	r.macAddressNisw = &macAddressNisw
	return r
}

func (r ApiVirtualizationInterfacesListRequest) MacAddressIe(macAddressIe string) ApiVirtualizationInterfacesListRequest {
	r.macAddressIe = &macAddressIe
	return r
}

func (r ApiVirtualizationInterfacesListRequest) MacAddressNie(macAddressNie string) ApiVirtualizationInterfacesListRequest {
	r.macAddressNie = &macAddressNie
	return r
}

func (r ApiVirtualizationInterfacesListRequest) TagN(tagN string) ApiVirtualizationInterfacesListRequest {
	r.tagN = &tagN
	return r
}

// Number of results to return per page.
func (r ApiVirtualizationInterfacesListRequest) Limit(limit int32) ApiVirtualizationInterfacesListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiVirtualizationInterfacesListRequest) Offset(offset int32) ApiVirtualizationInterfacesListRequest {
	r.offset = &offset
	return r
}

func (r ApiVirtualizationInterfacesListRequest) Execute() (*VirtualizationInterfacesList200Response, *http.Response, error) {
	return r.ApiService.VirtualizationInterfacesListExecute(r)
}

/*
VirtualizationInterfacesList Method for VirtualizationInterfacesList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiVirtualizationInterfacesListRequest
*/
func (a *VirtualizationApiService) VirtualizationInterfacesList(ctx context.Context) ApiVirtualizationInterfacesListRequest {
	return ApiVirtualizationInterfacesListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return VirtualizationInterfacesList200Response
func (a *VirtualizationApiService) VirtualizationInterfacesListExecute(r ApiVirtualizationInterfacesListRequest) (*VirtualizationInterfacesList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VirtualizationInterfacesList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirtualizationApiService.VirtualizationInterfacesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/virtualization/interfaces/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.enabled != nil {
		localVarQueryParams.Add("enabled", parameterToString(*r.enabled, ""))
	}
	if r.mtu != nil {
		localVarQueryParams.Add("mtu", parameterToString(*r.mtu, ""))
	}
	if r.created != nil {
		localVarQueryParams.Add("created", parameterToString(*r.created, ""))
	}
	if r.createdGte != nil {
		localVarQueryParams.Add("created__gte", parameterToString(*r.createdGte, ""))
	}
	if r.createdLte != nil {
		localVarQueryParams.Add("created__lte", parameterToString(*r.createdLte, ""))
	}
	if r.lastUpdated != nil {
		localVarQueryParams.Add("last_updated", parameterToString(*r.lastUpdated, ""))
	}
	if r.lastUpdatedGte != nil {
		localVarQueryParams.Add("last_updated__gte", parameterToString(*r.lastUpdatedGte, ""))
	}
	if r.lastUpdatedLte != nil {
		localVarQueryParams.Add("last_updated__lte", parameterToString(*r.lastUpdatedLte, ""))
	}
	if r.q != nil {
		localVarQueryParams.Add("q", parameterToString(*r.q, ""))
	}
	if r.clusterId != nil {
		localVarQueryParams.Add("cluster_id", parameterToString(*r.clusterId, ""))
	}
	if r.cluster != nil {
		localVarQueryParams.Add("cluster", parameterToString(*r.cluster, ""))
	}
	if r.virtualMachineId != nil {
		localVarQueryParams.Add("virtual_machine_id", parameterToString(*r.virtualMachineId, ""))
	}
	if r.virtualMachine != nil {
		localVarQueryParams.Add("virtual_machine", parameterToString(*r.virtualMachine, ""))
	}
	if r.parentId != nil {
		localVarQueryParams.Add("parent_id", parameterToString(*r.parentId, ""))
	}
	if r.macAddress != nil {
		localVarQueryParams.Add("mac_address", parameterToString(*r.macAddress, ""))
	}
	if r.tag != nil {
		localVarQueryParams.Add("tag", parameterToString(*r.tag, ""))
	}
	if r.idN != nil {
		localVarQueryParams.Add("id__n", parameterToString(*r.idN, ""))
	}
	if r.idLte != nil {
		localVarQueryParams.Add("id__lte", parameterToString(*r.idLte, ""))
	}
	if r.idLt != nil {
		localVarQueryParams.Add("id__lt", parameterToString(*r.idLt, ""))
	}
	if r.idGte != nil {
		localVarQueryParams.Add("id__gte", parameterToString(*r.idGte, ""))
	}
	if r.idGt != nil {
		localVarQueryParams.Add("id__gt", parameterToString(*r.idGt, ""))
	}
	if r.nameN != nil {
		localVarQueryParams.Add("name__n", parameterToString(*r.nameN, ""))
	}
	if r.nameIc != nil {
		localVarQueryParams.Add("name__ic", parameterToString(*r.nameIc, ""))
	}
	if r.nameNic != nil {
		localVarQueryParams.Add("name__nic", parameterToString(*r.nameNic, ""))
	}
	if r.nameIew != nil {
		localVarQueryParams.Add("name__iew", parameterToString(*r.nameIew, ""))
	}
	if r.nameNiew != nil {
		localVarQueryParams.Add("name__niew", parameterToString(*r.nameNiew, ""))
	}
	if r.nameIsw != nil {
		localVarQueryParams.Add("name__isw", parameterToString(*r.nameIsw, ""))
	}
	if r.nameNisw != nil {
		localVarQueryParams.Add("name__nisw", parameterToString(*r.nameNisw, ""))
	}
	if r.nameIe != nil {
		localVarQueryParams.Add("name__ie", parameterToString(*r.nameIe, ""))
	}
	if r.nameNie != nil {
		localVarQueryParams.Add("name__nie", parameterToString(*r.nameNie, ""))
	}
	if r.nameEmpty != nil {
		localVarQueryParams.Add("name__empty", parameterToString(*r.nameEmpty, ""))
	}
	if r.mtuN != nil {
		localVarQueryParams.Add("mtu__n", parameterToString(*r.mtuN, ""))
	}
	if r.mtuLte != nil {
		localVarQueryParams.Add("mtu__lte", parameterToString(*r.mtuLte, ""))
	}
	if r.mtuLt != nil {
		localVarQueryParams.Add("mtu__lt", parameterToString(*r.mtuLt, ""))
	}
	if r.mtuGte != nil {
		localVarQueryParams.Add("mtu__gte", parameterToString(*r.mtuGte, ""))
	}
	if r.mtuGt != nil {
		localVarQueryParams.Add("mtu__gt", parameterToString(*r.mtuGt, ""))
	}
	if r.clusterIdN != nil {
		localVarQueryParams.Add("cluster_id__n", parameterToString(*r.clusterIdN, ""))
	}
	if r.clusterN != nil {
		localVarQueryParams.Add("cluster__n", parameterToString(*r.clusterN, ""))
	}
	if r.virtualMachineIdN != nil {
		localVarQueryParams.Add("virtual_machine_id__n", parameterToString(*r.virtualMachineIdN, ""))
	}
	if r.virtualMachineN != nil {
		localVarQueryParams.Add("virtual_machine__n", parameterToString(*r.virtualMachineN, ""))
	}
	if r.parentIdN != nil {
		localVarQueryParams.Add("parent_id__n", parameterToString(*r.parentIdN, ""))
	}
	if r.macAddressN != nil {
		localVarQueryParams.Add("mac_address__n", parameterToString(*r.macAddressN, ""))
	}
	if r.macAddressIc != nil {
		localVarQueryParams.Add("mac_address__ic", parameterToString(*r.macAddressIc, ""))
	}
	if r.macAddressNic != nil {
		localVarQueryParams.Add("mac_address__nic", parameterToString(*r.macAddressNic, ""))
	}
	if r.macAddressIew != nil {
		localVarQueryParams.Add("mac_address__iew", parameterToString(*r.macAddressIew, ""))
	}
	if r.macAddressNiew != nil {
		localVarQueryParams.Add("mac_address__niew", parameterToString(*r.macAddressNiew, ""))
	}
	if r.macAddressIsw != nil {
		localVarQueryParams.Add("mac_address__isw", parameterToString(*r.macAddressIsw, ""))
	}
	if r.macAddressNisw != nil {
		localVarQueryParams.Add("mac_address__nisw", parameterToString(*r.macAddressNisw, ""))
	}
	if r.macAddressIe != nil {
		localVarQueryParams.Add("mac_address__ie", parameterToString(*r.macAddressIe, ""))
	}
	if r.macAddressNie != nil {
		localVarQueryParams.Add("mac_address__nie", parameterToString(*r.macAddressNie, ""))
	}
	if r.tagN != nil {
		localVarQueryParams.Add("tag__n", parameterToString(*r.tagN, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVirtualizationInterfacesPartialUpdateRequest struct {
	ctx context.Context
	ApiService *VirtualizationApiService
	id int32
	data *WritableVMInterface
}

func (r ApiVirtualizationInterfacesPartialUpdateRequest) Data(data WritableVMInterface) ApiVirtualizationInterfacesPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiVirtualizationInterfacesPartialUpdateRequest) Execute() (*VMInterface, *http.Response, error) {
	return r.ApiService.VirtualizationInterfacesPartialUpdateExecute(r)
}

/*
VirtualizationInterfacesPartialUpdate Method for VirtualizationInterfacesPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this interface.
 @return ApiVirtualizationInterfacesPartialUpdateRequest
*/
func (a *VirtualizationApiService) VirtualizationInterfacesPartialUpdate(ctx context.Context, id int32) ApiVirtualizationInterfacesPartialUpdateRequest {
	return ApiVirtualizationInterfacesPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return VMInterface
func (a *VirtualizationApiService) VirtualizationInterfacesPartialUpdateExecute(r ApiVirtualizationInterfacesPartialUpdateRequest) (*VMInterface, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VMInterface
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirtualizationApiService.VirtualizationInterfacesPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/virtualization/interfaces/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVirtualizationInterfacesReadRequest struct {
	ctx context.Context
	ApiService *VirtualizationApiService
	id int32
}

func (r ApiVirtualizationInterfacesReadRequest) Execute() (*VMInterface, *http.Response, error) {
	return r.ApiService.VirtualizationInterfacesReadExecute(r)
}

/*
VirtualizationInterfacesRead Method for VirtualizationInterfacesRead

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this interface.
 @return ApiVirtualizationInterfacesReadRequest
*/
func (a *VirtualizationApiService) VirtualizationInterfacesRead(ctx context.Context, id int32) ApiVirtualizationInterfacesReadRequest {
	return ApiVirtualizationInterfacesReadRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return VMInterface
func (a *VirtualizationApiService) VirtualizationInterfacesReadExecute(r ApiVirtualizationInterfacesReadRequest) (*VMInterface, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VMInterface
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirtualizationApiService.VirtualizationInterfacesRead")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/virtualization/interfaces/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVirtualizationInterfacesUpdateRequest struct {
	ctx context.Context
	ApiService *VirtualizationApiService
	id int32
	data *WritableVMInterface
}

func (r ApiVirtualizationInterfacesUpdateRequest) Data(data WritableVMInterface) ApiVirtualizationInterfacesUpdateRequest {
	r.data = &data
	return r
}

func (r ApiVirtualizationInterfacesUpdateRequest) Execute() (*VMInterface, *http.Response, error) {
	return r.ApiService.VirtualizationInterfacesUpdateExecute(r)
}

/*
VirtualizationInterfacesUpdate Method for VirtualizationInterfacesUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this interface.
 @return ApiVirtualizationInterfacesUpdateRequest
*/
func (a *VirtualizationApiService) VirtualizationInterfacesUpdate(ctx context.Context, id int32) ApiVirtualizationInterfacesUpdateRequest {
	return ApiVirtualizationInterfacesUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return VMInterface
func (a *VirtualizationApiService) VirtualizationInterfacesUpdateExecute(r ApiVirtualizationInterfacesUpdateRequest) (*VMInterface, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VMInterface
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirtualizationApiService.VirtualizationInterfacesUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/virtualization/interfaces/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVirtualizationVirtualMachinesBulkDeleteRequest struct {
	ctx context.Context
	ApiService *VirtualizationApiService
}

func (r ApiVirtualizationVirtualMachinesBulkDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.VirtualizationVirtualMachinesBulkDeleteExecute(r)
}

/*
VirtualizationVirtualMachinesBulkDelete Method for VirtualizationVirtualMachinesBulkDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiVirtualizationVirtualMachinesBulkDeleteRequest
*/
func (a *VirtualizationApiService) VirtualizationVirtualMachinesBulkDelete(ctx context.Context) ApiVirtualizationVirtualMachinesBulkDeleteRequest {
	return ApiVirtualizationVirtualMachinesBulkDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *VirtualizationApiService) VirtualizationVirtualMachinesBulkDeleteExecute(r ApiVirtualizationVirtualMachinesBulkDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirtualizationApiService.VirtualizationVirtualMachinesBulkDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/virtualization/virtual-machines/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiVirtualizationVirtualMachinesBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *VirtualizationApiService
	data *WritableVirtualMachineWithConfigContext
}

func (r ApiVirtualizationVirtualMachinesBulkPartialUpdateRequest) Data(data WritableVirtualMachineWithConfigContext) ApiVirtualizationVirtualMachinesBulkPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiVirtualizationVirtualMachinesBulkPartialUpdateRequest) Execute() (*VirtualMachineWithConfigContext, *http.Response, error) {
	return r.ApiService.VirtualizationVirtualMachinesBulkPartialUpdateExecute(r)
}

/*
VirtualizationVirtualMachinesBulkPartialUpdate Method for VirtualizationVirtualMachinesBulkPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiVirtualizationVirtualMachinesBulkPartialUpdateRequest
*/
func (a *VirtualizationApiService) VirtualizationVirtualMachinesBulkPartialUpdate(ctx context.Context) ApiVirtualizationVirtualMachinesBulkPartialUpdateRequest {
	return ApiVirtualizationVirtualMachinesBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return VirtualMachineWithConfigContext
func (a *VirtualizationApiService) VirtualizationVirtualMachinesBulkPartialUpdateExecute(r ApiVirtualizationVirtualMachinesBulkPartialUpdateRequest) (*VirtualMachineWithConfigContext, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VirtualMachineWithConfigContext
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirtualizationApiService.VirtualizationVirtualMachinesBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/virtualization/virtual-machines/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVirtualizationVirtualMachinesBulkUpdateRequest struct {
	ctx context.Context
	ApiService *VirtualizationApiService
	data *WritableVirtualMachineWithConfigContext
}

func (r ApiVirtualizationVirtualMachinesBulkUpdateRequest) Data(data WritableVirtualMachineWithConfigContext) ApiVirtualizationVirtualMachinesBulkUpdateRequest {
	r.data = &data
	return r
}

func (r ApiVirtualizationVirtualMachinesBulkUpdateRequest) Execute() (*VirtualMachineWithConfigContext, *http.Response, error) {
	return r.ApiService.VirtualizationVirtualMachinesBulkUpdateExecute(r)
}

/*
VirtualizationVirtualMachinesBulkUpdate Method for VirtualizationVirtualMachinesBulkUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiVirtualizationVirtualMachinesBulkUpdateRequest
*/
func (a *VirtualizationApiService) VirtualizationVirtualMachinesBulkUpdate(ctx context.Context) ApiVirtualizationVirtualMachinesBulkUpdateRequest {
	return ApiVirtualizationVirtualMachinesBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return VirtualMachineWithConfigContext
func (a *VirtualizationApiService) VirtualizationVirtualMachinesBulkUpdateExecute(r ApiVirtualizationVirtualMachinesBulkUpdateRequest) (*VirtualMachineWithConfigContext, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VirtualMachineWithConfigContext
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirtualizationApiService.VirtualizationVirtualMachinesBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/virtualization/virtual-machines/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVirtualizationVirtualMachinesCreateRequest struct {
	ctx context.Context
	ApiService *VirtualizationApiService
	data *WritableVirtualMachineWithConfigContext
}

func (r ApiVirtualizationVirtualMachinesCreateRequest) Data(data WritableVirtualMachineWithConfigContext) ApiVirtualizationVirtualMachinesCreateRequest {
	r.data = &data
	return r
}

func (r ApiVirtualizationVirtualMachinesCreateRequest) Execute() (*VirtualMachineWithConfigContext, *http.Response, error) {
	return r.ApiService.VirtualizationVirtualMachinesCreateExecute(r)
}

/*
VirtualizationVirtualMachinesCreate Method for VirtualizationVirtualMachinesCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiVirtualizationVirtualMachinesCreateRequest
*/
func (a *VirtualizationApiService) VirtualizationVirtualMachinesCreate(ctx context.Context) ApiVirtualizationVirtualMachinesCreateRequest {
	return ApiVirtualizationVirtualMachinesCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return VirtualMachineWithConfigContext
func (a *VirtualizationApiService) VirtualizationVirtualMachinesCreateExecute(r ApiVirtualizationVirtualMachinesCreateRequest) (*VirtualMachineWithConfigContext, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VirtualMachineWithConfigContext
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirtualizationApiService.VirtualizationVirtualMachinesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/virtualization/virtual-machines/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVirtualizationVirtualMachinesDeleteRequest struct {
	ctx context.Context
	ApiService *VirtualizationApiService
	id int32
}

func (r ApiVirtualizationVirtualMachinesDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.VirtualizationVirtualMachinesDeleteExecute(r)
}

/*
VirtualizationVirtualMachinesDelete Method for VirtualizationVirtualMachinesDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this virtual machine.
 @return ApiVirtualizationVirtualMachinesDeleteRequest
*/
func (a *VirtualizationApiService) VirtualizationVirtualMachinesDelete(ctx context.Context, id int32) ApiVirtualizationVirtualMachinesDeleteRequest {
	return ApiVirtualizationVirtualMachinesDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *VirtualizationApiService) VirtualizationVirtualMachinesDeleteExecute(r ApiVirtualizationVirtualMachinesDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirtualizationApiService.VirtualizationVirtualMachinesDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/virtualization/virtual-machines/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiVirtualizationVirtualMachinesListRequest struct {
	ctx context.Context
	ApiService *VirtualizationApiService
	id *string
	name *string
	cluster *string
	vcpus *string
	memory *string
	disk *string
	created *string
	createdGte *string
	createdLte *string
	lastUpdated *string
	lastUpdatedGte *string
	lastUpdatedLte *string
	tenantGroupId *string
	tenantGroup *string
	tenantId *string
	tenant *string
	localContextData *string
	q *string
	status *string
	clusterGroupId *string
	clusterGroup *string
	clusterTypeId *string
	clusterType *string
	clusterId *string
	regionId *string
	region *string
	siteGroupId *string
	siteGroup *string
	siteId *string
	site *string
	roleId *string
	role *string
	platformId *string
	platform *string
	macAddress *string
	hasPrimaryIp *string
	tag *string
	idN *string
	idLte *string
	idLt *string
	idGte *string
	idGt *string
	nameN *string
	nameIc *string
	nameNic *string
	nameIew *string
	nameNiew *string
	nameIsw *string
	nameNisw *string
	nameIe *string
	nameNie *string
	nameEmpty *string
	clusterN *string
	vcpusN *string
	vcpusLte *string
	vcpusLt *string
	vcpusGte *string
	vcpusGt *string
	memoryN *string
	memoryLte *string
	memoryLt *string
	memoryGte *string
	memoryGt *string
	diskN *string
	diskLte *string
	diskLt *string
	diskGte *string
	diskGt *string
	tenantGroupIdN *string
	tenantGroupN *string
	tenantIdN *string
	tenantN *string
	statusN *string
	clusterGroupIdN *string
	clusterGroupN *string
	clusterTypeIdN *string
	clusterTypeN *string
	clusterIdN *string
	regionIdN *string
	regionN *string
	siteGroupIdN *string
	siteGroupN *string
	siteIdN *string
	siteN *string
	roleIdN *string
	roleN *string
	platformIdN *string
	platformN *string
	macAddressN *string
	macAddressIc *string
	macAddressNic *string
	macAddressIew *string
	macAddressNiew *string
	macAddressIsw *string
	macAddressNisw *string
	macAddressIe *string
	macAddressNie *string
	tagN *string
	limit *int32
	offset *int32
}

func (r ApiVirtualizationVirtualMachinesListRequest) Id(id string) ApiVirtualizationVirtualMachinesListRequest {
	r.id = &id
	return r
}

func (r ApiVirtualizationVirtualMachinesListRequest) Name(name string) ApiVirtualizationVirtualMachinesListRequest {
	r.name = &name
	return r
}

func (r ApiVirtualizationVirtualMachinesListRequest) Cluster(cluster string) ApiVirtualizationVirtualMachinesListRequest {
	r.cluster = &cluster
	return r
}

func (r ApiVirtualizationVirtualMachinesListRequest) Vcpus(vcpus string) ApiVirtualizationVirtualMachinesListRequest {
	r.vcpus = &vcpus
	return r
}

func (r ApiVirtualizationVirtualMachinesListRequest) Memory(memory string) ApiVirtualizationVirtualMachinesListRequest {
	r.memory = &memory
	return r
}

func (r ApiVirtualizationVirtualMachinesListRequest) Disk(disk string) ApiVirtualizationVirtualMachinesListRequest {
	r.disk = &disk
	return r
}

func (r ApiVirtualizationVirtualMachinesListRequest) Created(created string) ApiVirtualizationVirtualMachinesListRequest {
	r.created = &created
	return r
}

func (r ApiVirtualizationVirtualMachinesListRequest) CreatedGte(createdGte string) ApiVirtualizationVirtualMachinesListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiVirtualizationVirtualMachinesListRequest) CreatedLte(createdLte string) ApiVirtualizationVirtualMachinesListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiVirtualizationVirtualMachinesListRequest) LastUpdated(lastUpdated string) ApiVirtualizationVirtualMachinesListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiVirtualizationVirtualMachinesListRequest) LastUpdatedGte(lastUpdatedGte string) ApiVirtualizationVirtualMachinesListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiVirtualizationVirtualMachinesListRequest) LastUpdatedLte(lastUpdatedLte string) ApiVirtualizationVirtualMachinesListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiVirtualizationVirtualMachinesListRequest) TenantGroupId(tenantGroupId string) ApiVirtualizationVirtualMachinesListRequest {
	r.tenantGroupId = &tenantGroupId
	return r
}

func (r ApiVirtualizationVirtualMachinesListRequest) TenantGroup(tenantGroup string) ApiVirtualizationVirtualMachinesListRequest {
	r.tenantGroup = &tenantGroup
	return r
}

func (r ApiVirtualizationVirtualMachinesListRequest) TenantId(tenantId string) ApiVirtualizationVirtualMachinesListRequest {
	r.tenantId = &tenantId
	return r
}

func (r ApiVirtualizationVirtualMachinesListRequest) Tenant(tenant string) ApiVirtualizationVirtualMachinesListRequest {
	r.tenant = &tenant
	return r
}

func (r ApiVirtualizationVirtualMachinesListRequest) LocalContextData(localContextData string) ApiVirtualizationVirtualMachinesListRequest {
	r.localContextData = &localContextData
	return r
}

func (r ApiVirtualizationVirtualMachinesListRequest) Q(q string) ApiVirtualizationVirtualMachinesListRequest {
	r.q = &q
	return r
}

func (r ApiVirtualizationVirtualMachinesListRequest) Status(status string) ApiVirtualizationVirtualMachinesListRequest {
	r.status = &status
	return r
}

func (r ApiVirtualizationVirtualMachinesListRequest) ClusterGroupId(clusterGroupId string) ApiVirtualizationVirtualMachinesListRequest {
	r.clusterGroupId = &clusterGroupId
	return r
}

func (r ApiVirtualizationVirtualMachinesListRequest) ClusterGroup(clusterGroup string) ApiVirtualizationVirtualMachinesListRequest {
	r.clusterGroup = &clusterGroup
	return r
}

func (r ApiVirtualizationVirtualMachinesListRequest) ClusterTypeId(clusterTypeId string) ApiVirtualizationVirtualMachinesListRequest {
	r.clusterTypeId = &clusterTypeId
	return r
}

func (r ApiVirtualizationVirtualMachinesListRequest) ClusterType(clusterType string) ApiVirtualizationVirtualMachinesListRequest {
	r.clusterType = &clusterType
	return r
}

func (r ApiVirtualizationVirtualMachinesListRequest) ClusterId(clusterId string) ApiVirtualizationVirtualMachinesListRequest {
	r.clusterId = &clusterId
	return r
}

func (r ApiVirtualizationVirtualMachinesListRequest) RegionId(regionId string) ApiVirtualizationVirtualMachinesListRequest {
	r.regionId = &regionId
	return r
}

func (r ApiVirtualizationVirtualMachinesListRequest) Region(region string) ApiVirtualizationVirtualMachinesListRequest {
	r.region = &region
	return r
}

func (r ApiVirtualizationVirtualMachinesListRequest) SiteGroupId(siteGroupId string) ApiVirtualizationVirtualMachinesListRequest {
	r.siteGroupId = &siteGroupId
	return r
}

func (r ApiVirtualizationVirtualMachinesListRequest) SiteGroup(siteGroup string) ApiVirtualizationVirtualMachinesListRequest {
	r.siteGroup = &siteGroup
	return r
}

func (r ApiVirtualizationVirtualMachinesListRequest) SiteId(siteId string) ApiVirtualizationVirtualMachinesListRequest {
	r.siteId = &siteId
	return r
}

func (r ApiVirtualizationVirtualMachinesListRequest) Site(site string) ApiVirtualizationVirtualMachinesListRequest {
	r.site = &site
	return r
}

func (r ApiVirtualizationVirtualMachinesListRequest) RoleId(roleId string) ApiVirtualizationVirtualMachinesListRequest {
	r.roleId = &roleId
	return r
}

func (r ApiVirtualizationVirtualMachinesListRequest) Role(role string) ApiVirtualizationVirtualMachinesListRequest {
	r.role = &role
	return r
}

func (r ApiVirtualizationVirtualMachinesListRequest) PlatformId(platformId string) ApiVirtualizationVirtualMachinesListRequest {
	r.platformId = &platformId
	return r
}

func (r ApiVirtualizationVirtualMachinesListRequest) Platform(platform string) ApiVirtualizationVirtualMachinesListRequest {
	r.platform = &platform
	return r
}

func (r ApiVirtualizationVirtualMachinesListRequest) MacAddress(macAddress string) ApiVirtualizationVirtualMachinesListRequest {
	r.macAddress = &macAddress
	return r
}

func (r ApiVirtualizationVirtualMachinesListRequest) HasPrimaryIp(hasPrimaryIp string) ApiVirtualizationVirtualMachinesListRequest {
	r.hasPrimaryIp = &hasPrimaryIp
	return r
}

func (r ApiVirtualizationVirtualMachinesListRequest) Tag(tag string) ApiVirtualizationVirtualMachinesListRequest {
	r.tag = &tag
	return r
}

func (r ApiVirtualizationVirtualMachinesListRequest) IdN(idN string) ApiVirtualizationVirtualMachinesListRequest {
	r.idN = &idN
	return r
}

func (r ApiVirtualizationVirtualMachinesListRequest) IdLte(idLte string) ApiVirtualizationVirtualMachinesListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiVirtualizationVirtualMachinesListRequest) IdLt(idLt string) ApiVirtualizationVirtualMachinesListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiVirtualizationVirtualMachinesListRequest) IdGte(idGte string) ApiVirtualizationVirtualMachinesListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiVirtualizationVirtualMachinesListRequest) IdGt(idGt string) ApiVirtualizationVirtualMachinesListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiVirtualizationVirtualMachinesListRequest) NameN(nameN string) ApiVirtualizationVirtualMachinesListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiVirtualizationVirtualMachinesListRequest) NameIc(nameIc string) ApiVirtualizationVirtualMachinesListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiVirtualizationVirtualMachinesListRequest) NameNic(nameNic string) ApiVirtualizationVirtualMachinesListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiVirtualizationVirtualMachinesListRequest) NameIew(nameIew string) ApiVirtualizationVirtualMachinesListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiVirtualizationVirtualMachinesListRequest) NameNiew(nameNiew string) ApiVirtualizationVirtualMachinesListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiVirtualizationVirtualMachinesListRequest) NameIsw(nameIsw string) ApiVirtualizationVirtualMachinesListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiVirtualizationVirtualMachinesListRequest) NameNisw(nameNisw string) ApiVirtualizationVirtualMachinesListRequest {
	r.nameNisw = &nameNisw
	return r
}

func (r ApiVirtualizationVirtualMachinesListRequest) NameIe(nameIe string) ApiVirtualizationVirtualMachinesListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiVirtualizationVirtualMachinesListRequest) NameNie(nameNie string) ApiVirtualizationVirtualMachinesListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiVirtualizationVirtualMachinesListRequest) NameEmpty(nameEmpty string) ApiVirtualizationVirtualMachinesListRequest {
	r.nameEmpty = &nameEmpty
	return r
}

func (r ApiVirtualizationVirtualMachinesListRequest) ClusterN(clusterN string) ApiVirtualizationVirtualMachinesListRequest {
	r.clusterN = &clusterN
	return r
}

func (r ApiVirtualizationVirtualMachinesListRequest) VcpusN(vcpusN string) ApiVirtualizationVirtualMachinesListRequest {
	r.vcpusN = &vcpusN
	return r
}

func (r ApiVirtualizationVirtualMachinesListRequest) VcpusLte(vcpusLte string) ApiVirtualizationVirtualMachinesListRequest {
	r.vcpusLte = &vcpusLte
	return r
}

func (r ApiVirtualizationVirtualMachinesListRequest) VcpusLt(vcpusLt string) ApiVirtualizationVirtualMachinesListRequest {
	r.vcpusLt = &vcpusLt
	return r
}

func (r ApiVirtualizationVirtualMachinesListRequest) VcpusGte(vcpusGte string) ApiVirtualizationVirtualMachinesListRequest {
	r.vcpusGte = &vcpusGte
	return r
}

func (r ApiVirtualizationVirtualMachinesListRequest) VcpusGt(vcpusGt string) ApiVirtualizationVirtualMachinesListRequest {
	r.vcpusGt = &vcpusGt
	return r
}

func (r ApiVirtualizationVirtualMachinesListRequest) MemoryN(memoryN string) ApiVirtualizationVirtualMachinesListRequest {
	r.memoryN = &memoryN
	return r
}

func (r ApiVirtualizationVirtualMachinesListRequest) MemoryLte(memoryLte string) ApiVirtualizationVirtualMachinesListRequest {
	r.memoryLte = &memoryLte
	return r
}

func (r ApiVirtualizationVirtualMachinesListRequest) MemoryLt(memoryLt string) ApiVirtualizationVirtualMachinesListRequest {
	r.memoryLt = &memoryLt
	return r
}

func (r ApiVirtualizationVirtualMachinesListRequest) MemoryGte(memoryGte string) ApiVirtualizationVirtualMachinesListRequest {
	r.memoryGte = &memoryGte
	return r
}

func (r ApiVirtualizationVirtualMachinesListRequest) MemoryGt(memoryGt string) ApiVirtualizationVirtualMachinesListRequest {
	r.memoryGt = &memoryGt
	return r
}

func (r ApiVirtualizationVirtualMachinesListRequest) DiskN(diskN string) ApiVirtualizationVirtualMachinesListRequest {
	r.diskN = &diskN
	return r
}

func (r ApiVirtualizationVirtualMachinesListRequest) DiskLte(diskLte string) ApiVirtualizationVirtualMachinesListRequest {
	r.diskLte = &diskLte
	return r
}

func (r ApiVirtualizationVirtualMachinesListRequest) DiskLt(diskLt string) ApiVirtualizationVirtualMachinesListRequest {
	r.diskLt = &diskLt
	return r
}

func (r ApiVirtualizationVirtualMachinesListRequest) DiskGte(diskGte string) ApiVirtualizationVirtualMachinesListRequest {
	r.diskGte = &diskGte
	return r
}

func (r ApiVirtualizationVirtualMachinesListRequest) DiskGt(diskGt string) ApiVirtualizationVirtualMachinesListRequest {
	r.diskGt = &diskGt
	return r
}

func (r ApiVirtualizationVirtualMachinesListRequest) TenantGroupIdN(tenantGroupIdN string) ApiVirtualizationVirtualMachinesListRequest {
	r.tenantGroupIdN = &tenantGroupIdN
	return r
}

func (r ApiVirtualizationVirtualMachinesListRequest) TenantGroupN(tenantGroupN string) ApiVirtualizationVirtualMachinesListRequest {
	r.tenantGroupN = &tenantGroupN
	return r
}

func (r ApiVirtualizationVirtualMachinesListRequest) TenantIdN(tenantIdN string) ApiVirtualizationVirtualMachinesListRequest {
	r.tenantIdN = &tenantIdN
	return r
}

func (r ApiVirtualizationVirtualMachinesListRequest) TenantN(tenantN string) ApiVirtualizationVirtualMachinesListRequest {
	r.tenantN = &tenantN
	return r
}

func (r ApiVirtualizationVirtualMachinesListRequest) StatusN(statusN string) ApiVirtualizationVirtualMachinesListRequest {
	r.statusN = &statusN
	return r
}

func (r ApiVirtualizationVirtualMachinesListRequest) ClusterGroupIdN(clusterGroupIdN string) ApiVirtualizationVirtualMachinesListRequest {
	r.clusterGroupIdN = &clusterGroupIdN
	return r
}

func (r ApiVirtualizationVirtualMachinesListRequest) ClusterGroupN(clusterGroupN string) ApiVirtualizationVirtualMachinesListRequest {
	r.clusterGroupN = &clusterGroupN
	return r
}

func (r ApiVirtualizationVirtualMachinesListRequest) ClusterTypeIdN(clusterTypeIdN string) ApiVirtualizationVirtualMachinesListRequest {
	r.clusterTypeIdN = &clusterTypeIdN
	return r
}

func (r ApiVirtualizationVirtualMachinesListRequest) ClusterTypeN(clusterTypeN string) ApiVirtualizationVirtualMachinesListRequest {
	r.clusterTypeN = &clusterTypeN
	return r
}

func (r ApiVirtualizationVirtualMachinesListRequest) ClusterIdN(clusterIdN string) ApiVirtualizationVirtualMachinesListRequest {
	r.clusterIdN = &clusterIdN
	return r
}

func (r ApiVirtualizationVirtualMachinesListRequest) RegionIdN(regionIdN string) ApiVirtualizationVirtualMachinesListRequest {
	r.regionIdN = &regionIdN
	return r
}

func (r ApiVirtualizationVirtualMachinesListRequest) RegionN(regionN string) ApiVirtualizationVirtualMachinesListRequest {
	r.regionN = &regionN
	return r
}

func (r ApiVirtualizationVirtualMachinesListRequest) SiteGroupIdN(siteGroupIdN string) ApiVirtualizationVirtualMachinesListRequest {
	r.siteGroupIdN = &siteGroupIdN
	return r
}

func (r ApiVirtualizationVirtualMachinesListRequest) SiteGroupN(siteGroupN string) ApiVirtualizationVirtualMachinesListRequest {
	r.siteGroupN = &siteGroupN
	return r
}

func (r ApiVirtualizationVirtualMachinesListRequest) SiteIdN(siteIdN string) ApiVirtualizationVirtualMachinesListRequest {
	r.siteIdN = &siteIdN
	return r
}

func (r ApiVirtualizationVirtualMachinesListRequest) SiteN(siteN string) ApiVirtualizationVirtualMachinesListRequest {
	r.siteN = &siteN
	return r
}

func (r ApiVirtualizationVirtualMachinesListRequest) RoleIdN(roleIdN string) ApiVirtualizationVirtualMachinesListRequest {
	r.roleIdN = &roleIdN
	return r
}

func (r ApiVirtualizationVirtualMachinesListRequest) RoleN(roleN string) ApiVirtualizationVirtualMachinesListRequest {
	r.roleN = &roleN
	return r
}

func (r ApiVirtualizationVirtualMachinesListRequest) PlatformIdN(platformIdN string) ApiVirtualizationVirtualMachinesListRequest {
	r.platformIdN = &platformIdN
	return r
}

func (r ApiVirtualizationVirtualMachinesListRequest) PlatformN(platformN string) ApiVirtualizationVirtualMachinesListRequest {
	r.platformN = &platformN
	return r
}

func (r ApiVirtualizationVirtualMachinesListRequest) MacAddressN(macAddressN string) ApiVirtualizationVirtualMachinesListRequest {
	r.macAddressN = &macAddressN
	return r
}

func (r ApiVirtualizationVirtualMachinesListRequest) MacAddressIc(macAddressIc string) ApiVirtualizationVirtualMachinesListRequest {
	r.macAddressIc = &macAddressIc
	return r
}

func (r ApiVirtualizationVirtualMachinesListRequest) MacAddressNic(macAddressNic string) ApiVirtualizationVirtualMachinesListRequest {
	r.macAddressNic = &macAddressNic
	return r
}

func (r ApiVirtualizationVirtualMachinesListRequest) MacAddressIew(macAddressIew string) ApiVirtualizationVirtualMachinesListRequest {
	r.macAddressIew = &macAddressIew
	return r
}

func (r ApiVirtualizationVirtualMachinesListRequest) MacAddressNiew(macAddressNiew string) ApiVirtualizationVirtualMachinesListRequest {
	r.macAddressNiew = &macAddressNiew
	return r
}

func (r ApiVirtualizationVirtualMachinesListRequest) MacAddressIsw(macAddressIsw string) ApiVirtualizationVirtualMachinesListRequest {
	r.macAddressIsw = &macAddressIsw
	return r
}

func (r ApiVirtualizationVirtualMachinesListRequest) MacAddressNisw(macAddressNisw string) ApiVirtualizationVirtualMachinesListRequest {
	r.macAddressNisw = &macAddressNisw
	return r
}

func (r ApiVirtualizationVirtualMachinesListRequest) MacAddressIe(macAddressIe string) ApiVirtualizationVirtualMachinesListRequest {
	r.macAddressIe = &macAddressIe
	return r
}

func (r ApiVirtualizationVirtualMachinesListRequest) MacAddressNie(macAddressNie string) ApiVirtualizationVirtualMachinesListRequest {
	r.macAddressNie = &macAddressNie
	return r
}

func (r ApiVirtualizationVirtualMachinesListRequest) TagN(tagN string) ApiVirtualizationVirtualMachinesListRequest {
	r.tagN = &tagN
	return r
}

// Number of results to return per page.
func (r ApiVirtualizationVirtualMachinesListRequest) Limit(limit int32) ApiVirtualizationVirtualMachinesListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiVirtualizationVirtualMachinesListRequest) Offset(offset int32) ApiVirtualizationVirtualMachinesListRequest {
	r.offset = &offset
	return r
}

func (r ApiVirtualizationVirtualMachinesListRequest) Execute() (*VirtualizationVirtualMachinesList200Response, *http.Response, error) {
	return r.ApiService.VirtualizationVirtualMachinesListExecute(r)
}

/*
VirtualizationVirtualMachinesList Method for VirtualizationVirtualMachinesList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiVirtualizationVirtualMachinesListRequest
*/
func (a *VirtualizationApiService) VirtualizationVirtualMachinesList(ctx context.Context) ApiVirtualizationVirtualMachinesListRequest {
	return ApiVirtualizationVirtualMachinesListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return VirtualizationVirtualMachinesList200Response
func (a *VirtualizationApiService) VirtualizationVirtualMachinesListExecute(r ApiVirtualizationVirtualMachinesListRequest) (*VirtualizationVirtualMachinesList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VirtualizationVirtualMachinesList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirtualizationApiService.VirtualizationVirtualMachinesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/virtualization/virtual-machines/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.cluster != nil {
		localVarQueryParams.Add("cluster", parameterToString(*r.cluster, ""))
	}
	if r.vcpus != nil {
		localVarQueryParams.Add("vcpus", parameterToString(*r.vcpus, ""))
	}
	if r.memory != nil {
		localVarQueryParams.Add("memory", parameterToString(*r.memory, ""))
	}
	if r.disk != nil {
		localVarQueryParams.Add("disk", parameterToString(*r.disk, ""))
	}
	if r.created != nil {
		localVarQueryParams.Add("created", parameterToString(*r.created, ""))
	}
	if r.createdGte != nil {
		localVarQueryParams.Add("created__gte", parameterToString(*r.createdGte, ""))
	}
	if r.createdLte != nil {
		localVarQueryParams.Add("created__lte", parameterToString(*r.createdLte, ""))
	}
	if r.lastUpdated != nil {
		localVarQueryParams.Add("last_updated", parameterToString(*r.lastUpdated, ""))
	}
	if r.lastUpdatedGte != nil {
		localVarQueryParams.Add("last_updated__gte", parameterToString(*r.lastUpdatedGte, ""))
	}
	if r.lastUpdatedLte != nil {
		localVarQueryParams.Add("last_updated__lte", parameterToString(*r.lastUpdatedLte, ""))
	}
	if r.tenantGroupId != nil {
		localVarQueryParams.Add("tenant_group_id", parameterToString(*r.tenantGroupId, ""))
	}
	if r.tenantGroup != nil {
		localVarQueryParams.Add("tenant_group", parameterToString(*r.tenantGroup, ""))
	}
	if r.tenantId != nil {
		localVarQueryParams.Add("tenant_id", parameterToString(*r.tenantId, ""))
	}
	if r.tenant != nil {
		localVarQueryParams.Add("tenant", parameterToString(*r.tenant, ""))
	}
	if r.localContextData != nil {
		localVarQueryParams.Add("local_context_data", parameterToString(*r.localContextData, ""))
	}
	if r.q != nil {
		localVarQueryParams.Add("q", parameterToString(*r.q, ""))
	}
	if r.status != nil {
		localVarQueryParams.Add("status", parameterToString(*r.status, ""))
	}
	if r.clusterGroupId != nil {
		localVarQueryParams.Add("cluster_group_id", parameterToString(*r.clusterGroupId, ""))
	}
	if r.clusterGroup != nil {
		localVarQueryParams.Add("cluster_group", parameterToString(*r.clusterGroup, ""))
	}
	if r.clusterTypeId != nil {
		localVarQueryParams.Add("cluster_type_id", parameterToString(*r.clusterTypeId, ""))
	}
	if r.clusterType != nil {
		localVarQueryParams.Add("cluster_type", parameterToString(*r.clusterType, ""))
	}
	if r.clusterId != nil {
		localVarQueryParams.Add("cluster_id", parameterToString(*r.clusterId, ""))
	}
	if r.regionId != nil {
		localVarQueryParams.Add("region_id", parameterToString(*r.regionId, ""))
	}
	if r.region != nil {
		localVarQueryParams.Add("region", parameterToString(*r.region, ""))
	}
	if r.siteGroupId != nil {
		localVarQueryParams.Add("site_group_id", parameterToString(*r.siteGroupId, ""))
	}
	if r.siteGroup != nil {
		localVarQueryParams.Add("site_group", parameterToString(*r.siteGroup, ""))
	}
	if r.siteId != nil {
		localVarQueryParams.Add("site_id", parameterToString(*r.siteId, ""))
	}
	if r.site != nil {
		localVarQueryParams.Add("site", parameterToString(*r.site, ""))
	}
	if r.roleId != nil {
		localVarQueryParams.Add("role_id", parameterToString(*r.roleId, ""))
	}
	if r.role != nil {
		localVarQueryParams.Add("role", parameterToString(*r.role, ""))
	}
	if r.platformId != nil {
		localVarQueryParams.Add("platform_id", parameterToString(*r.platformId, ""))
	}
	if r.platform != nil {
		localVarQueryParams.Add("platform", parameterToString(*r.platform, ""))
	}
	if r.macAddress != nil {
		localVarQueryParams.Add("mac_address", parameterToString(*r.macAddress, ""))
	}
	if r.hasPrimaryIp != nil {
		localVarQueryParams.Add("has_primary_ip", parameterToString(*r.hasPrimaryIp, ""))
	}
	if r.tag != nil {
		localVarQueryParams.Add("tag", parameterToString(*r.tag, ""))
	}
	if r.idN != nil {
		localVarQueryParams.Add("id__n", parameterToString(*r.idN, ""))
	}
	if r.idLte != nil {
		localVarQueryParams.Add("id__lte", parameterToString(*r.idLte, ""))
	}
	if r.idLt != nil {
		localVarQueryParams.Add("id__lt", parameterToString(*r.idLt, ""))
	}
	if r.idGte != nil {
		localVarQueryParams.Add("id__gte", parameterToString(*r.idGte, ""))
	}
	if r.idGt != nil {
		localVarQueryParams.Add("id__gt", parameterToString(*r.idGt, ""))
	}
	if r.nameN != nil {
		localVarQueryParams.Add("name__n", parameterToString(*r.nameN, ""))
	}
	if r.nameIc != nil {
		localVarQueryParams.Add("name__ic", parameterToString(*r.nameIc, ""))
	}
	if r.nameNic != nil {
		localVarQueryParams.Add("name__nic", parameterToString(*r.nameNic, ""))
	}
	if r.nameIew != nil {
		localVarQueryParams.Add("name__iew", parameterToString(*r.nameIew, ""))
	}
	if r.nameNiew != nil {
		localVarQueryParams.Add("name__niew", parameterToString(*r.nameNiew, ""))
	}
	if r.nameIsw != nil {
		localVarQueryParams.Add("name__isw", parameterToString(*r.nameIsw, ""))
	}
	if r.nameNisw != nil {
		localVarQueryParams.Add("name__nisw", parameterToString(*r.nameNisw, ""))
	}
	if r.nameIe != nil {
		localVarQueryParams.Add("name__ie", parameterToString(*r.nameIe, ""))
	}
	if r.nameNie != nil {
		localVarQueryParams.Add("name__nie", parameterToString(*r.nameNie, ""))
	}
	if r.nameEmpty != nil {
		localVarQueryParams.Add("name__empty", parameterToString(*r.nameEmpty, ""))
	}
	if r.clusterN != nil {
		localVarQueryParams.Add("cluster__n", parameterToString(*r.clusterN, ""))
	}
	if r.vcpusN != nil {
		localVarQueryParams.Add("vcpus__n", parameterToString(*r.vcpusN, ""))
	}
	if r.vcpusLte != nil {
		localVarQueryParams.Add("vcpus__lte", parameterToString(*r.vcpusLte, ""))
	}
	if r.vcpusLt != nil {
		localVarQueryParams.Add("vcpus__lt", parameterToString(*r.vcpusLt, ""))
	}
	if r.vcpusGte != nil {
		localVarQueryParams.Add("vcpus__gte", parameterToString(*r.vcpusGte, ""))
	}
	if r.vcpusGt != nil {
		localVarQueryParams.Add("vcpus__gt", parameterToString(*r.vcpusGt, ""))
	}
	if r.memoryN != nil {
		localVarQueryParams.Add("memory__n", parameterToString(*r.memoryN, ""))
	}
	if r.memoryLte != nil {
		localVarQueryParams.Add("memory__lte", parameterToString(*r.memoryLte, ""))
	}
	if r.memoryLt != nil {
		localVarQueryParams.Add("memory__lt", parameterToString(*r.memoryLt, ""))
	}
	if r.memoryGte != nil {
		localVarQueryParams.Add("memory__gte", parameterToString(*r.memoryGte, ""))
	}
	if r.memoryGt != nil {
		localVarQueryParams.Add("memory__gt", parameterToString(*r.memoryGt, ""))
	}
	if r.diskN != nil {
		localVarQueryParams.Add("disk__n", parameterToString(*r.diskN, ""))
	}
	if r.diskLte != nil {
		localVarQueryParams.Add("disk__lte", parameterToString(*r.diskLte, ""))
	}
	if r.diskLt != nil {
		localVarQueryParams.Add("disk__lt", parameterToString(*r.diskLt, ""))
	}
	if r.diskGte != nil {
		localVarQueryParams.Add("disk__gte", parameterToString(*r.diskGte, ""))
	}
	if r.diskGt != nil {
		localVarQueryParams.Add("disk__gt", parameterToString(*r.diskGt, ""))
	}
	if r.tenantGroupIdN != nil {
		localVarQueryParams.Add("tenant_group_id__n", parameterToString(*r.tenantGroupIdN, ""))
	}
	if r.tenantGroupN != nil {
		localVarQueryParams.Add("tenant_group__n", parameterToString(*r.tenantGroupN, ""))
	}
	if r.tenantIdN != nil {
		localVarQueryParams.Add("tenant_id__n", parameterToString(*r.tenantIdN, ""))
	}
	if r.tenantN != nil {
		localVarQueryParams.Add("tenant__n", parameterToString(*r.tenantN, ""))
	}
	if r.statusN != nil {
		localVarQueryParams.Add("status__n", parameterToString(*r.statusN, ""))
	}
	if r.clusterGroupIdN != nil {
		localVarQueryParams.Add("cluster_group_id__n", parameterToString(*r.clusterGroupIdN, ""))
	}
	if r.clusterGroupN != nil {
		localVarQueryParams.Add("cluster_group__n", parameterToString(*r.clusterGroupN, ""))
	}
	if r.clusterTypeIdN != nil {
		localVarQueryParams.Add("cluster_type_id__n", parameterToString(*r.clusterTypeIdN, ""))
	}
	if r.clusterTypeN != nil {
		localVarQueryParams.Add("cluster_type__n", parameterToString(*r.clusterTypeN, ""))
	}
	if r.clusterIdN != nil {
		localVarQueryParams.Add("cluster_id__n", parameterToString(*r.clusterIdN, ""))
	}
	if r.regionIdN != nil {
		localVarQueryParams.Add("region_id__n", parameterToString(*r.regionIdN, ""))
	}
	if r.regionN != nil {
		localVarQueryParams.Add("region__n", parameterToString(*r.regionN, ""))
	}
	if r.siteGroupIdN != nil {
		localVarQueryParams.Add("site_group_id__n", parameterToString(*r.siteGroupIdN, ""))
	}
	if r.siteGroupN != nil {
		localVarQueryParams.Add("site_group__n", parameterToString(*r.siteGroupN, ""))
	}
	if r.siteIdN != nil {
		localVarQueryParams.Add("site_id__n", parameterToString(*r.siteIdN, ""))
	}
	if r.siteN != nil {
		localVarQueryParams.Add("site__n", parameterToString(*r.siteN, ""))
	}
	if r.roleIdN != nil {
		localVarQueryParams.Add("role_id__n", parameterToString(*r.roleIdN, ""))
	}
	if r.roleN != nil {
		localVarQueryParams.Add("role__n", parameterToString(*r.roleN, ""))
	}
	if r.platformIdN != nil {
		localVarQueryParams.Add("platform_id__n", parameterToString(*r.platformIdN, ""))
	}
	if r.platformN != nil {
		localVarQueryParams.Add("platform__n", parameterToString(*r.platformN, ""))
	}
	if r.macAddressN != nil {
		localVarQueryParams.Add("mac_address__n", parameterToString(*r.macAddressN, ""))
	}
	if r.macAddressIc != nil {
		localVarQueryParams.Add("mac_address__ic", parameterToString(*r.macAddressIc, ""))
	}
	if r.macAddressNic != nil {
		localVarQueryParams.Add("mac_address__nic", parameterToString(*r.macAddressNic, ""))
	}
	if r.macAddressIew != nil {
		localVarQueryParams.Add("mac_address__iew", parameterToString(*r.macAddressIew, ""))
	}
	if r.macAddressNiew != nil {
		localVarQueryParams.Add("mac_address__niew", parameterToString(*r.macAddressNiew, ""))
	}
	if r.macAddressIsw != nil {
		localVarQueryParams.Add("mac_address__isw", parameterToString(*r.macAddressIsw, ""))
	}
	if r.macAddressNisw != nil {
		localVarQueryParams.Add("mac_address__nisw", parameterToString(*r.macAddressNisw, ""))
	}
	if r.macAddressIe != nil {
		localVarQueryParams.Add("mac_address__ie", parameterToString(*r.macAddressIe, ""))
	}
	if r.macAddressNie != nil {
		localVarQueryParams.Add("mac_address__nie", parameterToString(*r.macAddressNie, ""))
	}
	if r.tagN != nil {
		localVarQueryParams.Add("tag__n", parameterToString(*r.tagN, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVirtualizationVirtualMachinesPartialUpdateRequest struct {
	ctx context.Context
	ApiService *VirtualizationApiService
	id int32
	data *WritableVirtualMachineWithConfigContext
}

func (r ApiVirtualizationVirtualMachinesPartialUpdateRequest) Data(data WritableVirtualMachineWithConfigContext) ApiVirtualizationVirtualMachinesPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiVirtualizationVirtualMachinesPartialUpdateRequest) Execute() (*VirtualMachineWithConfigContext, *http.Response, error) {
	return r.ApiService.VirtualizationVirtualMachinesPartialUpdateExecute(r)
}

/*
VirtualizationVirtualMachinesPartialUpdate Method for VirtualizationVirtualMachinesPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this virtual machine.
 @return ApiVirtualizationVirtualMachinesPartialUpdateRequest
*/
func (a *VirtualizationApiService) VirtualizationVirtualMachinesPartialUpdate(ctx context.Context, id int32) ApiVirtualizationVirtualMachinesPartialUpdateRequest {
	return ApiVirtualizationVirtualMachinesPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return VirtualMachineWithConfigContext
func (a *VirtualizationApiService) VirtualizationVirtualMachinesPartialUpdateExecute(r ApiVirtualizationVirtualMachinesPartialUpdateRequest) (*VirtualMachineWithConfigContext, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VirtualMachineWithConfigContext
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirtualizationApiService.VirtualizationVirtualMachinesPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/virtualization/virtual-machines/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVirtualizationVirtualMachinesReadRequest struct {
	ctx context.Context
	ApiService *VirtualizationApiService
	id int32
}

func (r ApiVirtualizationVirtualMachinesReadRequest) Execute() (*VirtualMachineWithConfigContext, *http.Response, error) {
	return r.ApiService.VirtualizationVirtualMachinesReadExecute(r)
}

/*
VirtualizationVirtualMachinesRead Method for VirtualizationVirtualMachinesRead

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this virtual machine.
 @return ApiVirtualizationVirtualMachinesReadRequest
*/
func (a *VirtualizationApiService) VirtualizationVirtualMachinesRead(ctx context.Context, id int32) ApiVirtualizationVirtualMachinesReadRequest {
	return ApiVirtualizationVirtualMachinesReadRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return VirtualMachineWithConfigContext
func (a *VirtualizationApiService) VirtualizationVirtualMachinesReadExecute(r ApiVirtualizationVirtualMachinesReadRequest) (*VirtualMachineWithConfigContext, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VirtualMachineWithConfigContext
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirtualizationApiService.VirtualizationVirtualMachinesRead")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/virtualization/virtual-machines/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVirtualizationVirtualMachinesUpdateRequest struct {
	ctx context.Context
	ApiService *VirtualizationApiService
	id int32
	data *WritableVirtualMachineWithConfigContext
}

func (r ApiVirtualizationVirtualMachinesUpdateRequest) Data(data WritableVirtualMachineWithConfigContext) ApiVirtualizationVirtualMachinesUpdateRequest {
	r.data = &data
	return r
}

func (r ApiVirtualizationVirtualMachinesUpdateRequest) Execute() (*VirtualMachineWithConfigContext, *http.Response, error) {
	return r.ApiService.VirtualizationVirtualMachinesUpdateExecute(r)
}

/*
VirtualizationVirtualMachinesUpdate Method for VirtualizationVirtualMachinesUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this virtual machine.
 @return ApiVirtualizationVirtualMachinesUpdateRequest
*/
func (a *VirtualizationApiService) VirtualizationVirtualMachinesUpdate(ctx context.Context, id int32) ApiVirtualizationVirtualMachinesUpdateRequest {
	return ApiVirtualizationVirtualMachinesUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return VirtualMachineWithConfigContext
func (a *VirtualizationApiService) VirtualizationVirtualMachinesUpdateExecute(r ApiVirtualizationVirtualMachinesUpdateRequest) (*VirtualMachineWithConfigContext, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VirtualMachineWithConfigContext
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirtualizationApiService.VirtualizationVirtualMachinesUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/virtualization/virtual-machines/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
