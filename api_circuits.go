/*
NetBox API

API to access NetBox

API version: 2.11
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


// CircuitsApiService CircuitsApi service
type CircuitsApiService service

type ApiCircuitsCircuitTerminationsBulkDeleteRequest struct {
	ctx context.Context
	ApiService *CircuitsApiService
}

func (r ApiCircuitsCircuitTerminationsBulkDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.CircuitsCircuitTerminationsBulkDeleteExecute(r)
}

/*
CircuitsCircuitTerminationsBulkDelete Method for CircuitsCircuitTerminationsBulkDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCircuitsCircuitTerminationsBulkDeleteRequest
*/
func (a *CircuitsApiService) CircuitsCircuitTerminationsBulkDelete(ctx context.Context) ApiCircuitsCircuitTerminationsBulkDeleteRequest {
	return ApiCircuitsCircuitTerminationsBulkDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *CircuitsApiService) CircuitsCircuitTerminationsBulkDeleteExecute(r ApiCircuitsCircuitTerminationsBulkDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CircuitsApiService.CircuitsCircuitTerminationsBulkDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/circuits/circuit-terminations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCircuitsCircuitTerminationsBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *CircuitsApiService
	data *WritableCircuitTermination
}

func (r ApiCircuitsCircuitTerminationsBulkPartialUpdateRequest) Data(data WritableCircuitTermination) ApiCircuitsCircuitTerminationsBulkPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiCircuitsCircuitTerminationsBulkPartialUpdateRequest) Execute() (*CircuitTermination, *http.Response, error) {
	return r.ApiService.CircuitsCircuitTerminationsBulkPartialUpdateExecute(r)
}

/*
CircuitsCircuitTerminationsBulkPartialUpdate Method for CircuitsCircuitTerminationsBulkPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCircuitsCircuitTerminationsBulkPartialUpdateRequest
*/
func (a *CircuitsApiService) CircuitsCircuitTerminationsBulkPartialUpdate(ctx context.Context) ApiCircuitsCircuitTerminationsBulkPartialUpdateRequest {
	return ApiCircuitsCircuitTerminationsBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CircuitTermination
func (a *CircuitsApiService) CircuitsCircuitTerminationsBulkPartialUpdateExecute(r ApiCircuitsCircuitTerminationsBulkPartialUpdateRequest) (*CircuitTermination, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CircuitTermination
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CircuitsApiService.CircuitsCircuitTerminationsBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/circuits/circuit-terminations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCircuitsCircuitTerminationsBulkUpdateRequest struct {
	ctx context.Context
	ApiService *CircuitsApiService
	data *WritableCircuitTermination
}

func (r ApiCircuitsCircuitTerminationsBulkUpdateRequest) Data(data WritableCircuitTermination) ApiCircuitsCircuitTerminationsBulkUpdateRequest {
	r.data = &data
	return r
}

func (r ApiCircuitsCircuitTerminationsBulkUpdateRequest) Execute() (*CircuitTermination, *http.Response, error) {
	return r.ApiService.CircuitsCircuitTerminationsBulkUpdateExecute(r)
}

/*
CircuitsCircuitTerminationsBulkUpdate Method for CircuitsCircuitTerminationsBulkUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCircuitsCircuitTerminationsBulkUpdateRequest
*/
func (a *CircuitsApiService) CircuitsCircuitTerminationsBulkUpdate(ctx context.Context) ApiCircuitsCircuitTerminationsBulkUpdateRequest {
	return ApiCircuitsCircuitTerminationsBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CircuitTermination
func (a *CircuitsApiService) CircuitsCircuitTerminationsBulkUpdateExecute(r ApiCircuitsCircuitTerminationsBulkUpdateRequest) (*CircuitTermination, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CircuitTermination
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CircuitsApiService.CircuitsCircuitTerminationsBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/circuits/circuit-terminations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCircuitsCircuitTerminationsCreateRequest struct {
	ctx context.Context
	ApiService *CircuitsApiService
	data *WritableCircuitTermination
}

func (r ApiCircuitsCircuitTerminationsCreateRequest) Data(data WritableCircuitTermination) ApiCircuitsCircuitTerminationsCreateRequest {
	r.data = &data
	return r
}

func (r ApiCircuitsCircuitTerminationsCreateRequest) Execute() (*CircuitTermination, *http.Response, error) {
	return r.ApiService.CircuitsCircuitTerminationsCreateExecute(r)
}

/*
CircuitsCircuitTerminationsCreate Method for CircuitsCircuitTerminationsCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCircuitsCircuitTerminationsCreateRequest
*/
func (a *CircuitsApiService) CircuitsCircuitTerminationsCreate(ctx context.Context) ApiCircuitsCircuitTerminationsCreateRequest {
	return ApiCircuitsCircuitTerminationsCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CircuitTermination
func (a *CircuitsApiService) CircuitsCircuitTerminationsCreateExecute(r ApiCircuitsCircuitTerminationsCreateRequest) (*CircuitTermination, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CircuitTermination
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CircuitsApiService.CircuitsCircuitTerminationsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/circuits/circuit-terminations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCircuitsCircuitTerminationsDeleteRequest struct {
	ctx context.Context
	ApiService *CircuitsApiService
	id int32
}

func (r ApiCircuitsCircuitTerminationsDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.CircuitsCircuitTerminationsDeleteExecute(r)
}

/*
CircuitsCircuitTerminationsDelete Method for CircuitsCircuitTerminationsDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this circuit termination.
 @return ApiCircuitsCircuitTerminationsDeleteRequest
*/
func (a *CircuitsApiService) CircuitsCircuitTerminationsDelete(ctx context.Context, id int32) ApiCircuitsCircuitTerminationsDeleteRequest {
	return ApiCircuitsCircuitTerminationsDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *CircuitsApiService) CircuitsCircuitTerminationsDeleteExecute(r ApiCircuitsCircuitTerminationsDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CircuitsApiService.CircuitsCircuitTerminationsDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/circuits/circuit-terminations/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCircuitsCircuitTerminationsListRequest struct {
	ctx context.Context
	ApiService *CircuitsApiService
	id *string
	termSide *string
	portSpeed *string
	upstreamSpeed *string
	xconnectId *string
	created *string
	createdGte *string
	createdLte *string
	lastUpdated *string
	lastUpdatedGte *string
	lastUpdatedLte *string
	cabled *string
	q *string
	circuitId *string
	siteId *string
	site *string
	providerNetworkId *string
	idN *string
	idLte *string
	idLt *string
	idGte *string
	idGt *string
	termSideN *string
	portSpeedN *string
	portSpeedLte *string
	portSpeedLt *string
	portSpeedGte *string
	portSpeedGt *string
	upstreamSpeedN *string
	upstreamSpeedLte *string
	upstreamSpeedLt *string
	upstreamSpeedGte *string
	upstreamSpeedGt *string
	xconnectIdN *string
	xconnectIdIc *string
	xconnectIdNic *string
	xconnectIdIew *string
	xconnectIdNiew *string
	xconnectIdIsw *string
	xconnectIdNisw *string
	xconnectIdIe *string
	xconnectIdNie *string
	xconnectIdEmpty *string
	circuitIdN *string
	siteIdN *string
	siteN *string
	providerNetworkIdN *string
	limit *int32
	offset *int32
}

func (r ApiCircuitsCircuitTerminationsListRequest) Id(id string) ApiCircuitsCircuitTerminationsListRequest {
	r.id = &id
	return r
}

func (r ApiCircuitsCircuitTerminationsListRequest) TermSide(termSide string) ApiCircuitsCircuitTerminationsListRequest {
	r.termSide = &termSide
	return r
}

func (r ApiCircuitsCircuitTerminationsListRequest) PortSpeed(portSpeed string) ApiCircuitsCircuitTerminationsListRequest {
	r.portSpeed = &portSpeed
	return r
}

func (r ApiCircuitsCircuitTerminationsListRequest) UpstreamSpeed(upstreamSpeed string) ApiCircuitsCircuitTerminationsListRequest {
	r.upstreamSpeed = &upstreamSpeed
	return r
}

func (r ApiCircuitsCircuitTerminationsListRequest) XconnectId(xconnectId string) ApiCircuitsCircuitTerminationsListRequest {
	r.xconnectId = &xconnectId
	return r
}

func (r ApiCircuitsCircuitTerminationsListRequest) Created(created string) ApiCircuitsCircuitTerminationsListRequest {
	r.created = &created
	return r
}

func (r ApiCircuitsCircuitTerminationsListRequest) CreatedGte(createdGte string) ApiCircuitsCircuitTerminationsListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiCircuitsCircuitTerminationsListRequest) CreatedLte(createdLte string) ApiCircuitsCircuitTerminationsListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiCircuitsCircuitTerminationsListRequest) LastUpdated(lastUpdated string) ApiCircuitsCircuitTerminationsListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiCircuitsCircuitTerminationsListRequest) LastUpdatedGte(lastUpdatedGte string) ApiCircuitsCircuitTerminationsListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiCircuitsCircuitTerminationsListRequest) LastUpdatedLte(lastUpdatedLte string) ApiCircuitsCircuitTerminationsListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiCircuitsCircuitTerminationsListRequest) Cabled(cabled string) ApiCircuitsCircuitTerminationsListRequest {
	r.cabled = &cabled
	return r
}

func (r ApiCircuitsCircuitTerminationsListRequest) Q(q string) ApiCircuitsCircuitTerminationsListRequest {
	r.q = &q
	return r
}

func (r ApiCircuitsCircuitTerminationsListRequest) CircuitId(circuitId string) ApiCircuitsCircuitTerminationsListRequest {
	r.circuitId = &circuitId
	return r
}

func (r ApiCircuitsCircuitTerminationsListRequest) SiteId(siteId string) ApiCircuitsCircuitTerminationsListRequest {
	r.siteId = &siteId
	return r
}

func (r ApiCircuitsCircuitTerminationsListRequest) Site(site string) ApiCircuitsCircuitTerminationsListRequest {
	r.site = &site
	return r
}

func (r ApiCircuitsCircuitTerminationsListRequest) ProviderNetworkId(providerNetworkId string) ApiCircuitsCircuitTerminationsListRequest {
	r.providerNetworkId = &providerNetworkId
	return r
}

func (r ApiCircuitsCircuitTerminationsListRequest) IdN(idN string) ApiCircuitsCircuitTerminationsListRequest {
	r.idN = &idN
	return r
}

func (r ApiCircuitsCircuitTerminationsListRequest) IdLte(idLte string) ApiCircuitsCircuitTerminationsListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiCircuitsCircuitTerminationsListRequest) IdLt(idLt string) ApiCircuitsCircuitTerminationsListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiCircuitsCircuitTerminationsListRequest) IdGte(idGte string) ApiCircuitsCircuitTerminationsListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiCircuitsCircuitTerminationsListRequest) IdGt(idGt string) ApiCircuitsCircuitTerminationsListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiCircuitsCircuitTerminationsListRequest) TermSideN(termSideN string) ApiCircuitsCircuitTerminationsListRequest {
	r.termSideN = &termSideN
	return r
}

func (r ApiCircuitsCircuitTerminationsListRequest) PortSpeedN(portSpeedN string) ApiCircuitsCircuitTerminationsListRequest {
	r.portSpeedN = &portSpeedN
	return r
}

func (r ApiCircuitsCircuitTerminationsListRequest) PortSpeedLte(portSpeedLte string) ApiCircuitsCircuitTerminationsListRequest {
	r.portSpeedLte = &portSpeedLte
	return r
}

func (r ApiCircuitsCircuitTerminationsListRequest) PortSpeedLt(portSpeedLt string) ApiCircuitsCircuitTerminationsListRequest {
	r.portSpeedLt = &portSpeedLt
	return r
}

func (r ApiCircuitsCircuitTerminationsListRequest) PortSpeedGte(portSpeedGte string) ApiCircuitsCircuitTerminationsListRequest {
	r.portSpeedGte = &portSpeedGte
	return r
}

func (r ApiCircuitsCircuitTerminationsListRequest) PortSpeedGt(portSpeedGt string) ApiCircuitsCircuitTerminationsListRequest {
	r.portSpeedGt = &portSpeedGt
	return r
}

func (r ApiCircuitsCircuitTerminationsListRequest) UpstreamSpeedN(upstreamSpeedN string) ApiCircuitsCircuitTerminationsListRequest {
	r.upstreamSpeedN = &upstreamSpeedN
	return r
}

func (r ApiCircuitsCircuitTerminationsListRequest) UpstreamSpeedLte(upstreamSpeedLte string) ApiCircuitsCircuitTerminationsListRequest {
	r.upstreamSpeedLte = &upstreamSpeedLte
	return r
}

func (r ApiCircuitsCircuitTerminationsListRequest) UpstreamSpeedLt(upstreamSpeedLt string) ApiCircuitsCircuitTerminationsListRequest {
	r.upstreamSpeedLt = &upstreamSpeedLt
	return r
}

func (r ApiCircuitsCircuitTerminationsListRequest) UpstreamSpeedGte(upstreamSpeedGte string) ApiCircuitsCircuitTerminationsListRequest {
	r.upstreamSpeedGte = &upstreamSpeedGte
	return r
}

func (r ApiCircuitsCircuitTerminationsListRequest) UpstreamSpeedGt(upstreamSpeedGt string) ApiCircuitsCircuitTerminationsListRequest {
	r.upstreamSpeedGt = &upstreamSpeedGt
	return r
}

func (r ApiCircuitsCircuitTerminationsListRequest) XconnectIdN(xconnectIdN string) ApiCircuitsCircuitTerminationsListRequest {
	r.xconnectIdN = &xconnectIdN
	return r
}

func (r ApiCircuitsCircuitTerminationsListRequest) XconnectIdIc(xconnectIdIc string) ApiCircuitsCircuitTerminationsListRequest {
	r.xconnectIdIc = &xconnectIdIc
	return r
}

func (r ApiCircuitsCircuitTerminationsListRequest) XconnectIdNic(xconnectIdNic string) ApiCircuitsCircuitTerminationsListRequest {
	r.xconnectIdNic = &xconnectIdNic
	return r
}

func (r ApiCircuitsCircuitTerminationsListRequest) XconnectIdIew(xconnectIdIew string) ApiCircuitsCircuitTerminationsListRequest {
	r.xconnectIdIew = &xconnectIdIew
	return r
}

func (r ApiCircuitsCircuitTerminationsListRequest) XconnectIdNiew(xconnectIdNiew string) ApiCircuitsCircuitTerminationsListRequest {
	r.xconnectIdNiew = &xconnectIdNiew
	return r
}

func (r ApiCircuitsCircuitTerminationsListRequest) XconnectIdIsw(xconnectIdIsw string) ApiCircuitsCircuitTerminationsListRequest {
	r.xconnectIdIsw = &xconnectIdIsw
	return r
}

func (r ApiCircuitsCircuitTerminationsListRequest) XconnectIdNisw(xconnectIdNisw string) ApiCircuitsCircuitTerminationsListRequest {
	r.xconnectIdNisw = &xconnectIdNisw
	return r
}

func (r ApiCircuitsCircuitTerminationsListRequest) XconnectIdIe(xconnectIdIe string) ApiCircuitsCircuitTerminationsListRequest {
	r.xconnectIdIe = &xconnectIdIe
	return r
}

func (r ApiCircuitsCircuitTerminationsListRequest) XconnectIdNie(xconnectIdNie string) ApiCircuitsCircuitTerminationsListRequest {
	r.xconnectIdNie = &xconnectIdNie
	return r
}

func (r ApiCircuitsCircuitTerminationsListRequest) XconnectIdEmpty(xconnectIdEmpty string) ApiCircuitsCircuitTerminationsListRequest {
	r.xconnectIdEmpty = &xconnectIdEmpty
	return r
}

func (r ApiCircuitsCircuitTerminationsListRequest) CircuitIdN(circuitIdN string) ApiCircuitsCircuitTerminationsListRequest {
	r.circuitIdN = &circuitIdN
	return r
}

func (r ApiCircuitsCircuitTerminationsListRequest) SiteIdN(siteIdN string) ApiCircuitsCircuitTerminationsListRequest {
	r.siteIdN = &siteIdN
	return r
}

func (r ApiCircuitsCircuitTerminationsListRequest) SiteN(siteN string) ApiCircuitsCircuitTerminationsListRequest {
	r.siteN = &siteN
	return r
}

func (r ApiCircuitsCircuitTerminationsListRequest) ProviderNetworkIdN(providerNetworkIdN string) ApiCircuitsCircuitTerminationsListRequest {
	r.providerNetworkIdN = &providerNetworkIdN
	return r
}

// Number of results to return per page.
func (r ApiCircuitsCircuitTerminationsListRequest) Limit(limit int32) ApiCircuitsCircuitTerminationsListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiCircuitsCircuitTerminationsListRequest) Offset(offset int32) ApiCircuitsCircuitTerminationsListRequest {
	r.offset = &offset
	return r
}

func (r ApiCircuitsCircuitTerminationsListRequest) Execute() (*CircuitsCircuitTerminationsList200Response, *http.Response, error) {
	return r.ApiService.CircuitsCircuitTerminationsListExecute(r)
}

/*
CircuitsCircuitTerminationsList Method for CircuitsCircuitTerminationsList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCircuitsCircuitTerminationsListRequest
*/
func (a *CircuitsApiService) CircuitsCircuitTerminationsList(ctx context.Context) ApiCircuitsCircuitTerminationsListRequest {
	return ApiCircuitsCircuitTerminationsListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CircuitsCircuitTerminationsList200Response
func (a *CircuitsApiService) CircuitsCircuitTerminationsListExecute(r ApiCircuitsCircuitTerminationsListRequest) (*CircuitsCircuitTerminationsList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CircuitsCircuitTerminationsList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CircuitsApiService.CircuitsCircuitTerminationsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/circuits/circuit-terminations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.termSide != nil {
		localVarQueryParams.Add("term_side", parameterToString(*r.termSide, ""))
	}
	if r.portSpeed != nil {
		localVarQueryParams.Add("port_speed", parameterToString(*r.portSpeed, ""))
	}
	if r.upstreamSpeed != nil {
		localVarQueryParams.Add("upstream_speed", parameterToString(*r.upstreamSpeed, ""))
	}
	if r.xconnectId != nil {
		localVarQueryParams.Add("xconnect_id", parameterToString(*r.xconnectId, ""))
	}
	if r.created != nil {
		localVarQueryParams.Add("created", parameterToString(*r.created, ""))
	}
	if r.createdGte != nil {
		localVarQueryParams.Add("created__gte", parameterToString(*r.createdGte, ""))
	}
	if r.createdLte != nil {
		localVarQueryParams.Add("created__lte", parameterToString(*r.createdLte, ""))
	}
	if r.lastUpdated != nil {
		localVarQueryParams.Add("last_updated", parameterToString(*r.lastUpdated, ""))
	}
	if r.lastUpdatedGte != nil {
		localVarQueryParams.Add("last_updated__gte", parameterToString(*r.lastUpdatedGte, ""))
	}
	if r.lastUpdatedLte != nil {
		localVarQueryParams.Add("last_updated__lte", parameterToString(*r.lastUpdatedLte, ""))
	}
	if r.cabled != nil {
		localVarQueryParams.Add("cabled", parameterToString(*r.cabled, ""))
	}
	if r.q != nil {
		localVarQueryParams.Add("q", parameterToString(*r.q, ""))
	}
	if r.circuitId != nil {
		localVarQueryParams.Add("circuit_id", parameterToString(*r.circuitId, ""))
	}
	if r.siteId != nil {
		localVarQueryParams.Add("site_id", parameterToString(*r.siteId, ""))
	}
	if r.site != nil {
		localVarQueryParams.Add("site", parameterToString(*r.site, ""))
	}
	if r.providerNetworkId != nil {
		localVarQueryParams.Add("provider_network_id", parameterToString(*r.providerNetworkId, ""))
	}
	if r.idN != nil {
		localVarQueryParams.Add("id__n", parameterToString(*r.idN, ""))
	}
	if r.idLte != nil {
		localVarQueryParams.Add("id__lte", parameterToString(*r.idLte, ""))
	}
	if r.idLt != nil {
		localVarQueryParams.Add("id__lt", parameterToString(*r.idLt, ""))
	}
	if r.idGte != nil {
		localVarQueryParams.Add("id__gte", parameterToString(*r.idGte, ""))
	}
	if r.idGt != nil {
		localVarQueryParams.Add("id__gt", parameterToString(*r.idGt, ""))
	}
	if r.termSideN != nil {
		localVarQueryParams.Add("term_side__n", parameterToString(*r.termSideN, ""))
	}
	if r.portSpeedN != nil {
		localVarQueryParams.Add("port_speed__n", parameterToString(*r.portSpeedN, ""))
	}
	if r.portSpeedLte != nil {
		localVarQueryParams.Add("port_speed__lte", parameterToString(*r.portSpeedLte, ""))
	}
	if r.portSpeedLt != nil {
		localVarQueryParams.Add("port_speed__lt", parameterToString(*r.portSpeedLt, ""))
	}
	if r.portSpeedGte != nil {
		localVarQueryParams.Add("port_speed__gte", parameterToString(*r.portSpeedGte, ""))
	}
	if r.portSpeedGt != nil {
		localVarQueryParams.Add("port_speed__gt", parameterToString(*r.portSpeedGt, ""))
	}
	if r.upstreamSpeedN != nil {
		localVarQueryParams.Add("upstream_speed__n", parameterToString(*r.upstreamSpeedN, ""))
	}
	if r.upstreamSpeedLte != nil {
		localVarQueryParams.Add("upstream_speed__lte", parameterToString(*r.upstreamSpeedLte, ""))
	}
	if r.upstreamSpeedLt != nil {
		localVarQueryParams.Add("upstream_speed__lt", parameterToString(*r.upstreamSpeedLt, ""))
	}
	if r.upstreamSpeedGte != nil {
		localVarQueryParams.Add("upstream_speed__gte", parameterToString(*r.upstreamSpeedGte, ""))
	}
	if r.upstreamSpeedGt != nil {
		localVarQueryParams.Add("upstream_speed__gt", parameterToString(*r.upstreamSpeedGt, ""))
	}
	if r.xconnectIdN != nil {
		localVarQueryParams.Add("xconnect_id__n", parameterToString(*r.xconnectIdN, ""))
	}
	if r.xconnectIdIc != nil {
		localVarQueryParams.Add("xconnect_id__ic", parameterToString(*r.xconnectIdIc, ""))
	}
	if r.xconnectIdNic != nil {
		localVarQueryParams.Add("xconnect_id__nic", parameterToString(*r.xconnectIdNic, ""))
	}
	if r.xconnectIdIew != nil {
		localVarQueryParams.Add("xconnect_id__iew", parameterToString(*r.xconnectIdIew, ""))
	}
	if r.xconnectIdNiew != nil {
		localVarQueryParams.Add("xconnect_id__niew", parameterToString(*r.xconnectIdNiew, ""))
	}
	if r.xconnectIdIsw != nil {
		localVarQueryParams.Add("xconnect_id__isw", parameterToString(*r.xconnectIdIsw, ""))
	}
	if r.xconnectIdNisw != nil {
		localVarQueryParams.Add("xconnect_id__nisw", parameterToString(*r.xconnectIdNisw, ""))
	}
	if r.xconnectIdIe != nil {
		localVarQueryParams.Add("xconnect_id__ie", parameterToString(*r.xconnectIdIe, ""))
	}
	if r.xconnectIdNie != nil {
		localVarQueryParams.Add("xconnect_id__nie", parameterToString(*r.xconnectIdNie, ""))
	}
	if r.xconnectIdEmpty != nil {
		localVarQueryParams.Add("xconnect_id__empty", parameterToString(*r.xconnectIdEmpty, ""))
	}
	if r.circuitIdN != nil {
		localVarQueryParams.Add("circuit_id__n", parameterToString(*r.circuitIdN, ""))
	}
	if r.siteIdN != nil {
		localVarQueryParams.Add("site_id__n", parameterToString(*r.siteIdN, ""))
	}
	if r.siteN != nil {
		localVarQueryParams.Add("site__n", parameterToString(*r.siteN, ""))
	}
	if r.providerNetworkIdN != nil {
		localVarQueryParams.Add("provider_network_id__n", parameterToString(*r.providerNetworkIdN, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCircuitsCircuitTerminationsPartialUpdateRequest struct {
	ctx context.Context
	ApiService *CircuitsApiService
	id int32
	data *WritableCircuitTermination
}

func (r ApiCircuitsCircuitTerminationsPartialUpdateRequest) Data(data WritableCircuitTermination) ApiCircuitsCircuitTerminationsPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiCircuitsCircuitTerminationsPartialUpdateRequest) Execute() (*CircuitTermination, *http.Response, error) {
	return r.ApiService.CircuitsCircuitTerminationsPartialUpdateExecute(r)
}

/*
CircuitsCircuitTerminationsPartialUpdate Method for CircuitsCircuitTerminationsPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this circuit termination.
 @return ApiCircuitsCircuitTerminationsPartialUpdateRequest
*/
func (a *CircuitsApiService) CircuitsCircuitTerminationsPartialUpdate(ctx context.Context, id int32) ApiCircuitsCircuitTerminationsPartialUpdateRequest {
	return ApiCircuitsCircuitTerminationsPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return CircuitTermination
func (a *CircuitsApiService) CircuitsCircuitTerminationsPartialUpdateExecute(r ApiCircuitsCircuitTerminationsPartialUpdateRequest) (*CircuitTermination, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CircuitTermination
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CircuitsApiService.CircuitsCircuitTerminationsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/circuits/circuit-terminations/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCircuitsCircuitTerminationsPathsRequest struct {
	ctx context.Context
	ApiService *CircuitsApiService
	id int32
}

func (r ApiCircuitsCircuitTerminationsPathsRequest) Execute() (*CircuitTermination, *http.Response, error) {
	return r.ApiService.CircuitsCircuitTerminationsPathsExecute(r)
}

/*
CircuitsCircuitTerminationsPaths Method for CircuitsCircuitTerminationsPaths

Return all CablePaths which traverse a given pass-through port.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this circuit termination.
 @return ApiCircuitsCircuitTerminationsPathsRequest
*/
func (a *CircuitsApiService) CircuitsCircuitTerminationsPaths(ctx context.Context, id int32) ApiCircuitsCircuitTerminationsPathsRequest {
	return ApiCircuitsCircuitTerminationsPathsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return CircuitTermination
func (a *CircuitsApiService) CircuitsCircuitTerminationsPathsExecute(r ApiCircuitsCircuitTerminationsPathsRequest) (*CircuitTermination, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CircuitTermination
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CircuitsApiService.CircuitsCircuitTerminationsPaths")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/circuits/circuit-terminations/{id}/paths/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCircuitsCircuitTerminationsReadRequest struct {
	ctx context.Context
	ApiService *CircuitsApiService
	id int32
}

func (r ApiCircuitsCircuitTerminationsReadRequest) Execute() (*CircuitTermination, *http.Response, error) {
	return r.ApiService.CircuitsCircuitTerminationsReadExecute(r)
}

/*
CircuitsCircuitTerminationsRead Method for CircuitsCircuitTerminationsRead

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this circuit termination.
 @return ApiCircuitsCircuitTerminationsReadRequest
*/
func (a *CircuitsApiService) CircuitsCircuitTerminationsRead(ctx context.Context, id int32) ApiCircuitsCircuitTerminationsReadRequest {
	return ApiCircuitsCircuitTerminationsReadRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return CircuitTermination
func (a *CircuitsApiService) CircuitsCircuitTerminationsReadExecute(r ApiCircuitsCircuitTerminationsReadRequest) (*CircuitTermination, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CircuitTermination
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CircuitsApiService.CircuitsCircuitTerminationsRead")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/circuits/circuit-terminations/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCircuitsCircuitTerminationsUpdateRequest struct {
	ctx context.Context
	ApiService *CircuitsApiService
	id int32
	data *WritableCircuitTermination
}

func (r ApiCircuitsCircuitTerminationsUpdateRequest) Data(data WritableCircuitTermination) ApiCircuitsCircuitTerminationsUpdateRequest {
	r.data = &data
	return r
}

func (r ApiCircuitsCircuitTerminationsUpdateRequest) Execute() (*CircuitTermination, *http.Response, error) {
	return r.ApiService.CircuitsCircuitTerminationsUpdateExecute(r)
}

/*
CircuitsCircuitTerminationsUpdate Method for CircuitsCircuitTerminationsUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this circuit termination.
 @return ApiCircuitsCircuitTerminationsUpdateRequest
*/
func (a *CircuitsApiService) CircuitsCircuitTerminationsUpdate(ctx context.Context, id int32) ApiCircuitsCircuitTerminationsUpdateRequest {
	return ApiCircuitsCircuitTerminationsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return CircuitTermination
func (a *CircuitsApiService) CircuitsCircuitTerminationsUpdateExecute(r ApiCircuitsCircuitTerminationsUpdateRequest) (*CircuitTermination, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CircuitTermination
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CircuitsApiService.CircuitsCircuitTerminationsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/circuits/circuit-terminations/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCircuitsCircuitTypesBulkDeleteRequest struct {
	ctx context.Context
	ApiService *CircuitsApiService
}

func (r ApiCircuitsCircuitTypesBulkDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.CircuitsCircuitTypesBulkDeleteExecute(r)
}

/*
CircuitsCircuitTypesBulkDelete Method for CircuitsCircuitTypesBulkDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCircuitsCircuitTypesBulkDeleteRequest
*/
func (a *CircuitsApiService) CircuitsCircuitTypesBulkDelete(ctx context.Context) ApiCircuitsCircuitTypesBulkDeleteRequest {
	return ApiCircuitsCircuitTypesBulkDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *CircuitsApiService) CircuitsCircuitTypesBulkDeleteExecute(r ApiCircuitsCircuitTypesBulkDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CircuitsApiService.CircuitsCircuitTypesBulkDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/circuits/circuit-types/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCircuitsCircuitTypesBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *CircuitsApiService
	data *CircuitType
}

func (r ApiCircuitsCircuitTypesBulkPartialUpdateRequest) Data(data CircuitType) ApiCircuitsCircuitTypesBulkPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiCircuitsCircuitTypesBulkPartialUpdateRequest) Execute() (*CircuitType, *http.Response, error) {
	return r.ApiService.CircuitsCircuitTypesBulkPartialUpdateExecute(r)
}

/*
CircuitsCircuitTypesBulkPartialUpdate Method for CircuitsCircuitTypesBulkPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCircuitsCircuitTypesBulkPartialUpdateRequest
*/
func (a *CircuitsApiService) CircuitsCircuitTypesBulkPartialUpdate(ctx context.Context) ApiCircuitsCircuitTypesBulkPartialUpdateRequest {
	return ApiCircuitsCircuitTypesBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CircuitType
func (a *CircuitsApiService) CircuitsCircuitTypesBulkPartialUpdateExecute(r ApiCircuitsCircuitTypesBulkPartialUpdateRequest) (*CircuitType, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CircuitType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CircuitsApiService.CircuitsCircuitTypesBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/circuits/circuit-types/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCircuitsCircuitTypesBulkUpdateRequest struct {
	ctx context.Context
	ApiService *CircuitsApiService
	data *CircuitType
}

func (r ApiCircuitsCircuitTypesBulkUpdateRequest) Data(data CircuitType) ApiCircuitsCircuitTypesBulkUpdateRequest {
	r.data = &data
	return r
}

func (r ApiCircuitsCircuitTypesBulkUpdateRequest) Execute() (*CircuitType, *http.Response, error) {
	return r.ApiService.CircuitsCircuitTypesBulkUpdateExecute(r)
}

/*
CircuitsCircuitTypesBulkUpdate Method for CircuitsCircuitTypesBulkUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCircuitsCircuitTypesBulkUpdateRequest
*/
func (a *CircuitsApiService) CircuitsCircuitTypesBulkUpdate(ctx context.Context) ApiCircuitsCircuitTypesBulkUpdateRequest {
	return ApiCircuitsCircuitTypesBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CircuitType
func (a *CircuitsApiService) CircuitsCircuitTypesBulkUpdateExecute(r ApiCircuitsCircuitTypesBulkUpdateRequest) (*CircuitType, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CircuitType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CircuitsApiService.CircuitsCircuitTypesBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/circuits/circuit-types/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCircuitsCircuitTypesCreateRequest struct {
	ctx context.Context
	ApiService *CircuitsApiService
	data *CircuitType
}

func (r ApiCircuitsCircuitTypesCreateRequest) Data(data CircuitType) ApiCircuitsCircuitTypesCreateRequest {
	r.data = &data
	return r
}

func (r ApiCircuitsCircuitTypesCreateRequest) Execute() (*CircuitType, *http.Response, error) {
	return r.ApiService.CircuitsCircuitTypesCreateExecute(r)
}

/*
CircuitsCircuitTypesCreate Method for CircuitsCircuitTypesCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCircuitsCircuitTypesCreateRequest
*/
func (a *CircuitsApiService) CircuitsCircuitTypesCreate(ctx context.Context) ApiCircuitsCircuitTypesCreateRequest {
	return ApiCircuitsCircuitTypesCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CircuitType
func (a *CircuitsApiService) CircuitsCircuitTypesCreateExecute(r ApiCircuitsCircuitTypesCreateRequest) (*CircuitType, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CircuitType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CircuitsApiService.CircuitsCircuitTypesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/circuits/circuit-types/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCircuitsCircuitTypesDeleteRequest struct {
	ctx context.Context
	ApiService *CircuitsApiService
	id int32
}

func (r ApiCircuitsCircuitTypesDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.CircuitsCircuitTypesDeleteExecute(r)
}

/*
CircuitsCircuitTypesDelete Method for CircuitsCircuitTypesDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this circuit type.
 @return ApiCircuitsCircuitTypesDeleteRequest
*/
func (a *CircuitsApiService) CircuitsCircuitTypesDelete(ctx context.Context, id int32) ApiCircuitsCircuitTypesDeleteRequest {
	return ApiCircuitsCircuitTypesDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *CircuitsApiService) CircuitsCircuitTypesDeleteExecute(r ApiCircuitsCircuitTypesDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CircuitsApiService.CircuitsCircuitTypesDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/circuits/circuit-types/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCircuitsCircuitTypesListRequest struct {
	ctx context.Context
	ApiService *CircuitsApiService
	id *string
	name *string
	slug *string
	created *string
	createdGte *string
	createdLte *string
	lastUpdated *string
	lastUpdatedGte *string
	lastUpdatedLte *string
	q *string
	idN *string
	idLte *string
	idLt *string
	idGte *string
	idGt *string
	nameN *string
	nameIc *string
	nameNic *string
	nameIew *string
	nameNiew *string
	nameIsw *string
	nameNisw *string
	nameIe *string
	nameNie *string
	nameEmpty *string
	slugN *string
	slugIc *string
	slugNic *string
	slugIew *string
	slugNiew *string
	slugIsw *string
	slugNisw *string
	slugIe *string
	slugNie *string
	slugEmpty *string
	limit *int32
	offset *int32
}

func (r ApiCircuitsCircuitTypesListRequest) Id(id string) ApiCircuitsCircuitTypesListRequest {
	r.id = &id
	return r
}

func (r ApiCircuitsCircuitTypesListRequest) Name(name string) ApiCircuitsCircuitTypesListRequest {
	r.name = &name
	return r
}

func (r ApiCircuitsCircuitTypesListRequest) Slug(slug string) ApiCircuitsCircuitTypesListRequest {
	r.slug = &slug
	return r
}

func (r ApiCircuitsCircuitTypesListRequest) Created(created string) ApiCircuitsCircuitTypesListRequest {
	r.created = &created
	return r
}

func (r ApiCircuitsCircuitTypesListRequest) CreatedGte(createdGte string) ApiCircuitsCircuitTypesListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiCircuitsCircuitTypesListRequest) CreatedLte(createdLte string) ApiCircuitsCircuitTypesListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiCircuitsCircuitTypesListRequest) LastUpdated(lastUpdated string) ApiCircuitsCircuitTypesListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiCircuitsCircuitTypesListRequest) LastUpdatedGte(lastUpdatedGte string) ApiCircuitsCircuitTypesListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiCircuitsCircuitTypesListRequest) LastUpdatedLte(lastUpdatedLte string) ApiCircuitsCircuitTypesListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiCircuitsCircuitTypesListRequest) Q(q string) ApiCircuitsCircuitTypesListRequest {
	r.q = &q
	return r
}

func (r ApiCircuitsCircuitTypesListRequest) IdN(idN string) ApiCircuitsCircuitTypesListRequest {
	r.idN = &idN
	return r
}

func (r ApiCircuitsCircuitTypesListRequest) IdLte(idLte string) ApiCircuitsCircuitTypesListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiCircuitsCircuitTypesListRequest) IdLt(idLt string) ApiCircuitsCircuitTypesListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiCircuitsCircuitTypesListRequest) IdGte(idGte string) ApiCircuitsCircuitTypesListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiCircuitsCircuitTypesListRequest) IdGt(idGt string) ApiCircuitsCircuitTypesListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiCircuitsCircuitTypesListRequest) NameN(nameN string) ApiCircuitsCircuitTypesListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiCircuitsCircuitTypesListRequest) NameIc(nameIc string) ApiCircuitsCircuitTypesListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiCircuitsCircuitTypesListRequest) NameNic(nameNic string) ApiCircuitsCircuitTypesListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiCircuitsCircuitTypesListRequest) NameIew(nameIew string) ApiCircuitsCircuitTypesListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiCircuitsCircuitTypesListRequest) NameNiew(nameNiew string) ApiCircuitsCircuitTypesListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiCircuitsCircuitTypesListRequest) NameIsw(nameIsw string) ApiCircuitsCircuitTypesListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiCircuitsCircuitTypesListRequest) NameNisw(nameNisw string) ApiCircuitsCircuitTypesListRequest {
	r.nameNisw = &nameNisw
	return r
}

func (r ApiCircuitsCircuitTypesListRequest) NameIe(nameIe string) ApiCircuitsCircuitTypesListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiCircuitsCircuitTypesListRequest) NameNie(nameNie string) ApiCircuitsCircuitTypesListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiCircuitsCircuitTypesListRequest) NameEmpty(nameEmpty string) ApiCircuitsCircuitTypesListRequest {
	r.nameEmpty = &nameEmpty
	return r
}

func (r ApiCircuitsCircuitTypesListRequest) SlugN(slugN string) ApiCircuitsCircuitTypesListRequest {
	r.slugN = &slugN
	return r
}

func (r ApiCircuitsCircuitTypesListRequest) SlugIc(slugIc string) ApiCircuitsCircuitTypesListRequest {
	r.slugIc = &slugIc
	return r
}

func (r ApiCircuitsCircuitTypesListRequest) SlugNic(slugNic string) ApiCircuitsCircuitTypesListRequest {
	r.slugNic = &slugNic
	return r
}

func (r ApiCircuitsCircuitTypesListRequest) SlugIew(slugIew string) ApiCircuitsCircuitTypesListRequest {
	r.slugIew = &slugIew
	return r
}

func (r ApiCircuitsCircuitTypesListRequest) SlugNiew(slugNiew string) ApiCircuitsCircuitTypesListRequest {
	r.slugNiew = &slugNiew
	return r
}

func (r ApiCircuitsCircuitTypesListRequest) SlugIsw(slugIsw string) ApiCircuitsCircuitTypesListRequest {
	r.slugIsw = &slugIsw
	return r
}

func (r ApiCircuitsCircuitTypesListRequest) SlugNisw(slugNisw string) ApiCircuitsCircuitTypesListRequest {
	r.slugNisw = &slugNisw
	return r
}

func (r ApiCircuitsCircuitTypesListRequest) SlugIe(slugIe string) ApiCircuitsCircuitTypesListRequest {
	r.slugIe = &slugIe
	return r
}

func (r ApiCircuitsCircuitTypesListRequest) SlugNie(slugNie string) ApiCircuitsCircuitTypesListRequest {
	r.slugNie = &slugNie
	return r
}

func (r ApiCircuitsCircuitTypesListRequest) SlugEmpty(slugEmpty string) ApiCircuitsCircuitTypesListRequest {
	r.slugEmpty = &slugEmpty
	return r
}

// Number of results to return per page.
func (r ApiCircuitsCircuitTypesListRequest) Limit(limit int32) ApiCircuitsCircuitTypesListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiCircuitsCircuitTypesListRequest) Offset(offset int32) ApiCircuitsCircuitTypesListRequest {
	r.offset = &offset
	return r
}

func (r ApiCircuitsCircuitTypesListRequest) Execute() (*CircuitsCircuitTypesList200Response, *http.Response, error) {
	return r.ApiService.CircuitsCircuitTypesListExecute(r)
}

/*
CircuitsCircuitTypesList Method for CircuitsCircuitTypesList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCircuitsCircuitTypesListRequest
*/
func (a *CircuitsApiService) CircuitsCircuitTypesList(ctx context.Context) ApiCircuitsCircuitTypesListRequest {
	return ApiCircuitsCircuitTypesListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CircuitsCircuitTypesList200Response
func (a *CircuitsApiService) CircuitsCircuitTypesListExecute(r ApiCircuitsCircuitTypesListRequest) (*CircuitsCircuitTypesList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CircuitsCircuitTypesList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CircuitsApiService.CircuitsCircuitTypesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/circuits/circuit-types/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.slug != nil {
		localVarQueryParams.Add("slug", parameterToString(*r.slug, ""))
	}
	if r.created != nil {
		localVarQueryParams.Add("created", parameterToString(*r.created, ""))
	}
	if r.createdGte != nil {
		localVarQueryParams.Add("created__gte", parameterToString(*r.createdGte, ""))
	}
	if r.createdLte != nil {
		localVarQueryParams.Add("created__lte", parameterToString(*r.createdLte, ""))
	}
	if r.lastUpdated != nil {
		localVarQueryParams.Add("last_updated", parameterToString(*r.lastUpdated, ""))
	}
	if r.lastUpdatedGte != nil {
		localVarQueryParams.Add("last_updated__gte", parameterToString(*r.lastUpdatedGte, ""))
	}
	if r.lastUpdatedLte != nil {
		localVarQueryParams.Add("last_updated__lte", parameterToString(*r.lastUpdatedLte, ""))
	}
	if r.q != nil {
		localVarQueryParams.Add("q", parameterToString(*r.q, ""))
	}
	if r.idN != nil {
		localVarQueryParams.Add("id__n", parameterToString(*r.idN, ""))
	}
	if r.idLte != nil {
		localVarQueryParams.Add("id__lte", parameterToString(*r.idLte, ""))
	}
	if r.idLt != nil {
		localVarQueryParams.Add("id__lt", parameterToString(*r.idLt, ""))
	}
	if r.idGte != nil {
		localVarQueryParams.Add("id__gte", parameterToString(*r.idGte, ""))
	}
	if r.idGt != nil {
		localVarQueryParams.Add("id__gt", parameterToString(*r.idGt, ""))
	}
	if r.nameN != nil {
		localVarQueryParams.Add("name__n", parameterToString(*r.nameN, ""))
	}
	if r.nameIc != nil {
		localVarQueryParams.Add("name__ic", parameterToString(*r.nameIc, ""))
	}
	if r.nameNic != nil {
		localVarQueryParams.Add("name__nic", parameterToString(*r.nameNic, ""))
	}
	if r.nameIew != nil {
		localVarQueryParams.Add("name__iew", parameterToString(*r.nameIew, ""))
	}
	if r.nameNiew != nil {
		localVarQueryParams.Add("name__niew", parameterToString(*r.nameNiew, ""))
	}
	if r.nameIsw != nil {
		localVarQueryParams.Add("name__isw", parameterToString(*r.nameIsw, ""))
	}
	if r.nameNisw != nil {
		localVarQueryParams.Add("name__nisw", parameterToString(*r.nameNisw, ""))
	}
	if r.nameIe != nil {
		localVarQueryParams.Add("name__ie", parameterToString(*r.nameIe, ""))
	}
	if r.nameNie != nil {
		localVarQueryParams.Add("name__nie", parameterToString(*r.nameNie, ""))
	}
	if r.nameEmpty != nil {
		localVarQueryParams.Add("name__empty", parameterToString(*r.nameEmpty, ""))
	}
	if r.slugN != nil {
		localVarQueryParams.Add("slug__n", parameterToString(*r.slugN, ""))
	}
	if r.slugIc != nil {
		localVarQueryParams.Add("slug__ic", parameterToString(*r.slugIc, ""))
	}
	if r.slugNic != nil {
		localVarQueryParams.Add("slug__nic", parameterToString(*r.slugNic, ""))
	}
	if r.slugIew != nil {
		localVarQueryParams.Add("slug__iew", parameterToString(*r.slugIew, ""))
	}
	if r.slugNiew != nil {
		localVarQueryParams.Add("slug__niew", parameterToString(*r.slugNiew, ""))
	}
	if r.slugIsw != nil {
		localVarQueryParams.Add("slug__isw", parameterToString(*r.slugIsw, ""))
	}
	if r.slugNisw != nil {
		localVarQueryParams.Add("slug__nisw", parameterToString(*r.slugNisw, ""))
	}
	if r.slugIe != nil {
		localVarQueryParams.Add("slug__ie", parameterToString(*r.slugIe, ""))
	}
	if r.slugNie != nil {
		localVarQueryParams.Add("slug__nie", parameterToString(*r.slugNie, ""))
	}
	if r.slugEmpty != nil {
		localVarQueryParams.Add("slug__empty", parameterToString(*r.slugEmpty, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCircuitsCircuitTypesPartialUpdateRequest struct {
	ctx context.Context
	ApiService *CircuitsApiService
	id int32
	data *CircuitType
}

func (r ApiCircuitsCircuitTypesPartialUpdateRequest) Data(data CircuitType) ApiCircuitsCircuitTypesPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiCircuitsCircuitTypesPartialUpdateRequest) Execute() (*CircuitType, *http.Response, error) {
	return r.ApiService.CircuitsCircuitTypesPartialUpdateExecute(r)
}

/*
CircuitsCircuitTypesPartialUpdate Method for CircuitsCircuitTypesPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this circuit type.
 @return ApiCircuitsCircuitTypesPartialUpdateRequest
*/
func (a *CircuitsApiService) CircuitsCircuitTypesPartialUpdate(ctx context.Context, id int32) ApiCircuitsCircuitTypesPartialUpdateRequest {
	return ApiCircuitsCircuitTypesPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return CircuitType
func (a *CircuitsApiService) CircuitsCircuitTypesPartialUpdateExecute(r ApiCircuitsCircuitTypesPartialUpdateRequest) (*CircuitType, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CircuitType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CircuitsApiService.CircuitsCircuitTypesPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/circuits/circuit-types/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCircuitsCircuitTypesReadRequest struct {
	ctx context.Context
	ApiService *CircuitsApiService
	id int32
}

func (r ApiCircuitsCircuitTypesReadRequest) Execute() (*CircuitType, *http.Response, error) {
	return r.ApiService.CircuitsCircuitTypesReadExecute(r)
}

/*
CircuitsCircuitTypesRead Method for CircuitsCircuitTypesRead

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this circuit type.
 @return ApiCircuitsCircuitTypesReadRequest
*/
func (a *CircuitsApiService) CircuitsCircuitTypesRead(ctx context.Context, id int32) ApiCircuitsCircuitTypesReadRequest {
	return ApiCircuitsCircuitTypesReadRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return CircuitType
func (a *CircuitsApiService) CircuitsCircuitTypesReadExecute(r ApiCircuitsCircuitTypesReadRequest) (*CircuitType, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CircuitType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CircuitsApiService.CircuitsCircuitTypesRead")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/circuits/circuit-types/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCircuitsCircuitTypesUpdateRequest struct {
	ctx context.Context
	ApiService *CircuitsApiService
	id int32
	data *CircuitType
}

func (r ApiCircuitsCircuitTypesUpdateRequest) Data(data CircuitType) ApiCircuitsCircuitTypesUpdateRequest {
	r.data = &data
	return r
}

func (r ApiCircuitsCircuitTypesUpdateRequest) Execute() (*CircuitType, *http.Response, error) {
	return r.ApiService.CircuitsCircuitTypesUpdateExecute(r)
}

/*
CircuitsCircuitTypesUpdate Method for CircuitsCircuitTypesUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this circuit type.
 @return ApiCircuitsCircuitTypesUpdateRequest
*/
func (a *CircuitsApiService) CircuitsCircuitTypesUpdate(ctx context.Context, id int32) ApiCircuitsCircuitTypesUpdateRequest {
	return ApiCircuitsCircuitTypesUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return CircuitType
func (a *CircuitsApiService) CircuitsCircuitTypesUpdateExecute(r ApiCircuitsCircuitTypesUpdateRequest) (*CircuitType, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CircuitType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CircuitsApiService.CircuitsCircuitTypesUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/circuits/circuit-types/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCircuitsCircuitsBulkDeleteRequest struct {
	ctx context.Context
	ApiService *CircuitsApiService
}

func (r ApiCircuitsCircuitsBulkDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.CircuitsCircuitsBulkDeleteExecute(r)
}

/*
CircuitsCircuitsBulkDelete Method for CircuitsCircuitsBulkDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCircuitsCircuitsBulkDeleteRequest
*/
func (a *CircuitsApiService) CircuitsCircuitsBulkDelete(ctx context.Context) ApiCircuitsCircuitsBulkDeleteRequest {
	return ApiCircuitsCircuitsBulkDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *CircuitsApiService) CircuitsCircuitsBulkDeleteExecute(r ApiCircuitsCircuitsBulkDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CircuitsApiService.CircuitsCircuitsBulkDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/circuits/circuits/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCircuitsCircuitsBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *CircuitsApiService
	data *WritableCircuit
}

func (r ApiCircuitsCircuitsBulkPartialUpdateRequest) Data(data WritableCircuit) ApiCircuitsCircuitsBulkPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiCircuitsCircuitsBulkPartialUpdateRequest) Execute() (*Circuit, *http.Response, error) {
	return r.ApiService.CircuitsCircuitsBulkPartialUpdateExecute(r)
}

/*
CircuitsCircuitsBulkPartialUpdate Method for CircuitsCircuitsBulkPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCircuitsCircuitsBulkPartialUpdateRequest
*/
func (a *CircuitsApiService) CircuitsCircuitsBulkPartialUpdate(ctx context.Context) ApiCircuitsCircuitsBulkPartialUpdateRequest {
	return ApiCircuitsCircuitsBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Circuit
func (a *CircuitsApiService) CircuitsCircuitsBulkPartialUpdateExecute(r ApiCircuitsCircuitsBulkPartialUpdateRequest) (*Circuit, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Circuit
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CircuitsApiService.CircuitsCircuitsBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/circuits/circuits/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCircuitsCircuitsBulkUpdateRequest struct {
	ctx context.Context
	ApiService *CircuitsApiService
	data *WritableCircuit
}

func (r ApiCircuitsCircuitsBulkUpdateRequest) Data(data WritableCircuit) ApiCircuitsCircuitsBulkUpdateRequest {
	r.data = &data
	return r
}

func (r ApiCircuitsCircuitsBulkUpdateRequest) Execute() (*Circuit, *http.Response, error) {
	return r.ApiService.CircuitsCircuitsBulkUpdateExecute(r)
}

/*
CircuitsCircuitsBulkUpdate Method for CircuitsCircuitsBulkUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCircuitsCircuitsBulkUpdateRequest
*/
func (a *CircuitsApiService) CircuitsCircuitsBulkUpdate(ctx context.Context) ApiCircuitsCircuitsBulkUpdateRequest {
	return ApiCircuitsCircuitsBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Circuit
func (a *CircuitsApiService) CircuitsCircuitsBulkUpdateExecute(r ApiCircuitsCircuitsBulkUpdateRequest) (*Circuit, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Circuit
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CircuitsApiService.CircuitsCircuitsBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/circuits/circuits/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCircuitsCircuitsCreateRequest struct {
	ctx context.Context
	ApiService *CircuitsApiService
	data *WritableCircuit
}

func (r ApiCircuitsCircuitsCreateRequest) Data(data WritableCircuit) ApiCircuitsCircuitsCreateRequest {
	r.data = &data
	return r
}

func (r ApiCircuitsCircuitsCreateRequest) Execute() (*Circuit, *http.Response, error) {
	return r.ApiService.CircuitsCircuitsCreateExecute(r)
}

/*
CircuitsCircuitsCreate Method for CircuitsCircuitsCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCircuitsCircuitsCreateRequest
*/
func (a *CircuitsApiService) CircuitsCircuitsCreate(ctx context.Context) ApiCircuitsCircuitsCreateRequest {
	return ApiCircuitsCircuitsCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Circuit
func (a *CircuitsApiService) CircuitsCircuitsCreateExecute(r ApiCircuitsCircuitsCreateRequest) (*Circuit, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Circuit
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CircuitsApiService.CircuitsCircuitsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/circuits/circuits/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCircuitsCircuitsDeleteRequest struct {
	ctx context.Context
	ApiService *CircuitsApiService
	id int32
}

func (r ApiCircuitsCircuitsDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.CircuitsCircuitsDeleteExecute(r)
}

/*
CircuitsCircuitsDelete Method for CircuitsCircuitsDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this circuit.
 @return ApiCircuitsCircuitsDeleteRequest
*/
func (a *CircuitsApiService) CircuitsCircuitsDelete(ctx context.Context, id int32) ApiCircuitsCircuitsDeleteRequest {
	return ApiCircuitsCircuitsDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *CircuitsApiService) CircuitsCircuitsDeleteExecute(r ApiCircuitsCircuitsDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CircuitsApiService.CircuitsCircuitsDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/circuits/circuits/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCircuitsCircuitsListRequest struct {
	ctx context.Context
	ApiService *CircuitsApiService
	id *string
	cid *string
	installDate *string
	commitRate *string
	created *string
	createdGte *string
	createdLte *string
	lastUpdated *string
	lastUpdatedGte *string
	lastUpdatedLte *string
	tenantGroupId *string
	tenantGroup *string
	tenantId *string
	tenant *string
	q *string
	providerId *string
	provider *string
	providerNetworkId *string
	typeId *string
	type_ *string
	status *string
	regionId *string
	region *string
	siteGroupId *string
	siteGroup *string
	siteId *string
	site *string
	tag *string
	idN *string
	idLte *string
	idLt *string
	idGte *string
	idGt *string
	cidN *string
	cidIc *string
	cidNic *string
	cidIew *string
	cidNiew *string
	cidIsw *string
	cidNisw *string
	cidIe *string
	cidNie *string
	cidEmpty *string
	installDateN *string
	installDateLte *string
	installDateLt *string
	installDateGte *string
	installDateGt *string
	commitRateN *string
	commitRateLte *string
	commitRateLt *string
	commitRateGte *string
	commitRateGt *string
	tenantGroupIdN *string
	tenantGroupN *string
	tenantIdN *string
	tenantN *string
	providerIdN *string
	providerN *string
	providerNetworkIdN *string
	typeIdN *string
	typeN *string
	statusN *string
	regionIdN *string
	regionN *string
	siteGroupIdN *string
	siteGroupN *string
	siteIdN *string
	siteN *string
	tagN *string
	limit *int32
	offset *int32
}

func (r ApiCircuitsCircuitsListRequest) Id(id string) ApiCircuitsCircuitsListRequest {
	r.id = &id
	return r
}

func (r ApiCircuitsCircuitsListRequest) Cid(cid string) ApiCircuitsCircuitsListRequest {
	r.cid = &cid
	return r
}

func (r ApiCircuitsCircuitsListRequest) InstallDate(installDate string) ApiCircuitsCircuitsListRequest {
	r.installDate = &installDate
	return r
}

func (r ApiCircuitsCircuitsListRequest) CommitRate(commitRate string) ApiCircuitsCircuitsListRequest {
	r.commitRate = &commitRate
	return r
}

func (r ApiCircuitsCircuitsListRequest) Created(created string) ApiCircuitsCircuitsListRequest {
	r.created = &created
	return r
}

func (r ApiCircuitsCircuitsListRequest) CreatedGte(createdGte string) ApiCircuitsCircuitsListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiCircuitsCircuitsListRequest) CreatedLte(createdLte string) ApiCircuitsCircuitsListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiCircuitsCircuitsListRequest) LastUpdated(lastUpdated string) ApiCircuitsCircuitsListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiCircuitsCircuitsListRequest) LastUpdatedGte(lastUpdatedGte string) ApiCircuitsCircuitsListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiCircuitsCircuitsListRequest) LastUpdatedLte(lastUpdatedLte string) ApiCircuitsCircuitsListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiCircuitsCircuitsListRequest) TenantGroupId(tenantGroupId string) ApiCircuitsCircuitsListRequest {
	r.tenantGroupId = &tenantGroupId
	return r
}

func (r ApiCircuitsCircuitsListRequest) TenantGroup(tenantGroup string) ApiCircuitsCircuitsListRequest {
	r.tenantGroup = &tenantGroup
	return r
}

func (r ApiCircuitsCircuitsListRequest) TenantId(tenantId string) ApiCircuitsCircuitsListRequest {
	r.tenantId = &tenantId
	return r
}

func (r ApiCircuitsCircuitsListRequest) Tenant(tenant string) ApiCircuitsCircuitsListRequest {
	r.tenant = &tenant
	return r
}

func (r ApiCircuitsCircuitsListRequest) Q(q string) ApiCircuitsCircuitsListRequest {
	r.q = &q
	return r
}

func (r ApiCircuitsCircuitsListRequest) ProviderId(providerId string) ApiCircuitsCircuitsListRequest {
	r.providerId = &providerId
	return r
}

func (r ApiCircuitsCircuitsListRequest) Provider(provider string) ApiCircuitsCircuitsListRequest {
	r.provider = &provider
	return r
}

func (r ApiCircuitsCircuitsListRequest) ProviderNetworkId(providerNetworkId string) ApiCircuitsCircuitsListRequest {
	r.providerNetworkId = &providerNetworkId
	return r
}

func (r ApiCircuitsCircuitsListRequest) TypeId(typeId string) ApiCircuitsCircuitsListRequest {
	r.typeId = &typeId
	return r
}

func (r ApiCircuitsCircuitsListRequest) Type_(type_ string) ApiCircuitsCircuitsListRequest {
	r.type_ = &type_
	return r
}

func (r ApiCircuitsCircuitsListRequest) Status(status string) ApiCircuitsCircuitsListRequest {
	r.status = &status
	return r
}

func (r ApiCircuitsCircuitsListRequest) RegionId(regionId string) ApiCircuitsCircuitsListRequest {
	r.regionId = &regionId
	return r
}

func (r ApiCircuitsCircuitsListRequest) Region(region string) ApiCircuitsCircuitsListRequest {
	r.region = &region
	return r
}

func (r ApiCircuitsCircuitsListRequest) SiteGroupId(siteGroupId string) ApiCircuitsCircuitsListRequest {
	r.siteGroupId = &siteGroupId
	return r
}

func (r ApiCircuitsCircuitsListRequest) SiteGroup(siteGroup string) ApiCircuitsCircuitsListRequest {
	r.siteGroup = &siteGroup
	return r
}

func (r ApiCircuitsCircuitsListRequest) SiteId(siteId string) ApiCircuitsCircuitsListRequest {
	r.siteId = &siteId
	return r
}

func (r ApiCircuitsCircuitsListRequest) Site(site string) ApiCircuitsCircuitsListRequest {
	r.site = &site
	return r
}

func (r ApiCircuitsCircuitsListRequest) Tag(tag string) ApiCircuitsCircuitsListRequest {
	r.tag = &tag
	return r
}

func (r ApiCircuitsCircuitsListRequest) IdN(idN string) ApiCircuitsCircuitsListRequest {
	r.idN = &idN
	return r
}

func (r ApiCircuitsCircuitsListRequest) IdLte(idLte string) ApiCircuitsCircuitsListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiCircuitsCircuitsListRequest) IdLt(idLt string) ApiCircuitsCircuitsListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiCircuitsCircuitsListRequest) IdGte(idGte string) ApiCircuitsCircuitsListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiCircuitsCircuitsListRequest) IdGt(idGt string) ApiCircuitsCircuitsListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiCircuitsCircuitsListRequest) CidN(cidN string) ApiCircuitsCircuitsListRequest {
	r.cidN = &cidN
	return r
}

func (r ApiCircuitsCircuitsListRequest) CidIc(cidIc string) ApiCircuitsCircuitsListRequest {
	r.cidIc = &cidIc
	return r
}

func (r ApiCircuitsCircuitsListRequest) CidNic(cidNic string) ApiCircuitsCircuitsListRequest {
	r.cidNic = &cidNic
	return r
}

func (r ApiCircuitsCircuitsListRequest) CidIew(cidIew string) ApiCircuitsCircuitsListRequest {
	r.cidIew = &cidIew
	return r
}

func (r ApiCircuitsCircuitsListRequest) CidNiew(cidNiew string) ApiCircuitsCircuitsListRequest {
	r.cidNiew = &cidNiew
	return r
}

func (r ApiCircuitsCircuitsListRequest) CidIsw(cidIsw string) ApiCircuitsCircuitsListRequest {
	r.cidIsw = &cidIsw
	return r
}

func (r ApiCircuitsCircuitsListRequest) CidNisw(cidNisw string) ApiCircuitsCircuitsListRequest {
	r.cidNisw = &cidNisw
	return r
}

func (r ApiCircuitsCircuitsListRequest) CidIe(cidIe string) ApiCircuitsCircuitsListRequest {
	r.cidIe = &cidIe
	return r
}

func (r ApiCircuitsCircuitsListRequest) CidNie(cidNie string) ApiCircuitsCircuitsListRequest {
	r.cidNie = &cidNie
	return r
}

func (r ApiCircuitsCircuitsListRequest) CidEmpty(cidEmpty string) ApiCircuitsCircuitsListRequest {
	r.cidEmpty = &cidEmpty
	return r
}

func (r ApiCircuitsCircuitsListRequest) InstallDateN(installDateN string) ApiCircuitsCircuitsListRequest {
	r.installDateN = &installDateN
	return r
}

func (r ApiCircuitsCircuitsListRequest) InstallDateLte(installDateLte string) ApiCircuitsCircuitsListRequest {
	r.installDateLte = &installDateLte
	return r
}

func (r ApiCircuitsCircuitsListRequest) InstallDateLt(installDateLt string) ApiCircuitsCircuitsListRequest {
	r.installDateLt = &installDateLt
	return r
}

func (r ApiCircuitsCircuitsListRequest) InstallDateGte(installDateGte string) ApiCircuitsCircuitsListRequest {
	r.installDateGte = &installDateGte
	return r
}

func (r ApiCircuitsCircuitsListRequest) InstallDateGt(installDateGt string) ApiCircuitsCircuitsListRequest {
	r.installDateGt = &installDateGt
	return r
}

func (r ApiCircuitsCircuitsListRequest) CommitRateN(commitRateN string) ApiCircuitsCircuitsListRequest {
	r.commitRateN = &commitRateN
	return r
}

func (r ApiCircuitsCircuitsListRequest) CommitRateLte(commitRateLte string) ApiCircuitsCircuitsListRequest {
	r.commitRateLte = &commitRateLte
	return r
}

func (r ApiCircuitsCircuitsListRequest) CommitRateLt(commitRateLt string) ApiCircuitsCircuitsListRequest {
	r.commitRateLt = &commitRateLt
	return r
}

func (r ApiCircuitsCircuitsListRequest) CommitRateGte(commitRateGte string) ApiCircuitsCircuitsListRequest {
	r.commitRateGte = &commitRateGte
	return r
}

func (r ApiCircuitsCircuitsListRequest) CommitRateGt(commitRateGt string) ApiCircuitsCircuitsListRequest {
	r.commitRateGt = &commitRateGt
	return r
}

func (r ApiCircuitsCircuitsListRequest) TenantGroupIdN(tenantGroupIdN string) ApiCircuitsCircuitsListRequest {
	r.tenantGroupIdN = &tenantGroupIdN
	return r
}

func (r ApiCircuitsCircuitsListRequest) TenantGroupN(tenantGroupN string) ApiCircuitsCircuitsListRequest {
	r.tenantGroupN = &tenantGroupN
	return r
}

func (r ApiCircuitsCircuitsListRequest) TenantIdN(tenantIdN string) ApiCircuitsCircuitsListRequest {
	r.tenantIdN = &tenantIdN
	return r
}

func (r ApiCircuitsCircuitsListRequest) TenantN(tenantN string) ApiCircuitsCircuitsListRequest {
	r.tenantN = &tenantN
	return r
}

func (r ApiCircuitsCircuitsListRequest) ProviderIdN(providerIdN string) ApiCircuitsCircuitsListRequest {
	r.providerIdN = &providerIdN
	return r
}

func (r ApiCircuitsCircuitsListRequest) ProviderN(providerN string) ApiCircuitsCircuitsListRequest {
	r.providerN = &providerN
	return r
}

func (r ApiCircuitsCircuitsListRequest) ProviderNetworkIdN(providerNetworkIdN string) ApiCircuitsCircuitsListRequest {
	r.providerNetworkIdN = &providerNetworkIdN
	return r
}

func (r ApiCircuitsCircuitsListRequest) TypeIdN(typeIdN string) ApiCircuitsCircuitsListRequest {
	r.typeIdN = &typeIdN
	return r
}

func (r ApiCircuitsCircuitsListRequest) TypeN(typeN string) ApiCircuitsCircuitsListRequest {
	r.typeN = &typeN
	return r
}

func (r ApiCircuitsCircuitsListRequest) StatusN(statusN string) ApiCircuitsCircuitsListRequest {
	r.statusN = &statusN
	return r
}

func (r ApiCircuitsCircuitsListRequest) RegionIdN(regionIdN string) ApiCircuitsCircuitsListRequest {
	r.regionIdN = &regionIdN
	return r
}

func (r ApiCircuitsCircuitsListRequest) RegionN(regionN string) ApiCircuitsCircuitsListRequest {
	r.regionN = &regionN
	return r
}

func (r ApiCircuitsCircuitsListRequest) SiteGroupIdN(siteGroupIdN string) ApiCircuitsCircuitsListRequest {
	r.siteGroupIdN = &siteGroupIdN
	return r
}

func (r ApiCircuitsCircuitsListRequest) SiteGroupN(siteGroupN string) ApiCircuitsCircuitsListRequest {
	r.siteGroupN = &siteGroupN
	return r
}

func (r ApiCircuitsCircuitsListRequest) SiteIdN(siteIdN string) ApiCircuitsCircuitsListRequest {
	r.siteIdN = &siteIdN
	return r
}

func (r ApiCircuitsCircuitsListRequest) SiteN(siteN string) ApiCircuitsCircuitsListRequest {
	r.siteN = &siteN
	return r
}

func (r ApiCircuitsCircuitsListRequest) TagN(tagN string) ApiCircuitsCircuitsListRequest {
	r.tagN = &tagN
	return r
}

// Number of results to return per page.
func (r ApiCircuitsCircuitsListRequest) Limit(limit int32) ApiCircuitsCircuitsListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiCircuitsCircuitsListRequest) Offset(offset int32) ApiCircuitsCircuitsListRequest {
	r.offset = &offset
	return r
}

func (r ApiCircuitsCircuitsListRequest) Execute() (*CircuitsCircuitsList200Response, *http.Response, error) {
	return r.ApiService.CircuitsCircuitsListExecute(r)
}

/*
CircuitsCircuitsList Method for CircuitsCircuitsList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCircuitsCircuitsListRequest
*/
func (a *CircuitsApiService) CircuitsCircuitsList(ctx context.Context) ApiCircuitsCircuitsListRequest {
	return ApiCircuitsCircuitsListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CircuitsCircuitsList200Response
func (a *CircuitsApiService) CircuitsCircuitsListExecute(r ApiCircuitsCircuitsListRequest) (*CircuitsCircuitsList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CircuitsCircuitsList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CircuitsApiService.CircuitsCircuitsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/circuits/circuits/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.cid != nil {
		localVarQueryParams.Add("cid", parameterToString(*r.cid, ""))
	}
	if r.installDate != nil {
		localVarQueryParams.Add("install_date", parameterToString(*r.installDate, ""))
	}
	if r.commitRate != nil {
		localVarQueryParams.Add("commit_rate", parameterToString(*r.commitRate, ""))
	}
	if r.created != nil {
		localVarQueryParams.Add("created", parameterToString(*r.created, ""))
	}
	if r.createdGte != nil {
		localVarQueryParams.Add("created__gte", parameterToString(*r.createdGte, ""))
	}
	if r.createdLte != nil {
		localVarQueryParams.Add("created__lte", parameterToString(*r.createdLte, ""))
	}
	if r.lastUpdated != nil {
		localVarQueryParams.Add("last_updated", parameterToString(*r.lastUpdated, ""))
	}
	if r.lastUpdatedGte != nil {
		localVarQueryParams.Add("last_updated__gte", parameterToString(*r.lastUpdatedGte, ""))
	}
	if r.lastUpdatedLte != nil {
		localVarQueryParams.Add("last_updated__lte", parameterToString(*r.lastUpdatedLte, ""))
	}
	if r.tenantGroupId != nil {
		localVarQueryParams.Add("tenant_group_id", parameterToString(*r.tenantGroupId, ""))
	}
	if r.tenantGroup != nil {
		localVarQueryParams.Add("tenant_group", parameterToString(*r.tenantGroup, ""))
	}
	if r.tenantId != nil {
		localVarQueryParams.Add("tenant_id", parameterToString(*r.tenantId, ""))
	}
	if r.tenant != nil {
		localVarQueryParams.Add("tenant", parameterToString(*r.tenant, ""))
	}
	if r.q != nil {
		localVarQueryParams.Add("q", parameterToString(*r.q, ""))
	}
	if r.providerId != nil {
		localVarQueryParams.Add("provider_id", parameterToString(*r.providerId, ""))
	}
	if r.provider != nil {
		localVarQueryParams.Add("provider", parameterToString(*r.provider, ""))
	}
	if r.providerNetworkId != nil {
		localVarQueryParams.Add("provider_network_id", parameterToString(*r.providerNetworkId, ""))
	}
	if r.typeId != nil {
		localVarQueryParams.Add("type_id", parameterToString(*r.typeId, ""))
	}
	if r.type_ != nil {
		localVarQueryParams.Add("type", parameterToString(*r.type_, ""))
	}
	if r.status != nil {
		localVarQueryParams.Add("status", parameterToString(*r.status, ""))
	}
	if r.regionId != nil {
		localVarQueryParams.Add("region_id", parameterToString(*r.regionId, ""))
	}
	if r.region != nil {
		localVarQueryParams.Add("region", parameterToString(*r.region, ""))
	}
	if r.siteGroupId != nil {
		localVarQueryParams.Add("site_group_id", parameterToString(*r.siteGroupId, ""))
	}
	if r.siteGroup != nil {
		localVarQueryParams.Add("site_group", parameterToString(*r.siteGroup, ""))
	}
	if r.siteId != nil {
		localVarQueryParams.Add("site_id", parameterToString(*r.siteId, ""))
	}
	if r.site != nil {
		localVarQueryParams.Add("site", parameterToString(*r.site, ""))
	}
	if r.tag != nil {
		localVarQueryParams.Add("tag", parameterToString(*r.tag, ""))
	}
	if r.idN != nil {
		localVarQueryParams.Add("id__n", parameterToString(*r.idN, ""))
	}
	if r.idLte != nil {
		localVarQueryParams.Add("id__lte", parameterToString(*r.idLte, ""))
	}
	if r.idLt != nil {
		localVarQueryParams.Add("id__lt", parameterToString(*r.idLt, ""))
	}
	if r.idGte != nil {
		localVarQueryParams.Add("id__gte", parameterToString(*r.idGte, ""))
	}
	if r.idGt != nil {
		localVarQueryParams.Add("id__gt", parameterToString(*r.idGt, ""))
	}
	if r.cidN != nil {
		localVarQueryParams.Add("cid__n", parameterToString(*r.cidN, ""))
	}
	if r.cidIc != nil {
		localVarQueryParams.Add("cid__ic", parameterToString(*r.cidIc, ""))
	}
	if r.cidNic != nil {
		localVarQueryParams.Add("cid__nic", parameterToString(*r.cidNic, ""))
	}
	if r.cidIew != nil {
		localVarQueryParams.Add("cid__iew", parameterToString(*r.cidIew, ""))
	}
	if r.cidNiew != nil {
		localVarQueryParams.Add("cid__niew", parameterToString(*r.cidNiew, ""))
	}
	if r.cidIsw != nil {
		localVarQueryParams.Add("cid__isw", parameterToString(*r.cidIsw, ""))
	}
	if r.cidNisw != nil {
		localVarQueryParams.Add("cid__nisw", parameterToString(*r.cidNisw, ""))
	}
	if r.cidIe != nil {
		localVarQueryParams.Add("cid__ie", parameterToString(*r.cidIe, ""))
	}
	if r.cidNie != nil {
		localVarQueryParams.Add("cid__nie", parameterToString(*r.cidNie, ""))
	}
	if r.cidEmpty != nil {
		localVarQueryParams.Add("cid__empty", parameterToString(*r.cidEmpty, ""))
	}
	if r.installDateN != nil {
		localVarQueryParams.Add("install_date__n", parameterToString(*r.installDateN, ""))
	}
	if r.installDateLte != nil {
		localVarQueryParams.Add("install_date__lte", parameterToString(*r.installDateLte, ""))
	}
	if r.installDateLt != nil {
		localVarQueryParams.Add("install_date__lt", parameterToString(*r.installDateLt, ""))
	}
	if r.installDateGte != nil {
		localVarQueryParams.Add("install_date__gte", parameterToString(*r.installDateGte, ""))
	}
	if r.installDateGt != nil {
		localVarQueryParams.Add("install_date__gt", parameterToString(*r.installDateGt, ""))
	}
	if r.commitRateN != nil {
		localVarQueryParams.Add("commit_rate__n", parameterToString(*r.commitRateN, ""))
	}
	if r.commitRateLte != nil {
		localVarQueryParams.Add("commit_rate__lte", parameterToString(*r.commitRateLte, ""))
	}
	if r.commitRateLt != nil {
		localVarQueryParams.Add("commit_rate__lt", parameterToString(*r.commitRateLt, ""))
	}
	if r.commitRateGte != nil {
		localVarQueryParams.Add("commit_rate__gte", parameterToString(*r.commitRateGte, ""))
	}
	if r.commitRateGt != nil {
		localVarQueryParams.Add("commit_rate__gt", parameterToString(*r.commitRateGt, ""))
	}
	if r.tenantGroupIdN != nil {
		localVarQueryParams.Add("tenant_group_id__n", parameterToString(*r.tenantGroupIdN, ""))
	}
	if r.tenantGroupN != nil {
		localVarQueryParams.Add("tenant_group__n", parameterToString(*r.tenantGroupN, ""))
	}
	if r.tenantIdN != nil {
		localVarQueryParams.Add("tenant_id__n", parameterToString(*r.tenantIdN, ""))
	}
	if r.tenantN != nil {
		localVarQueryParams.Add("tenant__n", parameterToString(*r.tenantN, ""))
	}
	if r.providerIdN != nil {
		localVarQueryParams.Add("provider_id__n", parameterToString(*r.providerIdN, ""))
	}
	if r.providerN != nil {
		localVarQueryParams.Add("provider__n", parameterToString(*r.providerN, ""))
	}
	if r.providerNetworkIdN != nil {
		localVarQueryParams.Add("provider_network_id__n", parameterToString(*r.providerNetworkIdN, ""))
	}
	if r.typeIdN != nil {
		localVarQueryParams.Add("type_id__n", parameterToString(*r.typeIdN, ""))
	}
	if r.typeN != nil {
		localVarQueryParams.Add("type__n", parameterToString(*r.typeN, ""))
	}
	if r.statusN != nil {
		localVarQueryParams.Add("status__n", parameterToString(*r.statusN, ""))
	}
	if r.regionIdN != nil {
		localVarQueryParams.Add("region_id__n", parameterToString(*r.regionIdN, ""))
	}
	if r.regionN != nil {
		localVarQueryParams.Add("region__n", parameterToString(*r.regionN, ""))
	}
	if r.siteGroupIdN != nil {
		localVarQueryParams.Add("site_group_id__n", parameterToString(*r.siteGroupIdN, ""))
	}
	if r.siteGroupN != nil {
		localVarQueryParams.Add("site_group__n", parameterToString(*r.siteGroupN, ""))
	}
	if r.siteIdN != nil {
		localVarQueryParams.Add("site_id__n", parameterToString(*r.siteIdN, ""))
	}
	if r.siteN != nil {
		localVarQueryParams.Add("site__n", parameterToString(*r.siteN, ""))
	}
	if r.tagN != nil {
		localVarQueryParams.Add("tag__n", parameterToString(*r.tagN, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCircuitsCircuitsPartialUpdateRequest struct {
	ctx context.Context
	ApiService *CircuitsApiService
	id int32
	data *WritableCircuit
}

func (r ApiCircuitsCircuitsPartialUpdateRequest) Data(data WritableCircuit) ApiCircuitsCircuitsPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiCircuitsCircuitsPartialUpdateRequest) Execute() (*Circuit, *http.Response, error) {
	return r.ApiService.CircuitsCircuitsPartialUpdateExecute(r)
}

/*
CircuitsCircuitsPartialUpdate Method for CircuitsCircuitsPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this circuit.
 @return ApiCircuitsCircuitsPartialUpdateRequest
*/
func (a *CircuitsApiService) CircuitsCircuitsPartialUpdate(ctx context.Context, id int32) ApiCircuitsCircuitsPartialUpdateRequest {
	return ApiCircuitsCircuitsPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Circuit
func (a *CircuitsApiService) CircuitsCircuitsPartialUpdateExecute(r ApiCircuitsCircuitsPartialUpdateRequest) (*Circuit, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Circuit
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CircuitsApiService.CircuitsCircuitsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/circuits/circuits/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCircuitsCircuitsReadRequest struct {
	ctx context.Context
	ApiService *CircuitsApiService
	id int32
}

func (r ApiCircuitsCircuitsReadRequest) Execute() (*Circuit, *http.Response, error) {
	return r.ApiService.CircuitsCircuitsReadExecute(r)
}

/*
CircuitsCircuitsRead Method for CircuitsCircuitsRead

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this circuit.
 @return ApiCircuitsCircuitsReadRequest
*/
func (a *CircuitsApiService) CircuitsCircuitsRead(ctx context.Context, id int32) ApiCircuitsCircuitsReadRequest {
	return ApiCircuitsCircuitsReadRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Circuit
func (a *CircuitsApiService) CircuitsCircuitsReadExecute(r ApiCircuitsCircuitsReadRequest) (*Circuit, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Circuit
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CircuitsApiService.CircuitsCircuitsRead")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/circuits/circuits/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCircuitsCircuitsUpdateRequest struct {
	ctx context.Context
	ApiService *CircuitsApiService
	id int32
	data *WritableCircuit
}

func (r ApiCircuitsCircuitsUpdateRequest) Data(data WritableCircuit) ApiCircuitsCircuitsUpdateRequest {
	r.data = &data
	return r
}

func (r ApiCircuitsCircuitsUpdateRequest) Execute() (*Circuit, *http.Response, error) {
	return r.ApiService.CircuitsCircuitsUpdateExecute(r)
}

/*
CircuitsCircuitsUpdate Method for CircuitsCircuitsUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this circuit.
 @return ApiCircuitsCircuitsUpdateRequest
*/
func (a *CircuitsApiService) CircuitsCircuitsUpdate(ctx context.Context, id int32) ApiCircuitsCircuitsUpdateRequest {
	return ApiCircuitsCircuitsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Circuit
func (a *CircuitsApiService) CircuitsCircuitsUpdateExecute(r ApiCircuitsCircuitsUpdateRequest) (*Circuit, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Circuit
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CircuitsApiService.CircuitsCircuitsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/circuits/circuits/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCircuitsProviderNetworksBulkDeleteRequest struct {
	ctx context.Context
	ApiService *CircuitsApiService
}

func (r ApiCircuitsProviderNetworksBulkDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.CircuitsProviderNetworksBulkDeleteExecute(r)
}

/*
CircuitsProviderNetworksBulkDelete Method for CircuitsProviderNetworksBulkDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCircuitsProviderNetworksBulkDeleteRequest
*/
func (a *CircuitsApiService) CircuitsProviderNetworksBulkDelete(ctx context.Context) ApiCircuitsProviderNetworksBulkDeleteRequest {
	return ApiCircuitsProviderNetworksBulkDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *CircuitsApiService) CircuitsProviderNetworksBulkDeleteExecute(r ApiCircuitsProviderNetworksBulkDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CircuitsApiService.CircuitsProviderNetworksBulkDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/circuits/provider-networks/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCircuitsProviderNetworksBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *CircuitsApiService
	data *WritableProviderNetwork
}

func (r ApiCircuitsProviderNetworksBulkPartialUpdateRequest) Data(data WritableProviderNetwork) ApiCircuitsProviderNetworksBulkPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiCircuitsProviderNetworksBulkPartialUpdateRequest) Execute() (*ProviderNetwork, *http.Response, error) {
	return r.ApiService.CircuitsProviderNetworksBulkPartialUpdateExecute(r)
}

/*
CircuitsProviderNetworksBulkPartialUpdate Method for CircuitsProviderNetworksBulkPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCircuitsProviderNetworksBulkPartialUpdateRequest
*/
func (a *CircuitsApiService) CircuitsProviderNetworksBulkPartialUpdate(ctx context.Context) ApiCircuitsProviderNetworksBulkPartialUpdateRequest {
	return ApiCircuitsProviderNetworksBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ProviderNetwork
func (a *CircuitsApiService) CircuitsProviderNetworksBulkPartialUpdateExecute(r ApiCircuitsProviderNetworksBulkPartialUpdateRequest) (*ProviderNetwork, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProviderNetwork
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CircuitsApiService.CircuitsProviderNetworksBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/circuits/provider-networks/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCircuitsProviderNetworksBulkUpdateRequest struct {
	ctx context.Context
	ApiService *CircuitsApiService
	data *WritableProviderNetwork
}

func (r ApiCircuitsProviderNetworksBulkUpdateRequest) Data(data WritableProviderNetwork) ApiCircuitsProviderNetworksBulkUpdateRequest {
	r.data = &data
	return r
}

func (r ApiCircuitsProviderNetworksBulkUpdateRequest) Execute() (*ProviderNetwork, *http.Response, error) {
	return r.ApiService.CircuitsProviderNetworksBulkUpdateExecute(r)
}

/*
CircuitsProviderNetworksBulkUpdate Method for CircuitsProviderNetworksBulkUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCircuitsProviderNetworksBulkUpdateRequest
*/
func (a *CircuitsApiService) CircuitsProviderNetworksBulkUpdate(ctx context.Context) ApiCircuitsProviderNetworksBulkUpdateRequest {
	return ApiCircuitsProviderNetworksBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ProviderNetwork
func (a *CircuitsApiService) CircuitsProviderNetworksBulkUpdateExecute(r ApiCircuitsProviderNetworksBulkUpdateRequest) (*ProviderNetwork, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProviderNetwork
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CircuitsApiService.CircuitsProviderNetworksBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/circuits/provider-networks/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCircuitsProviderNetworksCreateRequest struct {
	ctx context.Context
	ApiService *CircuitsApiService
	data *WritableProviderNetwork
}

func (r ApiCircuitsProviderNetworksCreateRequest) Data(data WritableProviderNetwork) ApiCircuitsProviderNetworksCreateRequest {
	r.data = &data
	return r
}

func (r ApiCircuitsProviderNetworksCreateRequest) Execute() (*ProviderNetwork, *http.Response, error) {
	return r.ApiService.CircuitsProviderNetworksCreateExecute(r)
}

/*
CircuitsProviderNetworksCreate Method for CircuitsProviderNetworksCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCircuitsProviderNetworksCreateRequest
*/
func (a *CircuitsApiService) CircuitsProviderNetworksCreate(ctx context.Context) ApiCircuitsProviderNetworksCreateRequest {
	return ApiCircuitsProviderNetworksCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ProviderNetwork
func (a *CircuitsApiService) CircuitsProviderNetworksCreateExecute(r ApiCircuitsProviderNetworksCreateRequest) (*ProviderNetwork, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProviderNetwork
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CircuitsApiService.CircuitsProviderNetworksCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/circuits/provider-networks/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCircuitsProviderNetworksDeleteRequest struct {
	ctx context.Context
	ApiService *CircuitsApiService
	id int32
}

func (r ApiCircuitsProviderNetworksDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.CircuitsProviderNetworksDeleteExecute(r)
}

/*
CircuitsProviderNetworksDelete Method for CircuitsProviderNetworksDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this provider network.
 @return ApiCircuitsProviderNetworksDeleteRequest
*/
func (a *CircuitsApiService) CircuitsProviderNetworksDelete(ctx context.Context, id int32) ApiCircuitsProviderNetworksDeleteRequest {
	return ApiCircuitsProviderNetworksDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *CircuitsApiService) CircuitsProviderNetworksDeleteExecute(r ApiCircuitsProviderNetworksDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CircuitsApiService.CircuitsProviderNetworksDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/circuits/provider-networks/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCircuitsProviderNetworksListRequest struct {
	ctx context.Context
	ApiService *CircuitsApiService
	id *string
	name *string
	created *string
	createdGte *string
	createdLte *string
	lastUpdated *string
	lastUpdatedGte *string
	lastUpdatedLte *string
	q *string
	providerId *string
	provider *string
	tag *string
	idN *string
	idLte *string
	idLt *string
	idGte *string
	idGt *string
	nameN *string
	nameIc *string
	nameNic *string
	nameIew *string
	nameNiew *string
	nameIsw *string
	nameNisw *string
	nameIe *string
	nameNie *string
	nameEmpty *string
	providerIdN *string
	providerN *string
	tagN *string
	limit *int32
	offset *int32
}

func (r ApiCircuitsProviderNetworksListRequest) Id(id string) ApiCircuitsProviderNetworksListRequest {
	r.id = &id
	return r
}

func (r ApiCircuitsProviderNetworksListRequest) Name(name string) ApiCircuitsProviderNetworksListRequest {
	r.name = &name
	return r
}

func (r ApiCircuitsProviderNetworksListRequest) Created(created string) ApiCircuitsProviderNetworksListRequest {
	r.created = &created
	return r
}

func (r ApiCircuitsProviderNetworksListRequest) CreatedGte(createdGte string) ApiCircuitsProviderNetworksListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiCircuitsProviderNetworksListRequest) CreatedLte(createdLte string) ApiCircuitsProviderNetworksListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiCircuitsProviderNetworksListRequest) LastUpdated(lastUpdated string) ApiCircuitsProviderNetworksListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiCircuitsProviderNetworksListRequest) LastUpdatedGte(lastUpdatedGte string) ApiCircuitsProviderNetworksListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiCircuitsProviderNetworksListRequest) LastUpdatedLte(lastUpdatedLte string) ApiCircuitsProviderNetworksListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiCircuitsProviderNetworksListRequest) Q(q string) ApiCircuitsProviderNetworksListRequest {
	r.q = &q
	return r
}

func (r ApiCircuitsProviderNetworksListRequest) ProviderId(providerId string) ApiCircuitsProviderNetworksListRequest {
	r.providerId = &providerId
	return r
}

func (r ApiCircuitsProviderNetworksListRequest) Provider(provider string) ApiCircuitsProviderNetworksListRequest {
	r.provider = &provider
	return r
}

func (r ApiCircuitsProviderNetworksListRequest) Tag(tag string) ApiCircuitsProviderNetworksListRequest {
	r.tag = &tag
	return r
}

func (r ApiCircuitsProviderNetworksListRequest) IdN(idN string) ApiCircuitsProviderNetworksListRequest {
	r.idN = &idN
	return r
}

func (r ApiCircuitsProviderNetworksListRequest) IdLte(idLte string) ApiCircuitsProviderNetworksListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiCircuitsProviderNetworksListRequest) IdLt(idLt string) ApiCircuitsProviderNetworksListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiCircuitsProviderNetworksListRequest) IdGte(idGte string) ApiCircuitsProviderNetworksListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiCircuitsProviderNetworksListRequest) IdGt(idGt string) ApiCircuitsProviderNetworksListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiCircuitsProviderNetworksListRequest) NameN(nameN string) ApiCircuitsProviderNetworksListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiCircuitsProviderNetworksListRequest) NameIc(nameIc string) ApiCircuitsProviderNetworksListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiCircuitsProviderNetworksListRequest) NameNic(nameNic string) ApiCircuitsProviderNetworksListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiCircuitsProviderNetworksListRequest) NameIew(nameIew string) ApiCircuitsProviderNetworksListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiCircuitsProviderNetworksListRequest) NameNiew(nameNiew string) ApiCircuitsProviderNetworksListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiCircuitsProviderNetworksListRequest) NameIsw(nameIsw string) ApiCircuitsProviderNetworksListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiCircuitsProviderNetworksListRequest) NameNisw(nameNisw string) ApiCircuitsProviderNetworksListRequest {
	r.nameNisw = &nameNisw
	return r
}

func (r ApiCircuitsProviderNetworksListRequest) NameIe(nameIe string) ApiCircuitsProviderNetworksListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiCircuitsProviderNetworksListRequest) NameNie(nameNie string) ApiCircuitsProviderNetworksListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiCircuitsProviderNetworksListRequest) NameEmpty(nameEmpty string) ApiCircuitsProviderNetworksListRequest {
	r.nameEmpty = &nameEmpty
	return r
}

func (r ApiCircuitsProviderNetworksListRequest) ProviderIdN(providerIdN string) ApiCircuitsProviderNetworksListRequest {
	r.providerIdN = &providerIdN
	return r
}

func (r ApiCircuitsProviderNetworksListRequest) ProviderN(providerN string) ApiCircuitsProviderNetworksListRequest {
	r.providerN = &providerN
	return r
}

func (r ApiCircuitsProviderNetworksListRequest) TagN(tagN string) ApiCircuitsProviderNetworksListRequest {
	r.tagN = &tagN
	return r
}

// Number of results to return per page.
func (r ApiCircuitsProviderNetworksListRequest) Limit(limit int32) ApiCircuitsProviderNetworksListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiCircuitsProviderNetworksListRequest) Offset(offset int32) ApiCircuitsProviderNetworksListRequest {
	r.offset = &offset
	return r
}

func (r ApiCircuitsProviderNetworksListRequest) Execute() (*CircuitsProviderNetworksList200Response, *http.Response, error) {
	return r.ApiService.CircuitsProviderNetworksListExecute(r)
}

/*
CircuitsProviderNetworksList Method for CircuitsProviderNetworksList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCircuitsProviderNetworksListRequest
*/
func (a *CircuitsApiService) CircuitsProviderNetworksList(ctx context.Context) ApiCircuitsProviderNetworksListRequest {
	return ApiCircuitsProviderNetworksListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CircuitsProviderNetworksList200Response
func (a *CircuitsApiService) CircuitsProviderNetworksListExecute(r ApiCircuitsProviderNetworksListRequest) (*CircuitsProviderNetworksList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CircuitsProviderNetworksList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CircuitsApiService.CircuitsProviderNetworksList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/circuits/provider-networks/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.created != nil {
		localVarQueryParams.Add("created", parameterToString(*r.created, ""))
	}
	if r.createdGte != nil {
		localVarQueryParams.Add("created__gte", parameterToString(*r.createdGte, ""))
	}
	if r.createdLte != nil {
		localVarQueryParams.Add("created__lte", parameterToString(*r.createdLte, ""))
	}
	if r.lastUpdated != nil {
		localVarQueryParams.Add("last_updated", parameterToString(*r.lastUpdated, ""))
	}
	if r.lastUpdatedGte != nil {
		localVarQueryParams.Add("last_updated__gte", parameterToString(*r.lastUpdatedGte, ""))
	}
	if r.lastUpdatedLte != nil {
		localVarQueryParams.Add("last_updated__lte", parameterToString(*r.lastUpdatedLte, ""))
	}
	if r.q != nil {
		localVarQueryParams.Add("q", parameterToString(*r.q, ""))
	}
	if r.providerId != nil {
		localVarQueryParams.Add("provider_id", parameterToString(*r.providerId, ""))
	}
	if r.provider != nil {
		localVarQueryParams.Add("provider", parameterToString(*r.provider, ""))
	}
	if r.tag != nil {
		localVarQueryParams.Add("tag", parameterToString(*r.tag, ""))
	}
	if r.idN != nil {
		localVarQueryParams.Add("id__n", parameterToString(*r.idN, ""))
	}
	if r.idLte != nil {
		localVarQueryParams.Add("id__lte", parameterToString(*r.idLte, ""))
	}
	if r.idLt != nil {
		localVarQueryParams.Add("id__lt", parameterToString(*r.idLt, ""))
	}
	if r.idGte != nil {
		localVarQueryParams.Add("id__gte", parameterToString(*r.idGte, ""))
	}
	if r.idGt != nil {
		localVarQueryParams.Add("id__gt", parameterToString(*r.idGt, ""))
	}
	if r.nameN != nil {
		localVarQueryParams.Add("name__n", parameterToString(*r.nameN, ""))
	}
	if r.nameIc != nil {
		localVarQueryParams.Add("name__ic", parameterToString(*r.nameIc, ""))
	}
	if r.nameNic != nil {
		localVarQueryParams.Add("name__nic", parameterToString(*r.nameNic, ""))
	}
	if r.nameIew != nil {
		localVarQueryParams.Add("name__iew", parameterToString(*r.nameIew, ""))
	}
	if r.nameNiew != nil {
		localVarQueryParams.Add("name__niew", parameterToString(*r.nameNiew, ""))
	}
	if r.nameIsw != nil {
		localVarQueryParams.Add("name__isw", parameterToString(*r.nameIsw, ""))
	}
	if r.nameNisw != nil {
		localVarQueryParams.Add("name__nisw", parameterToString(*r.nameNisw, ""))
	}
	if r.nameIe != nil {
		localVarQueryParams.Add("name__ie", parameterToString(*r.nameIe, ""))
	}
	if r.nameNie != nil {
		localVarQueryParams.Add("name__nie", parameterToString(*r.nameNie, ""))
	}
	if r.nameEmpty != nil {
		localVarQueryParams.Add("name__empty", parameterToString(*r.nameEmpty, ""))
	}
	if r.providerIdN != nil {
		localVarQueryParams.Add("provider_id__n", parameterToString(*r.providerIdN, ""))
	}
	if r.providerN != nil {
		localVarQueryParams.Add("provider__n", parameterToString(*r.providerN, ""))
	}
	if r.tagN != nil {
		localVarQueryParams.Add("tag__n", parameterToString(*r.tagN, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCircuitsProviderNetworksPartialUpdateRequest struct {
	ctx context.Context
	ApiService *CircuitsApiService
	id int32
	data *WritableProviderNetwork
}

func (r ApiCircuitsProviderNetworksPartialUpdateRequest) Data(data WritableProviderNetwork) ApiCircuitsProviderNetworksPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiCircuitsProviderNetworksPartialUpdateRequest) Execute() (*ProviderNetwork, *http.Response, error) {
	return r.ApiService.CircuitsProviderNetworksPartialUpdateExecute(r)
}

/*
CircuitsProviderNetworksPartialUpdate Method for CircuitsProviderNetworksPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this provider network.
 @return ApiCircuitsProviderNetworksPartialUpdateRequest
*/
func (a *CircuitsApiService) CircuitsProviderNetworksPartialUpdate(ctx context.Context, id int32) ApiCircuitsProviderNetworksPartialUpdateRequest {
	return ApiCircuitsProviderNetworksPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ProviderNetwork
func (a *CircuitsApiService) CircuitsProviderNetworksPartialUpdateExecute(r ApiCircuitsProviderNetworksPartialUpdateRequest) (*ProviderNetwork, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProviderNetwork
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CircuitsApiService.CircuitsProviderNetworksPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/circuits/provider-networks/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCircuitsProviderNetworksReadRequest struct {
	ctx context.Context
	ApiService *CircuitsApiService
	id int32
}

func (r ApiCircuitsProviderNetworksReadRequest) Execute() (*ProviderNetwork, *http.Response, error) {
	return r.ApiService.CircuitsProviderNetworksReadExecute(r)
}

/*
CircuitsProviderNetworksRead Method for CircuitsProviderNetworksRead

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this provider network.
 @return ApiCircuitsProviderNetworksReadRequest
*/
func (a *CircuitsApiService) CircuitsProviderNetworksRead(ctx context.Context, id int32) ApiCircuitsProviderNetworksReadRequest {
	return ApiCircuitsProviderNetworksReadRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ProviderNetwork
func (a *CircuitsApiService) CircuitsProviderNetworksReadExecute(r ApiCircuitsProviderNetworksReadRequest) (*ProviderNetwork, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProviderNetwork
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CircuitsApiService.CircuitsProviderNetworksRead")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/circuits/provider-networks/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCircuitsProviderNetworksUpdateRequest struct {
	ctx context.Context
	ApiService *CircuitsApiService
	id int32
	data *WritableProviderNetwork
}

func (r ApiCircuitsProviderNetworksUpdateRequest) Data(data WritableProviderNetwork) ApiCircuitsProviderNetworksUpdateRequest {
	r.data = &data
	return r
}

func (r ApiCircuitsProviderNetworksUpdateRequest) Execute() (*ProviderNetwork, *http.Response, error) {
	return r.ApiService.CircuitsProviderNetworksUpdateExecute(r)
}

/*
CircuitsProviderNetworksUpdate Method for CircuitsProviderNetworksUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this provider network.
 @return ApiCircuitsProviderNetworksUpdateRequest
*/
func (a *CircuitsApiService) CircuitsProviderNetworksUpdate(ctx context.Context, id int32) ApiCircuitsProviderNetworksUpdateRequest {
	return ApiCircuitsProviderNetworksUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ProviderNetwork
func (a *CircuitsApiService) CircuitsProviderNetworksUpdateExecute(r ApiCircuitsProviderNetworksUpdateRequest) (*ProviderNetwork, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProviderNetwork
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CircuitsApiService.CircuitsProviderNetworksUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/circuits/provider-networks/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCircuitsProvidersBulkDeleteRequest struct {
	ctx context.Context
	ApiService *CircuitsApiService
}

func (r ApiCircuitsProvidersBulkDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.CircuitsProvidersBulkDeleteExecute(r)
}

/*
CircuitsProvidersBulkDelete Method for CircuitsProvidersBulkDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCircuitsProvidersBulkDeleteRequest
*/
func (a *CircuitsApiService) CircuitsProvidersBulkDelete(ctx context.Context) ApiCircuitsProvidersBulkDeleteRequest {
	return ApiCircuitsProvidersBulkDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *CircuitsApiService) CircuitsProvidersBulkDeleteExecute(r ApiCircuitsProvidersBulkDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CircuitsApiService.CircuitsProvidersBulkDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/circuits/providers/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCircuitsProvidersBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *CircuitsApiService
	data *Provider
}

func (r ApiCircuitsProvidersBulkPartialUpdateRequest) Data(data Provider) ApiCircuitsProvidersBulkPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiCircuitsProvidersBulkPartialUpdateRequest) Execute() (*Provider, *http.Response, error) {
	return r.ApiService.CircuitsProvidersBulkPartialUpdateExecute(r)
}

/*
CircuitsProvidersBulkPartialUpdate Method for CircuitsProvidersBulkPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCircuitsProvidersBulkPartialUpdateRequest
*/
func (a *CircuitsApiService) CircuitsProvidersBulkPartialUpdate(ctx context.Context) ApiCircuitsProvidersBulkPartialUpdateRequest {
	return ApiCircuitsProvidersBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Provider
func (a *CircuitsApiService) CircuitsProvidersBulkPartialUpdateExecute(r ApiCircuitsProvidersBulkPartialUpdateRequest) (*Provider, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Provider
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CircuitsApiService.CircuitsProvidersBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/circuits/providers/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCircuitsProvidersBulkUpdateRequest struct {
	ctx context.Context
	ApiService *CircuitsApiService
	data *Provider
}

func (r ApiCircuitsProvidersBulkUpdateRequest) Data(data Provider) ApiCircuitsProvidersBulkUpdateRequest {
	r.data = &data
	return r
}

func (r ApiCircuitsProvidersBulkUpdateRequest) Execute() (*Provider, *http.Response, error) {
	return r.ApiService.CircuitsProvidersBulkUpdateExecute(r)
}

/*
CircuitsProvidersBulkUpdate Method for CircuitsProvidersBulkUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCircuitsProvidersBulkUpdateRequest
*/
func (a *CircuitsApiService) CircuitsProvidersBulkUpdate(ctx context.Context) ApiCircuitsProvidersBulkUpdateRequest {
	return ApiCircuitsProvidersBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Provider
func (a *CircuitsApiService) CircuitsProvidersBulkUpdateExecute(r ApiCircuitsProvidersBulkUpdateRequest) (*Provider, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Provider
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CircuitsApiService.CircuitsProvidersBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/circuits/providers/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCircuitsProvidersCreateRequest struct {
	ctx context.Context
	ApiService *CircuitsApiService
	data *Provider
}

func (r ApiCircuitsProvidersCreateRequest) Data(data Provider) ApiCircuitsProvidersCreateRequest {
	r.data = &data
	return r
}

func (r ApiCircuitsProvidersCreateRequest) Execute() (*Provider, *http.Response, error) {
	return r.ApiService.CircuitsProvidersCreateExecute(r)
}

/*
CircuitsProvidersCreate Method for CircuitsProvidersCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCircuitsProvidersCreateRequest
*/
func (a *CircuitsApiService) CircuitsProvidersCreate(ctx context.Context) ApiCircuitsProvidersCreateRequest {
	return ApiCircuitsProvidersCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Provider
func (a *CircuitsApiService) CircuitsProvidersCreateExecute(r ApiCircuitsProvidersCreateRequest) (*Provider, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Provider
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CircuitsApiService.CircuitsProvidersCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/circuits/providers/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCircuitsProvidersDeleteRequest struct {
	ctx context.Context
	ApiService *CircuitsApiService
	id int32
}

func (r ApiCircuitsProvidersDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.CircuitsProvidersDeleteExecute(r)
}

/*
CircuitsProvidersDelete Method for CircuitsProvidersDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this provider.
 @return ApiCircuitsProvidersDeleteRequest
*/
func (a *CircuitsApiService) CircuitsProvidersDelete(ctx context.Context, id int32) ApiCircuitsProvidersDeleteRequest {
	return ApiCircuitsProvidersDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *CircuitsApiService) CircuitsProvidersDeleteExecute(r ApiCircuitsProvidersDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CircuitsApiService.CircuitsProvidersDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/circuits/providers/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCircuitsProvidersListRequest struct {
	ctx context.Context
	ApiService *CircuitsApiService
	id *string
	name *string
	slug *string
	asn *string
	account *string
	created *string
	createdGte *string
	createdLte *string
	lastUpdated *string
	lastUpdatedGte *string
	lastUpdatedLte *string
	q *string
	regionId *string
	region *string
	siteGroupId *string
	siteGroup *string
	siteId *string
	site *string
	tag *string
	idN *string
	idLte *string
	idLt *string
	idGte *string
	idGt *string
	nameN *string
	nameIc *string
	nameNic *string
	nameIew *string
	nameNiew *string
	nameIsw *string
	nameNisw *string
	nameIe *string
	nameNie *string
	nameEmpty *string
	slugN *string
	slugIc *string
	slugNic *string
	slugIew *string
	slugNiew *string
	slugIsw *string
	slugNisw *string
	slugIe *string
	slugNie *string
	slugEmpty *string
	asnN *string
	asnLte *string
	asnLt *string
	asnGte *string
	asnGt *string
	accountN *string
	accountIc *string
	accountNic *string
	accountIew *string
	accountNiew *string
	accountIsw *string
	accountNisw *string
	accountIe *string
	accountNie *string
	accountEmpty *string
	regionIdN *string
	regionN *string
	siteGroupIdN *string
	siteGroupN *string
	siteIdN *string
	siteN *string
	tagN *string
	limit *int32
	offset *int32
}

func (r ApiCircuitsProvidersListRequest) Id(id string) ApiCircuitsProvidersListRequest {
	r.id = &id
	return r
}

func (r ApiCircuitsProvidersListRequest) Name(name string) ApiCircuitsProvidersListRequest {
	r.name = &name
	return r
}

func (r ApiCircuitsProvidersListRequest) Slug(slug string) ApiCircuitsProvidersListRequest {
	r.slug = &slug
	return r
}

func (r ApiCircuitsProvidersListRequest) Asn(asn string) ApiCircuitsProvidersListRequest {
	r.asn = &asn
	return r
}

func (r ApiCircuitsProvidersListRequest) Account(account string) ApiCircuitsProvidersListRequest {
	r.account = &account
	return r
}

func (r ApiCircuitsProvidersListRequest) Created(created string) ApiCircuitsProvidersListRequest {
	r.created = &created
	return r
}

func (r ApiCircuitsProvidersListRequest) CreatedGte(createdGte string) ApiCircuitsProvidersListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiCircuitsProvidersListRequest) CreatedLte(createdLte string) ApiCircuitsProvidersListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiCircuitsProvidersListRequest) LastUpdated(lastUpdated string) ApiCircuitsProvidersListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiCircuitsProvidersListRequest) LastUpdatedGte(lastUpdatedGte string) ApiCircuitsProvidersListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiCircuitsProvidersListRequest) LastUpdatedLte(lastUpdatedLte string) ApiCircuitsProvidersListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiCircuitsProvidersListRequest) Q(q string) ApiCircuitsProvidersListRequest {
	r.q = &q
	return r
}

func (r ApiCircuitsProvidersListRequest) RegionId(regionId string) ApiCircuitsProvidersListRequest {
	r.regionId = &regionId
	return r
}

func (r ApiCircuitsProvidersListRequest) Region(region string) ApiCircuitsProvidersListRequest {
	r.region = &region
	return r
}

func (r ApiCircuitsProvidersListRequest) SiteGroupId(siteGroupId string) ApiCircuitsProvidersListRequest {
	r.siteGroupId = &siteGroupId
	return r
}

func (r ApiCircuitsProvidersListRequest) SiteGroup(siteGroup string) ApiCircuitsProvidersListRequest {
	r.siteGroup = &siteGroup
	return r
}

func (r ApiCircuitsProvidersListRequest) SiteId(siteId string) ApiCircuitsProvidersListRequest {
	r.siteId = &siteId
	return r
}

func (r ApiCircuitsProvidersListRequest) Site(site string) ApiCircuitsProvidersListRequest {
	r.site = &site
	return r
}

func (r ApiCircuitsProvidersListRequest) Tag(tag string) ApiCircuitsProvidersListRequest {
	r.tag = &tag
	return r
}

func (r ApiCircuitsProvidersListRequest) IdN(idN string) ApiCircuitsProvidersListRequest {
	r.idN = &idN
	return r
}

func (r ApiCircuitsProvidersListRequest) IdLte(idLte string) ApiCircuitsProvidersListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiCircuitsProvidersListRequest) IdLt(idLt string) ApiCircuitsProvidersListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiCircuitsProvidersListRequest) IdGte(idGte string) ApiCircuitsProvidersListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiCircuitsProvidersListRequest) IdGt(idGt string) ApiCircuitsProvidersListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiCircuitsProvidersListRequest) NameN(nameN string) ApiCircuitsProvidersListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiCircuitsProvidersListRequest) NameIc(nameIc string) ApiCircuitsProvidersListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiCircuitsProvidersListRequest) NameNic(nameNic string) ApiCircuitsProvidersListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiCircuitsProvidersListRequest) NameIew(nameIew string) ApiCircuitsProvidersListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiCircuitsProvidersListRequest) NameNiew(nameNiew string) ApiCircuitsProvidersListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiCircuitsProvidersListRequest) NameIsw(nameIsw string) ApiCircuitsProvidersListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiCircuitsProvidersListRequest) NameNisw(nameNisw string) ApiCircuitsProvidersListRequest {
	r.nameNisw = &nameNisw
	return r
}

func (r ApiCircuitsProvidersListRequest) NameIe(nameIe string) ApiCircuitsProvidersListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiCircuitsProvidersListRequest) NameNie(nameNie string) ApiCircuitsProvidersListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiCircuitsProvidersListRequest) NameEmpty(nameEmpty string) ApiCircuitsProvidersListRequest {
	r.nameEmpty = &nameEmpty
	return r
}

func (r ApiCircuitsProvidersListRequest) SlugN(slugN string) ApiCircuitsProvidersListRequest {
	r.slugN = &slugN
	return r
}

func (r ApiCircuitsProvidersListRequest) SlugIc(slugIc string) ApiCircuitsProvidersListRequest {
	r.slugIc = &slugIc
	return r
}

func (r ApiCircuitsProvidersListRequest) SlugNic(slugNic string) ApiCircuitsProvidersListRequest {
	r.slugNic = &slugNic
	return r
}

func (r ApiCircuitsProvidersListRequest) SlugIew(slugIew string) ApiCircuitsProvidersListRequest {
	r.slugIew = &slugIew
	return r
}

func (r ApiCircuitsProvidersListRequest) SlugNiew(slugNiew string) ApiCircuitsProvidersListRequest {
	r.slugNiew = &slugNiew
	return r
}

func (r ApiCircuitsProvidersListRequest) SlugIsw(slugIsw string) ApiCircuitsProvidersListRequest {
	r.slugIsw = &slugIsw
	return r
}

func (r ApiCircuitsProvidersListRequest) SlugNisw(slugNisw string) ApiCircuitsProvidersListRequest {
	r.slugNisw = &slugNisw
	return r
}

func (r ApiCircuitsProvidersListRequest) SlugIe(slugIe string) ApiCircuitsProvidersListRequest {
	r.slugIe = &slugIe
	return r
}

func (r ApiCircuitsProvidersListRequest) SlugNie(slugNie string) ApiCircuitsProvidersListRequest {
	r.slugNie = &slugNie
	return r
}

func (r ApiCircuitsProvidersListRequest) SlugEmpty(slugEmpty string) ApiCircuitsProvidersListRequest {
	r.slugEmpty = &slugEmpty
	return r
}

func (r ApiCircuitsProvidersListRequest) AsnN(asnN string) ApiCircuitsProvidersListRequest {
	r.asnN = &asnN
	return r
}

func (r ApiCircuitsProvidersListRequest) AsnLte(asnLte string) ApiCircuitsProvidersListRequest {
	r.asnLte = &asnLte
	return r
}

func (r ApiCircuitsProvidersListRequest) AsnLt(asnLt string) ApiCircuitsProvidersListRequest {
	r.asnLt = &asnLt
	return r
}

func (r ApiCircuitsProvidersListRequest) AsnGte(asnGte string) ApiCircuitsProvidersListRequest {
	r.asnGte = &asnGte
	return r
}

func (r ApiCircuitsProvidersListRequest) AsnGt(asnGt string) ApiCircuitsProvidersListRequest {
	r.asnGt = &asnGt
	return r
}

func (r ApiCircuitsProvidersListRequest) AccountN(accountN string) ApiCircuitsProvidersListRequest {
	r.accountN = &accountN
	return r
}

func (r ApiCircuitsProvidersListRequest) AccountIc(accountIc string) ApiCircuitsProvidersListRequest {
	r.accountIc = &accountIc
	return r
}

func (r ApiCircuitsProvidersListRequest) AccountNic(accountNic string) ApiCircuitsProvidersListRequest {
	r.accountNic = &accountNic
	return r
}

func (r ApiCircuitsProvidersListRequest) AccountIew(accountIew string) ApiCircuitsProvidersListRequest {
	r.accountIew = &accountIew
	return r
}

func (r ApiCircuitsProvidersListRequest) AccountNiew(accountNiew string) ApiCircuitsProvidersListRequest {
	r.accountNiew = &accountNiew
	return r
}

func (r ApiCircuitsProvidersListRequest) AccountIsw(accountIsw string) ApiCircuitsProvidersListRequest {
	r.accountIsw = &accountIsw
	return r
}

func (r ApiCircuitsProvidersListRequest) AccountNisw(accountNisw string) ApiCircuitsProvidersListRequest {
	r.accountNisw = &accountNisw
	return r
}

func (r ApiCircuitsProvidersListRequest) AccountIe(accountIe string) ApiCircuitsProvidersListRequest {
	r.accountIe = &accountIe
	return r
}

func (r ApiCircuitsProvidersListRequest) AccountNie(accountNie string) ApiCircuitsProvidersListRequest {
	r.accountNie = &accountNie
	return r
}

func (r ApiCircuitsProvidersListRequest) AccountEmpty(accountEmpty string) ApiCircuitsProvidersListRequest {
	r.accountEmpty = &accountEmpty
	return r
}

func (r ApiCircuitsProvidersListRequest) RegionIdN(regionIdN string) ApiCircuitsProvidersListRequest {
	r.regionIdN = &regionIdN
	return r
}

func (r ApiCircuitsProvidersListRequest) RegionN(regionN string) ApiCircuitsProvidersListRequest {
	r.regionN = &regionN
	return r
}

func (r ApiCircuitsProvidersListRequest) SiteGroupIdN(siteGroupIdN string) ApiCircuitsProvidersListRequest {
	r.siteGroupIdN = &siteGroupIdN
	return r
}

func (r ApiCircuitsProvidersListRequest) SiteGroupN(siteGroupN string) ApiCircuitsProvidersListRequest {
	r.siteGroupN = &siteGroupN
	return r
}

func (r ApiCircuitsProvidersListRequest) SiteIdN(siteIdN string) ApiCircuitsProvidersListRequest {
	r.siteIdN = &siteIdN
	return r
}

func (r ApiCircuitsProvidersListRequest) SiteN(siteN string) ApiCircuitsProvidersListRequest {
	r.siteN = &siteN
	return r
}

func (r ApiCircuitsProvidersListRequest) TagN(tagN string) ApiCircuitsProvidersListRequest {
	r.tagN = &tagN
	return r
}

// Number of results to return per page.
func (r ApiCircuitsProvidersListRequest) Limit(limit int32) ApiCircuitsProvidersListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiCircuitsProvidersListRequest) Offset(offset int32) ApiCircuitsProvidersListRequest {
	r.offset = &offset
	return r
}

func (r ApiCircuitsProvidersListRequest) Execute() (*CircuitsProvidersList200Response, *http.Response, error) {
	return r.ApiService.CircuitsProvidersListExecute(r)
}

/*
CircuitsProvidersList Method for CircuitsProvidersList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCircuitsProvidersListRequest
*/
func (a *CircuitsApiService) CircuitsProvidersList(ctx context.Context) ApiCircuitsProvidersListRequest {
	return ApiCircuitsProvidersListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CircuitsProvidersList200Response
func (a *CircuitsApiService) CircuitsProvidersListExecute(r ApiCircuitsProvidersListRequest) (*CircuitsProvidersList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CircuitsProvidersList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CircuitsApiService.CircuitsProvidersList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/circuits/providers/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.slug != nil {
		localVarQueryParams.Add("slug", parameterToString(*r.slug, ""))
	}
	if r.asn != nil {
		localVarQueryParams.Add("asn", parameterToString(*r.asn, ""))
	}
	if r.account != nil {
		localVarQueryParams.Add("account", parameterToString(*r.account, ""))
	}
	if r.created != nil {
		localVarQueryParams.Add("created", parameterToString(*r.created, ""))
	}
	if r.createdGte != nil {
		localVarQueryParams.Add("created__gte", parameterToString(*r.createdGte, ""))
	}
	if r.createdLte != nil {
		localVarQueryParams.Add("created__lte", parameterToString(*r.createdLte, ""))
	}
	if r.lastUpdated != nil {
		localVarQueryParams.Add("last_updated", parameterToString(*r.lastUpdated, ""))
	}
	if r.lastUpdatedGte != nil {
		localVarQueryParams.Add("last_updated__gte", parameterToString(*r.lastUpdatedGte, ""))
	}
	if r.lastUpdatedLte != nil {
		localVarQueryParams.Add("last_updated__lte", parameterToString(*r.lastUpdatedLte, ""))
	}
	if r.q != nil {
		localVarQueryParams.Add("q", parameterToString(*r.q, ""))
	}
	if r.regionId != nil {
		localVarQueryParams.Add("region_id", parameterToString(*r.regionId, ""))
	}
	if r.region != nil {
		localVarQueryParams.Add("region", parameterToString(*r.region, ""))
	}
	if r.siteGroupId != nil {
		localVarQueryParams.Add("site_group_id", parameterToString(*r.siteGroupId, ""))
	}
	if r.siteGroup != nil {
		localVarQueryParams.Add("site_group", parameterToString(*r.siteGroup, ""))
	}
	if r.siteId != nil {
		localVarQueryParams.Add("site_id", parameterToString(*r.siteId, ""))
	}
	if r.site != nil {
		localVarQueryParams.Add("site", parameterToString(*r.site, ""))
	}
	if r.tag != nil {
		localVarQueryParams.Add("tag", parameterToString(*r.tag, ""))
	}
	if r.idN != nil {
		localVarQueryParams.Add("id__n", parameterToString(*r.idN, ""))
	}
	if r.idLte != nil {
		localVarQueryParams.Add("id__lte", parameterToString(*r.idLte, ""))
	}
	if r.idLt != nil {
		localVarQueryParams.Add("id__lt", parameterToString(*r.idLt, ""))
	}
	if r.idGte != nil {
		localVarQueryParams.Add("id__gte", parameterToString(*r.idGte, ""))
	}
	if r.idGt != nil {
		localVarQueryParams.Add("id__gt", parameterToString(*r.idGt, ""))
	}
	if r.nameN != nil {
		localVarQueryParams.Add("name__n", parameterToString(*r.nameN, ""))
	}
	if r.nameIc != nil {
		localVarQueryParams.Add("name__ic", parameterToString(*r.nameIc, ""))
	}
	if r.nameNic != nil {
		localVarQueryParams.Add("name__nic", parameterToString(*r.nameNic, ""))
	}
	if r.nameIew != nil {
		localVarQueryParams.Add("name__iew", parameterToString(*r.nameIew, ""))
	}
	if r.nameNiew != nil {
		localVarQueryParams.Add("name__niew", parameterToString(*r.nameNiew, ""))
	}
	if r.nameIsw != nil {
		localVarQueryParams.Add("name__isw", parameterToString(*r.nameIsw, ""))
	}
	if r.nameNisw != nil {
		localVarQueryParams.Add("name__nisw", parameterToString(*r.nameNisw, ""))
	}
	if r.nameIe != nil {
		localVarQueryParams.Add("name__ie", parameterToString(*r.nameIe, ""))
	}
	if r.nameNie != nil {
		localVarQueryParams.Add("name__nie", parameterToString(*r.nameNie, ""))
	}
	if r.nameEmpty != nil {
		localVarQueryParams.Add("name__empty", parameterToString(*r.nameEmpty, ""))
	}
	if r.slugN != nil {
		localVarQueryParams.Add("slug__n", parameterToString(*r.slugN, ""))
	}
	if r.slugIc != nil {
		localVarQueryParams.Add("slug__ic", parameterToString(*r.slugIc, ""))
	}
	if r.slugNic != nil {
		localVarQueryParams.Add("slug__nic", parameterToString(*r.slugNic, ""))
	}
	if r.slugIew != nil {
		localVarQueryParams.Add("slug__iew", parameterToString(*r.slugIew, ""))
	}
	if r.slugNiew != nil {
		localVarQueryParams.Add("slug__niew", parameterToString(*r.slugNiew, ""))
	}
	if r.slugIsw != nil {
		localVarQueryParams.Add("slug__isw", parameterToString(*r.slugIsw, ""))
	}
	if r.slugNisw != nil {
		localVarQueryParams.Add("slug__nisw", parameterToString(*r.slugNisw, ""))
	}
	if r.slugIe != nil {
		localVarQueryParams.Add("slug__ie", parameterToString(*r.slugIe, ""))
	}
	if r.slugNie != nil {
		localVarQueryParams.Add("slug__nie", parameterToString(*r.slugNie, ""))
	}
	if r.slugEmpty != nil {
		localVarQueryParams.Add("slug__empty", parameterToString(*r.slugEmpty, ""))
	}
	if r.asnN != nil {
		localVarQueryParams.Add("asn__n", parameterToString(*r.asnN, ""))
	}
	if r.asnLte != nil {
		localVarQueryParams.Add("asn__lte", parameterToString(*r.asnLte, ""))
	}
	if r.asnLt != nil {
		localVarQueryParams.Add("asn__lt", parameterToString(*r.asnLt, ""))
	}
	if r.asnGte != nil {
		localVarQueryParams.Add("asn__gte", parameterToString(*r.asnGte, ""))
	}
	if r.asnGt != nil {
		localVarQueryParams.Add("asn__gt", parameterToString(*r.asnGt, ""))
	}
	if r.accountN != nil {
		localVarQueryParams.Add("account__n", parameterToString(*r.accountN, ""))
	}
	if r.accountIc != nil {
		localVarQueryParams.Add("account__ic", parameterToString(*r.accountIc, ""))
	}
	if r.accountNic != nil {
		localVarQueryParams.Add("account__nic", parameterToString(*r.accountNic, ""))
	}
	if r.accountIew != nil {
		localVarQueryParams.Add("account__iew", parameterToString(*r.accountIew, ""))
	}
	if r.accountNiew != nil {
		localVarQueryParams.Add("account__niew", parameterToString(*r.accountNiew, ""))
	}
	if r.accountIsw != nil {
		localVarQueryParams.Add("account__isw", parameterToString(*r.accountIsw, ""))
	}
	if r.accountNisw != nil {
		localVarQueryParams.Add("account__nisw", parameterToString(*r.accountNisw, ""))
	}
	if r.accountIe != nil {
		localVarQueryParams.Add("account__ie", parameterToString(*r.accountIe, ""))
	}
	if r.accountNie != nil {
		localVarQueryParams.Add("account__nie", parameterToString(*r.accountNie, ""))
	}
	if r.accountEmpty != nil {
		localVarQueryParams.Add("account__empty", parameterToString(*r.accountEmpty, ""))
	}
	if r.regionIdN != nil {
		localVarQueryParams.Add("region_id__n", parameterToString(*r.regionIdN, ""))
	}
	if r.regionN != nil {
		localVarQueryParams.Add("region__n", parameterToString(*r.regionN, ""))
	}
	if r.siteGroupIdN != nil {
		localVarQueryParams.Add("site_group_id__n", parameterToString(*r.siteGroupIdN, ""))
	}
	if r.siteGroupN != nil {
		localVarQueryParams.Add("site_group__n", parameterToString(*r.siteGroupN, ""))
	}
	if r.siteIdN != nil {
		localVarQueryParams.Add("site_id__n", parameterToString(*r.siteIdN, ""))
	}
	if r.siteN != nil {
		localVarQueryParams.Add("site__n", parameterToString(*r.siteN, ""))
	}
	if r.tagN != nil {
		localVarQueryParams.Add("tag__n", parameterToString(*r.tagN, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCircuitsProvidersPartialUpdateRequest struct {
	ctx context.Context
	ApiService *CircuitsApiService
	id int32
	data *Provider
}

func (r ApiCircuitsProvidersPartialUpdateRequest) Data(data Provider) ApiCircuitsProvidersPartialUpdateRequest {
	r.data = &data
	return r
}

func (r ApiCircuitsProvidersPartialUpdateRequest) Execute() (*Provider, *http.Response, error) {
	return r.ApiService.CircuitsProvidersPartialUpdateExecute(r)
}

/*
CircuitsProvidersPartialUpdate Method for CircuitsProvidersPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this provider.
 @return ApiCircuitsProvidersPartialUpdateRequest
*/
func (a *CircuitsApiService) CircuitsProvidersPartialUpdate(ctx context.Context, id int32) ApiCircuitsProvidersPartialUpdateRequest {
	return ApiCircuitsProvidersPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Provider
func (a *CircuitsApiService) CircuitsProvidersPartialUpdateExecute(r ApiCircuitsProvidersPartialUpdateRequest) (*Provider, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Provider
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CircuitsApiService.CircuitsProvidersPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/circuits/providers/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCircuitsProvidersReadRequest struct {
	ctx context.Context
	ApiService *CircuitsApiService
	id int32
}

func (r ApiCircuitsProvidersReadRequest) Execute() (*Provider, *http.Response, error) {
	return r.ApiService.CircuitsProvidersReadExecute(r)
}

/*
CircuitsProvidersRead Method for CircuitsProvidersRead

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this provider.
 @return ApiCircuitsProvidersReadRequest
*/
func (a *CircuitsApiService) CircuitsProvidersRead(ctx context.Context, id int32) ApiCircuitsProvidersReadRequest {
	return ApiCircuitsProvidersReadRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Provider
func (a *CircuitsApiService) CircuitsProvidersReadExecute(r ApiCircuitsProvidersReadRequest) (*Provider, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Provider
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CircuitsApiService.CircuitsProvidersRead")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/circuits/providers/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCircuitsProvidersUpdateRequest struct {
	ctx context.Context
	ApiService *CircuitsApiService
	id int32
	data *Provider
}

func (r ApiCircuitsProvidersUpdateRequest) Data(data Provider) ApiCircuitsProvidersUpdateRequest {
	r.data = &data
	return r
}

func (r ApiCircuitsProvidersUpdateRequest) Execute() (*Provider, *http.Response, error) {
	return r.ApiService.CircuitsProvidersUpdateExecute(r)
}

/*
CircuitsProvidersUpdate Method for CircuitsProvidersUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this provider.
 @return ApiCircuitsProvidersUpdateRequest
*/
func (a *CircuitsApiService) CircuitsProvidersUpdate(ctx context.Context, id int32) ApiCircuitsProvidersUpdateRequest {
	return ApiCircuitsProvidersUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Provider
func (a *CircuitsApiService) CircuitsProvidersUpdateExecute(r ApiCircuitsProvidersUpdateRequest) (*Provider, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Provider
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CircuitsApiService.CircuitsProvidersUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/circuits/providers/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
